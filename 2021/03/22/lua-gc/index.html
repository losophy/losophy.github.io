<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="原理GC算法的原理大体就是：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，可以删除 。这里的关键在于，如何找出没有“引用”的对象。使用引用计数的GC算法，会在一个对象被引用的情况下将该对象的引用计数加一 ，反之减一。 如果引用计数为0 ，那么就是没有引用的对象。 引用计数算法的优点是不需要扫描每个对象，对象本身的引用计数只需要减到0，就会被回收。 缺点是会有循环">
<meta property="og:type" content="article">
<meta property="og:title" content="lua gc">
<meta property="og:url" content="http://example.com/2021/03/22/lua-gc/index.html">
<meta property="og:site_name" content="losophy">
<meta property="og:description" content="原理GC算法的原理大体就是：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，可以删除 。这里的关键在于，如何找出没有“引用”的对象。使用引用计数的GC算法，会在一个对象被引用的情况下将该对象的引用计数加一 ，反之减一。 如果引用计数为0 ，那么就是没有引用的对象。 引用计数算法的优点是不需要扫描每个对象，对象本身的引用计数只需要减到0，就会被回收。 缺点是会有循环">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/112426112-4cd8d900-8d72-11eb-91d9-6b23756e362f.JPG">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/112426834-9544c680-8d73-11eb-97eb-ca4ada95361d.JPG">
<meta property="article:published_time" content="2021-03-21T17:22:15.000Z">
<meta property="article:modified_time" content="2021-05-11T16:54:56.245Z">
<meta property="article:author" content="losophy">
<meta property="article:tag" content="lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/11263320/112426112-4cd8d900-8d72-11eb-91d9-6b23756e362f.JPG">

<link rel="canonical" href="http://example.com/2021/03/22/lua-gc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>lua gc | losophy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/losophy" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">losophy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/22/lua-gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          lua gc
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 01:22:15" itemprop="dateCreated datePublished" datetime="2021-03-22T01:22:15+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 00:54:56" itemprop="dateModified" datetime="2021-05-12T00:54:56+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GC算法的原理大体就是：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，可以删除 。<br>这里的关键在于，如何找出没有“引用”的对象。<br>使用引用计数的GC算法，会在一个对象被引用的情况下将该对象的引用计数加一 ，反之减一。 如果引用计数为0 ，那么就是没有引用的对象。 引用计数算法的优点是不需要扫描每个对象，对象本身的引用计数只需要减到0，就会被回收。 缺点是会有循环引用问题<br>另一种算法是标记清除算法（ Mark and Sweep ）。 它的原理是每一次做GC的时候，首先扫描并且标记系统中 的所有对象，被扫描并且标记到的对象认为是可达的（ reachable ），这些对象不会被回收；反之，没有被标记的对象认为是可以回收的 。 Lua采用的就是这种算法 。</p>
<h2 id="双色标记清除算法"><a href="#双色标记清除算法" class="headerlink" title="双色标记清除算法"></a>双色标记清除算法</h2><p>早期的Lua 5.0使用的是双色标记清除算法，该算法的原理是 ：系统中的每个对象非黑即白，也就是要么被引用，要么没有被引用。<br>具体操作是这样的：</p>
<ul>
<li>每个新创建的对象的颜色为白色</li>
<li>在初始化阶段，边历root链表中的对象，并将其加入到对象链表中</li>
<li>在标记阶段，当对象链表中还有未扫描的元素，从中取出一个对象并将其标记为黑色，边历这个对象关联的其他所有对象，标记为黑色</li>
<li>在回收阶段，追历所有对象，如果为白色，这些对象就是没有被引用的对象，逐个回收。否则，这些对象是被引用的对象 ， 重新加入对象链表中等待丁一轮的GC检查。<br><img src="https://user-images.githubusercontent.com/11263320/112426112-4cd8d900-8d72-11eb-91d9-6b23756e362f.JPG" alt="捕获"><br>这个算法的缺陷在于，每个对象的状态是“二元”的，每个对象只可能有一种状态，不能有其他中间状态，这就要求这个算法每次做GC操作时不可被打断地一次性扫描并清除完所有对象。<br>如果在遍历对象链表时标记每个对象颜色的过程中被打断，此时新增了一个对象，那么应该将这个对象标记为白色还是黑色？如果标记为白色，假如GC已经到了回收阶段，那么这个对象就会在没有遍历其关联对象的情况下被回收；如果标记为黑色，假如GC已经到了回收阶段，那么这个对象在本轮GC中并没有被扫描过就认为是不必回<br>收的 。 可以看到，在双色标记清除算法中，标记阶段和回收阶段必须合在一起完成。<br>不能被打断，也就意味着每次GC操作的代价极大。在GC过程中，程序必须暂停下来，不能进行其他操作。</li>
</ul>
<h2 id="三色增量标记清除算法"><a href="#三色增量标记清除算法" class="headerlink" title="三色增量标记清除算法"></a>三色增量标记清除算法</h2><p>从Lua 5.1 开始，采用了在该算法的基础上改进的三色增量标记清除算法。与前面的算法相比，这个算法中每个对象的颜色多了一种（实际上，在Lua中是4种，后面再展开讨论）。 这样的好处在于：它不必再要求GC一次性扫描完所有的对象，这个GC过程可以是增量的，可以被中断再恢复并继续进行的 。<br>3种颜色的分类如下：</p>
<ul>
<li>白色： 当前对象为待访问状态，表示对象还没有被GC标记过，这也是任何一个对象创建后的初始状态。 换言之，如果一个对象在结束GC扫描过程后仍然是白色，则说明该对象没有被系统中的任何一个对象所引用，可以回收其空间了 。</li>
<li>灰色： 当前对象为待扫描状态，表示对象已经被GC访问过，但是该对象引用的其他对象还没有被访问到 。</li>
<li>黑色： 当前对象为己扫描状态，表示对象已经被GC访问过，并且该对象引用的其他对象也被访问过了 。<br><img src="https://user-images.githubusercontent.com/11263320/112426834-9544c680-8d73-11eb-97eb-ca4ada95361d.JPG" alt="捕获"><br>具体操作是这样的：</li>
<li>每个新创建的对象颜色为白色</li>
<li>初始化阶段，远历 root 节点中引用的对象，从白色置为灰色，并且放入到灰色节点列表中</li>
<li>标记阶段，当灰色链表中还有未扫描的元素，从中取出一个对象并将其标记为黑色，遍历这个对象关联的其他所有对象．如果是白色，标记为灰色，加入灰色链表中。</li>
<li>回收阶段，遍历所有对象，如果为白色，这些对象都是没有被引用的对象，逐个回收。否则，重新加入对象链求中等待丁一轮的 GC检查</li>
</ul>
<p>可以看到，引入了灰色节点的概念后，算法不再要求一次性完整执行完毕，而是可以把已经扫描但是其引用的对象还未被扫描的对象置为灰色。 在标记阶段中，只要灰色节点集合中还有元素在，那么这个标记过程就会继续下去，即使中间被打断转而执行其他操作了，也没有关系 。</p>
<p>然而即使是这样，却仍然有另一个没有解决的问题。 从上面的算法可以看出，没有被引用的对象的颜色在扫描过程中始终保持不变，为白色 。 那么，假如一个对象在GC过程的标记阶段之后创建，根据前面对颜色的描述，它应该是白色的，这样在紧跟着的回收阶段，这个对象就会在没有被扫描标记的情况下被认为是没有被引用的对象而删除 。</p>
<p>因此， Lua的GC算法除了前面的三色概念之外，又细分出来一个“双白色”的概念 。 简单地说， Lua中的白色分为“当前白色”和“非当前臼色”。 这两种白色的状态交替使用，第N；欠GC使用的是第一种白色，那么下一次就是另外一种，以此类推。</p>
<p>代码在回收时会做判断，如果某个对象的白色不是此次GC使用的白色状态，那么将不会认为是没有被引用的对象而回收，这样的白色对象将留在下一次GC中进行扫描，因为在下一次GC中上一次幸免的白色将成为这次的回收颜色。</p>
<h2 id="GC的全流程"><a href="#GC的全流程" class="headerlink" title="GC的全流程"></a>GC的全流程</h2><p>Lua内部用一个宏表示哪些数据类型需要进行GC ( Garbage Collection ，垃圾回收）操作 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iscollectable(o) (ttype(o) &gt;= LUA TSTRING)</span></span><br></pre></td></tr></table></figure>
<p>可以看到， LUA TSTRING （包括 LUA TSTRING ）之后的数据类型都需要进行GC操作 。</p>
<p>需要进行GC操作的数据类型都会有一个CommonHeader宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>
<p>next：GCObject链表指针，这个指针将所有GC对象都链接在一起形成链表<br>tt：表示数据的类型，即<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/109">lua数据类型</a>的宏 。<br>marked : 标记字段，用于存储前面提到的几种颜色。<br>marked具体值定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Layout for bit use in `marked&#x27; field:</span></span><br><span class="line"><span class="comment">** bit 0 - object is white (type 0)</span></span><br><span class="line"><span class="comment">** bit 1 - object is white (type 1)</span></span><br><span class="line"><span class="comment">** bit 2 - object is black</span></span><br><span class="line"><span class="comment">** bit 3 - for userdata: has been finalized</span></span><br><span class="line"><span class="comment">** bit 3 - for tables: has weak keys</span></span><br><span class="line"><span class="comment">** bit 4 - for tables: has weak values</span></span><br><span class="line"><span class="comment">** bit 5 - object is fixed (should not be collected)</span></span><br><span class="line"><span class="comment">** bit 6 - object is &quot;super&quot; fixed (only the main thread)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE0BIT	0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE1BIT	1   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACKBIT	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINALIZEDBIT	3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYWEAKBIT	3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUEWEAKBIT	4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIXEDBIT	5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFIXEDBIT	6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)</span></span><br></pre></td></tr></table></figure>
<p>这里WHITE OBIT和WHITE1BIT就是前面提到的两种 白色状态，称为0型白色和 l型白色。 当前的白色见lobal_State 中的 currentwhite ，而otherwhit e宏用于表示非当前GC将要回收的白色类型 。 切换白色，需要使用 changewhite宏 ； 要得到当前的白色状态，则使用luaC_white宏 。</p>
<p>FINALIZEDBIT用于标记没有被引用需要回收的 udata 。 u data 的处理与其他数据类型不同，<br>由于它是用户传人的数据，它的回收可能会调用用户注册的GC函数，所以统一来处理。<br>KEYWE A KBIT和VALUEWE A KBIT用于标记弱表中键／值的weak属性 。FIXEDBIT和 SFIXEDBIT用于表示该对象不可回收，其中 F IX ED BIT仅用于 lua State对象自身的标记，而SFIXEDBIT标记了一系列Lua语法中的关键字对应的字符串为不可回收字符串，具体可以看看l u aX i n it 函数的实现</p>
<p>在保存全局状态的global_State结构体中，有以下几个与GC相关的数据成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> &#123;</span></span><br><span class="line">  lu_byte currentwhite;<span class="comment">//存放当前GC的白色</span></span><br><span class="line">  lu_byte gcstate;  <span class="comment">//存放GC状态，分别有以下几种 ： GCS pause （暂停阶段） 、 GCSpropagate（传播阶段，用于遍历灰色节点检查对象的引用情况）、 GCSsweepstring （字符串回收阶段） , GCSsweep （回收阶段，用于对除了字符串之外的所有其他数据类型进行回收）和GCSfinalize （终止阶段） 。</span></span><br><span class="line">  <span class="keyword">int</span> sweepstrgc;  <span class="comment">//字符串回收阶段，每次针对字符串散列桶的一组字符串进行回收，这个值用于记录对应的散列桶索引 。</span></span><br><span class="line">  GCObject *rootgc;  <span class="comment">//存放待GC对象的链表，所有对象创建之后都会放入该链表中</span></span><br><span class="line">  GCObject **sweepgc; <span class="comment">//待处理的回收数据都存放在rootgc链表中，由于回收阶段不是一次性全部回收这个链表的所有数据，所以使用这个变量来保存当前回收的位置，下一次从这个位置开始继续回收操作</span></span><br><span class="line">  GCObject *gray;  <span class="comment">//存放灰色节点的链表</span></span><br><span class="line">  GCObject *grayagain; <span class="comment">//存放需要一次性扫描处理的灰色节点链表，也就是说，这个链表上所有数据的处理需要一步到位，不能被打断</span></span><br><span class="line">  GCObject *weak;  <span class="comment">//存放弱表的链表</span></span><br><span class="line">  GCObject *tmudata;  <span class="comment">//所有带有GC元方法的 udata存放在一个链表中，这个成员指向这千链表的最后一个元素</span></span><br><span class="line">  lu_mem GCthreshold;<span class="comment">//开始进行GC的阔值，当totalbytes大于这个值时开始自动GC</span></span><br><span class="line">  lu_mem totalbytes;  <span class="comment">//当前分配的内存大小</span></span><br><span class="line">  lu_mem estimate; <span class="comment">//一个估计值，用于保存实际在用的内存大小 </span></span><br><span class="line">  lu_mem gcdept;  <span class="comment">//用于在单次GC之前保存待回收的数据大小</span></span><br><span class="line">  <span class="keyword">int</span> gcpause;  <span class="comment">//用于控制下一轮GC开始的时机</span></span><br><span class="line">  <span class="keyword">int</span> gcstepmul; <span class="comment">//控制GC的回收速度</span></span><br><span class="line">  ...</span><br><span class="line">&#125; global_State;</span><br></pre></td></tr></table></figure>
<h3 id="新创建对象"><a href="#新创建对象" class="headerlink" title="新创建对象"></a>新创建对象</h3><p>从前面的分析可以知道，对于每个新创建的对象，最基本的操作就是将对象的颜色设置为白色，意指本次GC还未扫描到的对象，同时将对象挂载到扫描过程会遍历的链表上 。 基本思想就是如此，但是针对不同的数据类型，会有不同的处理。</p>
<p>一般的数据类型调用的是luaC_link函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_link</span> <span class="params">(lua_State *L, GCObject *o, lu_byte tt)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  o-&gt;gch.next = g-&gt;rootgc;</span><br><span class="line">  g-&gt;rootgc = o;</span><br><span class="line">  o-&gt;gch.marked = luaC_white(g);</span><br><span class="line">  o-&gt;gch.tt = tt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数做的事情为：</p>
<ul>
<li>将对象挂载到 rootgc链表上</li>
<li>设置颜色为白色</li>
<li>设置数据的类型</li>
</ul>
<p>但是UpValue和udata类型的数据的创建过程有些不一样<br>先来看UpValue，新建一个UpValue类型的数据，调用的是luaC_linkupval函数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_linkupval</span> <span class="params">(lua_State *L, UpVal *uv)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = obj2gco(uv);</span><br><span class="line">  o-&gt;gch.next = g-&gt;rootgc;  <span class="comment">/* link upvalue into `rootgc&#x27; list */</span></span><br><span class="line">  g-&gt;rootgc = o;</span><br><span class="line">  <span class="keyword">if</span> (isgray(o)) &#123; </span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcstate == GCSpropagate) &#123;</span><br><span class="line">      gray2black(o);  <span class="comment">/* closed upvalues need barrier */</span></span><br><span class="line">      luaC_barrier(L, uv, uv-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* sweep phase: sweep it (turning it into white) */</span></span><br><span class="line">      makewhite(g, o);</span><br><span class="line">      lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的疑问是，前面的数据类型在最开始的时候 ，都是将颜色设置为白色，而针对UpValue,则是根据颜色是不是灰色来做后面的一些操作 。 原因在于， UpValue是针对已有对象的间接引用，所以它的处理在对象颜色是灰色的情况下区分了两种情况 。</p>
<ul>
<li>如果当前在扫描阶段，那么将对象从灰色变成黑色 。 需要注意的是，到这一步需要加barrier </li>
<li>如果不是在扫描阶段，都置为白色 。 第705行的注释说到这一步，将其回 收， 其实这个表达并不完全准确 。 这里置为白色，我的理解和创建其他类型数据的函数luaC link一样，都是一个创建对象的正常流程 。</li>
</ul>
<p>再来看udata数据的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Udata *<span class="title">luaS_newudata</span> <span class="params">(lua_State *L, <span class="keyword">size_t</span> s, Table *e)</span> </span>&#123;</span><br><span class="line">  Udata *u;</span><br><span class="line">  <span class="keyword">if</span> (s &gt; MAX_SIZET - <span class="keyword">sizeof</span>(Udata))</span><br><span class="line">    luaM_toobig(L);</span><br><span class="line">  u = cast(Udata *, luaM_malloc(L, s + <span class="keyword">sizeof</span>(Udata)));</span><br><span class="line">  u-&gt;uv.marked = luaC_white(G(L));  <span class="comment">/* is not finalized */</span></span><br><span class="line">  u-&gt;uv.tt = LUA_TUSERDATA;</span><br><span class="line">  u-&gt;uv.len = s;</span><br><span class="line">  u-&gt;uv.metatable = <span class="literal">NULL</span>;</span><br><span class="line">  u-&gt;uv.env = e;</span><br><span class="line">  <span class="comment">/* chain it on udata list (after main thread) */</span></span><br><span class="line">  u-&gt;uv.next = G(L)-&gt;mainthread-&gt;next;</span><br><span class="line">  G(L)-&gt;mainthread-&gt;next = obj2gco(u);</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何时候创建的 udata ，在GC链表中都会放在mainthread之后 。 除此之外，这类型的数据与其他数据并无差别 。 之所以这么做，是因为udata是用户注册的C数据。 在回收时，我们可能会调用用户注册的函数，此时就需要把这些udata统一放在一个地方来处理，这样做是为了方便编写代码 。 </p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>前面提到过， Lua的GC过程是增聋的 、 中间可以被打断的，每一次单独进入 GC时，都会根据当前GC所处的阶段来进行不同的处理，这个人口函数是singlestep。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (g-&gt;gcstate) &#123;</span><br><span class="line">  <span class="keyword">case</span> GCSpause: &#123;</span><br><span class="line">    markroot(L);  <span class="comment">/* start a new collection */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>初始化阶段将从root节点出发，遍历rootl连表上的所有节点，将它们的颜色从白色变成灰色，加入到gray链表中 。 初始化阶段的人口是markroot函数 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mark root set */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markroot</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  g-&gt;gray = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">  markobject(g, g-&gt;mainthread);</span><br><span class="line">  <span class="comment">/* make global table be traversed before main stack */</span></span><br><span class="line">  markvalue(g, gt(g-&gt;mainthread));</span><br><span class="line">  markvalue(g, registry(L));</span><br><span class="line">  markmt(g);</span><br><span class="line">  g-&gt;gcstate = GCSpropagate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 markobject和『『1arkvalue函数都用于标记对象的颜色为灰色，不同的是前者是针对object而后者是针对TValue ，它们最终都会调用reallymarkobject 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reallymarkobject</span> <span class="params">(global_State *g, GCObject *o)</span> </span>&#123;</span><br><span class="line">  lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">  white2gray(o);</span><br><span class="line">  <span class="keyword">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TUSERDATA: &#123;</span><br><span class="line">      Table *mt = gco2u(o)-&gt;metatable;</span><br><span class="line">      gray2black(o);  <span class="comment">/* udata are never gray */</span></span><br><span class="line">      <span class="keyword">if</span> (mt) markobject(g, mt);</span><br><span class="line">      markobject(g, gco2u(o)-&gt;env);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TUPVAL: &#123;</span><br><span class="line">      UpVal *uv = gco2uv(o);</span><br><span class="line">      markvalue(g, uv-&gt;v);</span><br><span class="line">      <span class="keyword">if</span> (uv-&gt;v == &amp;uv-&gt;u.value)  <span class="comment">/* closed? */</span></span><br><span class="line">        gray2black(o);  <span class="comment">/* open upvalues are never black */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TFUNCTION: &#123;</span><br><span class="line">      gco2cl(o)-&gt;c.gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTABLE: &#123;</span><br><span class="line">      gco2h(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTHREAD: &#123;</span><br><span class="line">      gco2th(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TPROTO: &#123;</span><br><span class="line">      gco2p(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: lua_assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于绝大部分类型的对象，这里只是简单地将其颜色改变为灰色并加入到gray链表中，但是有几个类型是区别处理的</p>
<ul>
<li>对于字符串类型的数据，由于这种类型没有引用其他数据，所以略过将其颜色改为灰色的流程，直接将不是黑色的字符串对象回收即可 。</li>
<li>对于 udata类型的数据，因为这种类型永远也不会引用其他数据，所以这里也是一步到位，直接将其标记为黑色。 另外，对于这种类型，还需要标记对应的metatable和env表。</li>
<li>对于UpValue类型的数据，如果当前是close状态的话，那么该UpValue 已经没有与其他数据的引用关系了，可以直接标记为黑色 。 至于open状态的 UpValue ，由于其引用状态可能会频繁发生变动，所以留待后面的remarkupvals函数进行原子性的标记</li>
</ul>
<h3 id="扫描标记阶段"><a href="#扫描标记阶段" class="headerlink" title="扫描标记阶段"></a>扫描标记阶段</h3><p>扫描阶段就是遍历灰色对象链表来分析对象的引用情况，这个阶段是GC所有阶段中步骤最长的 。 整个过程分为两部分。 第一步首先遍历gray链表来标记所有数据，在这个过程中，有些数据需要重新扫描，这些数据会放在grayagain链表中，调用 atomic 函数重新进行扫描。 而第二步则是遍历grayagain链表，一次性扫描其中的数据 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GCSpropagate: &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;gray)</span><br><span class="line">        <span class="keyword">return</span> propagatemark(g);</span><br><span class="line">      <span class="keyword">else</span> &#123;  <span class="comment">/* no more `gray&#x27; objects */</span></span><br><span class="line">        atomic(L);  <span class="comment">/* finish mark phase */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一步将扫描所有gray链表中的对象，将它们及其引用到的对象标记成黑色 。 需要注意的是，前面的初始化阶段是一次到位的，而这一步却可以多次进行，每次扫描之后会返回本次扫描标记的对象大小之和，其入口函数是propagatemark ，再次扫描时，只要gray链表中还有待扫描的对象，就继续执行这个函数进行标记 。 当灰色链表已经遍历完毕时，进入atomic函数中完成标记阶段。</p>
<p>可以看到，第一步遍历gray链表中对象的处理是可以中断的，而第二步调用atomic 函数的操作是原子的、不能被打断的，这也是atomic函数的名字由来 。 这是Lua 5.1 的GC算法优于之前版本的GC算法的原因之一 ： 可以增量地来进行数据扫描，不会因为一次GC扫描操作导致整个系统被卡住很久 。</p>
<p>propagatemark 函数与前面的 reallymarkobject 函数做的事情其实差不多，都是对对象标记颜色的动作 。 区别在于，这里将对象从灰色标记成黑色，表示这个对象及其所引用的对象都已经标记过 。 另一个区别在于，前面的流程不会递归对一个对象所引用的对象进行标记，而这里会根据不同的类型调用对应向土raverse＊函数进行标记。 在实际工作中，对每种类型的对象的处理还不太一样，下面逐个类型来看看 。</p>
<h4 id="扫描Table对象"><a href="#扫描Table对象" class="headerlink" title="扫描Table对象"></a>扫描Table对象</h4><p>在tra versetable函数中，如果扫描到该表是弱表，那么将会把该对象加入weak链表中，这个链表将在扫描阶段的最后一步进行一次不能中断的处理，这部分将在后面谈到 。 同时，如果该表是弱表，那么将该对象回退到灰色状态，重新进行扫描。 在不是弱表的情况下，将遍历标记表的散列部分及数组部分的所有元素 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTABLE: &#123;</span><br><span class="line">      Table *h = gco2h(o);</span><br><span class="line">      g-&gt;gray = h-&gt;gclist;</span><br><span class="line">      <span class="keyword">if</span> (traversetable(g, h))  <span class="comment">/* table is weak? */</span></span><br><span class="line">        black2gray(o);  <span class="comment">/* keep it gray */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">sizeof</span>(Table) + <span class="keyword">sizeof</span>(TValue) * h-&gt;sizearray +</span><br><span class="line">                             <span class="keyword">sizeof</span>(Node) * sizenode(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描函数对象"><a href="#扫描函数对象" class="headerlink" title="扫描函数对象"></a>扫描函数对象</h4><p>针对函数对象，进行处理的函数是traverseclosure ，该函数主要是对函数中的所有 UpValue进行标记。 相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LUA_TFUNCTION: &#123;</span><br><span class="line">      Closure *cl = gco2cl(o);</span><br><span class="line">      g-&gt;gray = cl-&gt;c.gclist;</span><br><span class="line">      traverseclosure(g, cl);</span><br><span class="line">      <span class="keyword">return</span> (cl-&gt;c.isC) ? sizeCclosure(cl-&gt;c.nupvalues) :</span><br><span class="line">                           sizeLclosure(cl-&gt;l.nupvalues);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描线程对象"><a href="#扫描线程对象" class="headerlink" title="扫描线程对象"></a>扫描线程对象</h4><p>针对线程对象，这里的处理是将该对象从gcli st中摘下来，放入grayaga in链表中，同时将颜色退回到灰色，以备后面的原子阶段再做一次扫描 。 因为t hread上关联的对象是Lua运行时的状态，变化很频繁，所以这里只是简单地放在grayagain链表中 ， 后面再一次性标记完毕 。 相关代码如下 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LUA_TTHREAD: &#123;</span><br><span class="line">      lua_State *th = gco2th(o);</span><br><span class="line">      g-&gt;gray = th-&gt;gclist;</span><br><span class="line">      th-&gt;gclist = g-&gt;grayagain;</span><br><span class="line">      g-&gt;grayagain = o;</span><br><span class="line">      black2gray(o);</span><br><span class="line">      traversestack(g, th);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">sizeof</span>(lua_State) + <span class="keyword">sizeof</span>(TValue) * th-&gt;stacksize +</span><br><span class="line">                                 <span class="keyword">sizeof</span>(CallInfo) * th-&gt;size_ci;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描proto对象"><a href="#扫描proto对象" class="headerlink" title="扫描proto对象"></a>扫描proto对象</h4><p>最后一种特殊类型是 Proto类型，将会调用traverseproto函数标记一个 Proto数据中的文件名、字符串 、 upvalue 、局部变量等所有被引用的对象 。</p>
<h4 id="扫描其余的类型"><a href="#扫描其余的类型" class="headerlink" title="扫描其余的类型"></a>扫描其余的类型</h4><p>就是简单地调用gray2black将颜色从灰色置为黑色就好了</p>
<h4 id="barrier操作"><a href="#barrier操作" class="headerlink" title="barrier操作"></a>barrier操作</h4><p>从前面的描述可以知道，分步增量式的扫描标记算法中间可以被打断以执行其他操作，此时就会出现新增加的对象与已经被扫描过的对象之间会有引用关系的变化，而算法中需要保证不会出现黑色对象引用的对象中有白色对象的情况，于是需要两种不同的处理</p>
<ul>
<li>标记过程向前走一步。 这种情况指的是，如果一个新创建对象的颜色是白色，而它被一个黑色对象引用了，那么将这个对象的颜色从白色变成灰色，也就是这个GC过程中的进度向前走了一步。</li>
<li>标记过程向后走一步 。 与前面的情况一样，但是此时是将黑色的对象回退到灰色，也就是这个原先已经被标记为黑色的对象需要重新被扫描，这相当于在GC过程中向后走了一步 。<br>在代码中，最终调用 luaC ba rr ierf函数的都是向前走的操作；反之，调用luaC barrierback的操作则是向后走的操作：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_barrier(L,p,v) &#123; <span class="meta-keyword">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(p)))  \</span></span><br><span class="line">	luaC_barrierf(L,obj2gco(p),gcvalue(v)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_barriert(L,t,v) &#123; <span class="meta-keyword">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(t)))  \</span></span><br><span class="line">	luaC_barrierback(L,t); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_objbarrier(L,p,o)  \</span></span><br><span class="line">	&#123; <span class="keyword">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(p))) \</span><br><span class="line">		luaC_barrierf(L,obj2gco(p),obj2gco(o)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_objbarriert(L,t,o)  \</span></span><br><span class="line">   &#123; <span class="keyword">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(t))) luaC_barrierback(L,t); &#125;</span><br></pre></td></tr></table></figure>
可以看到，回退操作仅针对Table类型的对象，而其他类型的对象都是向前操作 。<br>Table是Lua中最常见的数据结构，而且一个Tab le与其关联的k町、 va lue之间是 l t~N的对应关系 。 如果针对Table对象做的是向前的标记操作，那么就意味着：但凡一个Table只要有新增的对象，都帘要将这个新对象标记为灰色并加入gray链表中等待扫描。<br>实际上，这样会有不必要的开销 。 所以，针对Table类型的对象，使用的是针对该Table对象本身要做的向后操作，这样不论有多少个对象新增至UTable中，只要改变了一次，就将这个Table对象回退到灰色状态，等待重新扫描 。 但是这里需要注意的是，对Table对象进行回退操作时，并不是将它放入gray链表中，因为这样做实际上还会出现前面提到的多次反复标记的问题。 针对Table对象，对它执行回退操作，是将它加入到 grayagain链表中，用于在扫描完毕gray链表之后再进行一次性的原子扫描：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_barrierback</span> <span class="params">(lua_State *L, Table *t)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = obj2gco(t);</span><br><span class="line">  lua_assert(isblack(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">  black2gray(o);  <span class="comment">/* make table gray (again) */</span></span><br><span class="line">  t-&gt;gclist = g-&gt;grayagain;</span><br><span class="line">  g-&gt;grayagain = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，需要进行barrierback操作的对象，最后并没有如新建对象那样加入gray链表中，而是加入grayagain列表中，避免一个对象频繁地进行“被回退－扫描－回退－扫描”过程 。 既然需要重新扫描，那么一次J性地放在grayagain链表中就可以了 。 至于如何回收grayagain链表中的数据，下面将说明</li>
</ul>
<p>而相对地，向前的操作就简单多了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_barrierf</span> <span class="params">(lua_State *L, GCObject *o, GCObject *v)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span><br><span class="line">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">  lua_assert(ttype(&amp;o-&gt;gch) != LUA_TTABLE);</span><br><span class="line">  <span class="comment">/* must keep invariant? */</span></span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcstate == GCSpropagate)</span><br><span class="line">    reallymarkobject(g, v);  <span class="comment">/* restore invariant */</span></span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">/* don&#x27;t mind */</span></span><br><span class="line">    makewhite(g, o);  <span class="comment">/* mark as white just to avoid other barriers */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只要当前的GC没有在扫描标记阶段，就标记这个对象，否则将对象标记为白色，等待下一次的GC<br>当gray链表中没有对象时，并不能马上进入下一个阶段，这是因为前面还有未处理的数据，这一步需要一次性不被中断地完成，其人口是atomic函数<br>前面提到Lua的增量式GC算法分为多个阶段，可以被中断，然而这一步则例外。 这一步将处理弱表链表和前面提到的grayagain链表，是扫描阶段的最后一步，不可中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomic</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">size_t</span> udsize;  <span class="comment">/* total size of userdata to be finalized */</span></span><br><span class="line">  <span class="comment">/* remark occasional upvalues of (maybe) dead threads */</span></span><br><span class="line">  remarkupvals(g);</span><br><span class="line">  <span class="comment">/* traverse objects cautch by write barrier and by &#x27;remarkupvals&#x27; */</span></span><br><span class="line">  propagateall(g);</span><br><span class="line">  <span class="comment">/* remark weak tables */</span></span><br><span class="line">  g-&gt;gray = g-&gt;weak;</span><br><span class="line">  g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">  lua_assert(!iswhite(obj2gco(g-&gt;mainthread)));</span><br><span class="line">  markobject(g, L);  <span class="comment">/* mark running thread */</span></span><br><span class="line">  markmt(g);  <span class="comment">/* mark basic metatables (again) */</span></span><br><span class="line">  propagateall(g);</span><br><span class="line">  <span class="comment">/* remark gray again */</span></span><br><span class="line">  g-&gt;gray = g-&gt;grayagain;</span><br><span class="line">  g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  propagateall(g);</span><br><span class="line">  udsize = luaC_separateudata(L, <span class="number">0</span>);  <span class="comment">/* separate userdata to be finalized */</span></span><br><span class="line">  marktmu(g);  <span class="comment">/* mark `preserved&#x27; userdata */</span></span><br><span class="line">  udsize += propagateall(g);  <span class="comment">/* remark, to propagate `preserveness&#x27; */</span></span><br><span class="line">  cleartable(g-&gt;weak);  <span class="comment">/* remove collected objects from weak tables */</span></span><br><span class="line">  <span class="comment">/* flip current white */</span></span><br><span class="line">  g-&gt;currentwhite = cast_byte(otherwhite(g));</span><br><span class="line">  g-&gt;sweepstrgc = <span class="number">0</span>;</span><br><span class="line">  g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class="line">  g-&gt;gcstate = GCSsweepstring;</span><br><span class="line">  g-&gt;estimate = g-&gt;totalbytes - udsize;  <span class="comment">/* first estimate */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我们分别做了以下几个操作</p>
<ul>
<li>调用remarkupvals 函数去标记open状态的UpValue ，这一步完毕之后， gray链表又会有新的对象，于是需要调用 propagateall再次将gray链表中的对象标记一下 。</li>
<li>修改gray链表指针，使其指向管理弱表的weak指针，同时标记当前的 Lua_State指针以及基本的meta表。</li>
<li>修改gray链表指针指向grayagain指针，同样是调用propagateall函数进行遍历扫描操作。</li>
<li>调用luaC_separateudatax;fudata进行处理。</li>
<li>在第548行，还将当前白色类型切换到了下一次GC操作的白色类型 。</li>
<li>修改状态到下个回收阶段。</li>
</ul>
<p>现在就可以谈谈前面提到的对udata进行处理的luaC_separateudata 函数了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move `dead&#x27; udata that need finalization to list `tmudata&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">luaC_separateudata</span> <span class="params">(lua_State *L, <span class="keyword">int</span> all)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">size_t</span> deadmem = <span class="number">0</span>;</span><br><span class="line">  GCObject **p = &amp;g-&gt;mainthread-&gt;next;</span><br><span class="line">  GCObject *curr;</span><br><span class="line">  <span class="keyword">while</span> ((curr = *p) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))</span><br><span class="line">      p = &amp;curr-&gt;gch.next;  <span class="comment">/* don&#x27;t bother with them */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fasttm(L, gco2u(curr)-&gt;metatable, TM_GC) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      markfinalized(gco2u(curr));  <span class="comment">/* don&#x27;t need finalization */</span></span><br><span class="line">      p = &amp;curr-&gt;gch.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* must call its gc method */</span></span><br><span class="line">      deadmem += sizeudata(gco2u(curr));</span><br><span class="line">      markfinalized(gco2u(curr));</span><br><span class="line">      *p = curr-&gt;gch.next;</span><br><span class="line">      <span class="comment">/* link `curr&#x27; at the end of `tmudata&#x27; list */</span></span><br><span class="line">      <span class="keyword">if</span> (g-&gt;tmudata == <span class="literal">NULL</span>)  <span class="comment">/* list is empty? */</span></span><br><span class="line">        g-&gt;tmudata = curr-&gt;gch.next = curr;  <span class="comment">/* creates a circular list */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        curr-&gt;gch.next = g-&gt;tmudata-&gt;gch.next;</span><br><span class="line">        g-&gt;tmudata-&gt;gch.next = curr;</span><br><span class="line">        g-&gt;tmudata = curr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deadmem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它主要对mainthread之后的对象进行遍历（前面谈到了将udata放在mai nthread之后，这是为了统一放在一个地方，方便处理），然后进行如下的操作 。</p>
<ul>
<li>如果该对象不需要回收，就继续处理下一个对象。</li>
<li>否则，先看该对象有没有注册GC函数，如果没有，就直接标记该对象的状态是finalized 。</li>
<li>否则，除了标记该对象为 finalized之外，还将这些对象加入tmudata链表中 。 同样，这里将udata放在一个链表中也是为了统一处理，后面将会提至Ufina l ized状态的处理。</li>
</ul>
<h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p>回收阶段分为两步，一步是针对字符串类型的回收，另一步则是针对其他类型对象的回收 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GCSsweepstring: &#123;</span><br><span class="line">      lu_mem old = g-&gt;totalbytes;</span><br><span class="line">      sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  <span class="comment">/* nothing more to sweep? */</span></span><br><span class="line">        g-&gt;gcstate = GCSsweep;  <span class="comment">/* end sweep-string phase */</span></span><br><span class="line">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">return</span> GCSWEEPCOST;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> GCSsweep: &#123;</span><br><span class="line">      lu_mem old = g-&gt;totalbytes;</span><br><span class="line">      g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span><br><span class="line">      <span class="keyword">if</span> (*g-&gt;sweepgc == <span class="literal">NULL</span>) &#123;  <span class="comment">/* nothing more to sweep? */</span></span><br><span class="line">        checkSizes(L);</span><br><span class="line">        g-&gt;gcstate = GCSfinalize;  <span class="comment">/* end sweep phase */</span></span><br><span class="line">      &#125;</span><br><span class="line">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">return</span> GCSWEEPMAX*GCSWEEPCOST;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>针对字符串类型的数据，每次调用sweepwholelist函数回收字符串散列桶数组中的一个字符串链表，其中每次操作的散列桶索引值存放在sweepstrgc变量中 。 当所有字符串散列桶数据全部遍历完毕时，切换到下一个状态GCSsweep进行其他数据的回收</p>
<p>对于其他类型数据的回收，我们调用sweeplist函数进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> GCObject **<span class="title">sweeplist</span> <span class="params">(lua_State *L, GCObject **p, lu_mem count)</span> </span>&#123;</span><br><span class="line">  GCObject *curr;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">int</span> deadmask = otherwhite(g);</span><br><span class="line">  <span class="keyword">while</span> ((curr = *p) != <span class="literal">NULL</span> &amp;&amp; count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr-&gt;gch.tt == LUA_TTHREAD)  <span class="comment">/* sweep open upvalues of each thread */</span></span><br><span class="line">      sweepwholelist(L, &amp;gco2th(curr)-&gt;openupval);</span><br><span class="line">    <span class="keyword">if</span> ((curr-&gt;gch.marked ^ WHITEBITS) &amp; deadmask) &#123;  <span class="comment">/* not dead? */</span></span><br><span class="line">      lua_assert(!isdead(g, curr) || testbit(curr-&gt;gch.marked, FIXEDBIT));</span><br><span class="line">      makewhite(g, curr);  <span class="comment">/* make it white (for next cycle) */</span></span><br><span class="line">      p = &amp;curr-&gt;gch.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* must erase `curr&#x27; */</span></span><br><span class="line">      lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));</span><br><span class="line">      *p = curr-&gt;gch.next;</span><br><span class="line">      <span class="keyword">if</span> (curr == g-&gt;rootgc)  <span class="comment">/* is the first element of the list? */</span></span><br><span class="line">        g-&gt;rootgc = curr-&gt;gch.next;  <span class="comment">/* adjust first */</span></span><br><span class="line">      freeobj(L, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里我们首先拿到otherwhite ，这表示本次GC操作不可以被回收的白色类型 。 后面就是依次遍历链表中的数据，判断每个对象的白色是否满足被回收的颜色条件。</p>
<h3 id="结束阶段"><a href="#结束阶段" class="headerlink" title="结束阶段"></a>结束阶段</h3><p>走到了最后一步回收阶段，这一阶段主要针对tmudata链表进行处理，在所有数据都处理完毕后，重新将GC状态切换到暂停状态，这表示下一次新的GC可以开始了 。 相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GCSfinalize: &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;tmudata) &#123;</span><br><span class="line">        GCTM(L);</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;estimate &gt; GCFINALIZECOST)</span><br><span class="line">          g-&gt;estimate -= GCFINALIZECOST;</span><br><span class="line">        <span class="keyword">return</span> GCFINALIZECOST;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        g-&gt;gcstate = GCSpause;  <span class="comment">/* end collection */</span></span><br><span class="line">        g-&gt;gcdept = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到了结束阶段，其实也可以中断。 只要tmudata链表中还有对象，就一直调用GCTM函数来处理。 前面提到， tmudata链表是用来存放所有自带GC元方法的 udata对象，因此这里的工作就是调用这些注册的GC元方法进行对象回收：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GCTM</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = g-&gt;tmudata-&gt;gch.next;  <span class="comment">/* get first element */</span></span><br><span class="line">  Udata *udata = rawgco2u(o);</span><br><span class="line">  <span class="keyword">const</span> TValue *tm;</span><br><span class="line">  <span class="comment">/* remove udata from `tmudata&#x27; */</span></span><br><span class="line">  <span class="keyword">if</span> (o == g-&gt;tmudata)  <span class="comment">/* last element? */</span></span><br><span class="line">    g-&gt;tmudata = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    g-&gt;tmudata-&gt;gch.next = udata-&gt;uv.next;</span><br><span class="line">  udata-&gt;uv.next = g-&gt;mainthread-&gt;next;  <span class="comment">/* return it to `root&#x27; list */</span></span><br><span class="line">  g-&gt;mainthread-&gt;next = o;</span><br><span class="line">  makewhite(g, o);</span><br><span class="line">  tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);</span><br><span class="line">  <span class="keyword">if</span> (tm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lu_byte oldah = L-&gt;allowhook;</span><br><span class="line">    lu_mem oldt = g-&gt;GCthreshold;</span><br><span class="line">    L-&gt;allowhook = <span class="number">0</span>;  <span class="comment">/* stop debug hooks during GC tag method */</span></span><br><span class="line">    g-&gt;GCthreshold = <span class="number">2</span>*g-&gt;totalbytes;  <span class="comment">/* avoid GC steps */</span></span><br><span class="line">    setobj2s(L, L-&gt;top, tm);</span><br><span class="line">    setuvalue(L, L-&gt;top+<span class="number">1</span>, udata);</span><br><span class="line">    L-&gt;top += <span class="number">2</span>;</span><br><span class="line">    luaD_call(L, L-&gt;top - <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    L-&gt;allowhook = oldah;  <span class="comment">/* restore hooks */</span></span><br><span class="line">    g-&gt;GCthreshold = oldt;  <span class="comment">/* restore threshold */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCTM函数的主要逻辑就是循环遍历tmudata链表中的对象，针对每个对象调用 fasttm函数，其中会使用GC元方法来进行对象的回收。</p>
<p>当所有操作都完成， tmudata链表中不再有对象了，此时一个GC的完整流程就走完了， Lua将GC状态切换到GCSpause ，等待下一次的GC操作 </p>
<h2 id="进度控制"><a href="#进度控制" class="headerlink" title="进度控制"></a>进度控制</h2><p>在Lua代码中，有两种回收方式，一种是自动回收，一种是由用户自己调用API来触发一次回收。<br>自动回收会在每次调用内存分配相关的操作时检查是再满足触发条件，这个操作在宏luaC_checkGC中进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_checkGC(L) &#123; \</span></span><br><span class="line">  condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - <span class="number">1</span>)); \</span><br><span class="line">  <span class="keyword">if</span> (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \</span><br><span class="line">	luaC_step(L); &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，触发自动化GC的条件就是： totalbytes大于等于GCthreshold值。 在这两个变量中， totalbytes用于保存当前分配的内存大小，而GCthreshold保存的是一个｜竭值，这个值可以由一些参数影响和控制，由此改变触发的条件。<br>由于自动GC会在使用者不知道的情况下触发，不太可控，因而很多人选择关闭它，具体操作就是通过将GCthreshold设置为一个非常大的值来达到一直不满足自动触发条件。<br>接下来，看看手动 GC受哪些参数影响 。 首先， estimate 和 gcpause两个成员将影响每次GCthreshold 的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> setthreshold(g)  (g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)</span></span><br></pre></td></tr></table></figure>
<p>这里estimate是一个预估的当前使用的内存数量，而gcpause则是一个百分比，这个宏的作用就是按照估计值的百分比计算出新的阔值来 。 其中， gcpause通过lua_gc这个C接口来进行设置。 可以看到，百分比越大，下一次开始GC的时间就会越长 。</p>
<p>另一个影响GC进度的参数是gcstepmul成员，它同样可以通过 lua_gc来设置。 这个参数将影响每次手动GC时调用 singlestep函数的次数，从而影响到GC回收的速度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_step</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  l_mem lim = (GCSTEPSIZE/<span class="number">100</span>) * g-&gt;gcstepmul;</span><br><span class="line">  <span class="keyword">if</span> (lim == <span class="number">0</span>)</span><br><span class="line">    lim = (MAX_LUMEM<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">/* no limit */</span></span><br><span class="line">  g-&gt;gcdept += g-&gt;totalbytes - g-&gt;GCthreshold;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    lim -= singlestep(L);</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcstate == GCSpause)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (lim &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcstate != GCSpause) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcdept &lt; GCSTEPSIZE)</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE;  <span class="comment">/* - lim/g-&gt;gcstepmul;*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      g-&gt;gcdept -= GCSTEPSIZE;</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_assert(g-&gt;totalbytes &gt;= g-&gt;estimate);</span><br><span class="line">    setthreshold(g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简要说明这个函数中各行代码的作用 。</p>
<ul>
<li>第 612～614 行： GCSTEPSIZE 是一个宏，表示每次 GC 的步长大小 。 使用这个宏以及gcstepmul参数，可以计算出这一次回收计划至少回收的内存数量 。</li>
<li>第615行： gcdept用于在每次回收之前累加当前使用内存到阔值之间的差值，用于后面计算下一次触发GC的阑值。</li>
<li>第616-620行 ：当计划待回收内存还没有回收完之前，一直循环调用 singlestep 函数来进行回收，除非这里完成了完整的GC。</li>
<li>第621 ～631 行 ：完成回收之后，设置下一次触发回收操作的 ｜胡值 。 如果此时状态不是GCSpause ，那么表示没有完成一个 GC ， 此时分两种情况来处理：如果前面保存的 gcdept太小，小于GCSTEPSIZE ，那么下一次阔值就设置得比当前使用内存大GCSTEPSIZE ，即只要再多分配 GCSTEPSIZE 的内存就会再次触发 GC ；否则将 gcdept 减去 GCSTEPSIZE ，将GCthreshold设置得跟 totalbytes一样，以求尽快触发下一次GC 。 如果完成了一个 GC,那么调用 setthreshold来计算下一次GC的阔值。 可以看到 setthreshold只会在一次GC完成之后被调用，而不会影响没有完成的GC全流程 。 因此， setthreshold影响的是两次完整GC之间的时长 。 而gcdept参数会在每次GC完毕之后重新清零，它用于保存一次完整GC的内部状态 。</li>
</ul>
<p>同时，还需要注意的一点是，这个过程会改变GCthreshold的值，所以如果希望关闭自动GC,还需要在手动执行完一次GC之后重新设置关闭自动GC 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Lua设计与实现》<br>New Garbage Collector 详见<a target="_blank" rel="noopener" href="http://wiki.luajit.org/New-Garbage-Collector">http://wiki.luajit.org/New-Garbage-Collector</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/lua/" rel="tag"><i class="fa fa-tag"></i> lua</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/20/lua%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="prev" title="lua虚拟机">
      <i class="fa fa-chevron-left"></i> lua虚拟机
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/22/lua-Table/" rel="next" title="lua Table">
      lua Table <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">双色标记清除算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">三色增量标记清除算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">GC的全流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">新创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-number">4.2.</span> <span class="nav-text">初始化阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">4.3.</span> <span class="nav-text">扫描标记阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8FTable%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.1.</span> <span class="nav-text">扫描Table对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.2.</span> <span class="nav-text">扫描函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.3.</span> <span class="nav-text">扫描线程对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8Fproto%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.4.</span> <span class="nav-text">扫描proto对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E5%85%B6%E4%BD%99%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.3.5.</span> <span class="nav-text">扫描其余的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#barrier%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.6.</span> <span class="nav-text">barrier操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="nav-number">4.4.</span> <span class="nav-text">回收阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E9%98%B6%E6%AE%B5"><span class="nav-number">4.5.</span> <span class="nav-text">结束阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%BA%A6%E6%8E%A7%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">进度控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <!--
  <p class="site-author-name" itemprop="name">losophy</p>
  -->
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">losophy</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
