[{"title":"Actor模型","url":"/post/d6fe94a3.html","content":"<p>The actor model in computer science is a mathematical model of concurrent computation that treats actor as the universal primitive of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Actor模型\"><a href=\"#Actor模型\" class=\"headerlink\" title=\"Actor模型\"></a>Actor模型</h2><p><code>Actor</code>模型被称为高并发事务的终极解决方案，实体之通过消息通讯，各自处理自己的数据，能够实现这并行。<br><code>Actor</code>模型实例：<code>skynet</code>，<code>Erlang</code>。</p>\n<p><code>Actor</code>模型是一个概念模型，用于处理并发计算。它定义了一系列系统组件应该如何动作和交互的通用规则，最著名的使用这套规则的编程语言是<code>Erlang</code>。<br>一个<code>Actor</code>指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。<br>这个理念很像面向对象语言，一个对象接收一条消息（方法调用），然后根据接收的消息做事（调用了哪个方法）。</p>\n<p><code>Actors</code>一大重要特征在于<code>actors</code>之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个<code>actor</code>能维持一个私有的状态，并且这个状态不可能被另一个<code>actor</code>所改变。</p>\n<h2 id=\"思路方向\"><a href=\"#思路方向\" class=\"headerlink\" title=\"思路方向\"></a>思路方向</h2><p>其实无论是使用数据库锁 还是多线程，这里有一个共同思路，就是将数据喂给线程，就如同计算机是一套加工流水线，数据作为原材料投入这个流水线的开始，流水线出来后就是成品，这套模式的前提是数据是被动的，自身不复杂，没有自身业务逻辑要求。适合大数据处理或互联网网站应用等等。</p>\n<p>但是如果数据自身要求有严格的一致性，也就是事务机制，数据就不能被动被加工，要让数据自己有行为能力保护实现自己的一致性，就像孩子小的时候可以任由爸妈怎么照顾关心都可以，但是如果孩子长大有自己的思想和要求，他就可能不喜欢被爸妈照顾，他要求自己通过行动实现自己的要求。</p>\n<p>数据也是如此。只有我们改变思路，让数据自己有行为维护自己的一致性，才能真正安全实现真正的事务。<br>我们可以看到：</p>\n<blockquote>\n<p><code>Actor</code>模型=数据+行为+消息</p>\n</blockquote>\n<p><code>Actor</code>模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证<code>Actor</code>内部数据只有被自己修改。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/138\">El salir de la posada es la mayor jornada y más difícil es llegar a buen puerto. El fin corona la obra.</a></p>\n","tags":["design"]},{"title":"Hexo+GitHub Pages博客搭建","url":"/post/aae6d682.html","content":"<p><code>Hexo</code>是一种使用<code>Node.js</code>编写的静态博客框架，快速、简洁、扩展丰富。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h2><p>从官网下载<code>Node.js</code>，安装。<br>安装结束后，添加阿里的国内镜像源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用GitHub-Pages\"><a href=\"#使用GitHub-Pages\" class=\"headerlink\" title=\"使用GitHub Pages\"></a>使用GitHub Pages</h2><p><a href=\"https://pages.github.com/\">GitHub Pages</a> 是一个<code>GitHub</code>提供的静态站点托管服务。<br>新建一个项目，项目名为<code>（你的账号名.github.io）</code>。<br>建成项目后，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。<br>然后等一会儿，再回到<code>GitHub Pages</code>，点击那个链接，就可以看见自己的网页了。</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件就存放在<code>D:\\blog</code>目录下。<br><code>cmd</code>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装<code>Hexo</code>。会有几个报错，无视它即可。<br>安装完后输入<code>hexo -v</code>可以验证是否安装成功。</p>\n<div class=\"note info\"><p>如遇到，无法加载文件 .ps1，这是因为在此系统中禁止执行脚本的缘故。执行下列命令即可解决。</p></div>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set-executionpolicy remotesigned</span><br><span class=\"line\">输入y</span><br></pre></td></tr></table></figure>\n<p>然后就可以初始化网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。<br>这样本地的网站配置也就弄好了，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>\n<p>就可以在本地看到博客了。</p>\n<h2 id=\"写文章、发布文章\"><a href=\"#写文章、发布文章\" class=\"headerlink\" title=\"写文章、发布文章\"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开<code>git bash</code>，安装一个扩展<code>npm i hexo-deployer-git</code>。<br>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。<br>然后打开<code>D:\\blog\\source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>编写完<code>markdown</code>文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到<code>github</code>上。这时打开你的<code>github.io</code>主页就能看到发布的文章了。</p>\n<h2 id=\"删除文章\"><a href=\"#删除文章\" class=\"headerlink\" title=\"删除文章\"></a>删除文章</h2><p>直接在<code>source/_post</code>，删除所需删除的<code>md</code>文件。<br>执行<code>hexo clean</code>清除缓存文件 <code>(db.json) </code>和已生成的静态文件<code> (public)</code>。<br>然后再生成发布</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<h2 id=\"绑定私人域名\"><a href=\"#绑定私人域名\" class=\"headerlink\" title=\"绑定私人域名\"></a>绑定私人域名</h2><p><code>ping</code>你的<code>github.io</code>域名，得到一个IP。<br>修改你的域名解析记录，添加一个A记录，用得到的IP。<br><img src=\"https://user-images.githubusercontent.com/11263320/111414144-6d71b500-871a-11eb-824f-ef1c4c9fee70.JPG\" alt=\"捕获\"><br>在<code>blog\\source</code>生成文件<code>CNAME</code>，内容为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">你要用到的域名</span><br></pre></td></tr></table></figure>\n<div class=\"note warning\"><p>注意域名不要加http://或https://。</p></div>\n\n<p>再生成发布下<code>hexo</code>就可以了。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/6\">Cualquier cosa que la mente del hombre puede concebir o creer se puede.</a></p>\n","tags":["blog"]},{"title":"Hexo替换主题","url":"/post/e0582cf9.html","content":"<p>之前在<a href=\"https://github.com/losophy/losophy.github.io/issues/6\">Hexo+GitHub Pages博客搭建</a>搭建了博客，这里将替换hexo的主题。这个<a href=\"https://hexo.io/themes/\">网站</a>有很多主题可以供我们去选择。我们这次安装主题也是上面这些主题中其中一个，它就是 NexT。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"安装NexT主题\"><a href=\"#安装NexT主题\" class=\"headerlink\" title=\"安装NexT主题\"></a>安装NexT主题</h2><p>将主题克隆到themes目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> &lt;博客存放的目录&gt;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/114160164-36797280-9959-11eb-95be-9fe07290a533.JPG\" alt=\"gff\"></p>\n<h2 id=\"使用NexT主题\"><a href=\"#使用NexT主题\" class=\"headerlink\" title=\"使用NexT主题\"></a>使用NexT主题</h2><p>打开_config.yml文件，该文件为站点配置文件，存放位置如下图所示：<br><img src=\"https://user-images.githubusercontent.com/11263320/114160272-54df6e00-9959-11eb-907e-16f6e9a907f5.JPG\" alt=\"fgsdfgs\"><br>将主题修改为next<br><img src=\"https://user-images.githubusercontent.com/11263320/114160330-632d8a00-9959-11eb-80dd-fd3020941291.JPG\" alt=\"hgdfshdg\"></p>\n<h2 id=\"部署到服务器\"><a href=\"#部署到服务器\" class=\"headerlink\" title=\"部署到服务器\"></a>部署到服务器</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/114160707-ccad9880-9959-11eb-98b5-9baa2c65bb07.JPG\" alt=\"捕获\"><br>这里可能会出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro&#x2F;post.swig‘ as post_template %&#125;“</span><br></pre></td></tr></table></figure>\n<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/118\">El amor es como el agua que no se seca.</a></p>\n","tags":["blog"]},{"title":"IO模型select,poll,epoll","url":"/post/c352656a.html","content":"<p>服务端需要管理多个客户端连接，而<code>recv</code>只能监视单个<code>socket</code>，而且还不能阻塞。这种矛盾下，人们开始寻找监视多个<code>socket</code>的方法。</p>\n<a id=\"more\"></a>\n\n<p>假如能够预先传入一个<code>socket</code>列表，如果列表中的<code>socket</code>都没有数据，挂起进程，直到有一个<code>socket</code>收到数据，唤醒进程。这种方法很直接，是<code>select</code>的设计思想。<br><code>poll</code>是<code>select</code>的一个小改进。底层实现为链表，不再限制最大链接数。<br><code>epoll</code>是<code>select</code>和<code>poll</code>的增强版本。但当处理大量的连接的读写，<code>select</code>是低效的。因为<code>kernel</code>每次都要对<code>select</code>传入的一组<code>socket</code>号做轮询。大量的<code>cpu</code>时间都耗了进去。而使用<code>epoll</code>这些，派一个文件描述符站岗，效率自然高了许多。</p>\n<h2 id=\"缓存I-O\"><a href=\"#缓存I-O\" class=\"headerlink\" title=\"缓存I/O\"></a>缓存I/O</h2><p>缓存<code>I/O</code>又称为标准<code>I/O</code>，大多数文件系统的默认<code>I/O</code>操作都是缓存<code>I/O</code>。在<code>Linux</code>的缓存<code>I/O</code>机制中，操作系统会将<code>I/O</code>的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<h2 id=\"五种IO模型\"><a href=\"#五种IO模型\" class=\"headerlink\" title=\"五种IO模型\"></a>五种IO模型</h2><h3 id=\"阻塞式I-O模型\"><a href=\"#阻塞式I-O模型\" class=\"headerlink\" title=\"阻塞式I/O模型\"></a>阻塞式I/O模型</h3><p>默认情况下，所有套接字都是阻塞的。<code>recvfrom</code>等待数据准备好，从内核向进程复制数据。</p>\n<h3 id=\"非阻塞式I-O\"><a href=\"#非阻塞式I-O\" class=\"headerlink\" title=\"非阻塞式I/O\"></a>非阻塞式I/O</h3><p>进程把一个套接字设置成非阻塞是在通知内核，当所请求的<code>I/O</code>操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误，<code>recvfrom</code>总是立即返回。</p>\n<h3 id=\"I-O多路复用\"><a href=\"#I-O多路复用\" class=\"headerlink\" title=\"I/O多路复用\"></a>I/O多路复用</h3><p>虽然<code>I/O</code>多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，<code>I/O多</code>路复用是阻塞在<code>select</code>，<code>epoll</code>这样的系统调用之上，而没有阻塞在真正的<code>I/O</code>系统调用如<code>recvfrom</code>之上。其本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。<code>select</code>、<code>poll</code>和<code>epoll </code>都是<code>Linux API</code>提供的<code>IO</code>复用方式。</p>\n<h3 id=\"信号驱动式I-O\"><a href=\"#信号驱动式I-O\" class=\"headerlink\" title=\"信号驱动式I/O\"></a>信号驱动式I/O</h3><p>用的很少，就不做讲解了。</p>\n<h3 id=\"异步I-O\"><a href=\"#异步I-O\" class=\"headerlink\" title=\"异步I/O\"></a>异步I/O</h3><p>这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我。<code>recvfrom</code>函数(经<code>socket</code>接收数据)。</p>\n<h2 id=\"再看POSIX对同步、异步这两个术语的定义\"><a href=\"#再看POSIX对同步、异步这两个术语的定义\" class=\"headerlink\" title=\"再看POSIX对同步、异步这两个术语的定义\"></a>再看POSIX对同步、异步这两个术语的定义</h2><blockquote>\n<ul>\n<li>同步<code>I/O</code>操作：导致请求进程阻塞，直到<code>I/O</code>操作完成；</li>\n<li>异步<code>I/O</code>操作：不导致请求进程阻塞。</li>\n</ul>\n</blockquote>\n<h2 id=\"各IO运行机制\"><a href=\"#各IO运行机制\" class=\"headerlink\" title=\"各IO运行机制\"></a>各IO运行机制</h2><h3 id=\"select运行机制\"><a href=\"#select运行机制\" class=\"headerlink\" title=\"select运行机制\"></a>select运行机制</h3><p><code>select()</code>的机制中提供一种<code>fd_set</code>的数据结构，实际上是一个<code>long</code>类型的数组，每一个数组元素都能与一打开的文件句柄（不管是<code>Socket</code>句柄,还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用<code>select()</code>时，由内核根据<code>IO</code>状态修改<code>fd_set</code>的内容，由此来通知执行了<code>select()</code>的进程哪一<code>Socket</code>或文件可读。</p>\n<p>从流程上来看，使用<code>select</code>函数进行<code>IO</code>请求和同步阻塞模型没有太大的区别，甚至还多了添加监视<code>socket</code>，以及调用<code>select</code>函数的额外操作，效率更差。但是，使用<code>select</code>以后最大的优势是用户可以在一个线程内同时处理多个<code>socket</code>的IO请求。用户可以注册多个<code>socket</code>，然后不断地调用<code>select</code>读取被激活的<code>socket</code>，即可达到在同一个线程内同时处理多个<code>IO</code>请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<h3 id=\"poll运行机制\"><a href=\"#poll运行机制\" class=\"headerlink\" title=\"poll运行机制\"></a>poll运行机制</h3><p><code>poll</code>的机制与select类似，与<code>select</code>在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是<code>poll</code>没有最大文件描述符数量的限制。</p>\n<h3 id=\"epoll运行机制\"><a href=\"#epoll运行机制\" class=\"headerlink\" title=\"epoll运行机制\"></a>epoll运行机制</h3><p><code>epoll</code>在<code>Linux2.6</code>内核正式提出，是基于事件驱动的<code>I/O</code>方式，相对于<code>select</code>来说，<code>epoll</code>没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的<code>copy</code>只需一次。<br><code>epoll</code>是<code>Linux</code>内核为处理大批量文件描述符而作了改进的<code>poll</code>，是<code>Linux</code>下多路复用<code>IO</code>接口<code>select/poll</code>的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统<code>CPU</code>利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核<code>IO</code>事件异步唤醒而加入<code>Ready</code>队列的描述符集合就行了。<br><code>epoll</code>除了提供<code>select/poll</code>那种<code>IO</code>事件的水平触发<code>（Level Triggered）</code>外，还提供了边缘触发<code>（Edge Triggered）</code>，这就使得用户空间程序有可能缓存IO状态，减少<code>epoll_wait/epoll_pwait</code>的调用，提高应用程序效率。</p>\n<ul>\n<li>水平触发（LT）：默认工作模式，即当<code>epoll_wait</code>检测到某描述符事件就绪并通知应用程序时，<strong>应用程序可以不立即处理该事件</strong>；下次调用<code>epoll_wait</code>时，会再次通知此事件。</li>\n<li>边缘触发（ET）： 当<code>epoll_wait</code>检测到某描述符事件就绪并通知应用程序时，<strong>应用程序必须立即处理该事件。如果不处理，下次调用<code>epoll_wait</code>时，不会再次通知此事件</strong>。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。<br><code>LT</code>和<code>ET</code>原本应该是用于脉冲信号的，可能用它来解释更加形象。<code>Level</code>和<code>Edge</code>指的就是触发点，<code>Level</code>为只要处于水平，那么就一直触发，而<code>Edge</code>则为上升沿和下降沿的时候触发。比如：0-&gt;1 就是<code>Edge</code>，1-&gt;1 就是<code>Level</code>。<br><code>ET</code>模式很大程度上减少了<code>epoll</code>事件的触发次数，因此效率比<code>LT</code>模式下高。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一张图总结一下<code>select,poll,epoll</code>的区别：<br><img src=\"https://user-images.githubusercontent.com/11263320/107748824-9d611d80-6d54-11eb-8873-f5c79ac617b8.png\" alt=\"屏幕快照 2021-02-12 下午4 55 45\"><br><code>epoll</code>是<code>Linux</code>目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超<code>select</code>和<code>poll</code>。目前流行的高性能<code>web</code>服务器<code>Nginx</code>正式依赖于<code>epoll</code>提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞<code>I/O</code>方式可能性能更好。</p>\n<p>既然<code>select，poll，epoll</code>都是<code>I/O</code>多路复用的具体的实现，之所以现在同时存在，其实他们也是不同历史时期的产物。</p>\n<blockquote>\n<ul>\n<li>select出现是1984年在BSD里面实现的</li>\n<li>14年之后也就是1997年才实现了poll，其实拖那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求</li>\n<li>2002, 大神 Davide Libenzi 实现了epoll</li>\n</ul>\n</blockquote>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/19\">La cabra siempre tira al monte.</a></p>\n","tags":["linux kernel"]},{"title":"Jenkins","url":"/post/9a7f448e.html","content":"<p>Jenkins是一款由Java开发的开源软件项目，旨在提供一个开放易用的软件平台，使持续集成变成可能。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"通过Docker安装和启动Jenkins\"><a href=\"#通过Docker安装和启动Jenkins\" class=\"headerlink\" title=\"通过Docker安装和启动Jenkins\"></a>通过Docker安装和启动Jenkins</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull jenkins:1.554.1</span><br></pre></td></tr></table></figure>\n<p>拉取镜像之后，我们先创建目录，然后就可以启动Jenkins的Container了，我们要把Jenkins的文件存储地址挂载到主机上，万一Jenkins的服务器重装或者迁移，我们都可以很方便地把之前的项目配置保留，否则就只能进入Container的文件系统里去复制了。另外，Jenkins会搭建在内网的服务器上，而非生产服务器，如果外网能直接访问，那么可能会造成一定的风险。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir /var/jenkins_home</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo docker run -d --name myjenkins -p 49001:8080 -v /var/jenkins_home:/var/jenkins_home jenkins</span></span><br></pre></td></tr></table></figure>\n<p>这样我们就顺利启动了Jenkins的服务，8080端口是Jenkins的默认监听端口，我们把它映射到了本地主机的49001端口，要注意把搭建Jenkins服务器的iptables关闭，一切顺利的话，我们就可以看到Jenkins的欢迎页面了。建议创建几个用户和权限，方便多人协同操作。<br><img src=\"https://user-images.githubusercontent.com/11263320/117755231-6a90cd80-b24e-11eb-89c2-01ad9bb291e8.JPG\" alt=\"捕获\"></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/130\">Dios cura y el médico pasa la factura.</a></p>\n","tags":["design"]},{"title":"Linux内核考古","url":"/post/ddcc6cb.html","content":"<p>这里记录下Linux内核的进化历史。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Linux内核版本的年表\"><a href=\"#Linux内核版本的年表\" class=\"headerlink\" title=\"Linux内核版本的年表\"></a>Linux内核版本的年表</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/116653815-7d87e000-a9ba-11eb-8652-7ac948f38fa5.png\" alt=\"a33ef0ac7688dbdcdd5f89601d8d6358\"></p>\n<h2 id=\"内核变化\"><a href=\"#内核变化\" class=\"headerlink\" title=\"内核变化\"></a>内核变化</h2><p>Linux内核的2.6 时代跨度非常大，从2.6.1 (2003年12月发布) 到 2.6.39(2011年5月发布)，跨越了39 个大版本。之后版本变化更新就快多了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>Linux内核版本历史 详见：<a href=\"https://en.wikipedia.org/wiki/Linux_kernel_version_history\">https://en.wikipedia.org/wiki/Linux_kernel_version_history</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/125\">Nadie es perfecto. Atentamente: Nadie.</a></p>\n","tags":["linux kernel"]},{"title":"NexT主题美化","url":"/post/71afd747.html","content":"<p>Hexo博客支持很多主题风格，其中Next主题是Github上Star最多的主题。关于主题的界面美化手法有以下这么多种。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"选择-Scheme\"><a href=\"#选择-Scheme\" class=\"headerlink\" title=\"选择 Scheme\"></a>选择 Scheme</h2><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。<br>编辑主题配置文件(themes\\next_config.yml)，确定喜爱的scheme</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">scheme: Pisces</span><br></pre></td></tr></table></figure>\n<h2 id=\"侧边栏显示当前浏览进度\"><a href=\"#侧边栏显示当前浏览进度\" class=\"headerlink\" title=\"侧边栏显示当前浏览进度\"></a>侧边栏显示当前浏览进度</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115645384-da4c2080-a352-11eb-8614-7c0ac37bab8c.JPG\" alt=\"捕获\"><br>打开 themes/next/_config.yml ，搜索关键字 scrollpercent ,把 false 改为 true<br>如果想把 top 按钮放在侧边栏，搜索关键字sidebar ,把 false 改为 true</p>\n<h2 id=\"右上角添加github入口\"><a href=\"#右上角添加github入口\" class=\"headerlink\" title=\"右上角添加github入口\"></a>右上角添加github入口</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115648404-f2726e80-a357-11eb-8778-d89058048806.JPG\" alt=\"捕获\"><br>1.首先到GitHub Corners或者GitHub Ribbons选择自己喜欢的图标，然后copy相应的代码<br>2.然后将刚才复制的代码粘贴到themes/next/layout/_layout.swig文件中</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;headband&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面一行<br>3.把代码中的href后面的值替换成你要跳转的地址，比如你的GitHub主页</p>\n<h2 id=\"隐藏网页底部powered-By-Hexo-强力驱动\"><a href=\"#隐藏网页底部powered-By-Hexo-强力驱动\" class=\"headerlink\" title=\"隐藏网页底部powered By Hexo / 强力驱动\"></a>隐藏网页底部powered By Hexo / 强力驱动</h2><p>打开themes/next/layout/_partials/footer.swig,使用注释隐藏之间的代码即可，或者直接删除。位置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--</span><br><span class=\"line\">&#123;%- if theme.footer.powered %&#125;</span><br><span class=\"line\">  &lt;div class&#x3D;&quot;powered-by&quot;&gt;</span><br><span class=\"line\">    &#123;%- set next_site &#x3D; &#39;https:&#x2F;&#x2F;theme-next.org&#39; %&#125;</span><br><span class=\"line\">    &#123;%- if theme.scheme !&#x3D;&#x3D; &#39;Gemini&#39; %&#125;</span><br><span class=\"line\">      &#123;%- set next_site &#x3D; &#39;https:&#x2F;&#x2F;&#39; + theme.scheme | lower + &#39;.theme-next.org&#39; %&#125;</span><br><span class=\"line\">    &#123;%- endif %&#125;</span><br><span class=\"line\">    &#123;&#123;- __(&#39;footer.powered&#39;, next_url(&#39;https:&#x2F;&#x2F;hexo.io&#39;, &#39;Hexo&#39;, &#123;class: &#39;theme-link&#39;&#125;) + &#39; &amp; &#39; + next_url(next_site, &#39;NexT.&#39; + theme.scheme, &#123;class: &#39;theme-link&#39;&#125;)) &#125;&#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&#123;%- endif %&#125;</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置菜单\"><a href=\"#设置菜单\" class=\"headerlink\" title=\"设置菜单\"></a>设置菜单</h2><h3 id=\"设定菜单内容\"><a href=\"#设定菜单内容\" class=\"headerlink\" title=\"设定菜单内容\"></a>设定菜单内容</h3><p>编辑主题配置文件(themes\\next_config.yml)，设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  #home: &#x2F; || fa fa-home</span><br><span class=\"line\">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class=\"line\">  #tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class=\"line\">  #categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class=\"line\">  #archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理菜单的点击跳转\"><a href=\"#处理菜单的点击跳转\" class=\"headerlink\" title=\"处理菜单的点击跳转\"></a>处理菜单的点击跳转</h3><p>按照上面的方式设置的菜单之后，点击标签，或者关于我都会出现错误页面，那这是怎么回事呢？<br>在默认情况，source 目录只有 _posts 一个文件夹的，并没有生成对应的 tags,about 等文件夹，所以就会出现错误 页面。<br>生成下菜单文件夹的可以了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n<p>将 source/tags/index.md 的内容修改为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">date: 2021-11-10 12:36:26</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>同样，about页面也按上面的方法生成下<br><img src=\"https://user-images.githubusercontent.com/11263320/114270259-f0e2a580-9a3d-11eb-9317-bbab438285a2.JPG\" alt=\"捕获\"><br>再重新部署一下项目，就不会出现错误页面问题了</p>\n<h2 id=\"添加搜索功能\"><a href=\"#添加搜索功能\" class=\"headerlink\" title=\"添加搜索功能\"></a>添加搜索功能</h2><p>在博客根目录安装搜索插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-search --安装插件，用于生成博客索引数据</span><br></pre></td></tr></table></figure>\n<p>修改博客配置文件（根目录/_config.yml），添加以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json #之前就是这里出了问题导致图标错误，错误的教程是 search.xml</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 1000</span><br></pre></td></tr></table></figure>\n<p>修改主题的根目录配置文件(themes\\next_config.yml)，把enable的false改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # if auto, trigger search by changing input</span><br><span class=\"line\">  # if manual, trigger search by pressing enter key or search button</span><br><span class=\"line\">  trigger: auto</span><br><span class=\"line\">  # show top n results per article, show all results by setting to -1</span><br><span class=\"line\">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>\n<p>重新生成下页面，就可以看到搜索框了<br><img src=\"https://user-images.githubusercontent.com/11263320/115741541-6fd2c900-a3c2-11eb-9982-8ec9693aadbd.JPG\" alt=\"捕获\"></p>\n<h2 id=\"修改文章底部带-号的标签\"><a href=\"#修改文章底部带-号的标签\" class=\"headerlink\" title=\"修改文章底部带#号的标签\"></a>修改文章底部带#号的标签</h2><p>将 # 换成标签图标。<br>[NexT 7.1.0 Released]修改方法为：<br>打开模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”，进行如下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;post-tags&quot;&gt;</span><br><span class=\"line\">          &#123;% for tag in post.tags %&#125;</span><br><span class=\"line\">            &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class=\"line\">          &#123;% endfor %&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文章目录默认展开\"><a href=\"#文章目录默认展开\" class=\"headerlink\" title=\"文章目录默认展开\"></a>文章目录默认展开</h2><p>文章目录样式文件custom.styl文件位于themes/next/source/css/_custom，打开后添加内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;文章目录默认展开</span><br><span class=\"line\">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置博客摘要显示\"><a href=\"#设置博客摘要显示\" class=\"headerlink\" title=\"设置博客摘要显示\"></a>设置博客摘要显示</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/117776036-abe4a580-b26d-11eb-8fbc-81d28cef7077.JPG\" alt=\"捕获\"><br>对于摘要显示，首先我们需要开启摘要功能，修改主题配置文件，打开阅读全文按钮read_more_btn</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Automatically excerpt description in homepage as preamble text.</span><br><span class=\"line\">excerpt_description: true</span><br><span class=\"line\"></span><br><span class=\"line\"># Read more button</span><br><span class=\"line\"># If true, the read more button will be displayed in excerpt section.</span><br><span class=\"line\">read_more_btn: true #显示阅读全文按钮</span><br></pre></td></tr></table></figure>\n<p>开启后，就可以在<!-- more -->前加上摘要文字了<br><img src=\"https://user-images.githubusercontent.com/11263320/117776158-d171af00-b26d-11eb-9082-9e57d263c08e.JPG\" alt=\"捕获\"></p>\n<h2 id=\"删除侧边栏上的作者名\"><a href=\"#删除侧边栏上的作者名\" class=\"headerlink\" title=\"删除侧边栏上的作者名\"></a>删除侧边栏上的作者名</h2><p>找到这个文件，注释掉这段代码<br><img src=\"https://user-images.githubusercontent.com/11263320/117854387-0573c100-b2bc-11eb-8b73-65349f4ed39a.JPG\" alt=\"捕获\"><br>效果如下图<br><img src=\"https://user-images.githubusercontent.com/11263320/117854474-18869100-b2bc-11eb-91b4-c39cef6a285c.JPG\" alt=\"捕获\"></p>\n<h2 id=\"自定义404页面\"><a href=\"#自定义404页面\" class=\"headerlink\" title=\"自定义404页面\"></a>自定义404页面</h2><p>当你的Github Pages博客访问一个不存在的url时，Github Page会显示一个404的页面。<br>为了显示一个友好的404页面，或者在出现404时，不要太让人看出来是Github Pages，我们可以自定义404页面。<br>在你的/myblog/source/下，增加一个404.html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">\t&lt;head&gt;</span><br><span class=\"line\">\t\t&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t\t&lt;title&gt;404&lt;&#x2F;title&gt;</span><br><span class=\"line\">\t&lt;&#x2F;head&gt;</span><br><span class=\"line\">\t&lt;body&gt;</span><br><span class=\"line\">\t\t&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; \t\t\t  src&#x3D;&quot;&#x2F;&#x2F;qzonestyle.gtimg.cn&#x2F;qzone&#x2F;hybrid&#x2F;app&#x2F;404&#x2F;search_children.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class=\"line\">\t&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>发布后，访问一个不存在的url时，就可以看到404页面了。这里我使用了腾讯的公益404页面。<br><img src=\"https://user-images.githubusercontent.com/11263320/117858713-bda36880-b2c0-11eb-8210-3c1262c3dc36.JPG\" alt=\"捕获\"></p>\n<h2 id=\"利用Hexo-abbrlink插件生成唯一文章链接\"><a href=\"#利用Hexo-abbrlink插件生成唯一文章链接\" class=\"headerlink\" title=\"利用Hexo-abbrlink插件生成唯一文章链接\"></a>利用Hexo-abbrlink插件生成唯一文章链接</h2><p>Hexo在生成博客文章链接时，默认是按照年、月、日、标题格式来生成的，可以在站点配置文件中指定new_post_name的值。默认是:year/:month/:day/:title这样的格式。如果你的标题是中文的话，你的URL链接就会包含中文。复制后的url路径就是把中文变成了一大堆字符串编码，如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那这个url链接岂不是失效了。<br>为了给每一篇文章来上一个属于自己的链接，可以利用hexo-abbrlink插件，来解决这个问题。<br>首先安装下hexo-abbrlink</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>\n<p>站点配置文件(_config.yml)里改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">permalink: post&#x2F;:abbrlink.html</span><br><span class=\"line\">abbrlink:</span><br><span class=\"line\">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class=\"line\">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>\n<p>生成完后,原文章md文件的Front-matter 内会增加abbrlink 字段,值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址,换句话说,就是本篇文章有了自己的专属链接。<br>当然，也可以选择不同的算法和进制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">crc16 &amp; hex</span><br><span class=\"line\">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;66c8.html</span><br><span class=\"line\"></span><br><span class=\"line\">crc16 &amp; dec</span><br><span class=\"line\">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;65535.html</span><br><span class=\"line\">crc32 &amp; hex</span><br><span class=\"line\">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;8ddf18fb.html</span><br><span class=\"line\"></span><br><span class=\"line\">crc32 &amp; dec</span><br><span class=\"line\">https:&#x2F;&#x2F;post.zz173.com&#x2F;posts&#x2F;1690090958.html</span><br></pre></td></tr></table></figure>\n<p>注意，这个配置完成之后，文章的链接有可能会变成了undefined，新的文章没问题，老的文章不行。执行hexo clean清掉以前生成的文章缓存，然后hexo g重新渲染就ok了。</p>\n<h2 id=\"添加相关文章推荐\"><a href=\"#添加相关文章推荐\" class=\"headerlink\" title=\"添加相关文章推荐\"></a>添加相关文章推荐</h2><p>安装推荐文章的插件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>\n<p>主题配置信息如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">related_posts:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  title: 相关文章推荐      # 属性的命名</span><br><span class=\"line\">  display_in_home: false # false代表首页不显示</span><br><span class=\"line\">  params:</span><br><span class=\"line\">    maxCount: 5          # 最多5条</span><br><span class=\"line\">    #PPMixingRate: 0.0   # 相关度</span><br><span class=\"line\">    #isDate: true        # 是否显示日期</span><br><span class=\"line\">    #isImage: false      # 是否显示配图</span><br><span class=\"line\">    isExcerpt: false     # 是否显示摘要</span><br></pre></td></tr></table></figure>\n<h2 id=\"改字符高亮的颜色\"><a href=\"#改字符高亮的颜色\" class=\"headerlink\" title=\"改字符高亮的颜色\"></a>改字符高亮的颜色</h2><p>设置background和color。<br><img src=\"https://user-images.githubusercontent.com/11263320/118073375-495ee700-b3de-11eb-8c95-c620abcd6e29.JPG\" alt=\"捕获\"></p>\n","tags":["blog"]},{"title":"NexT问题改进","url":"/post/943049d2.html","content":"<p>这里一定要注意，Next是不是更新到最新的版本。有可能下面的问题是版本老旧造成的。</p>\n<a id=\"more\"></a>\n\n<div class=\"note warning\"><p>新版本维护的地址是这个：https://github.com/theme-next/hexo-theme-next</p></div>\n\n<h2 id=\"主题分页的翻页箭头显示异常\"><a href=\"#主题分页的翻页箭头显示异常\" class=\"headerlink\" title=\"主题分页的翻页箭头显示异常\"></a>主题分页的翻页箭头显示异常</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115652669-45502400-a360-11eb-837c-cef626156a95.JPG\" alt=\"捕获\"><br>修改代码的位置: <code>themes\\next\\layout\\_partials\\pagination.swig</code><br>修改为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> page.prev or page.next %&#125;</span><br><span class=\"line\">  &lt;nav <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;pagination&quot;</span>&gt;</span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: <span class=\"string\">&#x27;&lt;&#x27;</span>,</span><br><span class=\"line\">        next_text: <span class=\"string\">&#x27;&gt;&#x27;</span>,</span><br><span class=\"line\">        mid_size: <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &lt;/nav&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中文目录不跳转\"><a href=\"#中文目录不跳转\" class=\"headerlink\" title=\"中文目录不跳转\"></a>中文目录不跳转</h2><p>文章左侧的中文目录一直不能跳转也不能展开<br>浏览器按F12，点击目录链接会在控制台报错：<code>Cannot read property &#39;top&#39; of undefined</code>。<br>打开控制台，查看目录的的超链接标签，会看到 href 是一串乱码。<br>实际上直接点击这个超链接是可以跳转的，但是点目录却不行。这是因为标题 id 是中文，但是目录的连接是中文乱码，代码里头的 JQuery 选择器拿着乱码是没法找到对应 id 的标题的。<br>顺着控制台错误提示找到<code>themes\\next\\source\\js\\src\\post-details.js</code>，找到第 75 行为目录绑定点击事件的方法，会看到：<br><img src=\"https://user-images.githubusercontent.com/11263320/115653689-30749000-a362-11eb-872c-8552058812b2.JPG\" alt=\"捕获\"><br>targetSelector就是对应标题的 id，我们在他被塞到选择器之前重新编码一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对获取到的url进行重编码</span></span><br><span class=\"line\">targetSelector = <span class=\"built_in\">decodeURI</span>(<span class=\"built_in\">this</span>.getAttribute(<span class=\"string\">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<p>然后 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g </span><br><span class=\"line\">hexo s </span><br></pre></td></tr></table></figure>\n<p>重新跑一下，发现目录就正常了。</p>\n","tags":["blog"]},{"title":"Nginx作为Node.js前端Web Server","url":"/post/42c2382c.html","content":"<p>一个<code>Node.js</code>进程就可以完成负载，但是随着后期访问量的加大，一个进程、一台服务器已经不能满足我们的需要了，这时<code>Nginx</code>就可以发挥自己反向代理的能力。我们可以在<code>Nginx</code>后端添加多个服务器或启动多个进程来分担访问压力。</p>\n<a id=\"more\"></a>\n\n<p>这样做大致有如下好处：</p>\n<h2 id=\"静态文件性能\"><a href=\"#静态文件性能\" class=\"headerlink\" title=\"静态文件性能\"></a>静态文件性能</h2><p>Node.js的静态文件处理性能受制于它的单线程异步I/O模型，注定了静态文件性能不会很好。我们应该避免在生产环境下直接使用Node.js来处理静态文件。</p>\n<h2 id=\"反向代理规则\"><a href=\"#反向代理规则\" class=\"headerlink\" title=\"反向代理规则\"></a>反向代理规则</h2><p>有时会存在反向代理服务器配置多样化的情况，有时我们希望配置较好的机器能够分担更多的压力，有时又因为session的关系，我们需要将同一来源IP的客户端全转发到同一个进程上，对于诸如此类的规则，使用Nginx的配置文件就可以简单实现。</p>\n<h2 id=\"扩展性\"><a href=\"#扩展性\" class=\"headerlink\" title=\"扩展性\"></a>扩展性</h2><p>Nginx可以加入许多扩展来帮助我们处理业务，最典型的就是加入Lua语言的扩展。胶水语言Lua赋予了Nginx复杂逻辑判断的能力，并且保持了一贯的高效性。例如我们有一个API服务，对访问会进行MD5签名或对同一客户端来源有访问频率限制，这部分代码是后端业务处理前必须通过的验证，具有卡口的作用。利用Lua扩展，我们就可以高效、简单地完成这个卡口。</p>\n<h2 id=\"稳定性和转发性能\"><a href=\"#稳定性和转发性能\" class=\"headerlink\" title=\"稳定性和转发性能\"></a>稳定性和转发性能</h2><p>Nginx在同样的负载下，相比Node.js占用的CPU和内存资源更少。同时，高效地转发性能、便捷地转发配置也是我们选择它作为反向代理的原因之一，比如我们可以根据不同的URL请求路径转发到不同的后端机器上，也可以设定超时时间等，方便管理。</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><p>Nginx已经被各大互联网公司广泛应用，经过一些配置可以有效抵挡类似slowloris等的DoS攻击。</p>\n<h2 id=\"运维管理\"><a href=\"#运维管理\" class=\"headerlink\" title=\"运维管理\"></a>运维管理</h2><p>如果我们目前只有一台Web服务器，同时有多个站点需要占用80端口，这时我们只需让Node.js服务监听本地的特殊端口如3000，通过Nginx的反向代理配置，就可以将多个端点域名指向一台机器了。</p>\n","tags":["nodejs"]},{"title":"STL Adapters","url":"/post/20d016ff.html","content":"<p>配接器在STL组件的灵活组合运用功能上，扮演着轴承、转换器的角色。Adaper这个概念，事实上是一种设计模式。在《设计模式》中adapter定义如下：将一个class的接口转换为另一个class的接口，使原本因接口不兼容而不能合作的classes，可以一起运作。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"adapter模式\"><a href=\"#adapter模式\" class=\"headerlink\" title=\"adapter模式\"></a>adapter模式</h2><p>如果你有一个存在的系统需要插入一个新的类库,但是新的类库并不能匹配你写的系统，这时候我们就需要写一个适配器了,用这个适配器来适配新类库的接口。</p>\n<p>adapter取自生活中的配接器<br><img src=\"https://user-images.githubusercontent.com/11263320/111445192-200b3d00-8746-11eb-9fc2-f2eb3b84b33a.jpg\" alt=\"242dd42a2834349bcff8dd6ecbea15ce37d3be5b\"><br>在软件中也就是<br><img src=\"https://user-images.githubusercontent.com/11263320/111445271-3618fd80-8746-11eb-9055-ab836b4a01a6.jpg\" alt=\"902397dda144ad34bc5d346cd2a20cf430ad857f\"></p>\n<p>实现Adapter的方式主要有两种：组合(composition)和继承(inheritance)。<br>stl主要是用组合这种方式<br>container adapters内藏了一个container member一样，reverse iterator底层内藏了iterator member，而functions 的底层内藏了一个functions， 每个配接器的底层都有封装了一个对象，既然是这个对象的主人，就有资格调用该对象，并在参数和返回值上动手脚。</p>\n<h2 id=\"stl配接器分类\"><a href=\"#stl配接器分类\" class=\"headerlink\" title=\"stl配接器分类\"></a>stl配接器分类</h2><p>function adapter（通过它们之间的绑定，组合，修饰能力，几乎可以无限制地创造出各种可能的表达式。如使用bind2nd）<br>container adapter（如queue和stack，这两者底层容器都是deque，修饰deque的接口而成就出另一种容器风貌）<br>iterator adapter（所谓对迭代器的修饰，只是一种观念上的改变（赋值操作变成插入操作、前进变成后退、绑定到特殊装置上）。如insert iterators，reverse iterators，iostream iterators）</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/98\">Sigue estudiando y serás una calavera sabia.</a></p>\n","tags":["cpp"]},{"title":"STL Algorithms","url":"/post/f5e61589.html","content":"<p>广义而言，我们所写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都用来解决或大或小的逻辑问题或数学问题。<br>STL算法包括排序、查找、排列组合算法，以及用于数据移动、复制、删除、比较、组合、运算等等。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"质变与非质变\"><a href=\"#质变与非质变\" class=\"headerlink\" title=\"质变与非质变\"></a>质变与非质变</h2><p>如果以运算过程中会更改区间内的元素内容区分算法，可以分为质变算法与非质变算法。</p>\n<ul>\n<li>质变算法包括：拷贝、互换、替换、填写、删除、排列组合、分割、随机重排、排序等等。</li>\n<li>非质变算法包括：查找、匹配、计数、巡访、比较、寻找极值等等。</li>\n</ul>\n<h2 id=\"算法泛化\"><a href=\"#算法泛化\" class=\"headerlink\" title=\"算法泛化\"></a>算法泛化</h2><p>所有泛型算法的前两个参数都是一对迭代器，通常称为first和last，用以标示算法的操作区间。STL习惯采用前闭后开区间，写成[first,last)，表示区间涵盖first至last（不含last）之间的所有元素。当first==last时，上述所表现的便是一个空区间。</p>\n<p>只要把操作对象的型别加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化，整个算法也就在一个抽象层面上工作了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Iterator</span>,<span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\">Iterator <span class=\"title\">find</span><span class=\"params\">(Iterator begin, Iterator end, <span class=\"keyword\">const</span> T&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(begin != end &amp;&amp; *begin != value)</span><br><span class=\"line\">        ++begin;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/96\">Hay un mundo mejor, pero carísimo.</a></p>\n","tags":["cpp"]},{"title":"STL Allocator","url":"/post/bec1f717.html","content":"<p>Allocator译为空间配置器而不是内存配置器，是因为空间也可以是磁盘或其它辅助介质。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"设计哲学\"><a href=\"#设计哲学\" class=\"headerlink\" title=\"设计哲学\"></a>设计哲学</h2><ul>\n<li>向system heap要求空间</li>\n<li>考虑多线程状态</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区块”可能造成的内存碎片问题</li>\n</ul>\n<p>考虚到小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略：当配置区块超过128bytes时，视之为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用复杂的内存池整理方式，而不再求助于第一级配置器。</p>\n<h2 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h2><p>内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升。</p>\n<h2 id=\"内存基本处理工具\"><a href=\"#内存基本处理工具\" class=\"headerlink\" title=\"内存基本处理工具\"></a>内存基本处理工具</h2><p>STL定义有五个全局函数，作用于未初始化空间上。这样的功能对于容器的实现很有帮助。<br>分别是用于构造的construct()和用于析构的destroy()，另三个函数是uninitialized_copy()，uninitialized_fill()，uninitialized_fill_n()，分别对应该于高层次函数copy()，fill()，fill_n()。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/93\">La prueba más clara de que existe vida inteligente en el universo es que nadie ha intentado contactar con nosotros.</a></p>\n","tags":["cpp"]},{"title":"STL Containers","url":"/post/cd6c706d.html","content":"<p>这里介绍下stl中的肉器。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"容器分类\"><a href=\"#容器分类\" class=\"headerlink\" title=\"容器分类\"></a>容器分类</h2><p>STL容器分两种：序列式容器，关联式容器。<br><img src=\"https://user-images.githubusercontent.com/11263320/111740539-e5c5ab00-88bf-11eb-9df6-00311a3ee53b.jpg\" alt=\"未标题-1副本\"><br>上图以内缩方式来表达基层与衍生层的关系。<br>heap内含一个vector，priority-queue内含一个heap、stack和queue都含一个deque，set/map/multiset/multimap都内含一个RB-tree，hash_x都内含一个hastable。</p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><p>所谓序列式容器，其中的元素都可序(ordered)，但未必有序(sorted)。C++语言本身提供了一个序列式容器array。STL另外再提供 上列呈现的序列式容器。</p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p>vector的数据安排以及操作方式与array非常相似。两者唯一差别在于空间的运用的灵活性上。array是静态空间，设定要先定义空间。vector是动态空间，它的内部机制会自行扩充空间以容纳新元素。vector人运用对于内存的合理利用与运用的灵活性有很大的帮助。<br>vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。这里具体要看空间配置的策略。</p>\n<h4 id=\"vector的数据结构\"><a href=\"#vector的数据结构\" class=\"headerlink\" title=\"vector的数据结构\"></a>vector的数据结构</h4><p>线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的观念。<br>它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。<br><img src=\"https://user-images.githubusercontent.com/11263320/111742634-79e54180-88c3-11eb-82f0-394f0666b691.JPG\" alt=\"捕获\"></p>\n<h4 id=\"vector的迭代器\"><a href=\"#vector的迭代器\" class=\"headerlink\" title=\"vector的迭代器\"></a>vector的迭代器</h4><p>因为普通指针就可以满足vector的所有必要条件，而vector支持随机存取，所以vector提供的是Random Access Iterators。</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>list的好处是每次插入或删除一个元素，就配置或释放一个元素空间。list对于空间的运用有绝对的精准，一点也不浪费。而且对于任何位置的元素插入或无素移除，list永远是常数时间。<br>list和vector的选择最多视所元素的多寡、元素的构造复杂度、元素存取行为的特性而定。</p>\n<h4 id=\"list的数据结构\"><a href=\"#list的数据结构\" class=\"headerlink\" title=\"list的数据结构\"></a>list的数据结构</h4><p>从list的节点结构看，STL中的list是个双向链表。</p>\n<h4 id=\"list的迭代器\"><a href=\"#list的迭代器\" class=\"headerlink\" title=\"list的迭代器\"></a>list的迭代器</h4><p>所其操作上看，其迭代器是Bidirectional Itertors。</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。<br>deque没有容量观念。不像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”。<br>deque的数据结构：array无法成长，vector虽可成长，却只能向尾端成长，而且是个假象。deque采用一块空间作缓冲区，利用这个空间成长。<br><img src=\"https://user-images.githubusercontent.com/11263320/111743229-553d9980-88c4-11eb-8302-75aa7b6dc28e.JPG\" alt=\"捕获\"></p>\n<h4 id=\"deque的迭代器\"><a href=\"#deque的迭代器\" class=\"headerlink\" title=\"deque的迭代器\"></a>deque的迭代器</h4><p>和vector相似，是Random Access Iterators。</p>\n<h3 id=\"stack与queue\"><a href=\"#stack与queue\" class=\"headerlink\" title=\"stack与queue\"></a>stack与queue</h3><p>这两种都没有迭代器，数据结构是用deque实现的（其实用list也可以）。</p>\n<p>为什么选择deque作为stack、queue的底层默认容器？<br>stack是后进先出的特殊线性数据结构，只要具有push_back()和pop_back()操作的线性结构，都可以作为stack的底层容器，比如vector和list都可以；queue是先进先出的特殊线性数据结构，只要具有push_back和pop_front()操作的线性结构，都可以作为queue的底层容器，比如list<br>但是STL中对stack和queue选择deque作为其底层容器，主要是因为：<br>（1）stack和queue不需要遍历（stack和queue没有迭代器），只需要在固定的一端或者两端进行操作<br>（2）在stack中元素增长时，deque比vector的效率高<br>（3）在queue中的元素增长时，deque不仅效率高，而且内存使用率也高</p>\n<h3 id=\"heap\"><a href=\"#heap\" class=\"headerlink\" title=\"heap\"></a>heap</h3><p>heap不归属于stl容器组件，它是priority queue的助手。priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）的元素开始取。binary max heap正是具有这样的特性，适合作为priority queue的底层机制。</p>\n<h4 id=\"heap底部容器\"><a href=\"#heap底部容器\" class=\"headerlink\" title=\"heap底部容器\"></a>heap底部容器</h4><p>以vector表现的完全二叉树。实现算法为最大堆。</p>\n<p>priority_queue<br>priority_queue是一个拥有权值观念的queue。<br>priority_queue没有迭代器。</p>\n<h3 id=\"slist\"><a href=\"#slist\" class=\"headerlink\" title=\"slist\"></a>slist</h3><p>这是个单向链表，所以迭代器变为Forward Iterator。</p>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及这两大类的衍生体mutiset（多键集合）和multimap（多键映射表）。由于RB-tree自动排序的效果很不错，所以这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。<br>此外，STL还提供了一个关联式容器：hash_table（散列表），以及以此为底层机制而完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset（散列多键集合）、hash_multimap（散列多键映射表）。</p>\n<p>所谓关联式容器，观念上类似关联式数据库（key-value）。当元素被插入到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。<br>关联式容器没有所谓头尾（只有最大元素与最小元素）。<br>一般而言，关联式容器的内部结构是一个balanced binary tree，以便获得良好的搜寻效率。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>set的特性是所有元素都会根据元素的键值自动被排序。set元素的键值就是实值，实值就是健值。set不允许两个元素有相同的键值。</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>map的特性是，所有元素都会根据元素的键值自动被排序。map的所有元素都是pair。</p>\n<h3 id=\"multiset与multimap\"><a href=\"#multiset与multimap\" class=\"headerlink\" title=\"multiset与multimap\"></a>multiset与multimap</h3><p>特性以及用法和各自兄弟(set，map)完全相同，唯一的差别在于它们允许键值重复。</p>\n<h3 id=\"hashtable\"><a href=\"#hashtable\" class=\"headerlink\" title=\"hashtable\"></a>hashtable</h3><p>二叉搜索树表现的构造在一个假设上：输入数据有足够的随机性。而hash_table（散列表）的数据结构的操作表现是以统计为基础，不需仰赖输入元素的随机性。<br>hash_set、hash_map、hash_multiset、hash_multimap<br>都是以hash_table为底层机制。但其实元素不能自动排序。</p>\n<h2 id=\"Hash与RB树的区别\"><a href=\"#Hash与RB树的区别\" class=\"headerlink\" title=\"Hash与RB树的区别\"></a>Hash与RB树的区别</h2><p>权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性，有序性。<br>总体来说，hash查找速度会比RB树快，而且查找速度基本和数据量大小无关，属于常数级别;而RB树的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。</p>\n<p>红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。<br>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。<br>红黑树是有序的，Hash是无序的，根据需求来选择。</p>\n<p>拿红黑树实现的Map和Hash实现的HashMap相比：<br>如果只需要判断Map中某个值是否存在之类的操作，当然是Hash实现的要更加高效。<br>如果是需要将两个Map求并集交集差集等大量比较操作，就是红黑树实现的Map更加高效。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/95\">El amor es una cosa esplendorosa…hasta que te sorprende tu esposa.</a></p>\n","tags":["cpp"]},{"title":"STL Functors","url":"/post/303d52cd.html","content":"<p>仿函数其实上就是一个“行为类似函数”的对象。仿函数可以让STL算法有更灵活的演出。<br>c++11中已经引入lamda表达式，相当于将这部分内容加入了语法。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>为实现仿函数，其类别定义中必须自定义（或说改写、重载）function call运算子（operator()）。拥有这样的运算子后，我们就可以在仿函数的对象后而加上一对小括号，以此调用仿函数所定义 的operator()。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>STL仿函数的分类，若以操作数的个数划分，可分为一元和二元仿函数，若以功能划分，可以为算术运算、关系运算、逻辑运算三在类。</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>在我们写代码时有时会发现有些功能实现的代码，会不断的在不同的成员函数中用到，但是又不好将这些代码独立出来成为一个类的一个成员函数。但是又很想复用这些代码。写一个公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。这时就可以用仿函数了，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。这样就免去了对一些公共变量的全局化的维护了。又可以使那些代码独立出来，以便下次复用。而且这些仿函数，还可以用关联，聚合，依赖的类之间的关系，与用到他们的类组合在一起，这样有利于资源的管理（这点可能是它相对于函数最显著的优点了）。</p>\n<p>有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针，依据函数生成对象，甚至是让函数之间有继承关系，对函数进行运算和操作的效果。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/97\">Si un día te levantas con ganas de estudiar, toma una aspirina y vuelvete a acostar.</a></p>\n","tags":["cpp"]},{"title":"STL Iterators","url":"/post/588cfd1.html","content":"<p>这里介绍下stl的Iterators。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>提供一种方法，使之能够依序巡访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>\n<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><p>迭代器是一种行为类似指针人对象。而指针的各种行为中最常见也最重要的便是内容提领(*)和成员访问(-&gt;)，迭代器最重要的编程工作就是对这两个操作进行重载工作。</p>\n<h2 id=\"Traits编程技法（STL源代码门钥）\"><a href=\"#Traits编程技法（STL源代码门钥）\" class=\"headerlink\" title=\"Traits编程技法（STL源代码门钥）\"></a>Traits编程技法（STL源代码门钥）</h2><p>Traits就像一台“特性萃取机”，榨取各个迭代器的特性（相应型别）<br><img src=\"https://user-images.githubusercontent.com/11263320/109153358-c8f9f400-77a7-11eb-9fc2-f553290702c7.png\" alt=\"20180320140804433\"><br>迭代器相应有以上↑这五种型别。如果你希望你所开发的容器能与stl兼容，一定要为你的容器迭代器定义这五种相应型别。<br>value type：迭代器所指对象的型别。<br>difference type：两个迭代器之间的距离。<br>reference type：引用<br>pointer type：指针<br>iterator_category：这里就是移动特性与施行操作了。</p>\n<h2 id=\"按iterator-category区分迭代器的五类\"><a href=\"#按iterator-category区分迭代器的五类\" class=\"headerlink\" title=\"按iterator_category区分迭代器的五类\"></a>按iterator_category区分迭代器的五类</h2><p>Input Iterator<br>Output Iterator<br>Forward Iterator<br>Bidirectional Iterator<br>Random Access Iterator</p>\n<p>为了符合规范，任何迭代器都应该提供五个内嵌相应型别，以利于traits萃取。STL提供了一个iterators class，继承它，就可以保证符合stl所需之规范。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/94\">En las próximas elecciones vote a las putas, votar a los hijos no dio res ultado.</a></p>\n","tags":["cpp"]},{"title":"TCP的通讯过程","url":"/post/ad0c7d39.html","content":"<p>在 TCP 通讯中主要有<strong>连接的建立</strong>、<strong>数据的传输</strong>、<strong>连接的关闭</strong>三个过程！每个过程完成不同的工作，而且序列号和确认号在每个过程中的变化都是不同的。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"TCP-建立连接\"><a href=\"#TCP-建立连接\" class=\"headerlink\" title=\"TCP 建立连接\"></a>TCP 建立连接</h2><p>TCP 建立连接，也就是我们常说的三次握手，它需要三步完成。在 TCP 的三次握手中，发送第一个 SYN 的一端执行的是主动打开。而接收这个 SYN 并发回下一个 SYN 的另一端执行的是被动打开。</p>\n<div class=\"note info\"><p>SYN：同步序列编号（Synchronize Sequence Numbers）。SYN用于建立TCP/IP时的握手连接，由客户端想服务端发送SYN，服务端向客户端发送SYN+ACK响应报文,客户端向服务端发送一个ACK响应报文，然后建立一个完整的连接,即三次握手。</p></div>\n\n<p>这里以客户端向服务器发起连接来说明。<br>1.客户端向服务器发送一个同步数据包请求建立连接，该数据包中，初始序列号（ISN）是客户端随机产生的一个值，确认号是 0；</p>\n<div class=\"note info\"><p>初始化序号（Initial Sequence Number），每次建立连接前重新初始化一个序列号，为了通信双方能够根据序号将不属于本连接的报文段丢弃。</p></div>\n<div class=\"note info\"><p>确认号（acknowledgement number）,指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p></div>\n\n<p>2.服务器收到这个同步请求数据包后，会对客户端进行一个同步确认。这个数据包中，序列号（ISN）是服务器随机产生的一个值，确认号是客户端的初始序列号+1</p>\n<p>3.客户端收到这个同步确认数据包后，再对服务器进行一个确认。该数据包中，序列号是上一个同步请求数据包中的确认号值，确认号是服务器的初始序列号+1。</p>\n<p>初始序列号（ISN）随时间而变化的，而且不同的操作系统也会有不同的实现方式，所以每个连接的初始序列号是不同的。 TCP 连接两端会在建立连接时，交互一些信息，如窗口大小、 MSS 等，以便为接着的数据传输做准备。<br><img src=\"https://user-images.githubusercontent.com/11263320/119770861-5f48cd80-beef-11eb-8ccc-61b1595eeb07.JPG\" alt=\"TCPConnect\"></p>\n<h3 id=\"窗口字段\"><a href=\"#窗口字段\" class=\"headerlink\" title=\"窗口字段\"></a>窗口字段</h3><p>用于接收端通知发送端：接收端当前能够接收的字节数（即当前允许发送端发送的字节数）。接收端通告的窗口大小变成0，发送端会发一个1字节的段（就是下一字节的数据，没新的数据段发送的时候发一个ack）（TCP零窗口探测），强制接收端重新宣告下一个期望的字节和窗口大小。如果接收方回复窗口大小仍然为零，则发送方的探测定时器加倍。没有收到ACK时，发送探测包的最大次数之后连接超时。</p>\n<h2 id=\"TCP-传输数据\"><a href=\"#TCP-传输数据\" class=\"headerlink\" title=\"TCP 传输数据\"></a>TCP 传输数据</h2><p>在 TCP 建立连接后，就可以开始传输数据了。 TCP 工作在全双工模式，它可以同时进行双向数据传输。这里为了简化，我们只谈服务器向客户端发送数据的情况，而客户端向服务器发送数据的原理和它是类似的，这里便不重复说明。<br>服务器向客户端发送一个数据包后，客户端收到这个数据包后，会向服务器发送一个确认数据包<br>1.发送数据：服务器向客户端发送一个带有数据的数据包，该数据包中的序列号和确认号与建立连接第三步的数据包中的序列号和确认号相同；<br>2.确认收到：客户端收到该数据包，向服务器发送一个确认数据包，该数据包中，序列号是为上一个数据包中的确认号值，而确认号为服务器发送的上一个数据包中的序列号+所该数据包中所带数据的大小。<br>数据分段中的序列号可以保证所有传输的数据按照正常的次序进行重组，而且通过确认保证数据传输的完整性<br><img src=\"https://user-images.githubusercontent.com/11263320/119771680-a71c2480-bef0-11eb-96eb-436715435192.jpg\" alt=\"115A462I-0\"></p>\n<h2 id=\"TCP-关闭连接\"><a href=\"#TCP-关闭连接\" class=\"headerlink\" title=\"TCP 关闭连接\"></a>TCP 关闭连接</h2><p>前面我们提到，建立一个连接需要 3 个步骤，但是关闭一个连接需要经过 4 个步骤。因为TCP 连接是全双工的工作模式，所以每个方向上需要单独关闭。在 TCP 关闭连接时，首先关闭的一方（即发送第一个终止数据包的）将执行主动关闭，而另一方（收到这个终止数据包的）再执行被动关闭。<br>关闭连接的 4 个步骤如下：<br>1.服务器完成它的数据发送任务后，会主动向客户端发送一个终止数据包，以关闭在这个方向上的 TCP 连接。该数据包中，序列号为客户端发送的上一个数据包中的确认号值，而确认号为服务器发送的上一个数据包中的序列号+该数据包所带的数据的大小；<br>2.客户端收到服务器发送的终止数据包后，将对服务器发送确认信息，以关闭该方向上的 TCP 连接。这时的数据包中，序列号为第 1 步中的确认号值，而确认号为第 1 步的数据包中的序列号+1<br>3.同理，客户端完成它的数据发送任务后，就也会向服务器发送一个终止数据包，以关闭在这个方向上的 TCP 连接，该数据包中，序列号为服务器发送的上一个数据包中的确认号值，而确认号为客户端发送的上一个数据包中的序列号+该数据包所带数据的大小；<br>4.服务器收到客户端发送的终止数据包后，将对客户端发送确认信息，以关闭该方向上的 TCP 连接。这时在数据包中，序列号为第 3 步中的确认号值，而确认号为第 3 步数据包中的序列号+1；<br><img src=\"https://user-images.githubusercontent.com/11263320/119774108-41ca3280-bef4-11eb-9679-99cf0584ab87.png\" alt=\"281600391879667\"></p>\n<div class=\"note warning\"><p>因为 FIN 和 SYN 一样，也要占一个序号。理论上服务器在 TCP 连接关闭时发送的终止数据包中，只有终止位是置 1，然后客户端进行确认。但是在实际的 TCP 实现中，在终止数据包中，确认位和终止位是同时置为 1 的，确认位置为 1 表示对最后一次传输的数据进行确认，终止位置为 1 表示关闭该方向的 TCP 连接</p></div>\n\n<h3 id=\"为什么需要TIME-WAIT？\"><a href=\"#为什么需要TIME-WAIT？\" class=\"headerlink\" title=\"为什么需要TIME_WAIT？\"></a>为什么需要TIME_WAIT？</h3><p>TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。<br>描述过程：<br>Client调用close()函数，给Server发送FIN，请求关闭连接；Server收到FIN之后给Client返回确认ACK，同时关闭读通道（不清楚就去看一下shutdown和close的差别），也就是说现在不能再从这个连接上读取东西，现在read返回0。此时Server的TCP状态转化为CLOSE_WAIT状态。<br>Client收到对自己的FIN确认后，关闭 写通道，不再向连接中写入任何数据。<br>接下来Server调用close()来关闭连接，给Client发送FIN，Client收到后给Server回复ACK确认，同时Client关闭读通道，进入TIME_WAIT状态。<br>Server接收到Client对自己的FIN的确认ACK，关闭写通道，TCP连接转化为CLOSED，也就是关闭连接。<br>Client在TIME_WAIT状态下要等待最大数据段生存期的两倍，然后才进入CLOSED状态，TCP协议关闭连接过程彻底结束。</p>\n<p>以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。<br>从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。</p>\n<p>原因有二：<br>一、保证TCP协议的全双工连接能够可靠关闭<br>二、保证这次连接的重复数据段从网络中消失</p>\n<p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>\n<p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>\n","tags":["linux kernel"]},{"title":"c++对象","url":"/post/c53bb450.html","content":"<p>这里探讨下c++对象的实现。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"对象模型\"><a href=\"#对象模型\" class=\"headerlink\" title=\"对象模型\"></a>对象模型</h2><p>和c不同，c是将数据和处理数据的函数分开的（数据流过程决定函数编写，过程式的）；而c++把数据和处理数据的方法关联在了一起（对象发起动作，操纵数据）。那么像class一样将数据和方法包含在一起，甚至再用上模板是否会增加布局成本呢？</p>\n<p>C++对象模式<br>在C++中，有两种类成员数据：static和非static，以及三种类成员函数：static、非static和virtual。</p>\n<p>在C++对象模型中，非static成员数据被配置于每一个类对象之内，static成员数据则被放在所有类对象之外。static和非static成员函数也被放在所有的类对象之外。</p>\n<p>C++在布局以及存取时间上主要的额外负担是由virtual引起，包括<br>1.虚函数机制（执行时绑定）<br>2.虚基类。还有一些多重继承下的额外负担。</p>\n<p>virtual函数则以两个步骤支持之：<br>1.每一个类产生出一堆指向virtual函数的指针，放在表格之中。这个表格被称为virtual表。<br>2.第一个类对象被添加了一个指针，指向相关的virtual表。这个指针的设定和重置都由每一个类的构造函数，析构函数和拷贝赋值运算符自动完成。另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time Type Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</p>\n<p>和c相比，c++的布局成本主要来自于virtual，virtual使得class object需要先找虚表，再由虚表找所在地，增加了耗费。而像nonstatic data menber，跟c中struct完全一样，所以这些并不会增加c++的布局成本（相对于c而言）。</p>\n<p>对于C++中的单继承<br>C++实际模型是：对于一般继承是扩充已有存在的虚函数表；对于虚继承添加一个虚函数表指针。</p>\n<p>对于C++中的多继承<br>1）每一个基类都有自己的虚函数表，基类各有虚表<br>2）子类的虚函数被放到第一个基类的虚函数表中，子类与第一个父类共用一张虚表<br>3）内存布局中，基类的排列顺序就是基类的声明顺序<br>4）重写：每一个基类的虚表中的fun都被重写成子类的fun，这样做就是为了解决不同的基类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>\n<p>对于C++中的多继承中的虚继承<br>虚继承的子类，有单独的虚函数表，另外也单独保存一份父类的虚函数表。</p>\n<h2 id=\"如何访问成员\"><a href=\"#如何访问成员\" class=\"headerlink\" title=\"如何访问成员\"></a>如何访问成员</h2><p>数据成员如何访问（直接取址）？<br>跟实际对象模型相关联，根据对象起始地址+偏移量取得。</p>\n<p>函数成员如何访问（间接取址）？<br>跟实际对象模型相关联，普通函数（nonstatic、static）根据编译、链接的结果直接获取函数地址；如果是虚函数根据对象模型，取出对于虚函数地址，然后在虚函数表中查找函数地址。</p>\n<p>多态如何实现?<br>多态（Polymorphisn）在C++中是通过虚函数实现的。如果类中有虚函数，编译器就会自动生成一个虚函数表，对象中包含一个指向虚函数表的指针。能够实现多态的关键在于：虚函数是允许被派生类重写的，在虚函数表中，派生类函数对覆盖（override）基类函数。除此之外，还必须通过指针或引用调用方法才行，将派生类对象赋给基类对象。</p>\n<p>为什么析构函数设为虚函数是必要的？<br>带有多态性质的基类应该声明一个虚析构函数。如果一个类带有任何虚函数，它就应该拥有一个虚析构函数。 </p>\n<p>如果析构函数不定义为虚函数，那么派生类就不会重写基类的析构函数，在有多态行为的时候，派生类的析构函数不会被调用到（有内存泄漏的风险！）。<br>一个类的设计目的不是作为基类使用，或不是为了具备多态性，就不该声明虚析构函数。</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>本质上一个引用通常是以一个指针来实现，而且是const指针。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《深度探索C++对象模型》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/86\">La esclavitud no se abolió, se cambió a 8 hrs diarias.</a></p>\n","tags":["cpp"]},{"title":"c++对象模型的顶端","url":"/post/e7a54727.html","content":"<p>这里探讨下c++的一些关键字。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h2><p>在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：模板对源代码重用，而不是通过继承和组合重用对象代码。当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。</p>\n<p>未使用的template member function不应该被实例化。<br>对于template的错误检查，只有在实例化操作时才会进行类型类型检查，而所有的语汇（lexing）错误和解析（parsing）错误都会在处理template声明的过程中被表示出来。也就是用到了语法分析器。<br>在目前的编译器中，面对一个template声明，在它被一组实际参数实例化之前，只能施以有限的错误检查。</p>\n<p>template中的名称决议法，分为 scope of the template definition 和 scope of the template instantiation.<br>template之中，对于一个nonmember的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而决定。如果互不相关，则使用“scope of the template declaration”来决定name，否则以“scope of the template instantiation”来决定name。<br>函数的决议结果，只和函数的原型有关，和函数的返回值没有关系。</p>\n<p>对于member function的实例化行为，编译器设计者需要考虑以下3种问题：<br>1.编译器如何找打函数的定义？ –&gt; 答案是产生template program text file, 有点类似header<br>2.编译器如何能够只实例化程序中用到的member function？ –&gt; 解法方法之一，是忽略此项要求，只要class的object被实例化，就全部产生出来；另一个解决方法是模拟链接操作，检测看看哪个函数真正需要，然后只为他们产生实例<br>3.编译器如何组织member definition在多个 .o文件中被实例化？  –&gt;方法是产生多个实例，但只在链接器中保存一个。</p>\n<p>对于member function，每个member function的地址都被放在active classes的virtual table中。<br>如果virtual table被产生出来，每个virtual function 都必须被实例化。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>欲支持exception handling，编译器的主要工作是找到catch子句，以处理被抛出来的exception。</p>\n<h2 id=\"执行期类型识别\"><a href=\"#执行期类型识别\" class=\"headerlink\" title=\"执行期类型识别\"></a>执行期类型识别</h2><p>dynamic_cast运算符可以在执行期决定真正的类型。<br>如果downcast是安全的，也就是说base type pointer指向一个derived class object。这个运算符会传回被适当转换过的指针。<br>如果downcast是不安全的，这个运算符会传回0。<br>dynamic_cast的成本是编译时会产生一个类型描述器。<br>执行期对一个class指针施以dynamic_cast运算符，会返回true或false，true指的是返回真正的地址，false表示没有指向任何对象。</p>\n<p>dynamic_cast运算符也适用于reference。<br>若将一个reference设为0，会引起一个临时对象被产生出来，该临时对象的初值为0，这个reference然后被设定成该临时对象的别名。<br>如果真正参考到derived class，downcast会继续执行程序，反之，会跑出一个bad_cast exception操作。</p>\n<p>typeid运算符<br>typeid运算符传回一个const reference。类型为type_info.<br>RTT1只适合于多态类，但是typeid同时也适用于内建类型。 如typeid(double) 会传回一个 const type_info&amp;。这个时候type_info object是静态取得，而非执行期取得。</p>\n<h2 id=\"效率、弹性\"><a href=\"#效率、弹性\" class=\"headerlink\" title=\"效率、弹性\"></a>效率、弹性</h2><p>传统的C++对象模型提供有效率的执行期支持。这份效率，再加上与C之间的兼容性，造成了C++的广泛被接受度。然而，在某些领域方面，像是动态共享函数库、共享内存、以及分布式对象方面，这个对象模型的弹性还是不够。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《深度探索C++对象模型》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/91\">Dios mío dame paciencia….. ???pero YA !!!!</a></p>\n","tags":["cpp"]},{"title":"c++执行期","url":"/post/b1b9c2c8.html","content":"<p>C++的一件困难事情：不太容易从程序代码看出表达式的复杂度。</p>\n<a id=\"more\"></a>\n\n<p>执行期语意学，即在程序执行时，编译器产生而外的指令调用，确保对象的构造，内存的释放，以及类型转换与临时对象的生成的安全进行。</p>\n<h2 id=\"对象的构造和析构\"><a href=\"#对象的构造和析构\" class=\"headerlink\" title=\"对象的构造和析构\"></a>对象的构造和析构</h2><p>一般而言，我们会把对象尽可能放置在使用它的那个程序区段附近，这样做可以节省不必要的对象产生操作和摧毁操作（主要是析构）。不建议把所有的对象放在函数或某个区段的起始处。</p>\n<p>全局对象<br>对于全局变量，C++会保证在调用全局变量之前，将全局变量构造出来。<br>而所有的全局变量都被放置在程序的数据段中（data segment），并且为没有显示指定值的变量初始化为0。<br>同时对于全局的类对象，在编译时期被放置于data segment中并且内容也为0.只有在程序启动时其对应的constructor才会实施。因此object需要静态初始化。<br>静态初始化的munch策略：<br>1.为每个需要静态初始化的文件产生一个_sti()函数，内含必要的constructor调用操作和inline expansions。<br>2.为每一个需要静态的内存释放操作的文件，产生一个_std()函数。<br>3.提供一个_main()函数调用所有的_sti()函数，一个_exit()函数调用所有的_std()函数</p>\n<p>局部静态对象<br>局部静态对象的构造函数只能被施行一次，析构函数也只有一次。<br>所以对于局部静态对象，一个很简单的思路就是导入一个临时性对象，当第一次传入时，设置为true，之后则不再进行处理。<br>条件式析构也是所有编译器所必须的，而局部静态对象需以构造的相反的顺序被析构。</p>\n<p>对象数组<br>对于以下数组定义，我们一般使用vec_new()函数来构造数组(这是在cfront中的方式), 对于VS等，则提供一个用来处理没有”virtual base class”的class，另一个用来处理”内含virtual base class”的class。后一个函数通常称为 vec_vnew()。<br>函数的原型一般如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\">vec_new( </span><br><span class=\"line\">    <span class=\"keyword\">void</span> *<span class=\"built_in\">array</span>,                       <span class=\"comment\">// 数组的起始地址</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> elem_size,                  <span class=\"comment\">//每一个class object大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> elem_count,                    <span class=\"comment\">//数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*constructor)(<span class=\"keyword\">void</span> *)        <span class=\"comment\">//类的constructor函数指针</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destructor)(<span class=\"keyword\">void</span> *, <span class=\"keyword\">char</span>)   <span class=\"comment\">//类的destructor函数指针</span></span><br></pre></td></tr></table></figure>\n<p>所以对上述的Point对象的初始化，对应的vec_new()的实例化如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">vec_new( &amp;knots, <span class=\"keyword\">sizeof</span>(Point), <span class=\"number\">10</span>, &amp;Point::Point, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同理，对于对象的删除，也有类似的vec_delete()来进行操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\">vec_new( </span><br><span class=\"line\">    <span class=\"keyword\">void</span> *<span class=\"built_in\">array</span>,                       <span class=\"comment\">// 数组的起始地址</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> elem_size,                  <span class=\"comment\">//每一个class object大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> elem_count,                    <span class=\"comment\">//数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destructor)(<span class=\"keyword\">void</span> *, <span class=\"keyword\">char</span>)   <span class=\"comment\">//类的destructor函数指针</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"new和delete运算符\"><a href=\"#new和delete运算符\" class=\"headerlink\" title=\"new和delete运算符\"></a>new和delete运算符</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pi = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>其实是通过两个步骤完成的，第一步通过适当的new运算符函数实例，配置所需的内存，然后将配置来的内存设定初值。</p>\n<p>使用pi，和使用pi所指的对象，其差别在于哪一个生命已经结束了。因为即使对象不合法，但是指针所指的对象也是合法的。<br>new其实是通过标准的c malloc完成的，每一次对new的调用必须传回一个独一无二的指针，指向默认1byte的内存地址。</p>\n<p>针对数组的new语意<br>如果类对象数组没定义constructor和destructor，则不会调用vec_new。<br>对于delete[] p_array, 只有中括号出现时，编译器才会寻找数组的维度，否则他只会假设单独的一个object要被删除。<br>那么如何记录数组的元素个数呢？一个明显的方法是为vec_new()所传回的每一个内存区域块设置一个额外的word，然后把元素个数包藏在那个word之中。而包藏的数值通常称为cookie。<br>在原始编译器中，有两个主要函数用来存取cookie</p>\n<p>注意，避免一个base class指针指向一个derived class object所组成的数组。</p>\n<p>如果一定要这样做，默认情况下只会交给施行vec_delete()函数的”被删除之指针类型的destructor“，也就是Point destructor。<br>所以，需要程序员如下显著的进行释放内存。</p>\n<p>placement Operator new语意</p>\n<h2 id=\"临时性对象\"><a href=\"#临时性对象\" class=\"headerlink\" title=\"临时性对象\"></a>临时性对象</h2><p>临时性对象的摧毁，应该是对完整表达式求值过程中最后一个步骤。该完整表达式造成临时对象的产生。<br>凡持有表达式执行结果的临时对象，应该保留到object的初始化操作完成为止。<br>如果一个临时对象被绑定于一个reference，对象将残留，直到初始化之reference生命结束，或直到临时对象的什么范畴结束。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《深度探索C++对象模型》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/90\">Un pesado es alguien que cuando le preguntas cómo está, va y te contesta.</a></p>\n","tags":["cpp"]},{"title":"c++数据","url":"/post/3ce46037.html","content":"<p>这里看看，c++的数据是怎样存储的。</p>\n<a id=\"more\"></a>\n\n<p>开始前先看看</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Z</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> Y,<span class=\"keyword\">public</span> Z &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述X，Y，Z，A中没有任何一个class内含明显的数据，其间只表示了继承关系。<br>按照书上的例子</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sizeof</span> X = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Y = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Z = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> A = <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p>译注是</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sizeof</span> X = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Y = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Z = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> A = <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>先看X，事实上并不是空的，编译器会安插进去一个char。使得这个class的对象在内存中配置独一无二的地址。</p>\n<p>至于Y和Z受到三个因素的影响：<br>1.语言本身所造成的额外负担。其实就是之前一直说的virtual问题。<br>2.编译器对于特殊情况所提供的优化处理。有些编译器会对这个1bytes作出不同的处理（例如省略）。<br>3.Alignment的限制，我的理解是字节对齐，在大部分机器上，群聚的结构体大小会受到alignment的限制，使它们能够更有效率地在内存中被存取。</p>\n<p>ps:一个虚基类对象只会在派生类中存在一份实体，不管它在class继承体系中出现了多少次。</p>\n<p>C++对象模型尽量以空间优化和存取速度优化的考虑来表现非static成员数据，并且保持和C语言struct数据配置的兼容性。它把数据直接存放在每一个类对象之中。对于继承而来的非static成员数据（不管是virtual还是非virtual基类）也是如此。而类的static成员数据是存放在全局中，只有一份实例（甚至即使该class没有任何对象实体，其static成员数据也已存在），但是一个template类的static成员数据的行为稍有不同。</p>\n<p>每一个类对象必须有足够的大小以容纳它所有的非static成员数据，它可能比你想象的还大，原因是：<br>1.由编译器自动加上的额外成员数据，用以支持某些语言特性（主要是各种virtual特性）。<br>2.因为alignment的需要。</p>\n<h2 id=\"成员数据的绑定\"><a href=\"#成员数据的绑定\" class=\"headerlink\" title=\"成员数据的绑定\"></a>成员数据的绑定</h2><p>先说说extern：<br>extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.。例如变量在xxx.cpp里面定义过了，现在在本头文件中，以extern int a; 的形式声明，那么include”本头文件”的cpp，都可以使用该变量。extern与（const&amp;static）不同，（const和static只在本模块中起作用） extern可以在其他模块中起作用。</p>\n<p>如果成员函数没参数，或者不闲的蛋疼把两个类型定义成同个关键字typedef。那么typedef或者成员数据放前放后都一样；如果出现了以上状况，那么必须把内联typedef 放在成员函数的参数之前。这个主要注意的是内联typedef声明需要放在类的起始处，而其他成员函数里面的数据，可以放在类里面的任何地方。</p>\n<h2 id=\"成员数据的布局\"><a href=\"#成员数据的布局\" class=\"headerlink\" title=\"成员数据的布局\"></a>成员数据的布局</h2><p>非static成员数据在类对象中的排列顺序将和其被声明的顺序一样，任何中间介入的static成员数据都不会被放进对象布局之中。</p>\n<p>c++ standard要求，同一个access section（访问级别）中，成员的排列只需要符合“较晚出现的成员在对象中有较高的地址”即可，并不一定要连续排列。原因之一是边界调整，原因之二是插入的关于virtual的东西，如vptr。<br>c++ standard也允许将多个access sections中的成员数据自由排列，不必在乎声明次序(是指access sections之间的自由排列)，但当前各家编译器都是把一个以上的access section连起来，依照声明次序，称为一个连续区块。另外access sections的多寡不会招来额外的负担。</p>\n<h2 id=\"成员数据的存取\"><a href=\"#成员数据的存取\" class=\"headerlink\" title=\"成员数据的存取\"></a>成员数据的存取</h2><p>static成员数据：在内存中只有一份实体，所以用什么方式，无论是指针也好，对象也罢；本子类的也好，从祖祖父继承来的也罢，都一样其存取路径还是一样的直接。</p>\n<p>非static成员数据：直接存放在每个对象中，所以只能由对象来对他们进行存取操作。对象分为explicit class object（自己定义的）和implicit class object（由this指针表达这个implicit class object）（成员函数中访问成员数据时用的）。</p>\n<p>从object origin存取”和“从pointer pt存取”的区别：<br>如果是关于virtual，这里就涉及多态的概念。如果用pt，那么我们不能说pt必然指向哪个class type（因此我们也就不知道编译时期这个成员真正的offset）所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能解决。但如果用“.”那么class type就确定无疑了，也就没那么多的事儿了。</p>\n<h2 id=\"继承与成员数据\"><a href=\"#继承与成员数据\" class=\"headerlink\" title=\"继承与成员数据\"></a>继承与成员数据</h2><p>单一继承不含virtual函数<br>其数据布局是这样的，子类对象总是把从父类对象弄成一个子对象，然后把这个子对象放在自己的成员数据之前。因此，子类通过对象或者通过对象指针访问父类成员不会存在间接性，父类成员在编译期就可以确定其offset值（父类成员在父类中的offset值和在子类中的offset值是一样的，因为子类对象把整个父类对象给扒拉下来直接按头上了）。因为父类对象在子类对象的首部，这样当父类指针被子类赋值时，父类指针仍然指向子类对象的父类部分（子对象）起始地址。<br>当然这样的存放方式也是有缺点的（指的是没有虚函数，没有多态的情况）。</p>\n<p>加上多态<br>加上多态即虚函数后，首先是virtual table 和vptr 会创建出来，当然这个创建过程会影响到constructor、copy constructor（为vptr设初值）、destructor（结束后删除vptr）。<br>至于vptr放在哪里要看具体的编译器，vptr放在尾端，可以兼容c的struct object；vptr放在前端可以避免“从class object起始点开始量起的offset在执行期必须备妥，甚至于class vptr之间的offset也必须备妥”。</p>\n<p>多重继承<br>单一继承提供了一种“自然多态”形式，换句话说单一继承可以把子对象一个一个的叠加在derived object上面，based object和derived object 都是从相同地址开始的。所以derived object转based object比较方便（只要改变对象size就行了）。</p>\n<p>虚拟继承<br>如果一个class 内含一个或多个virtual based class subobjects，那它将会被分成两个部分：不变的部分和共享的部分。不变的部分不论后继如何衍化，总是拥有固定的offset（从object头算起），所以这部分数据可以被直接存取。共享部分表现出来的就是virtual base class（虚基类） subobject（因为虚基类被多个class继承，也会被多个子object 更改，为了保证虚基类的 object 的统一性，就需要单独把虚基类的 object 给拎出来了），这一部分其位置会因为派生对象操作而发生变化，所以只能被间接存取（引入一个新的指针，指向共享的内容）。<br>当然只是单纯的引入指针指向共享的virtual base class subobject的话会存在两个缺点：1是随着虚基类的增加，指针的个数也会增加；2是虚基类之间如果也存在虚继承的话，间接存取的层数也会增加（子对象-&gt;父虚基类对象-&gt;祖父虚基类对象···）。<br>对于第一个问题，有两种解决方案：1是设一个指针指向一张虚基类表，虚基类表中存放虚基类对象访问地址；2是在虚基类表中存放每一个虚基类的offset，而不是地址。</p>\n<h2 id=\"对象成员的访问效率\"><a href=\"#对象成员的访问效率\" class=\"headerlink\" title=\"对象成员的访问效率\"></a>对象成员的访问效率</h2><p>指向数据成员的指针，是一个有点神秘又颇有用处的语言特性，特别是如果你需要详细调查类成员的底层布局的话。这样的调查可以用于决定vptr是放在class的起始处或者尾端。另外一个用途是可以用来决定类中的access sections的次序。</p>\n<p>指向成员数据的指针的效率问题<br>具体要看编译器怎样优化了</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><a href=\"https://github.com/losophy/losophy.github.io/issues/88\">https://github.com/losophy/losophy.github.io/issues/91</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/88\">El mejor amigo del perro es otro perro.</a></p>\n","tags":["cpp"]},{"title":"c++构造、解构、拷贝","url":"/post/e4e3f884.html","content":"<p>这里记录下c++构造、解构、拷贝。</p>\n<a id=\"more\"></a>\n\n<p>纯虚函数<br>虚函数是为了重载和多态的需要，子类中可以重写或不重写该函数；纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像Java中的interface。</p>\n<p>纯虚函数引入原因：<br>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。纯虚函数就是基类只定义了函数体，没有实现过程，定义方法如： virtual void Eat() = 0; 不要在cpp中定义；纯虚函数相当于接口，不能直接实例化，需要派生类来实现函数定义；</p>\n<p>纯虚函数不能调用的两处地方<br>1.在基类的构造函数中调用纯虚函数。<br>2.在基类的析构函数中调用纯虚函数。</p>\n<p>一些原则<br>纯虚函数的存在：一般来说不要把虚析构函数写成纯虚析构函数。<br>虚函数的存在：一般而言，把所有成员函数都声明成虚函数，然后再靠编译器优化操作吧非必要的virtual invocation去除，并不是好的设计观念。<br>虚函数中的const：因为不确定子类会不会更改数据，所以虚函数最好不要声明成const了。</p>\n<h2 id=\"无继承情况下的对象构造\"><a href=\"#无继承情况下的对象构造\" class=\"headerlink\" title=\"无继承情况下的对象构造\"></a>无继承情况下的对象构造</h2><p>三种对象的产生方式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Point global;<span class=\"comment\">//全局内存配置，生命周期等同整个程序的生命周期 </span></span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">foobar</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPoint local;<span class=\"comment\">//局部内存配置，生命周期在&#123;&#125;之间\t</span></span><br><span class=\"line\">\tPoint *heap=<span class=\"keyword\">new</span> Point;<span class=\"comment\">//堆内存配置，生命周期在new和delete之间，但在此处指针*heap的生命周期在&#123;&#125;之间 </span></span><br><span class=\"line\">\t*heap=local;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> heap;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>程序表现出<br>1.global内存配置<br>在C中，global被视为一个”临时性的定义”，因为它没有明确的初始化操作，一个”临时性的定义”可以在程序中发生多次.那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序data segment中一个”特别保留给为初始化的global objects使用”的空间。<br>C++并不支持”临时性的定义”，这是因为 class 构造行为的隐含应用的缘故.global在C++中被视为完全定义。C++中所有全局对象都被当作”初始化过的数据”来对待。<br>2.local内存配置<br>3.heap内存配置</p>\n<p>无继承情况下的对象构造。plain old data约等于bitwise copy semantic，他们的构造函数是trivial，要不就是根本没有被构造，要不就是构造了也没有被调用。复制构造函数、析构函数也都是类似的情况。</p>\n<h2 id=\"继承体系下的对象构造\"><a href=\"#继承体系下的对象构造\" class=\"headerlink\" title=\"继承体系下的对象构造\"></a>继承体系下的对象构造</h2><p>A.继承情况下对象的构造过程<br>a. 调用所有的虚基类构造函数，从左到右，由最深到最浅（虚基类在对象模型中是以独特的方式（固定部分与共享部分）支持的，不涉及到在对象模型中的偏移量的问题）<br>b. 调用所有的上一层的基类构造函数，以基类的声明顺序为顺序（这是因为一般基类的子对象都会被放在对象的开始，并且按基类声明的次序放置）<br>c. 如果类对象有虚函数表指针，设定其初值，指向适当的虚函数表<br>d. 如果有一个成员对象并没有出现在成员初始化列表中，且它有一个默认构造函数，那么该默认构造函数必须被调用<br>e. 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数本身，并以成员声明的顺序为顺序。<br>f. 程序员自己的代码（在此步以上的操作均为编译器安插的）</p>\n<p>B.继承情况下对象构造过程中如何压制虚基类的构造函数的重复调用<br>“virtual base class constructors的调用”有着明确的定义：只有一个完整的classobject被定义出来时，它才会被调用；如果object只是某个完整的object的subject，它就不会被调用。</p>\n<p>class PVertex 的object中，在保存 PVertex 自己的数据之前，上面有很多个父类的subobject，那么虚基类Point的构造函数不会被其他的subobject所调用，它的构造函数只有当整个object被定义出来时，也即PVertex数据定义出来时才会被调用，也就是只会被PVertex所调用。而在PVertex之前的subobject 对虚基类构造函数的调用操作将会被抑制。另外，如果没有最下层的PVertex，那么就是被Vertex3d调用。综上所述，这样才能保证共享虚基类对象的一致性。</p>\n<h2 id=\"对象复制\"><a href=\"#对象复制\" class=\"headerlink\" title=\"对象复制\"></a>对象复制</h2><p>关于重载赋值操作符和复制拷贝构造函数的区别</p>\n<p>拷贝构造函数是用一个已存在的对象去构造一个不存在的对象（拷贝构造函数毕竟还是构造函数嘛），也就是初始化一个对象。<br>而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过（即已经过构造函数的初始化了）的对象进行赋值。</p>\n<p>当设计一个类，并以一个类对象指定给另一个对象时，我们有三种选择：<br>a.什么都不做，实施默认行为<br>b.提供一个explicit copy assignment operator<br>c.拒绝拷贝，拒绝拷贝方式：<br>1.将copy assignment operator私有化<br>2.不提供函数定义，导致在链接失败</p>\n<p>对象赋值（拷贝）函数是为了打开named value return（NVR）<br>对象赋值操作copy assignment operator的合成条件和构造函数类似<br>当不要Bitwise Copy Semantics时，类就需要合成一个对象赋值操作：<br>1.当类内含一个成员对象，而成员对象声明有一个copy constructor operator时<br>2.当类继承一个基类对象而后者存在有一个copy constructor operator时<br>3.当类声明了一个或多个virtual functions时，<br>4.当类派生自一个继承串链，其中有一个或多个virtual base classes时。此时无论基类有没有copy operator。</p>\n<h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><p>如果类没有定义析构函数，那么只有类存在成员对象且该成员对象含有析构函数的情况下，编译器才会自动合出一个析构函数来。默认情况下编译器并不会合成一个析构函数，即使是它拥有一个virtual function。<br>析构函数的扩展方式与构造函数相同，但顺序相反。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《深度探索C++对象模型》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/89\">El dinero no trae la felicidad, pero cuando se va, se la lleva.</a></p>\n","tags":["cpp"]},{"title":"c++构造函数","url":"/post/d3363e0e.html","content":"<p>关键词explicit之所以被导入这个语言，就是为了提供给程序员一种方法，使他们能够制止“单一参数的构造函数”被当做一个转换运算符。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"默认构造函数的构建操作\"><a href=\"#默认构造函数的构建操作\" class=\"headerlink\" title=\"默认构造函数的构建操作\"></a>默认构造函数的构建操作</h2><p>以下四种情况类会被生成“有用的”默认构造函数<br>a.一个带有默认构造函数的成员对象类<br>  合成的默认构造函数是以inline的方式完成的，如果函数太复杂则会做成非inline的static实体</p>\n<p>b.带有默认构造函数的基类<br>  和上述情况相似，子类没有构造函数，编译器会默认合成一个调用基类默认（无参）构造函数的子类默认构造函数</p>\n<p>c.带有一个虚函数的class<br>  以下两种情况需要合成出默认构造函数<br>1）类声明（或继承）一个虚函数<br>2）类派生自一个继承串链，其中有一个或多个虚基类</p>\n<p>d.带有一个虚基类的类（菱形继承）</p>\n<p>关于默认构造函数的合成两点是需要注意的：<br>1）不是任何没有定义构造函数的类都会被合成出一个默认构造函数<br>2）编译器合成出来的默认构造函数不会对类内每一个成员数据都设定默认值</p>\n<h2 id=\"拷贝构造函数的构建操作\"><a href=\"#拷贝构造函数的构建操作\" class=\"headerlink\" title=\"拷贝构造函数的构建操作\"></a>拷贝构造函数的构建操作</h2><p>有三种情况，会以一个对象的内容作为另一个类对象的初值<br>1.对一个对象做明确的初始化操作<br>2.当对象被当作参数交给某个函数时<br>3.当函数传回一个类对象时</p>\n<p>一个类对象可以从两种方式复制得到，一种是拷贝构造，另一种是拷贝赋值操作（=）。</p>\n<p>关于复制<br>其实复制涉及到C++内部模型的两个概念，即Default Memberwise Initialization 和bitwise copy semantics。<br>Default Memberwise Initialization： 这是C 模型的内部一种实现方案,其原理就是对于同一类的两个对象直接的赋值进行的暗箱操作。说白了，就是将一个对象的内存空间中的数据，原封不动的拷贝出另一份来填满另一个对象的内存。<br>如果该类内含其他类的对象作为自己的成员变量的话，那赋值操作并不会对该对象变量进行赋值，而是递归的对其内部数据成员赋值（原理还是有关对象内存布局）。如果类中有个指针成员变量，而其指向堆中的一片区域，然而在赋值过程中，根据memberwise的概念，只是将指针的值进行了赋值，这样一来，这两个对象中的指针变量自然都是指向同一片内存区域了，即所谓的浅拷贝。所以这时就需要程序员自己来实现拷贝构造函数来完成那片堆内存的拷贝赋值操作，即所谓的深拷贝。</p>\n<p>不要bitwise copy semantic<br>什么时候一个类不展现出bitwise copy semantic呢？<br>1）当类内含有一个成员类对象，而这个成员类对象内有一个拷贝构造函数时（不论是class设计者明确声明，或者被编译器合成 ）。<br>2）当类继承自 一个基类，而基类有拷贝构造函数时（不论是类设计者明确声明，或者被编译器合成 ）。<br>3）当一个类声明了一个或多个virtual 函数时。<br>4）当类派生自一个继承串链，其中一个或者多个virtual基类。<br>在前两种情况中，编译器必须将成员或基类的“ 构造函数的调用操作” 安插到被合成的构造函数中。（就像构造函数中的操作那样）。<br>第三种情况，如果编译器对于每一个新产生的类对象的虚表不能成功而正确地设好其初值，将导致可怕的后果。因此，当编译器导入一个虚表到类之中时，该类就不再展现bitwise copy semantic了。如果没有 bitwise copy semantics的作用的话，很容易想到，编译器会用到默认复制来对两个对象的vptr进行复制，因为两个类对象的vp都指向同一个vptr，所以会导致可怕的后果。</p>\n<p>这里我都被bitwise 和Memberwise 搞昏了。反正就是以上四种情况，复制不是单纯的直接复制。编译器会开辟新内存。</p>\n<h2 id=\"构造函数使用\"><a href=\"#构造函数使用\" class=\"headerlink\" title=\"构造函数使用\"></a>构造函数使用</h2><p>在使用者层面做优化<br>一般来说是这么写的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tX xx;</span><br><span class=\"line\">\txx.X::X(p1,p2);<span class=\"comment\">//default constructor? OR member fuction?</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xx；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//编译器内部的伪码：</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> bar(X&amp; _result, <span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tX xx;</span><br><span class=\"line\">\txx.X::X(p1,p2);<span class=\"comment\">//default constructor? OR member fuction?</span></span><br><span class=\"line\">\t_result.X::XX(xx);<span class=\"comment\">//copy constructor</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;  <span class=\"comment\">//什么也不返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这么写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> X(p1,p2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//编译器内部的伪码：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(X&amp; _result, <span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t_result.X::X(p1,p2);<span class=\"comment\">//default constructor? OR member fuction?</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;<span class=\"comment\">//什么也不返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比较而言，少了个copy constructor。换句话说，少用局部变量，能直接计算返回的，就直接计算返回，这样可以少产生一个拷贝构造函数。</p>\n<p>在编译器层面做优化<br>在使用者层面做优化的例子，原先是使用者注意少用局部变量，能直接计算返回的，就直接计算返回，这样可以少产生一个拷贝构造函数。现在这件事情编译器代你做了，换句话说，即使我们仍用了xx做局部变量，保存计算结果，return xx，编译器也会自动把xx用_result替换掉，替你精简掉一个copy constructor。<br>然后呢，lippman把这种行为叫做“NRV优化”， NRV优化的本质是优化掉拷贝构造函数，当然去掉它的前提是作为使用者的我们用了xx做局部变量、return xx；如果我们没有这么做，而是直接return X(p1,p2) 那么这种行为也就不会发生了。</p>\n<p>要不要构造函数？<br>其实就是bitwise和Memberwise的问题了。如果类对象的成员数据以数值来储存。bitwise copy既不会导致memory leak，也不会产生address aliasing，因此它既快速又安全。如果类需要大量的memberwise初始化操作，例如以传值的方式传回对象，那么就需要explicit了。<br>当然，你也可以手动memcpy，但使用前提是：在class不含任何编译器产生的内部members。例如virtual相关内容。</p>\n<h2 id=\"成员们的初始化队列\"><a href=\"#成员们的初始化队列\" class=\"headerlink\" title=\"成员们的初始化队列\"></a>成员们的初始化队列</h2><p>当你写下一个构造函数的时候，你有机会设定类成员的初值。要不是经由成员初始化列表，就是在构造函数本身之内。除了四种情况，你的任何选择其实都差不多。</p>\n<p>必须使用初始化列表的情况<br>1）当初始化一个引用成员时<br>2）当初始化一个常量成员时<br>3）当调用一个基类的构造函数，而它拥有一组参数时<br>4）当调用一个类成员的构造函数，而它拥有一组参数时</p>\n<p>第一第二是因为：const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化，因此初始化const对象或引用的唯一机会是构造函数函数体之前的初始化列表中。<br>第三第四是因为：主要是性能问题，如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数。对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。</p>\n<p>所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表。<br>还有，对于初始化列表有些地方需要注意：list中的生成次序是由类中成员的声明次序决定的，而不是initialization list的排列次序决定的。</p>\n<p>全局对象的内存保证会在程序激活的时候被清为0。局部对象配置于程序的堆栈中，动态对象配置于自由空间中，都不一定会被清为0，它们的内容将是内存上次被使用后的遗迹。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《深度探索C++对象模型》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/87\">Hombre de buenas costumbres busca alguien que se las quite.</a></p>\n","tags":["cpp"]},{"title":"cmake","url":"/post/233853f2.html","content":"<p><code>CMake</code>是一个比<code>make</code>更高级的编译配置工具，它可以根据不同平台、不同的编译器，生成相应的<code>Makefile</code>或者<code>vcproj</code>项目。</p>\n<a id=\"more\"></a>\n\n<p>通过编写<code>CMakeLists.txt</code>，可以控制生成的<code>Makefile</code>，从而控制编译过程。<code>CMake</code>自动生成的<code>Makefile</code>不仅可以通过<code>make</code>命令构建项目生成目标文件，还支持安装<code>（make install）</code>、测试安装的程序是否能正确执行<code>（make test，或者ctest）</code>、生成当前平台的安装包<code>（make package）</code>、生成源码包<code>（make package_source）</code>、产生<code>Dashboard</code>显示数据并上传等高级功能，只要在<code>CMakeLists.txt</code>中简单配置，就可以完成很多复杂的功能，包括写测试用例。如果有嵌套目录，子目录下可以有自己的<code>CMakeLists.txt</code>。</p>\n<h3 id=\"外部编译\"><a href=\"#外部编译\" class=\"headerlink\" title=\"外部编译\"></a>外部编译</h3><p>外部编译，一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。通过这一点，也足以说服我们全部采用外部编译方式构建工程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#确定cmake最低版本需求</span><br><span class=\"line\">cmake_minimum_required(VERSION 3.0.0)</span><br><span class=\"line\"></span><br><span class=\"line\">#打印</span><br><span class=\"line\">MESSAGE(STATUS &quot;This is install dir &quot; $&#123;CMAKE_INSTALL_PREFIX&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#确定工程名</span><br><span class=\"line\">#(这一行会引入两个变量XXX_BINARY_DIR (二进制文件保存路径)和 #XXX_SOURCE_DIR(源代码保存路径))</span><br><span class=\"line\">project(XXX)</span><br><span class=\"line\"></span><br><span class=\"line\">#添加需要的库</span><br><span class=\"line\">set(CMAKE_PREFIX_PATH $&#123;CMAKE_PREFIX_PATH&#125; &quot;&#x2F;usr&#x2F;local&#x2F;share&#x2F;OpenCV&quot;)</span><br><span class=\"line\">find_package(OpenCV 3.2.0 REQUIRED)</span><br><span class=\"line\"></span><br><span class=\"line\">#添加需要的头文件</span><br><span class=\"line\">include_directories(include)</span><br><span class=\"line\">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class=\"line\">include_directories(&#x2F;usr&#x2F;local&#x2F;cuda-8.0&#x2F;include&#x2F;)</span><br><span class=\"line\"></span><br><span class=\"line\">#确定编译语言</span><br><span class=\"line\">#add_definitions(-std&#x3D;c++11)</span><br><span class=\"line\">set(CMAKE_CXX_STANDARD 11)</span><br><span class=\"line\"></span><br><span class=\"line\">#设定变量</span><br><span class=\"line\">ADD_DEFINITIONS( -DGPU -DCUDNN )</span><br><span class=\"line\"></span><br><span class=\"line\">#添加源代码</span><br><span class=\"line\">aux_source_directory($&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;src src)</span><br><span class=\"line\"></span><br><span class=\"line\">#编译动态库并链接库文件</span><br><span class=\"line\">link_directories($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class=\"line\">add_library(plate_recognition SHARED $&#123;SRC&#125;)</span><br><span class=\"line\">target_link_libraries(plate_recognition $&#123;OpenCV_LIBS&#125;)</span><br><span class=\"line\">target_link_libraries(plate_recognition -llianghao  -lpthread -lm -lstdc++)</span><br><span class=\"line\"></span><br><span class=\"line\">#生成可执行文件</span><br><span class=\"line\">link_directories($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class=\"line\">add_executable(Test $&#123;SRC&#125;)</span><br><span class=\"line\">target_link_libraries(Test $&#123;OpenCV_LIBS&#125;)</span><br><span class=\"line\">target_link_libraries(Test -llianghao  -lpthread -lm -lstdc++)</span><br><span class=\"line\"></span><br><span class=\"line\">#make install</span><br><span class=\"line\">SET(CMAKE_INSTALL_PREFIX $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">INSTALL(TARGETS myengine</span><br><span class=\"line\">    DESTINATION ..&#x2F;assets&#x2F;bin&#x2F;</span><br><span class=\"line\">   )</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目删除\"><a href=\"#项目删除\" class=\"headerlink\" title=\"项目删除\"></a>项目删除</h3><p><code>CMake</code>默认不提供<code>uninstall</code>这个<code>target</code>，想要的话，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xargs rm &lt; install_manifest.txt</span><br></pre></td></tr></table></figure>\n<p>对于不修改配置的项目足够了，<code>manifest.txt</code>是<code>CMake</code>生成的安装文件列表。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/35\">Donde hay humo, hay fuego.</a></p>\n","tags":["linux"]},{"title":"docker","url":"/post/f255ffad.html","content":"<p>用了<code>Docker</code>我们就可以更加专注地开发业务代码了，不用因安装环境而浪费时间。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"docker一些概念\"><a href=\"#docker一些概念\" class=\"headerlink\" title=\"docker一些概念\"></a>docker一些概念</h2><blockquote>\n<p><code>Image</code>：我们可以把它理解为一个执行环境<code>（env）</code>，在我们执行了<code>docker run</code>命令之后，<code>Docker</code>就会根据当前的<code>Image</code>创建一个新的<code>Container</code><br><code>Container</code>：是一个程序运行的沙箱，它们互相独立，但都运行在由<code>Image</code>创建的执行环境之上</p>\n</blockquote>\n<h2 id=\"利用docker运行各软件\"><a href=\"#利用docker运行各软件\" class=\"headerlink\" title=\"利用docker运行各软件\"></a>利用docker运行各软件</h2><p>使用<code>docker</code>运行各软件，然后暴露其端口。这里做，就不用担心不同版本的问题了。也让主机更干净。</p>\n<h3 id=\"docker-run-mongo\"><a href=\"#docker-run-mongo\" class=\"headerlink\" title=\"docker run mongo\"></a>docker run mongo</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 27017:27017 --name mongo -d mongo:4.4.6</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-run-redis\"><a href=\"#docker-run-redis\" class=\"headerlink\" title=\"docker run redis\"></a>docker run redis</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 6379:6379 --name redis -d redis:6.2.3</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地开发的程序\"><a href=\"#本地开发的程序\" class=\"headerlink\" title=\"本地开发的程序\"></a>本地开发的程序</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it -p 3000:3000 --name bbs --link redis-server:redis --link mongo bbs /bin/bash</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/141\">Aprender no es otra cosa que acordarse.</a></p>\n","tags":["docker"]},{"title":"docker更换国内镜像源","url":"/post/48508611.html","content":"<p>因为墙的关系，国外的源相对比较慢，切换国内镜提速十分重要。</p>\n<a id=\"more\"></a>\n\n<p>找到<code>daemon.json</code>文件，在这里加上镜像源。<br><img src=\"https://user-images.githubusercontent.com/11263320/117582016-9a4ab300-b132-11eb-97a0-1ac425de02b6.JPG\" alt=\"捕获\"></p>\n<p>可以用这些镜像源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Docker中国区官方镜像</span><br><span class=\"line\">https:&#x2F;&#x2F;registry.docker-cn.com</span><br><span class=\"line\"></span><br><span class=\"line\">网易</span><br><span class=\"line\">http:&#x2F;&#x2F;hub-mirror.c.163.com</span><br><span class=\"line\"></span><br><span class=\"line\">ustc </span><br><span class=\"line\">https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn</span><br><span class=\"line\"></span><br><span class=\"line\">中国科技大学</span><br><span class=\"line\">https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/128\">¡Gracias！</a></p>\n","tags":["docker"]},{"title":"epoll实现","url":"/post/e2082e23.html","content":"<p>在<code>linux</code>没有实现<code>epoll</code>事件驱动机制之前，我们一般选择用<code>select</code>或者<code>poll</code>等<code>IO</code>多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，<code>select</code>和<code>poll</code>的用武之地越来越有限，风头已经被<code>epoll</code>占尽。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"epoll实现\"><a href=\"#epoll实现\" class=\"headerlink\" title=\"epoll实现\"></a>epoll实现</h2><p><code>epoll</code>通过在<code>Linux</code>内核中申请一个简易的文件系统。<br>把原先的<code>select/poll</code>调用分成了3个部分：</p>\n<blockquote>\n<p>1）调用<code>epoll_create</code>建立一个<code>epoll</code>对象(在<code>epoll</code>文件系统中为这个句柄对象分配资源)<br>2）调用<code>epoll_ctl</code>向<code>epoll</code>对象中添加所有连接的套接字<br>3）调用<code>epoll_wait</code>收集发生的事件的连接</p>\n</blockquote>\n<p>要实现高并发的多个连接，只需要在进程启动时建立一个<code>epoll</code>对象，然后在需要的时候向这个<code>epoll</code>对象中添加或者删除连接。同时，<code>epoll_wait</code>的效率也非常高，因为调用<code>epoll_wait</code>时，并没有一股脑的向操作系统复制所有连接的句柄数据，内核也不需要去遍历全部的连接(不再需要从用户态复制句柄数据结构到内核态)。</p>\n<p>下面来看看<code>Linux</code>内核具体的<code>epoll</code>机制实现思路。<br>当某一进程调用<code>epoll_create</code>方法时，<code>Linux</code>内核会创建一个<code>eventpoll</code>结构体，这个结构体中有两个成员与<code>epoll</code>的使用方式密切相关。<code>eventpoll</code>结构体如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventpoll</span>&#123;</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"comment\">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span>  <span class=\"title\">rbr</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">rdlist</span>;</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每一个<code>epoll</code>对象都有一个独立的<code>eventpoll</code>结构体，用于存放通过<code>epoll_ctl</code>方法向<code>epoll</code>对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是<code>lgn</code>，其中<code>n</code>为树的高度)。</p>\n<p>而所有添加到<code>epoll</code>中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫<code>ep_poll_callback</code>，它会将发生的事件添加到<code>rdlist</code>双链表中。</p>\n<p>在<code>epoll</code>中，对于每一个事件，都会建立一个<code>epitem</code>结构体，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epitem</span>&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span>  <span class=\"title\">rbn</span>;</span><span class=\"comment\">//红黑树节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">rdllink</span>;</span><span class=\"comment\">//双向链表节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_filefd</span>  <span class=\"title\">ffd</span>;</span>  <span class=\"comment\">//事件句柄信息</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventpoll</span> *<span class=\"title\">ep</span>;</span>    <span class=\"comment\">//指向其所属的eventpoll对象</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">event</span>;</span> <span class=\"comment\">//期待发生的事件类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用<code>epoll_wait</code>检查是否有事件发生时，只需要检查<code>eventpoll</code>对象中的<code>rdlist</code>双链表中是否有<code>epitem</code>元素即可。如果<code>rdlist</code>不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>\n<p>从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了<code>epoll</code>的高效。<br>OK，讲解完了<code>epoll</code>的机理，我们便能很容易掌握<code>epoll</code>的用法了。<br>一句话描述就是：三步曲。</p>\n<blockquote>\n<p>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。<br>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。<br>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p>\n</blockquote>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h2><p>使用起来很清晰，首先要调用<code>epoll_create</code>建立一个<code>epoll</code>对象。参数<code>size</code>是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。<br><code>epoll_ctl</code>可以操作上面建立的<code>epoll</code>，例如，将刚建立的<code>socket</code>加入到<code>epoll</code>中让其监控，或者把<code>epoll</code>正在监控的某个<code>socket</code>句柄移出<code>epoll</code>，不再监控它等等。<br><code>epoll_wait</code>在调用时，在给定的<code>timeout</code>时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程。</p>\n<p><code>epoll</code>在被内核初始化时（操作系统启动），同时会开辟出<code>epoll</code>自己的内核高速<code>cache</code>区，用于安置每一个我们想监控的<code>socket</code>，这些<code>socket</code>会以红黑树的形式保存在内核<code>cache</code>里，以支持快速的查找、插入、删除。这个内核高速<code>cache</code>区，就是建立连续的物理内存页，然后在之上建立<code>slab</code>层，简单的说，就是物理上分配好你想要的<code>size</code>的内存对象，每次使用时都是使用空闲的已分配好的对象。</p>\n<p>几乎所有的<code>epoll</code>程序都使用下面的框架：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nfds = epoll_wait(epfd,events,<span class=\"number\">20</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;nfds;++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(events[i].data.fd==listenfd) <span class=\"comment\">//有新的连接</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class=\"comment\">//accept这个连接</span></span><br><span class=\"line\">                ev.data.fd=connfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class=\"comment\">//将新的fd添加到epoll的监听队列中</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( events[i].events&amp;EPOLLIN ) <span class=\"comment\">//接收到数据，读socket</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n = read(sockfd, line, MAXLINE)) &lt; <span class=\"number\">0</span>    <span class=\"comment\">//读</span></span><br><span class=\"line\">                ev.data.ptr = md;     <span class=\"comment\">//md为自定义类型，添加数据</span></span><br><span class=\"line\">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class=\"comment\">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(events[i].events&amp;EPOLLOUT) <span class=\"comment\">//有数据待发送，写socket</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class=\"comment\">//取数据</span></span><br><span class=\"line\">                sockfd = md-&gt;fd;</span><br><span class=\"line\">                send( sockfd, md-&gt;ptr, <span class=\"built_in\">strlen</span>((<span class=\"keyword\">char</span>*)md-&gt;ptr), <span class=\"number\">0</span> );        <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">                ev.data.fd=sockfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class=\"comment\">//修改标识符，等待下一个循环时接收数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//其他的处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"LT-和-ET\"><a href=\"#LT-和-ET\" class=\"headerlink\" title=\"LT 和 ET\"></a>LT 和 ET</h2><p>epoll还提供了两种工作模式。</p>\n<blockquote>\n<p>LT（水平触发）是缺省的工作模式<br>ET（边缘触发）是高速模式</p>\n</blockquote>\n<h3 id=\"用法演示\"><a href=\"#用法演示\" class=\"headerlink\" title=\"用法演示\"></a>用法演示</h3><blockquote>\n<ul>\n<li>  <a href=\"https://github.com/yedf/handy/blob/master/raw-examples/epoll.cc\">epoll.cc</a>，演示了epoll的通常用法，使用epoll的LT模式</li>\n<li>  <a href=\"https://github.com/yedf/handy/blob/master/raw-examples/epoll-et.cc\">epoll-et.cc</a>，演示了epoll的ET模式，与LT模式非常像，区别主要体现在不需要手动开关EPOLLOUT事件</li>\n</ul>\n</blockquote>\n<h3 id=\"LT-和-ET本质的区别是\"><a href=\"#LT-和-ET本质的区别是\" class=\"headerlink\" title=\"LT 和 ET本质的区别是\"></a>LT 和 ET本质的区别是</h3><p><code>LT</code>模式状态时，主线程正在<code>epoll_wait</code>等待事件时，请求到了，<code>epoll_wait</code>返回后没有去处理请求<code>(recv)</code>，那么下次<code>epoll_wait</code>时此请求还是会返回。<strong>因为没有处理时，每一次内核都会通知，所以这种模式编程出错误可能性要小一点</strong>。<br><code>ET</code>模式状态下，这次没处理，下次<code>epoll_wait</code>时将不返回。然后它会假设你知道文件描述符已经就绪，所以我们应该每次一定要处理。<strong>ET模式很大程度降低内核发送通知的次数，性能更好</strong>。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/25\">De músico, poeta y loco, todos tenemos un poco.</a></p>\n","tags":["linux kernel"]},{"title":"gdb调试","url":"/post/8db4c595.html","content":"<p>这里记录下使用gdb调试python程序。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd:gdb</span><br><span class=\"line\">gdb$ file yourpram</span><br><span class=\"line\"></span><br><span class=\"line\">* 保存历史命令</span><br><span class=\"line\">echo &#39;set history save on&#39; &gt;&gt; ~&#x2F;.gdbinit &amp;&amp; chmod 600 ~&#x2F;.gdbinit</span><br><span class=\"line\">gdb$ show history</span><br><span class=\"line\"></span><br><span class=\"line\">* 设置参数</span><br><span class=\"line\">gdb$ set args(e.g. set args 10 20 30 40 50)</span><br><span class=\"line\">gdb$ show args</span><br><span class=\"line\"></span><br><span class=\"line\">* 执行程序至 main() 主函数的起始位置，即在 main() 函数的第一行语句处停止执行（该行代码尚未执行）。</span><br><span class=\"line\">gdb$ start</span><br><span class=\"line\"></span><br><span class=\"line\">* 加断点</span><br><span class=\"line\">gdb$ b gdb_test.c:3 </span><br><span class=\"line\">gdb$ info b</span><br><span class=\"line\">gdb$ delete 1&#x2F;&#x2F;输入命令delete， 再加上断点编号，可以删除对应编号的断点</span><br><span class=\"line\"> </span><br><span class=\"line\"> * 打印参数</span><br><span class=\"line\">gdb$ p i</span><br><span class=\"line\">gdb$ p&#x2F;x i</span><br><span class=\"line\">gdb$ p *ts  &#x2F;&#x2F;打印结构体</span><br><span class=\"line\"></span><br><span class=\"line\">* 下一步</span><br><span class=\"line\">gdb$ n</span><br><span class=\"line\"></span><br><span class=\"line\">* run 指令会执行程序至第一个断点处，没有指令就一直执行程序</span><br><span class=\"line\">gdb$ run</span><br><span class=\"line\"></span><br><span class=\"line\">* 继承运行</span><br><span class=\"line\">gdb$ c</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>UI interface(TUI mode)<br>ctrl+X+A</li>\n</ul>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/105\">He oído hablar tan bien de ti, que creía que estabas muerto.</a></p>\n","tags":["gdb"]},{"title":"git项目相关问题","url":"/post/1121b4c3.html","content":"<p>这里记录下<code>git</code>的相关问题。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"提交不停弹出登陆弹窗的问题\"><a href=\"#提交不停弹出登陆弹窗的问题\" class=\"headerlink\" title=\"提交不停弹出登陆弹窗的问题\"></a>提交不停弹出登陆弹窗的问题</h2><p>无论是用<code>git push</code>还是<code>tortoisegit push</code>，都会不停弹出登录窗口。<br>结果不论如何填写用户名和密码，都说<code>logon failed</code>。</p>\n<p><code>google</code>了一下，发现原来有个<code>git credentials manager</code>这个软件，这是安装git的时候勾选安装的，这个弹窗就是这个软件弹出来的。</p>\n<p>根据提示，执行了<code>git credential-manager uninstall</code>。不再弹出登录窗口了，提交直接<code>push</code>就行了。</p>\n<h2 id=\"git项目如何过滤没有后缀的二进制文件\"><a href=\"#git项目如何过滤没有后缀的二进制文件\" class=\"headerlink\" title=\"git项目如何过滤没有后缀的二进制文件\"></a>git项目如何过滤没有后缀的二进制文件</h2><p>一般是输出到固定目录，比如<code>dest</code>然后统一忽略。要不然就赋予他们一个相同的<code>pattern</code>然后忽略。</p>\n<p>原本扩展名对<code>liunx</code>的影响不大，只是今年来<code>linux</code>也才慢慢的用扩展名标识文件类型。<br><code>window</code>文件你也可以不写扩展名。<br>不一定非要二进制文件才没有扩展名。<br><code>git</code>没有通过判断文件内容来忽略的接口，除非自己写。</p>\n<h2 id=\"git仓库太大的处理方法\"><a href=\"#git仓库太大的处理方法\" class=\"headerlink\" title=\"git仓库太大的处理方法\"></a>git仓库太大的处理方法</h2><h3 id=\"只下载最后一次的提交\"><a href=\"#只下载最后一次的提交\" class=\"headerlink\" title=\"只下载最后一次的提交\"></a>只下载最后一次的提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;Wuchenwcf&#x2F;MyCode.git --depth&#x3D;&#x3D;1</span><br></pre></td></tr></table></figure>\n<h3 id=\"git仓库压缩瘦身\"><a href=\"#git仓库压缩瘦身\" class=\"headerlink\" title=\"git仓库压缩瘦身\"></a>git仓库压缩瘦身</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看历史大文件</span><br><span class=\"line\">git rev-list --objects --all | grep &quot;$(git verify-pack -v .git&#x2F;objects&#x2F;pack&#x2F;*.idx | sort -k 3 -n | tail -5 | awk &#39;&#123;print$1&#125;&#39;)&quot;</span><br><span class=\"line\"># 从历史中删除 target&#x2F; 这个文件夹</span><br><span class=\"line\">git filter-branch --force --index-filter &#39;git rm -r  --cached --ignore-unmatch target&#x2F;&#39; --prune-empty --tag-name-filter cat -- --all</span><br><span class=\"line\"># 执行仓库压缩</span><br><span class=\"line\">git gc --prune&#x3D;now</span><br><span class=\"line\"># 推送到远程仓库</span><br><span class=\"line\">git push origin --force --all</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/3\">El hábito no hace al monje.</a></p>\n","tags":["git"]},{"title":"linux下的一些操作","url":"/post/9780b568.html","content":"<p>准确来说，是<code>linux</code>下的一些<code>shell</code>操作。写在这里也方便查找。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"wc查看单个或多个文件的行数或总行数\"><a href=\"#wc查看单个或多个文件的行数或总行数\" class=\"headerlink\" title=\"wc查看单个或多个文件的行数或总行数\"></a>wc查看单个或多个文件的行数或总行数</h2><p><code>wc</code>命令用来计算数字。利用<code>wc</code>指令我们可以计算文件的<code>Byte</code>数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则<code>wc</code>指令会从标准输入设备读取数据。</p>\n<p>查看cpp文件和h文件行数：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">find ./ -name &quot;*.cpp&quot; -o -name &quot;*.h&quot; |xargs cat|wc -l</span><br></pre></td></tr></table></figure>\n<h2 id=\"grep查找包含某个单词的所有文件\"><a href=\"#grep查找包含某个单词的所有文件\" class=\"headerlink\" title=\"grep查找包含某个单词的所有文件\"></a>grep查找包含某个单词的所有文件</h2><p>如果你想在当前目录下，查找某文件内是否有”hello,world!”字符串，可以像这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">grep -rn &quot;hello,world!&quot; *</span><br></pre></td></tr></table></figure>\n<h2 id=\"找文件\"><a href=\"#找文件\" class=\"headerlink\" title=\"找文件\"></a>找文件</h2><p>在<code>linux</code>下，主要用到的文件查找有<code>find</code>，<code>whereis</code>，<code>locate</code>。</p>\n<p>通常<code>find</code>不是很常用的。因为速度慢之外， 也很操硬盘！通常我们都是先使用<code>whereis</code>或者是<code>locate</code>来检查，如果真的找不到了，才以<code>find</code>来搜寻。 为什么呢？因为<code>whereis</code>和<code>locate</code>是利用数据库来搜寻数据，所以相当的快速，而且并没有实际的搜寻硬盘， 比较省时间！</p>\n<h3 id=\"whereis\"><a href=\"#whereis\" class=\"headerlink\" title=\"whereis\"></a>whereis</h3><p><code>whereis</code>命令会在指定的目录中查找符合条件的文件，文件应的属性应属于原始代码，二进制文件，或是帮助文件。</p>\n<h3 id=\"locate\"><a href=\"#locate\" class=\"headerlink\" title=\"locate\"></a>locate</h3><p><code>locate</code>命令用于查找符合条件的文件，它会去保存文件与目录名称的数据库内，查找符合条件的文件或目录。<br><code>locate</code>的使用更简单，直接在后面输入文件名后，就能够得到结果。（<code>locate</code>命令可以在搜寻数据库时快速找到文件，数据库由<code>updatedb</code>程序来更新）。</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><code>find</code>是一个非常有效的工具，它可以遍历当前目录甚至于整个文件系统来查找某些文件或目录。<br>查找文件名包含I的文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">find -name &quot;I*.cpp&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h2><p>我用得最多的是make的重定向。<br>只需要把<code>make</code>输出中的错误（及警告）信息输出到文件中，可以用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">make xxx 2&gt; build_output.txt</span><br></pre></td></tr></table></figure>\n<p>只需要把make输出中的正常（非错误，非警告）的信息输出到文件中，可以用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">make xxx 1&gt; build_output.txt</span><br></pre></td></tr></table></figure>\n<p>所有的信息都输出到同一个文件中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">make xxx &gt; build_output_all.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<p>其中的<code>2&gt;&amp;1</code>表示错误信息输出到<code>&amp;1</code>中，而<code>&amp;1</code>，指的是前面的那个文件：<code>build_output_all.txt</code>。</p>\n<div class=\"note warning\"><p>上面所有的`1,2`等数字，后面紧跟着大于号'>' ，中间不能有空格。</p></div>\n\n<h2 id=\"根据进程名称Kill多个进程\"><a href=\"#根据进程名称Kill多个进程\" class=\"headerlink\" title=\"根据进程名称Kill多个进程\"></a>根据进程名称Kill多个进程</h2><p>经常需要<code>Kill</code>多个进程，这些进程包含共同的关键字，可以用一条命令<code>Kill</code>掉它们。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps aux | grep &quot;common&quot; |grep -v grep| cut -c 9-15 | xargs kill -9</span><br></pre></td></tr></table></figure>\n<p>管道符<code>|</code>用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。下面说说用管道符联接起来的几个命令：<br><code>ps aux</code>查看所有进程的命令。这时检索出的进程将作为下一条命令<code>grep &quot;common</code>的输入。<code>grep &quot;common</code>选出所有含有关键字<code>common</code>的进程。<code>cut -c 9-15</code>截取输入行的第9个字符到第15个字符，而这正好是进程号<code>PID</code>。<code>grep -v grep</code>除去<code>grep</code>，<code>xargs kill –9</code>中的<code>xargs</code>命令是用来把前面命令的输出结果<code>pid</code>作为<code>kill –9</code>命令的参数，并执行该命令。<code>kill –9</code>会强行杀掉指定进程。<br><code>kill</code>完可以检查下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps -ef | grep skynet</span><br></pre></td></tr></table></figure>\n<h2 id=\"在linux下对比文件\"><a href=\"#在linux下对比文件\" class=\"headerlink\" title=\"在linux下对比文件\"></a>在linux下对比文件</h2><p><code>diff</code>是用来比较两个文本文件的差异的工具程序。是代码版本管理的基石之一。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> diff &lt;变动前的文件&gt; &lt;变动后的文件&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用split来分割大文件\"><a href=\"#使用split来分割大文件\" class=\"headerlink\" title=\"使用split来分割大文件\"></a>使用split来分割大文件</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">split  -b  20m  gkdb.db   gkdb_pack_</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>split</code>是命今<br><code>-B  20M</code>是指将每个分卷文件最大<code>20M</code><br><code>gkdb.db</code>需要分割的文件<br><code>gkdb_pack_</code>是指分割后的文件开头， 分割后后的文件名一般为<code>gkdb_pack_aa、gkdb_pack_ab、gkdb_pack_ac</code>依次类推</p>\n</blockquote>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/2\">Sin prisas ¡pero sin pausas!</a></p>\n","tags":["linux"]},{"title":"linux下的一些网络调试命令","url":"/post/750cd44d.html","content":"<p>这里记录一下，linux下的一些网络调试命令。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"测试到达目的主机的网络是否连接-但ping无法检查系统端口是否开放\"><a href=\"#测试到达目的主机的网络是否连接-但ping无法检查系统端口是否开放\" class=\"headerlink\" title=\"测试到达目的主机的网络是否连接,但ping无法检查系统端口是否开放\"></a>测试到达目的主机的网络是否连接,但ping无法检查系统端口是否开放</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping www.google.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"检查某个端口是否开放\"><a href=\"#检查某个端口是否开放\" class=\"headerlink\" title=\"检查某个端口是否开放\"></a>检查某个端口是否开放</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">telnet ip_addr:port</span><br></pre></td></tr></table></figure>\n<h2 id=\"检测发出数据包的主机到目标主机之间所经过的网关数量\"><a href=\"#检测发出数据包的主机到目标主机之间所经过的网关数量\" class=\"headerlink\" title=\"检测发出数据包的主机到目标主机之间所经过的网关数量\"></a>检测发出数据包的主机到目标主机之间所经过的网关数量</h2><p><code>traceroute</code>的原理是试图以最小的TTL发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关<code>ICMP</code>的应答。<br>程序利用增加存活时间<code>（TTL）</code>值来实现其功能。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并传送一个<code>ICMP TTL</code>数据包给原数据包的发出者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">traceroute www.google.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断连接是否健康\"><a href=\"#判断连接是否健康\" class=\"headerlink\" title=\"判断连接是否健康\"></a>判断连接是否健康</h2><h3 id=\"查看服务器端口有没有客户端来连接\"><a href=\"#查看服务器端口有没有客户端来连接\" class=\"headerlink\" title=\"查看服务器端口有没有客户端来连接\"></a>查看服务器端口有没有客户端来连接</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -anp | grep xxxx</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看到进程id之后，使用netstat命令查看其占用的端口\"><a href=\"#查看到进程id之后，使用netstat命令查看其占用的端口\" class=\"headerlink\" title=\"查看到进程id之后，使用netstat命令查看其占用的端口\"></a>查看到进程<code>id</code>之后，使用<code>netstat</code>命令查看其占用的端口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -nap | grep pid</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看tcp连接数及状态\"><a href=\"#查看tcp连接数及状态\" class=\"headerlink\" title=\"查看tcp连接数及状态\"></a>查看tcp连接数及状态</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LAST_ACK 5  </span><br><span class=\"line\">SYN_RECV 30  </span><br><span class=\"line\">ESTABLISHED 15  </span><br><span class=\"line\">FIN_WAIT1 51  </span><br><span class=\"line\">FIN_WAIT2 5  </span><br><span class=\"line\">TIME_WAIT 10  </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>状态：描述<br>CLOSED：无连接是活动的或正在进行<br>LISTEN：服务器在等待进入呼叫<br>SYN_RECV：一个连接请求已经到达，等待确认<br>SYN_SENT：应用已经开始，打开一个连接<br>ESTABLISHED：正常数据传输状态<br>FIN_WAIT1：应用说它已经完成<br>FIN_WAIT2：另一边已同意释放<br>ITMED_WAIT：等待所有分组死掉<br>CLOSING：两边同时尝试关闭<br>TIME_WAIT表示处理完毕，等待超时结束的请求数。<br>LAST_ACK：等待所有分组死掉</p>\n</blockquote>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/50\">No dejes camino viejo por sendero nuevo.</a></p>\n","tags":["linux"]},{"title":"linux信号","url":"/post/1f8fc9f6.html","content":"<p>在计算机科学中，信号是<code>Unix</code>、类<code>Unix</code>以及其他<code>POSIX</code>兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ctrl+c</span><br></pre></td></tr></table></figure>\n<h2 id=\"信号本质\"><a href=\"#信号本质\" class=\"headerlink\" title=\"信号本质\"></a>信号本质</h2><p>软中断信号（<code>signal</code>，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用<code>kill</code>发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。和单片机上编写的中断相似。</p>\n<h2 id=\"信号的种类\"><a href=\"#信号的种类\" class=\"headerlink\" title=\"信号的种类\"></a>信号的种类</h2><p>可以从两个不同的分类角度对信号进行分类：<br>可靠性方面：</p>\n<blockquote>\n<p>可靠信号<br>不可靠信号<br>与时间的关系上：<br>实时信号<br>非实时信号</p>\n</blockquote>\n<h2 id=\"信号处理流程\"><a href=\"#信号处理流程\" class=\"headerlink\" title=\"信号处理流程\"></a>信号处理流程</h2><p>对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个阶段：</p>\n<blockquote>\n<p>1.信号诞生<br>2.信号在进程中注册<br>3.信号的执行和注销</p>\n</blockquote>\n<h2 id=\"信号的发送\"><a href=\"#信号的发送\" class=\"headerlink\" title=\"信号的发送\"></a>信号的发送</h2><p>发送信号的主要函数有：<code>kill()</code>、<code>raise()</code>、 <code>sigqueue()</code>、<code>alarm()</code>、<code>setitimer()</code>以及<code>abort()</code>。</p>\n<h2 id=\"内核如何将一个信号通知到进程\"><a href=\"#内核如何将一个信号通知到进程\" class=\"headerlink\" title=\"内核如何将一个信号通知到进程\"></a>内核如何将一个信号通知到进程</h2><p>内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。<br>进程检查信号的时机是：进程即将从内核态返回用户态时。其实就是从异常或中断恢复发生时处理，这里我们可以把中断理解为：</p>\n<blockquote>\n<p>1）中断<br>2）<code>system call</code>两个时机<br>这两个时机都会有从内核态-&gt;用户态切换的过程。</p>\n</blockquote>\n<p>如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则唤醒。进程有一个链表的数据结果，维护一个未决信号的链表。信号在进程中注册，其实就是把该信号加入到这个未决信号链表当中。<br>可靠信号不管链表中是否已经有这个信号了，还是会加进去。不可靠信号，如果链表中已经有这个信号了，就会忽略。</p>\n<p>执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。<br>被屏蔽的信号，取消屏蔽后还会被检查。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/23\">El amor todo lo puede.</a></p>\n","tags":["linux kernel"]},{"title":"linux调试core，解决段错误","url":"/post/4b89e68.html","content":"<p>了解core文件，对查找程序崩溃有十分重要的意义。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"core文件在什么位置创建？\"><a href=\"#core文件在什么位置创建？\" class=\"headerlink\" title=\"core文件在什么位置创建？\"></a>core文件在什么位置创建？</h2><p>在进程当前工作目录的下创建。通常与程序在相同的路径下。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。有好多程序崩溃了，我们却找不到core文件放在什么位置。和chdir函数就有关系。当然程序崩溃了不一定都产生core文件。</p>\n<h2 id=\"什么时候不产生core文件？\"><a href=\"#什么时候不产生core文件？\" class=\"headerlink\" title=\"什么时候不产生core文件？\"></a>什么时候不产生core文件？</h2><p>在下列条件下不产生core文件：<br>( a )进程是设置-用户-ID，而且当前用户并非程序文件的所有者；<br>( b )进程是设置-组-ID，而且当前用户并非该程序文件的组所有者；<br>( c )用户没有写当前工作目录的许可权；<br>( d )文件太大。core文件的许可权(假定该文件在此之前并不存在)通常是用户读/写，组读和其他读。</p>\n<h2 id=\"如何产生core文件？\"><a href=\"#如何产生core文件？\" class=\"headerlink\" title=\"如何产生core文件？\"></a>如何产生core文件？</h2><p>系统中默认的是禁止产生core文件的<br>ulimit用于shell启动进程所占用的资源.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ulimit -c    0 </span><br></pre></td></tr></table></figure>\n<p>允许产生core文件，并且限制大小为1000 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ulimit -c 1000 </span><br></pre></td></tr></table></figure>\n<p>不限制大小</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ulimit -c unlimited</span><br></pre></td></tr></table></figure>\n<p>这时，再执行程序。当程序段错误时，就会产生core。如果还是无法产生core文件，注意看一下，程序是否有当前目录权限。</p>\n<h2 id=\"利用gdb定位到出错的具体位置\"><a href=\"#利用gdb定位到出错的具体位置\" class=\"headerlink\" title=\"利用gdb定位到出错的具体位置\"></a>利用gdb定位到出错的具体位置</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# gdb ./xxx core</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/114\">La lengua no tiene hueso, pero corta lo más grueso. </a></p>\n","tags":["gdb"]},{"title":"lua Table","url":"/post/6349ecd2.html","content":"<p><code>table</code>实现了关联数组，即可以同时用数字和字符串索引的数组。<br><code>table</code>是一种强大的语言构造。因为<code>table</code>的泛型特点，简化了使用<code>lua</code>编写程序所用的数据结构和算法。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"哈希与数组\"><a href=\"#哈希与数组\" class=\"headerlink\" title=\"哈希与数组\"></a>哈希与数组</h2><p>直到<code>Lua 4.0</code>为止，<code>table</code>都是作为纯哈希表实现的，所有的键值对都是显式存储的。在<code>Lua 5.0</code>版本引入了<code>table</code>的混合表示：每个<code>table</code>包含了一个哈希部分和一个数组部分，两个部分都可以是空的。<code>Lua</code>检测一个<code>table</code>是不是作为一个数组来使用，并自动将数字索引的值移动到数组部分，而非原本的存储在哈希部分。这种分裂只在底层实现层次进行；访问<code>table</code>域是透明的，即使是对虚拟机来说。<code>table</code>会自动根据内容使用两个部分。<br>这个混合机制有两个优点。第一，访问整型<code>key</code>的操作会变得更快了，因为不再需要哈希。第二，更重要的是，数组部分只占原来哈希部分的一半大小，因为哈希部分需要同时存储<code>key</code>和<code>value</code>，而数组部分的<code>key</code>已经隐含在下标了。结果是，如果一个<code>table</code>是作为数组使用的，它的表现就像数组一样，只要它的整型<code>key</code>是密集分布的。而且，哈希部分没有内存或者时间的代价，因为作为数组使用时，哈希部分不存在。反过来说，如果<code>table</code>是作为记录使用而非数组，那么数组部分就是空的。这些节省下来的内存是重要的。</p>\n<h2 id=\"Lua核心突出角色\"><a href=\"#Lua核心突出角色\" class=\"headerlink\" title=\"Lua核心突出角色\"></a>Lua核心突出角色</h2><p>从<code>Lua 4.0</code>开始，全局变量就存储在普通的<code>Lua table</code>里，称为全局<code>table</code>。<code>Lua 5.0</code>用元表和元方法取代了<code>tag</code>和<code>tag</code>方法（<code>Lua 3.0</code>引入的）。元表是普通的<code>Lua table</code>，元方法是作为元表的域存储的。<code>Lua 5.0</code>也引入了环境<code>table</code>，可以附加到<code>Lua</code>函数上；它们就是<code>Lua</code>函数索引的全局环境。<code>Lua 5.1</code>将环境变量<code>table</code>扩展到<code>C</code>函数、<code>userdata</code>和协程，取代了全局的环境变量。这些改动简化了<code>Lua</code>的实现、<code>Lua</code>和<code>C</code>程序员所用的<code>API</code>，因为全局变量和元方法可以在<code>Lua</code>里操控，不再需要特殊函数了。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>先看看表的数据类型定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Table</span> &#123;</span></span><br><span class=\"line\">  CommonHeader;</span><br><span class=\"line\">  lu_byte flags; <span class=\"comment\">//这是一个byte类型的数据，用于表示这个表中提供了哪些元方法。最开始这个flags是空的，也就是0，当查找一次之后，如果该表中存在某个元方法，那么将该元方法对应的flag bit置为1，这样下一次查找时只需要比较这个bit就行了。每个元方法对应的bit定义在ltm. h文件中。</span></span><br><span class=\"line\">  lu_byte lsizenode;  <span class=\"comment\">//该表中以2为底的散列表大小的对数值。同时由此可知，散列表部分的大小一定是2的幕，即如果散列桶数组要扩展的话，也是以每次在原大小基础上乘以2的形式扩展。</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Table</span> *<span class=\"title\">metatable</span>;</span><span class=\"comment\">//存放该表的元表</span></span><br><span class=\"line\">  TValue *<span class=\"built_in\">array</span>;  <span class=\"comment\">//指向数组部分的指针</span></span><br><span class=\"line\">  Node *node;  <span class=\"comment\">//指向该表的散列桶数组起始位置的指针 </span></span><br><span class=\"line\">  Node *lastfree;  <span class=\"comment\">//指向该表散列桶数组的最后位置的指针</span></span><br><span class=\"line\">  GCObject *gclist; <span class=\"comment\">//GC相关的链表</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sizearray;  <span class=\"comment\">//数组部分的大小</span></span><br><span class=\"line\">&#125; Table;</span><br></pre></td></tr></table></figure>\n<p>从<code>Node</code>类型来看，它包含两个成员，一个是<code>key</code>，另一个是<code>value（TValue）</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TKey</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    TValuefields;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">next</span>;</span>  <span class=\"comment\">/* for chaining */</span></span><br><span class=\"line\">  &#125; nk;</span><br><span class=\"line\">  TValue tvk;</span><br><span class=\"line\">&#125; TKey;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TValuefields\tValue value; int tt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">  GCObject *gc;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *p;</span><br><span class=\"line\">  lua_Number n;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; Value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">  TValue i_val;</span><br><span class=\"line\">  TKey i_key;</span><br><span class=\"line\">&#125; Node;</span><br></pre></td></tr></table></figure>\n<h2 id=\"表查找\"><a href=\"#表查找\" class=\"headerlink\" title=\"表查找\"></a>表查找</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> TValue *<span class=\"title\">luaH_getnum</span> <span class=\"params\">(Table *t, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cast(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, key<span class=\"number\">-1</span>) &lt; cast(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, t-&gt;sizearray))<span class=\"comment\">//如果输入的Key是一个正整数，并且它的位大于0并且少等于或等于数组的大小，尝试在数组部分查找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;t-&gt;<span class=\"built_in\">array</span>[key<span class=\"number\">-1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//如果不是，尝试在散列表部分查找，计算出该`Key`的散列值，根据此散列值访问`Node`数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该`Key`为止。</span></span><br><span class=\"line\">    lua_Number nk = cast_num(key);</span><br><span class=\"line\">    Node *n = hashnum(t, nk);</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  <span class=\"comment\">/* check whether `key&#x27; is somewhere in the chain */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ttisnumber(gkey(n)) &amp;&amp; luai_numeq(nvalue(gkey(n)), nk))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gval(n);  <span class=\"comment\">/* that&#x27;s it */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> n = gnext(n);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> luaO_nilobject;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，即使是一个正整数的<code>key</code>，其存储部分也不见得会一定落在数组部分，这完全取决于它的大小是再落在了当前数组可容纳的空间范围内（OP_NEWTABLE中GETARG_B）。也解释了<code>ipairs</code>遍历断裂的问题。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> t = &#123;&#125;</span><br><span class=\"line\">t[<span class=\"number\">1</span>] = <span class=\"number\">0</span> <span class=\"comment\">-- 1作为数组部分存储下来</span></span><br><span class=\"line\">t[<span class=\"number\">100</span>] = <span class=\"number\">0</span> <span class=\"comment\">--100存储到散列表部分中</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"新增元素\"><a href=\"#新增元素\" class=\"headerlink\" title=\"新增元素\"></a>新增元素</h2><p>当找不到对应的<code>key</code>时，最终都会调用内部的<code>newkey</code>函数分配一个新的<code>key</code>来返回。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TValue *<span class=\"title\">newkey</span> <span class=\"params\">(lua_State *L, Table *t, <span class=\"keyword\">const</span> TValue *key)</span> </span>&#123;</span><br><span class=\"line\">  Node *mp = mainposition(t, key);<span class=\"comment\">//根据key来查找其所在散列桶的mainposition</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!ttisnil(gval(mp)) || mp == dummynode) &#123;<span class=\"comment\">//如果该mainposition上已经有其他数据了，需要重新分配空间给这个新的key，然后将这个新的Node串联到对应的散列桶上</span></span><br><span class=\"line\">    Node *othern;</span><br><span class=\"line\">    Node *n = getfreepos(t);  <span class=\"comment\">/* get a free place */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"literal\">NULL</span>) &#123;  <span class=\"comment\">/* cannot find a free place? */</span></span><br><span class=\"line\">      rehash(L, t, key);  <span class=\"comment\">/* grow table */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> luaH_set(L, t, key);  <span class=\"comment\">/* re-insert key into grown table */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lua_assert(n != dummynode);</span><br><span class=\"line\">    othern = mainposition(t, key2tval(mp));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (othern != mp) &#123;  <span class=\"comment\">/* is colliding node out of its main position? */</span></span><br><span class=\"line\">      <span class=\"comment\">/* yes; move colliding node into free position */</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (gnext(othern) != mp) othern = gnext(othern);  <span class=\"comment\">/* find previous */</span></span><br><span class=\"line\">      gnext(othern) = n;  <span class=\"comment\">/* redo the chain with `n&#x27; in place of `mp&#x27; */</span></span><br><span class=\"line\">      *n = *mp;  <span class=\"comment\">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class=\"line\">      gnext(mp) = <span class=\"literal\">NULL</span>;  <span class=\"comment\">/* now `mp&#x27; is free */</span></span><br><span class=\"line\">      setnilvalue(gval(mp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* colliding node is in its own main position */</span></span><br><span class=\"line\">      <span class=\"comment\">/* new node will go into free position */</span></span><br><span class=\"line\">      gnext(n) = gnext(mp);  <span class=\"comment\">/* chain new position */</span></span><br><span class=\"line\">      gnext(mp) = n;</span><br><span class=\"line\">      mp = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  gkey(mp)-&gt;value = key-&gt;value; gkey(mp)-&gt;tt = key-&gt;tt;<span class=\"comment\">//如果该Node的值为nil，那么直接将key赋值并且返回Node的TValue指针就可以了</span></span><br><span class=\"line\">  luaC_barriert(L, t, key);</span><br><span class=\"line\">  lua_assert(ttisnil(gval(mp)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gval(mp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>散列表部分的数据组织是，首先计算数据的<code>key</code>所在的桶数组位置，这个位置称为<code>mainposition</code>。相同<code>mainposition</code>的数据以链表形式组织。<br>整个过程都是在散列桶部分进行的，理由是即使<code>key</code>是一个数字，也已经在调用<code>newkey</code>函数之前进行了查找，结果却没有找到，所以这个<code>key</code>都会进入散列桶部分来查找。</p>\n<h3 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h3><p>以上操作涉及重新对表空间进行分配的情况。入口函数是<code>rehash</code>，顾名思义，这个函数的作用就是为了做重新散列操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span> <span class=\"params\">(lua_State *L, Table *t, <span class=\"keyword\">const</span> TValue *ek)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nasize, na;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nums[MAXBITS+<span class=\"number\">1</span>];  <span class=\"comment\">//分配一个位图nums，将其中的所有位置0。这个位图的意义在于：nums数组中第 i个元素存放的是key在2(i-l）和i之间的元素数量。</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> totaluse;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;=MAXBITS; i++) nums[i] = <span class=\"number\">0</span>;  </span><br><span class=\"line\">  nasize = numusearray(t, nums);  <span class=\"comment\">//遍历Lua表中的数组部分，计算其中的元素数量，更新对应的nums数组中的元素数量</span></span><br><span class=\"line\">  totaluse = nasize;  <span class=\"comment\">/* all those keys are integer keys */</span></span><br><span class=\"line\">  totaluse += numusehash(t, nums, &amp;nasize);  <span class=\"comment\">//遍历lua表中的散列桶部分，因为其中也可能存放了正整数，需要根据这里的正整数数量更新对应的nums数组元素数量</span></span><br><span class=\"line\">  <span class=\"comment\">/* count extra key */</span></span><br><span class=\"line\">  nasize += countint(ek, nums);</span><br><span class=\"line\">  totaluse++;</span><br><span class=\"line\">  <span class=\"comment\">/* compute new size for array part */</span></span><br><span class=\"line\">  na = computesizes(nums, &amp;nasize);<span class=\"comment\">//此时nums数组已经有了当前这个Table中所有正整数的分配统计，逐个遍历nums数组，获得其范围区间内所包含的整数数量大于50%的最大索引，作为重新散列之后的数组大小，超过这个范围的正整数，就分配到散列桶部分了</span></span><br><span class=\"line\">  <span class=\"comment\">/* resize the table to new computed sizes */</span></span><br><span class=\"line\">  resize(L, t, nasize, totaluse - na);<span class=\"comment\">//根据上面计算得到的调整后的数组和散列桶大小调整表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在重新散列的过程中，除了增大Lua表的大小以容纳新的数据之外，还希望能借此机会对原有的数组和散列桶部分进行调整，让两部分都尽可能发挥其存储的最高容纳效率。那么，这里的标准是什么呢？希望在调整过后，数组在每一个2次方位置容纳的元素数量都超过该范围的50%。 能达到这个目标的话，就认为这个数组范围发挥了最大的效率。</p>\n<p>当数字键值的统计跑完之后，得到了这个数组每个元素的数据，也就是得到了落在每个范围内的数据数量。接着会计算怎样才能最大限度地使用这部分空间 。这个算法由函数<code>computesizes</code>实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">computesizes</span> <span class=\"params\">(<span class=\"keyword\">int</span> nums[], <span class=\"keyword\">int</span> *narray)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> twotoi;  <span class=\"comment\">/* 2^i */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;  <span class=\"comment\">/* number of elements smaller than 2^i */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> na = <span class=\"number\">0</span>;  <span class=\"comment\">/* number of elements to go to array part */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;  <span class=\"comment\">/* optimal size for array part */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, twotoi = <span class=\"number\">1</span>; twotoi/<span class=\"number\">2</span> &lt; *narray; i++, twotoi *= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      a += nums[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a &gt; twotoi/<span class=\"number\">2</span>) &#123;  <span class=\"comment\">/* more than half elements present? */</span></span><br><span class=\"line\">        n = twotoi;  <span class=\"comment\">/* optimal size (till now) */</span></span><br><span class=\"line\">        na = a;  <span class=\"comment\">/* all elements smaller than n will go to array part */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == *narray) <span class=\"keyword\">break</span>;  <span class=\"comment\">/* all elements already counted */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  *narray = n;</span><br><span class=\"line\">  lua_assert(*narray/<span class=\"number\">2</span> &lt;= na &amp;&amp; na &lt;= *narray);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> na;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>在一般算法库的设计中，针对容器类的迭代，会提供一个迭代器的数据，这个数据主要用于维护当前迭代到容器的哪部分数据了，下次再根据这个位置查找下一部分数据。表迭代不是这样设计的，很大的原因是为了兼容数组部分和散列桶部分的访问 。 迭代操作传入的不是一个迭代器，而是<code>key</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaH_next</span> <span class=\"params\">(lua_State *L, Table *t, StkId key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = findindex(L, t, key);  <span class=\"comment\">/* find original element */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i++; i &lt; t-&gt;sizearray; i++) &#123;  <span class=\"comment\">/* try first array part */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ttisnil(&amp;t-&gt;<span class=\"built_in\">array</span>[i])) &#123;  <span class=\"comment\">/* a non-nil value? */</span></span><br><span class=\"line\">      setnvalue(key, cast_num(i+<span class=\"number\">1</span>));</span><br><span class=\"line\">      setobj2s(L, key+<span class=\"number\">1</span>, &amp;t-&gt;<span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i -= t-&gt;sizearray; i &lt; sizenode(t); i++) &#123;  <span class=\"comment\">/* then hash part */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ttisnil(gval(gnode(t, i)))) &#123;  <span class=\"comment\">/* a non-nil value? */</span></span><br><span class=\"line\">      setobj2s(L, key, key2tval(gnode(t, i)));</span><br><span class=\"line\">      setobj2s(L, key+<span class=\"number\">1</span>, gval(gnode(t, i)));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">/* no more elements */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是在数组部分还是散列桶部分查找数据，查找成功都会返回该<code>key</code>的下一个数据。<br>这个函数一开始就进入<code>findindex</code>中进行查询，并区分数组和散列桶部分。<code>findindex</code>函数的返回结果是一个整数索引，如果这个索引在表的<code>sizearray</code>之内，则说明落入到数组部分，否则就落入到散列桶部分。在<code>luaH_next</code>函数中使用这个返回值时，看起来是两个循环，实际上已经根据这个值的范围进行了区分，不会同一个<code>key</code>走入两个循环中。而在返回散列桶部分时，这个索引值为”sizearray＋对应散列桶索引的值”。</p>\n<h2 id=\"取长度操作\"><a href=\"#取长度操作\" class=\"headerlink\" title=\"取长度操作\"></a>取长度操作</h2><p>在<code>Lua</code>中，可以使用<code>#</code>符号对表进行取长度操作。对<code>Lua</code>中的表进行取长度操作时，如果没有提供该表的元方法<code>_len</code>，那么该操作只针对该表的序列<code>（ sequence ）</code>部分进行。 “序列”指的是表的一个子集<code>&#123;1 ... n&#125;</code>，其中<code>n</code>是一个正整数，并且里面每个键对应的数据都不为<code>nil</code>。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaH_getn</span> <span class=\"params\">(Table *t)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> j = t-&gt;sizearray;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; ttisnil(&amp;t-&gt;<span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* there is a boundary in the array part: (binary) search for it */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j - i &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> m = (i+j)/<span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ttisnil(&amp;t-&gt;<span class=\"built_in\">array</span>[m - <span class=\"number\">1</span>])) j = m;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> i = m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* else must find a boundary in hash part */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t-&gt;node == dummynode)  <span class=\"comment\">/* hash part is empty? */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j;  <span class=\"comment\">/* that is easy... */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> unbound_search(t, j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果表中混合了这两种风格的数据，那么优先取数组部分的长度。如果表存在数组部分，在数组部分二分查找返回位置。如果前面的数组部分查不到满足条件的数据，进入散列表部分查找。<br>所以，尽量不要将一个表混用数组和散列桶部分，即一个表最好只存放一类数据。<code>Lua</code>的实现上确实提供了两者统一表示的遍历，但是这不意味着使用者就应该混用这两种方式。</p>\n<h2 id=\"从lua-5-1-1中分离出来的table实现代码\"><a href=\"#从lua-5-1-1中分离出来的table实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的table实现代码\"></a>从lua-5.1.1中分离出来的table实现代码</h2><p><a href=\"https://gist.github.com/losophy/fe348e052e92695ea83df77f9aa0a185\">ltable</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《Lua设计与实现》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/110\">Un hermano puede no ser un amigo, pero un amigo será siempre un hermano.</a></p>\n","tags":["lua"]},{"title":"lua gc","url":"/post/ba161a39.html","content":"<p>对于内存的管理，是程序在应用的时候的必需知识点。而<code>lua</code>的垃圾回收机制十分优秀，值得一读。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"GC算法\"><a href=\"#GC算法\" class=\"headerlink\" title=\"GC算法\"></a>GC算法</h2><p>大体原理是遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，可以删除 。</p>\n<div class=\"note info\"><p>这里的关键在于，如何找出没有“引用”的对象。</p></div>\n\n<h3 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h3><p>使用引用计数的<code>GC</code>算法，会在一个对象被引用的情况下将该对象的引用计数加一 ，反之减一。 如果引用计数为0 ，那么就是没有引用的对象。 引用计数算法的优点是不需要扫描每个对象，对象本身的引用计数只需要减到0，就会被回收。 缺点是会有循环引用问题。</p>\n<div class=\"note info\"><p>循环引用，比如说A和B两个对象，相互引用了对方作为自己的成员变量。只有当自己销毁的时候才能将成员变量的引用计数-1。但是因为A对象的销毁又依赖于B对象，B对象销毁又依赖于A对象。这样就造成了循环引用的问题。</p></div>\n\n<h3 id=\"标记清除算法（-Mark-and-Sweep-）\"><a href=\"#标记清除算法（-Mark-and-Sweep-）\" class=\"headerlink\" title=\"标记清除算法（ Mark and Sweep ）\"></a>标记清除算法（ Mark and Sweep ）</h3><p>它的原理是每一次做<code>GC</code>的时候，首先扫描并且标记系统中的所有对象，被扫描并且标记到的对象认为是可达的<code>（ reachable ）</code>，这些对象不会被回收；反之，没有被标记的对象认为是可以回收的。 <code>Lua</code>采用的就是这种算法 。</p>\n<h2 id=\"双色标记清除算法\"><a href=\"#双色标记清除算法\" class=\"headerlink\" title=\"双色标记清除算法\"></a>双色标记清除算法</h2><p>早期的<code>Lua 5.0</code>使用的是双色标记清除算法，该算法的原理是 ：系统中的每个对象非黑即白，也就是要么被引用，要么没有被引用。<br>具体操作是这样的：</p>\n<ul>\n<li>新分配的对象是白色的</li>\n<li>标记阶段将所有可到达的对象变黑</li>\n<li>扫描阶段将释放所有白色（无法到达）的对象，并将所有黑色（幸存的）对象的颜色变回白色，等待下一轮的<code>GC</code>检查</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/112426112-4cd8d900-8d72-11eb-91d9-6b23756e362f.JPG\" alt=\"捕获\"><br>这个算法的缺陷在于，每个对象的状态是“二元”的，每个对象只可能有一种状态，不能有其他中间状态，这就要求这个算法每次做<code>GC</code>操作时不可被打断地一次性扫描并清除完所有对象。<br>如果在遍历对象链表时标记每个对象颜色的过程中被打断，此时新增了一个对象，那么应该将这个对象标记为白色还是黑色？如果标记为白色，假如<code>GC</code>已经到了回收阶段，那么这个对象就会在没有遍历其关联对象的情况下被回收；如果标记为黑色，假如<code>GC</code>已经到了回收阶段，那么这个对象在本轮<code>GC</code>中并没有被扫描过就认为是不必回收的 。 可以看到，在双色标记清除算法中，标记阶段和回收阶段必须合在一起完成。不能被打断，也就意味着每次<code>GC</code>操作的代价极大。在<code>GC</code>过程中，程序必须暂停下来，不能进行其他操作。</p>\n<h2 id=\"三色增量标记清除算法\"><a href=\"#三色增量标记清除算法\" class=\"headerlink\" title=\"三色增量标记清除算法\"></a>三色增量标记清除算法</h2><p>从<code>Lua 5.1</code>开始，采用了在该算法的基础上改进的三色增量标记清除算法。与前面的算法相比，这个算法中每个对象的颜色多了一种（实际上，在<code>Lua</code>中是4种，后面再展开讨论）。 这样的好处在于：它不必再要求<code>GC</code>一次性扫描完所有的对象，这个GC过程可以是增量的，可以被中断再恢复并继续进行的 。<br>3种颜色的分类如下：</p>\n<ul>\n<li>白色： 当前对象为待访问状态，表示对象还没有被<code>GC</code>标记过，这也是任何一个对象创建后的初始状态。 换言之，如果一个对象在结束<code>GC</code>扫描过程后仍然是白色，则说明该对象没有被系统中的任何一个对象所引用，可以回收其空间了 </li>\n<li>灰色： 当前对象为待扫描状态，表示对象已经被<code>GC</code>访问过，但是该对象引用的其他对象还没有被访问到 </li>\n<li>黑色： 当前对象为己扫描状态，表示对象已经被<code>GC</code>访问过，并且该对象引用的其他对象也被访问过了 </li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/112426834-9544c680-8d73-11eb-97eb-ca4ada95361d.JPG\" alt=\"捕获\"><br>具体操作是这样的：</p>\n<ul>\n<li>每个新创建的对象颜色为白色</li>\n<li>初始化阶段，遍历<code>gc root</code>链表，把有引用的对象节点从白色置为灰色，并且放入到灰色节点链表中</li>\n<li>标记阶段，当灰色链表中还有未扫描的元素（灰色链表非空），从中取出一个对象节点并将其标记为黑色，遍历这个对象关联的其他所有对象．如果是白色，标记为灰色，加入灰色链表中</li>\n<li>回收阶段，遍历所有对象，如果为白色，这些对象都是没有被引用的对象，逐个回收。否则，重新加入对象链求中等待下一轮的 <code>GC</code>检查（黑色变白色，等待下次检查）。</li>\n</ul>\n<p>可以看到，引入了灰色节点的概念后，算法不再要求一次性完整执行完毕，而是可以把已经扫描但是其引用的对象还未被扫描的对象置为灰色。 在标记阶段中，只要灰色节点集合中还有元素在，那么这个标记过程就会继续下去，即使中间被打断转而执行其他操作了，也没有关系 。</p>\n<p>然而即使是这样，却仍然有另一个没有解决的问题。 从上面的算法可以看出，没有被引用的对象的颜色在扫描过程中始终保持不变，为白色 。 那么，假如一个对象在<code>GC</code>过程的标记阶段之后创建，根据前面对颜色的描述，它应该是白色的，这样在紧跟着的回收阶段，这个对象就会在没有被扫描标记的情况下被认为是没有被引用的对象而删除 。</p>\n<p>因此， <code>Lua</code>的<code>GC</code>算法除了前面的三色概念之外，又细分出来一个“双白色”的概念 。 简单地说， <code>Lua</code>中的白色分为“当前白色”和“非当前白色”。 这两种白色的状态交替使用，第<code>N</code>次<code>GC</code>使用的是第一种白色，那么下一次就是另外一种，以此类推。</p>\n<p>代码在回收时会做判断，如果某个对象的白色不是此次<code>GC</code>使用的白色状态，那么将不会认为是没有被引用的对象而回收，这样的白色对象将留在下一次<code>GC</code>中进行扫描，因为在下一次<code>GC</code>中上一次幸免的白色将成为这次的回收颜色。</p>\n<h2 id=\"GC的全流程\"><a href=\"#GC的全流程\" class=\"headerlink\" title=\"GC的全流程\"></a>GC的全流程</h2><p><code>Lua</code>内部用一个宏表示哪些数据类型需要进行<code>GC</code> ( <code>Garbage Collection</code>，垃圾回收）操作 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> iscollectable(o) (ttype(o) &gt;= LUA_TSTRING)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到， <code>LUA_TSTRING</code>（包括<code>LUA_TSTRING</code>）之后的数据类型都需要进行<code>GC</code>操作 。</p>\n<p>需要进行<code>GC</code>操作的数据类型都会有一个<code>CommonHeader</code>宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked <span class=\"comment\">//next：GCObject链表指针，这个指针将所有GC对象都链接在一起形成链表，tt：表示数据的类型，即[lua数据类型](https://github.com/losophy/losophy.github.io/issues/109)的宏，marked : 标记字段，用于存储前面提到的几种颜色</span></span></span><br></pre></td></tr></table></figure>\n<p><code>marked</code>具体值定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WHITE0BIT\t0 <span class=\"comment\">//0型白色</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WHITE1BIT\t1   <span class=\"comment\">//l型白色</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BLACKBIT\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FINALIZEDBIT\t3  <span class=\"comment\">//FINALIZEDBIT用于标记没有被引用需要回收的 udata 。 udata 的处理与其他数据类型不同，由于它是用户传入的数据，它的回收可能会调用用户注册的GC函数，所以统一来处理。</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KEYWEAKBIT\t3  <span class=\"comment\">//用于标记弱表中的键的weak属性</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> VALUEWEAKBIT\t4 <span class=\"comment\">//T用于标记弱表中的值的weak属性</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FIXEDBIT\t5  <span class=\"comment\">//用于表示该对象不可回收，仅用于lua_State对象自身的标记</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SFIXEDBIT\t6 <span class=\"comment\">//用于表示该对象不可回收，标记了一系列Lua语法中的关键字对应的字符串为不可回收字符串，具体可以看看luaXinit函数的实现</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WHITEBITS\tbit2mask(WHITE0BIT, WHITE1BIT)</span></span><br></pre></td></tr></table></figure>\n<p>这里<code>WHITE0BIT</code>和<code>WHITE1BIT</code>就是前面提到的两种白色状态，称为0型白色和l型白色。 当前的白色见<code>lobal_State</code>中的 <code>currentwhite</code>，而<code>otherwhite</code>宏用于表示非当前GC将要回收的白色类型 。 切换白色，需要使用<code>changewhite</code>宏 ； 要得到当前的白色状态，则使用<code>luaC_white</code>宏 。</p>\n<p>在保存全局状态的<code>global_State</code>结构体中，有以下几个与<code>GC</code>相关的数据成员：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_State</span> &#123;</span></span><br><span class=\"line\">  lu_byte currentwhite;<span class=\"comment\">//存放当前GC的白色</span></span><br><span class=\"line\">  lu_byte gcstate;  <span class=\"comment\">//存放GC状态，分别有以下几种 ： GCS pause （暂停阶段） 、 GCSpropagate（传播阶段，用于遍历灰色节点检查对象的引用情况）、 GCSsweepstring （字符串回收阶段） , GCSsweep （回收阶段，用于对除了字符串之外的所有其他数据类型进行回收）和GCSfinalize （终止阶段） 。</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sweepstrgc;  <span class=\"comment\">//字符串回收阶段，每次针对字符串散列桶的一组字符串进行回收，这个值用于记录对应的散列桶索引 。</span></span><br><span class=\"line\">  GCObject *rootgc;  <span class=\"comment\">//存放待GC对象的链表，所有对象创建之后都会放入该链表中</span></span><br><span class=\"line\">  GCObject **sweepgc; <span class=\"comment\">//待处理的回收数据都存放在rootgc链表中，由于回收阶段不是一次性全部回收这个链表的所有数据，所以使用这个变量来保存当前回收的位置，下一次从这个位置开始继续回收操作</span></span><br><span class=\"line\">  GCObject *gray;  <span class=\"comment\">//存放灰色节点的链表</span></span><br><span class=\"line\">  GCObject *grayagain; <span class=\"comment\">//存放需要一次性扫描处理的灰色节点链表，也就是说，这个链表上所有数据的处理需要一步到位，不能被打断</span></span><br><span class=\"line\">  GCObject *weak;  <span class=\"comment\">//存放弱表的链表</span></span><br><span class=\"line\">  GCObject *tmudata;  <span class=\"comment\">//所有带有GC元方法的 udata存放在一个链表中，这个成员指向这千链表的最后一个元素</span></span><br><span class=\"line\">  lu_mem GCthreshold;<span class=\"comment\">//开始进行GC的阔值，当totalbytes大于这个值时开始自动GC</span></span><br><span class=\"line\">  lu_mem totalbytes;  <span class=\"comment\">//当前分配的内存大小</span></span><br><span class=\"line\">  lu_mem estimate; <span class=\"comment\">//一个估计值，用于保存实际在用的内存大小 </span></span><br><span class=\"line\">  lu_mem gcdept;  <span class=\"comment\">//用于在单次GC之前保存待回收的数据大小</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> gcpause;  <span class=\"comment\">//用于控制下一轮GC开始的时机</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> gcstepmul; <span class=\"comment\">//控制GC的回收速度</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; global_State;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新创建对象\"><a href=\"#新创建对象\" class=\"headerlink\" title=\"新创建对象\"></a>新创建对象</h3><p>从前面的分析可以知道，对于每个新创建的对象，最基本的操作就是将对象的颜色设置为白色，意指本次<code>GC</code>还未扫描到的对象，同时将对象挂载到扫描过程会遍历的链表上 。 基本思想就是如此，但是针对不同的数据类型，会有不同的处理。</p>\n<p>一般的数据类型调用的是<code>luaC_link</code>函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_link</span> <span class=\"params\">(lua_State *L, GCObject *o, lu_byte tt)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  o-&gt;gch.next = g-&gt;rootgc;</span><br><span class=\"line\">  g-&gt;rootgc = o;<span class=\"comment\">//将对象挂载到 rootgc链表上</span></span><br><span class=\"line\">  o-&gt;gch.marked = luaC_white(g);<span class=\"comment\">//设置颜色为白色</span></span><br><span class=\"line\">  o-&gt;gch.tt = tt;<span class=\"comment\">//设置数据的类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是<code>UpValue</code>和<code>udata</code>类型的数据的创建过程有些不一样。<br>先来看<code>UpValue</code>，新建一个<code>UpValue</code>类型的数据，调用的是<code>luaC_linkupval</code>函数 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_linkupval</span> <span class=\"params\">(lua_State *L, UpVal *uv)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  GCObject *o = obj2gco(uv);</span><br><span class=\"line\">  o-&gt;gch.next = g-&gt;rootgc;  <span class=\"comment\">/* link upvalue into `rootgc&#x27; list */</span></span><br><span class=\"line\">  g-&gt;rootgc = o;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isgray(o)) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;gcstate == GCSpropagate) &#123;</span><br><span class=\"line\">      gray2black(o);  <span class=\"comment\">/* closed upvalues need barrier */</span></span><br><span class=\"line\">      luaC_barrier(L, uv, uv-&gt;v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* sweep phase: sweep it (turning it into white) */</span></span><br><span class=\"line\">      makewhite(g, o);</span><br><span class=\"line\">      lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的疑问是，前面的数据类型在最开始的时候 ，都是将颜色设置为白色，而针对<code>UpValue</code>,则是根据颜色是不是灰色来做后面的一些操作 。 原因在于， <code>UpValue</code>是针对已有对象的间接引用，所以它的处理在对象颜色是灰色的情况下区分了两种情况 。</p>\n<ul>\n<li>如果当前在扫描阶段，那么将对象从灰色变成黑色 。 需要注意的是，到这一步需要加<code>barrier</code></li>\n<li>如果不是在扫描阶段，都置为白色 。将其回收， 其实这个表达并不完全准确 。 这里置为白色，我的理解和创建其他类型数据的函数<code>luaC_link</code>一样，都是一个创建对象的正常流程</li>\n</ul>\n<p>再来看<code>udata</code>数据的创建：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Udata *<span class=\"title\">luaS_newudata</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">size_t</span> s, Table *e)</span> </span>&#123;</span><br><span class=\"line\">  Udata *u;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s &gt; MAX_SIZET - <span class=\"keyword\">sizeof</span>(Udata))</span><br><span class=\"line\">    luaM_toobig(L);</span><br><span class=\"line\">  u = cast(Udata *, luaM_malloc(L, s + <span class=\"keyword\">sizeof</span>(Udata)));</span><br><span class=\"line\">  u-&gt;uv.marked = luaC_white(G(L));  <span class=\"comment\">/* is not finalized */</span></span><br><span class=\"line\">  u-&gt;uv.tt = LUA_TUSERDATA;</span><br><span class=\"line\">  u-&gt;uv.len = s;</span><br><span class=\"line\">  u-&gt;uv.metatable = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  u-&gt;uv.env = e;</span><br><span class=\"line\">  <span class=\"comment\">/* chain it on udata list (after main thread) */</span></span><br><span class=\"line\">  u-&gt;uv.next = G(L)-&gt;mainthread-&gt;next;<span class=\"comment\">//任何时候创建的 udata ，在GC链表中都会放在mainthread之后 。 除此之外，这类型的数据与其他数据并无差别 。 之所以这么做，是因为udata是用户注册的C数据。 在回收时，我们可能会调用用户注册的函数，此时就需要把这些udata统一放在一个地方来处理，这样做是为了方便编写代码</span></span><br><span class=\"line\">  G(L)-&gt;mainthread-&gt;next = obj2gco(u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>前面提到过，<code>Lua</code>的<code>GC</code>过程是增益的 、 中间可以被打断的，每一次单独进入<code>GC</code>时，都会根据当前<code>GC</code>所处的阶段来进行不同的处理，这个入口函数是<code>singlestep</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (g-&gt;gcstate) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> GCSpause: &#123;</span><br><span class=\"line\">    markroot(L);  <span class=\"comment\">/* start a new collection */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>初始化阶段将从<code>root</code>节点出发，遍历<code>root</code>连表上的所有节点，将它们的颜色从白色变成灰色，加入到<code>gray</code>链表中 。 初始化阶段的入口是<code>markroot</code>函数 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">markroot</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  g-&gt;gray = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  g-&gt;grayagain = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  g-&gt;weak = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  markobject(g, g-&gt;mainthread); <span class=\"comment\">//针对object，标记对象的颜色为灰色，最终调用reallymarkobject函数</span></span><br><span class=\"line\">  <span class=\"comment\">/* make global table be traversed before main stack */</span></span><br><span class=\"line\">  markvalue(g, gt(g-&gt;mainthread)); <span class=\"comment\">//针对TValue，标记对象的颜色为灰色，最终调用reallymarkobject函数</span></span><br><span class=\"line\">  markvalue(g, registry(L));</span><br><span class=\"line\">  markmt(g);</span><br><span class=\"line\">  g-&gt;gcstate = GCSpropagate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看看<code>reallymarkobject</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reallymarkobject</span> <span class=\"params\">(global_State *g, GCObject *o)</span> </span>&#123;</span><br><span class=\"line\">  lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));</span><br><span class=\"line\">  white2gray(o);</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TSTRING: &#123;<span class=\"comment\">// 对于字符串类型的数据，由于这种类型没有引用其他数据，所以略过将其颜色改为灰色的流程，直接将不是黑色的字符串对象回收即可</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TUSERDATA: &#123;<span class=\"comment\">//对于 udata类型的数据，因为这种类型永远也不会引用其他数据，所以这里也是一步到位，直接将其标记为黑色。 另外，对于这种类型，还需要标记对应的metatable和env表</span></span><br><span class=\"line\">      Table *mt = gco2u(o)-&gt;metatable;</span><br><span class=\"line\">      gray2black(o);  <span class=\"comment\">/* udata are never gray */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mt) markobject(g, mt);</span><br><span class=\"line\">      markobject(g, gco2u(o)-&gt;env);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TUPVAL: &#123;<span class=\"comment\">//对于UpValue类型的数据，如果当前是close状态的话，那么该UpValue 已经没有与其他数据的引用关系了，可以直接标记为黑色 。 至于open状态的 UpValue ，由于其引用状态可能会频繁发生变动，所以留待后面的remarkupvals函数进行原子性的标记</span></span><br><span class=\"line\">      UpVal *uv = gco2uv(o);</span><br><span class=\"line\">      markvalue(g, uv-&gt;v);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (uv-&gt;v == &amp;uv-&gt;u.value)  <span class=\"comment\">/* closed? */</span></span><br><span class=\"line\">        gray2black(o);  <span class=\"comment\">/* open upvalues are never black */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TFUNCTION: &#123;</span><br><span class=\"line\">      gco2cl(o)-&gt;c.gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TTABLE: &#123;</span><br><span class=\"line\">      gco2h(o)-&gt;gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TTHREAD: &#123;</span><br><span class=\"line\">      gco2th(o)-&gt;gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TPROTO: &#123;</span><br><span class=\"line\">      gco2p(o)-&gt;gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: lua_assert(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，对于绝大部分类型的对象，这里只是简单地将其颜色改变为灰色并加入到gray链表中，但是有几个类型是区别处理的。</p>\n<h3 id=\"扫描标记阶段\"><a href=\"#扫描标记阶段\" class=\"headerlink\" title=\"扫描标记阶段\"></a>扫描标记阶段</h3><p>扫描阶段就是遍历灰色对象链表来分析对象的引用情况，这个阶段是<code>GC</code>所有阶段中步骤最长的 。 整个过程分为两部分。 第一步首先遍历<code>gray</code>链表来标记所有数据，在这个过程中，有些数据需要重新扫描，这些数据会放在<code>grayagain</code>链表中，调用<code>atomic</code>函数重新进行扫描。 而第二步则是遍历<code>grayagain</code>链表，一次性扫描其中的数据 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> GCSpropagate: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;gray)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> propagatemark(g);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* no more `gray&#x27; objects */</span></span><br><span class=\"line\">        atomic(L);  <span class=\"comment\">/* finish mark phase */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这一步将扫描所有<code>gray</code>链表中的对象，将它们及其引用到的对象标记成黑色 。 需要注意的是，前面的初始化阶段是一次到位的，而这一步却可以多次进行，每次扫描之后会返回本次扫描标记的对象大小之和，其入口函数是<code>propagatemark</code>，再次扫描时，只要<code>gray</code>链表中还有待扫描的对象，就继续执行这个函数进行标记 。 当灰色链表已经遍历完毕时，进入<code>atomic</code>函数中完成标记阶段。</p>\n<p>可以看到，第一步遍历<code>gray</code>链表中对象的处理是可以中断的，而第二步调用<code>atomic</code>函数的操作是原子的、不能被打断的，这也是<code>atomic</code>函数的名字由来 。 这是<code>Lua 5.1</code>的<code>GC</code>算法优于之前版本的<code>GC</code>算法的原因之一 ： 可以增量地来进行数据扫描，不会因为一次<code>GC</code>扫描操作导致整个系统被卡住很久 。</p>\n<p><code>propagatemark</code>函数与前面的<code>reallymarkobject</code>函数做的事情其实差不多，都是对对象标记颜色的动作 。 区别在于，这里将对象从灰色标记成黑色，表示这个对象及其所引用的对象都已经标记过 。 另一个区别在于，前面的流程不会递归对一个对象所引用的对象进行标记，而这里会根据不同的类型调用对应的<code>traverse*</code>函数进行标记。 在实际工作中，对每种类型的对象的处理还不太一样，下面逐个类型来看看 。</p>\n<h4 id=\"扫描Table对象\"><a href=\"#扫描Table对象\" class=\"headerlink\" title=\"扫描Table对象\"></a>扫描Table对象</h4><p>在<code>traversetable</code>函数中，如果扫描到该表是弱表，那么将会把该对象加入<code>weak</code>链表中，这个链表将在扫描阶段的最后一步进行一次不能中断的处理，这部分将在后面谈到 。 同时，如果该表是弱表，那么将该对象回退到灰色状态，重新进行扫描。 在不是弱表的情况下，将遍历标记表的散列部分及数组部分的所有元素 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TTABLE: &#123;</span><br><span class=\"line\">      Table *h = gco2h(o);</span><br><span class=\"line\">      g-&gt;gray = h-&gt;gclist;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (traversetable(g, h))  <span class=\"comment\">/* table is weak? */</span></span><br><span class=\"line\">        black2gray(o);  <span class=\"comment\">/* keep it gray */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(Table) + <span class=\"keyword\">sizeof</span>(TValue) * h-&gt;sizearray +</span><br><span class=\"line\">                             <span class=\"keyword\">sizeof</span>(Node) * sizenode(h);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"扫描函数对象\"><a href=\"#扫描函数对象\" class=\"headerlink\" title=\"扫描函数对象\"></a>扫描函数对象</h4><p>针对函数对象，进行处理的函数是<code>traverseclosure</code>，该函数主要是对函数中的所有<code>UpValue</code>进行标记。 相关代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> LUA_TFUNCTION: &#123;</span><br><span class=\"line\">      Closure *cl = gco2cl(o);</span><br><span class=\"line\">      g-&gt;gray = cl-&gt;c.gclist;</span><br><span class=\"line\">      traverseclosure(g, cl);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (cl-&gt;c.isC) ? sizeCclosure(cl-&gt;c.nupvalues) :</span><br><span class=\"line\">                           sizeLclosure(cl-&gt;l.nupvalues);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"扫描线程对象\"><a href=\"#扫描线程对象\" class=\"headerlink\" title=\"扫描线程对象\"></a>扫描线程对象</h4><p>针对线程对象，这里的处理是将该对象从<code>gclist</code>中摘下来，放入<code>grayagain</code>链表中，同时将颜色退回到灰色，以备后面的原子阶段再做一次扫描 。 因为<code>thread</code>上关联的对象是<code>Lua</code>运行时的状态，变化很频繁，所以这里只是简单地放在<code>grayagain</code>链表中 ， 后面再一次性标记完毕 。 相关代码如下 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> LUA_TTHREAD: &#123;</span><br><span class=\"line\">      lua_State *th = gco2th(o);</span><br><span class=\"line\">      g-&gt;gray = th-&gt;gclist;</span><br><span class=\"line\">      th-&gt;gclist = g-&gt;grayagain;</span><br><span class=\"line\">      g-&gt;grayagain = o;</span><br><span class=\"line\">      black2gray(o);</span><br><span class=\"line\">      traversestack(g, th);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(lua_State) + <span class=\"keyword\">sizeof</span>(TValue) * th-&gt;stacksize +</span><br><span class=\"line\">                                 <span class=\"keyword\">sizeof</span>(CallInfo) * th-&gt;size_ci;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"扫描proto对象\"><a href=\"#扫描proto对象\" class=\"headerlink\" title=\"扫描proto对象\"></a>扫描proto对象</h4><p>最后一种特殊类型是<code>Proto</code>类型，将会调用<code>traverseproto</code>函数标记一个<code>Proto</code>数据中的文件名、字符串 、<code>upvalue</code>、局部变量等所有被引用的对象 。</p>\n<h4 id=\"扫描其余的类型\"><a href=\"#扫描其余的类型\" class=\"headerlink\" title=\"扫描其余的类型\"></a>扫描其余的类型</h4><p>就是简单地调用<code>gray2black</code>将颜色从灰色置为黑色就好了。</p>\n<h4 id=\"barrier操作\"><a href=\"#barrier操作\" class=\"headerlink\" title=\"barrier操作\"></a>barrier操作</h4><p>从前面的描述可以知道，分步增量式的扫描标记算法中间可以被打断以执行其他操作，此时就会出现新增加的对象与已经被扫描过的对象之间会有引用关系的变化，而算法中需要保证不会出现黑色对象引用的对象中有白色对象的情况，于是需要两种不同的处理。</p>\n<ul>\n<li>标记过程向前走一步。 这种情况指的是，如果一个新创建对象的颜色是白色，而它被一个黑色对象引用了，那么将这个对象的颜色从白色变成灰色，也就是这个<code>GC</code>过程中的进度向前走了一步。</li>\n<li>标记过程向后走一步 。 与前面的情况一样，但是此时是将黑色的对象回退到灰色，也就是这个原先已经被标记为黑色的对象需要重新被扫描，这相当于在<code>GC</code>过程中向后走了一步 。<br>在代码中，最终调用<code>luaC_barrierf</code>函数的都是向前走的操作；反之，调用<code>luaC_barrierback</code>的操作则是向后走的操作：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_barrier(L,p,v) &#123; <span class=\"meta-keyword\">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(p)))  \\</span></span><br><span class=\"line\">\tluaC_barrierf(L,obj2gco(p),gcvalue(v)); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_barriert(L,t,v) &#123; <span class=\"meta-keyword\">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(t)))  \\</span></span><br><span class=\"line\">\tluaC_barrierback(L,t); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_objbarrier(L,p,o)  \\</span></span><br><span class=\"line\">\t&#123; <span class=\"keyword\">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(p))) \\</span><br><span class=\"line\">\t\tluaC_barrierf(L,obj2gco(p),obj2gco(o)); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_objbarriert(L,t,o)  \\</span></span><br><span class=\"line\">   &#123; <span class=\"keyword\">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(t))) luaC_barrierback(L,t); &#125;</span><br></pre></td></tr></table></figure>\n可以看到，回退操作仅针对<code>Table</code>类型的对象，而其他类型的对象都是向前操作。<br><code>Table</code>是<code>Lua</code>中最常见的数据结构，而且一个<code>Table</code>与其关联的<code>key</code>、<code>value</code>之间是1比<code>N</code>的对应关系 。 如果针对<code>Table</code>对象做的是向前的标记操作，那么就意味着：但凡一个<code>Table</code>只要有新增的对象，都帘要将这个新对象标记为灰色并加入<code>gray</code>链表中等待扫描。<br>实际上，这样会有不必要的开销 。 所以，针对<code>Table</code>类型的对象，使用的是针对该<code>Table</code>对象本身要做的向后操作，这样不论有多少个对象新增到<code>Table</code>中，只要改变了一次，就将这个<code>Table</code>对象回退到灰色状态，等待重新扫描 。 但是这里需要注意的是，对<code>Table</code>对象进行回退操作时，并不是将它放入<code>gray</code>链表中，因为这样做实际上还会出现前面提到的多次反复标记的问题。 针对<code>Table</code>对象，对它执行回退操作，是将它加入到 <code>grayagain</code>链表中，用于在扫描完毕<code>gray</code>链表之后再进行一次性的原子扫描：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_barrierback</span> <span class=\"params\">(lua_State *L, Table *t)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  GCObject *o = obj2gco(t);</span><br><span class=\"line\">  lua_assert(isblack(o) &amp;&amp; !isdead(g, o));</span><br><span class=\"line\">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class=\"line\">  black2gray(o);  <span class=\"comment\">/* make table gray (again) */</span></span><br><span class=\"line\">  t-&gt;gclist = g-&gt;grayagain;</span><br><span class=\"line\">  g-&gt;grayagain = o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n可以看到，需要进行<code>barrierback</code>操作的对象，最后并没有如新建对象那样加入<code>gray</code>链表中，而是加入<code>grayagain</code>列表中，避免一个对象频繁地进行“被回退－扫描－回退－扫描”过程 。 既然需要重新扫描，那么一次J性地放在<code>grayagain</code>链表中就可以了 。 至于如何回收<code>grayagain</code>链表中的数据，下面将说明。</li>\n</ul>\n<p>而相对地，向前的操作就简单多了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_barrierf</span> <span class=\"params\">(lua_State *L, GCObject *o, GCObject *v)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span><br><span class=\"line\">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class=\"line\">  lua_assert(ttype(&amp;o-&gt;gch) != LUA_TTABLE);</span><br><span class=\"line\">  <span class=\"comment\">/* must keep invariant? */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g-&gt;gcstate == GCSpropagate)</span><br><span class=\"line\">    reallymarkobject(g, v);  <span class=\"comment\">/* restore invariant */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>  <span class=\"comment\">/* don&#x27;t mind */</span></span><br><span class=\"line\">    makewhite(g, o);  <span class=\"comment\">/* mark as white just to avoid other barriers */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只要当前的<code>GC</code>没有在扫描标记阶段，就标记这个对象，否则将对象标记为白色，等待下一次的<code>GC</code>。<br>当<code>gray</code>链表中没有对象时，并不能马上进入下一个阶段，这是因为前面还有未处理的数据，这一步需要一次性不被中断地完成，其入口是<code>atomic</code>函数。<br>前面提到<code>Lua</code>的增量式<code>GC</code>算法分为多个阶段，可以被中断，然而这一步则例外。 这一步将处理弱表链表和前面提到的<code>grayagain</code>链表，是扫描阶段的最后一步，不可中断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">atomic</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> udsize;  <span class=\"comment\">/* total size of userdata to be finalized */</span></span><br><span class=\"line\">  <span class=\"comment\">/* remark occasional upvalues of (maybe) dead threads */</span></span><br><span class=\"line\">  remarkupvals(g);<span class=\"comment\">//调用remarkupvals函数去标记open状态的UpValue</span></span><br><span class=\"line\">  <span class=\"comment\">/* traverse objects cautch by write barrier and by &#x27;remarkupvals&#x27; */</span></span><br><span class=\"line\">  propagateall(g);<span class=\"comment\">//gray链表又会有新的对象，于是需要调用propagateall再次将gray链表中的对象标记一下</span></span><br><span class=\"line\">  <span class=\"comment\">/* remark weak tables */</span></span><br><span class=\"line\">  g-&gt;gray = g-&gt;weak;<span class=\"comment\">//修改gray链表指针，使其指向管理弱表的weak指针</span></span><br><span class=\"line\">  g-&gt;weak = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  lua_assert(!iswhite(obj2gco(g-&gt;mainthread)));</span><br><span class=\"line\">  markobject(g, L);  <span class=\"comment\">/* mark running thread */</span><span class=\"comment\">//标记当前的Lua_State指针以及基本的meta表</span></span><br><span class=\"line\">  markmt(g);  <span class=\"comment\">/* mark basic metatables (again) */</span></span><br><span class=\"line\">  propagateall(g);</span><br><span class=\"line\">  <span class=\"comment\">/* remark gray again */</span></span><br><span class=\"line\">  g-&gt;gray = g-&gt;grayagain;<span class=\"comment\">//修改gray链表指针指向grayagain指针</span></span><br><span class=\"line\">  g-&gt;grayagain = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  propagateall(g);<span class=\"comment\">//调用propagateall函数进行遍历扫描操作</span></span><br><span class=\"line\">  udsize = luaC_separateudata(L, <span class=\"number\">0</span>);  <span class=\"comment\">/* separate userdata to be finalized */</span></span><br><span class=\"line\">  marktmu(g);  <span class=\"comment\">/* mark `preserved&#x27; userdata */</span></span><br><span class=\"line\">  udsize += propagateall(g);  <span class=\"comment\">/* remark, to propagate `preserveness&#x27; */</span></span><br><span class=\"line\">  cleartable(g-&gt;weak);  <span class=\"comment\">/* remove collected objects from weak tables */</span></span><br><span class=\"line\">  <span class=\"comment\">/* flip current white */</span></span><br><span class=\"line\">  g-&gt;currentwhite = cast_byte(otherwhite(g));<span class=\"comment\">//将当前白色类型切换到了下一次GC操作的白色类型 </span></span><br><span class=\"line\">  g-&gt;sweepstrgc = <span class=\"number\">0</span>;</span><br><span class=\"line\">  g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class=\"line\">  g-&gt;gcstate = GCSsweepstring;<span class=\"comment\">//修改状态到下个回收阶段</span></span><br><span class=\"line\">  g-&gt;estimate = g-&gt;totalbytes - udsize;  <span class=\"comment\">/* first estimate */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在就可以谈谈前面提到的对<code>udata</code>进行处理的<code>luaC_separateudata</code>函数了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">luaC_separateudata</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> all)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> deadmem = <span class=\"number\">0</span>;</span><br><span class=\"line\">  GCObject **p = &amp;g-&gt;mainthread-&gt;next;</span><br><span class=\"line\">  GCObject *curr;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((curr = *p) != <span class=\"literal\">NULL</span>) &#123;<span class=\"comment\">//如果该对象不需要回收，就继续处理下一个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))<span class=\"comment\">//先看该对象有没有注册GC函数</span></span><br><span class=\"line\">      p = &amp;curr-&gt;gch.next;  <span class=\"comment\">/* don&#x27;t bother with them */</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fasttm(L, gco2u(curr)-&gt;metatable, TM_GC) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      markfinalized(gco2u(curr));  <span class=\"comment\">/* don&#x27;t need finalization */</span><span class=\"comment\">//如果没有，就直接标记该对象的状态是finalized</span></span><br><span class=\"line\">      p = &amp;curr-&gt;gch.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* must call its gc method */</span></span><br><span class=\"line\">      deadmem += sizeudata(gco2u(curr));</span><br><span class=\"line\">      markfinalized(gco2u(curr));<span class=\"comment\">//标记该对象为 finalized</span></span><br><span class=\"line\">      *p = curr-&gt;gch.next;</span><br><span class=\"line\">      <span class=\"comment\">/* link `curr&#x27; at the end of `tmudata&#x27; list */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;tmudata == <span class=\"literal\">NULL</span>)  <span class=\"comment\">/* list is empty? */</span><span class=\"comment\">//将这些对象加入tmudata链表中，这里将udata放在一个链表中也是为了统一处理，后面将会提至Ufinalized状态的处理</span></span><br><span class=\"line\">        g-&gt;tmudata = curr-&gt;gch.next = curr;  <span class=\"comment\">/* creates a circular list */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        curr-&gt;gch.next = g-&gt;tmudata-&gt;gch.next;</span><br><span class=\"line\">        g-&gt;tmudata-&gt;gch.next = curr;</span><br><span class=\"line\">        g-&gt;tmudata = curr;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> deadmem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它主要对<code>mainthread</code>之后的对象进行遍历（前面谈到了将<code>udata</code>放在<code>mainthread</code>之后，这是为了统一放在一个地方，方便处理）。</p>\n<h3 id=\"回收阶段\"><a href=\"#回收阶段\" class=\"headerlink\" title=\"回收阶段\"></a>回收阶段</h3><p>回收阶段分为两步，一步是针对字符串类型的回收，另一步则是针对其他类型对象的回收 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> GCSsweepstring: &#123;</span><br><span class=\"line\">      lu_mem old = g-&gt;totalbytes;</span><br><span class=\"line\">      sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  <span class=\"comment\">/* nothing more to sweep? */</span></span><br><span class=\"line\">        g-&gt;gcstate = GCSsweep;  <span class=\"comment\">/* end sweep-string phase */</span></span><br><span class=\"line\">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class=\"line\">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> GCSWEEPCOST;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">case</span> GCSsweep: &#123;</span><br><span class=\"line\">      lu_mem old = g-&gt;totalbytes;</span><br><span class=\"line\">      g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (*g-&gt;sweepgc == <span class=\"literal\">NULL</span>) &#123;  <span class=\"comment\">/* nothing more to sweep? */</span></span><br><span class=\"line\">        checkSizes(L);</span><br><span class=\"line\">        g-&gt;gcstate = GCSfinalize;  <span class=\"comment\">/* end sweep phase */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class=\"line\">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> GCSWEEPMAX*GCSWEEPCOST;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>针对字符串类型的数据，每次调用<code>sweepwholelist</code>函数回收字符串散列桶数组中的一个字符串链表，其中每次操作的散列桶索引值存放在<code>sweepstrgc</code>变量中 。 当所有字符串散列桶数据全部遍历完毕时，切换到下一个状态<code>GCSsweep</code>进行其他数据的回收。</p>\n<p>对于其他类型数据的回收，我们调用<code>sweeplist</code>函数进行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> GCObject **<span class=\"title\">sweeplist</span> <span class=\"params\">(lua_State *L, GCObject **p, lu_mem count)</span> </span>&#123;</span><br><span class=\"line\">  GCObject *curr;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> deadmask = otherwhite(g);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((curr = *p) != <span class=\"literal\">NULL</span> &amp;&amp; count-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr-&gt;gch.tt == LUA_TTHREAD)  <span class=\"comment\">/* sweep open upvalues of each thread */</span></span><br><span class=\"line\">      sweepwholelist(L, &amp;gco2th(curr)-&gt;openupval);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((curr-&gt;gch.marked ^ WHITEBITS) &amp; deadmask) &#123;  <span class=\"comment\">/* not dead? */</span></span><br><span class=\"line\">      lua_assert(!isdead(g, curr) || testbit(curr-&gt;gch.marked, FIXEDBIT));</span><br><span class=\"line\">      makewhite(g, curr);  <span class=\"comment\">/* make it white (for next cycle) */</span></span><br><span class=\"line\">      p = &amp;curr-&gt;gch.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* must erase `curr&#x27; */</span></span><br><span class=\"line\">      lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));</span><br><span class=\"line\">      *p = curr-&gt;gch.next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curr == g-&gt;rootgc)  <span class=\"comment\">/* is the first element of the list? */</span></span><br><span class=\"line\">        g-&gt;rootgc = curr-&gt;gch.next;  <span class=\"comment\">/* adjust first */</span></span><br><span class=\"line\">      freeobj(L, curr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里我们首先拿到<code>otherwhite</code>，这表示本次<code>GC</code>操作不可以被回收的白色类型 。 后面就是依次遍历链表中的数据，判断每个对象的白色是否满足被回收的颜色条件。</p>\n<h3 id=\"结束阶段\"><a href=\"#结束阶段\" class=\"headerlink\" title=\"结束阶段\"></a>结束阶段</h3><p>走到了最后一步回收阶段，这一阶段主要针对<code>tmudata</code>链表进行处理，在所有数据都处理完毕后，重新将<code>GC</code>状态切换到暂停状态，这表示下一次新的<code>GC</code>可以开始了 。 相关代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> GCSfinalize: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;tmudata) &#123;</span><br><span class=\"line\">        GCTM(L);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g-&gt;estimate &gt; GCFINALIZECOST)</span><br><span class=\"line\">          g-&gt;estimate -= GCFINALIZECOST;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GCFINALIZECOST;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        g-&gt;gcstate = GCSpause;  <span class=\"comment\">/* end collection */</span></span><br><span class=\"line\">        g-&gt;gcdept = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>到了结束阶段，其实也可以中断。 只要<code>tmudata</code>链表中还有对象，就一直调用<code>GCTM</code>函数来处理。 前面提到，<code>tmudata</code>链表是用来存放所有自带<code>GC</code>元方法的<code>udata</code>对象，因此这里的工作就是调用这些注册的<code>GC</code>元方法进行对象回收：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">GCTM</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  GCObject *o = g-&gt;tmudata-&gt;gch.next;  <span class=\"comment\">/* get first element */</span></span><br><span class=\"line\">  Udata *udata = rawgco2u(o);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> TValue *tm;</span><br><span class=\"line\">  <span class=\"comment\">/* remove udata from `tmudata&#x27; */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (o == g-&gt;tmudata)  <span class=\"comment\">/* last element? */</span></span><br><span class=\"line\">    g-&gt;tmudata = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    g-&gt;tmudata-&gt;gch.next = udata-&gt;uv.next;</span><br><span class=\"line\">  udata-&gt;uv.next = g-&gt;mainthread-&gt;next;  <span class=\"comment\">/* return it to `root&#x27; list */</span></span><br><span class=\"line\">  g-&gt;mainthread-&gt;next = o;</span><br><span class=\"line\">  makewhite(g, o);</span><br><span class=\"line\">  tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tm != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    lu_byte oldah = L-&gt;allowhook;</span><br><span class=\"line\">    lu_mem oldt = g-&gt;GCthreshold;</span><br><span class=\"line\">    L-&gt;allowhook = <span class=\"number\">0</span>;  <span class=\"comment\">/* stop debug hooks during GC tag method */</span></span><br><span class=\"line\">    g-&gt;GCthreshold = <span class=\"number\">2</span>*g-&gt;totalbytes;  <span class=\"comment\">/* avoid GC steps */</span></span><br><span class=\"line\">    setobj2s(L, L-&gt;top, tm);</span><br><span class=\"line\">    setuvalue(L, L-&gt;top+<span class=\"number\">1</span>, udata);</span><br><span class=\"line\">    L-&gt;top += <span class=\"number\">2</span>;</span><br><span class=\"line\">    luaD_call(L, L-&gt;top - <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    L-&gt;allowhook = oldah;  <span class=\"comment\">/* restore hooks */</span></span><br><span class=\"line\">    g-&gt;GCthreshold = oldt;  <span class=\"comment\">/* restore threshold */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>GCTM</code>函数的主要逻辑就是循环遍历<code>tmudata</code>链表中的对象，针对每个对象调用 <code>fasttm</code>函数，其中会使用<code>GC</code>元方法来进行对象的回收。</p>\n<p>当所有操作都完成，<code>tmudata</code>链表中不再有对象了，此时一个<code>GC</code>的完整流程就走完了，<code>Lua</code>将<code>GC</code>状态切换到<code>GCSpause</code>，等待下一次的<code>GC</code>操作。</p>\n<h2 id=\"进度控制\"><a href=\"#进度控制\" class=\"headerlink\" title=\"进度控制\"></a>进度控制</h2><p>在<code>Lua</code>代码中，有两种回收方式，一种是自动回收，一种是由用户自己调用<code>API</code>来触发一次回收。<br>自动回收会在每次调用内存分配相关的操作时检查是再满足触发条件，这个操作在宏<code>luaC_checkGC</code>中进行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_checkGC(L) &#123; \\</span></span><br><span class=\"line\">  condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - <span class=\"number\">1</span>)); \\</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \\</span><br><span class=\"line\">\tluaC_step(L); &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，触发自动化<code>GC</code>的条件就是：<code> totalbytes</code>大于等于<code>GCthreshold</code>值。 在这两个变量中，<code>totalbytes</code>用于保存当前分配的内存大小，而<code>GCthreshold</code>保存的是一个阈值，这个值可以由一些参数影响和控制，由此改变触发的条件。<br>由于自动<code>GC</code>会在使用者不知道的情况下触发，不太可控，因而很多人选择关闭它，具体操作就是通过将<code>GCthreshold</code>设置为一个非常大的值来达到一直不满足自动触发条件。<br>接下来，看看手动<code>GC</code>受哪些参数影响 。 首先，<code>estimate</code>和<code>gcpause</code>两个成员将影响每次<code>GCthreshold</code>的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> setthreshold(g)  (g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)</span></span><br></pre></td></tr></table></figure>\n<p>这里<code>estimate</code>是一个预估的当前使用的内存数量，而<code>gcpause</code>则是一个百分比，这个宏的作用就是按照估计值的百分比计算出新的阈值来 。 其中，<code>gcpause</code>通过<code>lua_gc</code>这个<code>C</code>接口来进行设置。 可以看到，百分比越大，下一次开始<code>GC</code>的时间就会越长 。</p>\n<p>另一个影响<code>GC</code>进度的参数是<code>gcstepmul</code>成员，它同样可以通过<code>lua_gc</code>来设置。 这个参数将影响每次手动<code>GC</code>时调用<code>singlestep</code>函数的次数，从而影响到<code>GC</code>回收的速度：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_step</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  l_mem lim = (GCSTEPSIZE/<span class=\"number\">100</span>) * g-&gt;gcstepmul;<span class=\"comment\">//GCSTEPSIZE 是一个宏，表示每次 GC 的步长大小 。 使用这个宏以及gcstepmul参数，可以计算出这一次回收计划至少回收的内存数量 </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lim == <span class=\"number\">0</span>)</span><br><span class=\"line\">    lim = (MAX_LUMEM<span class=\"number\">-1</span>)/<span class=\"number\">2</span>;  <span class=\"comment\">/* no limit */</span></span><br><span class=\"line\">  g-&gt;gcdept += g-&gt;totalbytes - g-&gt;GCthreshold;<span class=\"comment\">//gcdept用于在每次回收之前累加当前使用内存到阔值之间的差值，用于后面计算下一次触发GC的阑值</span></span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;<span class=\"comment\">//当计划待回收内存还没有回收完之前，一直循环调用 singlestep 函数来进行回收，除非这里完成了完整的GC</span></span><br><span class=\"line\">    lim -= singlestep(L);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;gcstate == GCSpause)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span> (lim &gt; <span class=\"number\">0</span>);<span class=\"comment\">//完成回收之后，设置下一次触发回收操作的阈值；如果完成了一个 GC,那么调用 setthreshold来计算下一次GC的阔值。 </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g-&gt;gcstate != GCSpause) &#123;<span class=\"comment\">//如果此时状态不是GCSpause ，那么表示没有完成一个GC </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;gcdept &lt; GCSTEPSIZE)<span class=\"comment\">//如果前面保存的 gcdept太小，小于GCSTEPSIZE ，那么下一次阔值就设置得比当前使用内存大GCSTEPSIZE ，即只要再多分配 GCSTEPSIZE 的内存就会再次触发GC </span></span><br><span class=\"line\">      g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE;  <span class=\"comment\">/* - lim/g-&gt;gcstepmul;*/</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//否则将 gcdept 减去 GCSTEPSIZE ，将GCthreshold设置得跟 totalbytes一样，以求尽快触发下一次GC 。 </span></span><br><span class=\"line\">      g-&gt;gcdept -= GCSTEPSIZE;</span><br><span class=\"line\">      g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    lua_assert(g-&gt;totalbytes &gt;= g-&gt;estimate);</span><br><span class=\"line\">    setthreshold(g);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>setthreshold</code>只会在一次<code>GC</code>完成之后被调用，而不会影响没有完成的<code>GC</code>全流程 。 因此，<code>setthreshold</code>影响的是两次完整<code>GC</code>之间的时长 。 而<code>gcdept</code>参数会在每次<code>GC</code>完毕之后重新清零，它用于保存一次完整GC的内部状态。<br>同时，还需要注意的一点是，这个过程会改变<code>GCthreshold</code>的值，所以如果希望关闭自动<code>GC</code>,还需要在手动执行完一次<code>GC</code>之后重新设置关闭自动<code>GC</code>。</p>\n<h2 id=\"从lua-5-1-1中分离出来的gc实现代码\"><a href=\"#从lua-5-1-1中分离出来的gc实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的gc实现代码\"></a>从lua-5.1.1中分离出来的gc实现代码</h2><p><a href=\"https://gist.github.com/losophy/544464c2d90da85fc9d0546d3f3dcf53\">lgc</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《Lua设计与实现》<br>New Garbage Collector 详见：<a href=\"http://wiki.luajit.org/New-Garbage-Collector\">http://wiki.luajit.org/New-Garbage-Collector</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/117\">El que realiza lo que desea, es grande; el que quiere realizar lo que puede, es sabio.</a></p>\n","tags":["lua"]},{"title":"lua state","url":"/post/f7329e6b.html","content":"<p><code>Lua</code>除了是一门扩展的言语外，还是一门“胶水语言”。最著名的就是作为游戏的脚本开发。</p>\n<p>这里主要说<code>lua</code>怎样与c交互。<br><code>Lua</code>和<code>c</code>语言通信的主要方法是一个无所不在的虚拟栈。几乎所有的<code>API</code>调用都会操作这个栈上的值。所有的数据交换，无论是<code>Lua</code>到<code>C</code>语言或<code>C</code>语言到<code>Lua</code>都通过这个栈来完成。栈可以解决<code>Lua</code>和<code>C</code>语言之间存在的两大差异，第一种差异是<code>Lua</code>使用垃圾收集，而<code>C</code>语言要求显式地释放内存；第二种是<code>Lua</code>使用动态类型，而<code>C</code>语言使用静态类型。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">lua_State *L = luaL_newstate();<span class=\"comment\">//创建一个新的环境</span></span><br></pre></td></tr></table></figure>\n<p><code>luaL_newstate</code>用c运行库的内存分配函数。<br><code>lua_newstate</code>可自定义内存分配函数。</p>\n<p>头文件<code>lua.h</code>定义了<code>lua</code>提供的基础函数，包括创建<code>lua</code>环境、调用<code>lua</code>函数（如<code>lua_pcall</code>）、读写<code>lua</code>环境中全局变量，以及注册供<code>lua</code>调用的新函数等。<code>Lua.h</code>中定义所有内容都有一个<code>lua_</code>前缀。<br>头文件<code>lauxlib.h</code>定义了辅助库<code>（auxiliary library,auxlib）</code>提供的函数。它的所有定义都以<code>luaL_</code>开头（如<code>luaL_loadbuffer</code>）。辅助库是一个使用<code>lua.h</code>中<code>API</code>编写出的一个较高的抽象层。<code>Lua</code>的所有标准库编写都用到了辅助库。</p>\n<div class=\"note warning\"><p>Lua脚本的编译执行是相互独立的，在不同的线程上执行。通过luaL_newstate()函数可以申请一个虚拟机，返回指针类型lua_State。今后其他所有Lua Api函数的调用都需要此指针作为第一参数，用来指定某个虚拟机。所以lua_State代表一个lua虚拟机对像，luaL_newstate()分配一个虚拟机。lua类库管理着所有的虚拟机。销毁指定虚拟机的所有对像（如果有垃圾回收相关的无方法则会调用该方法）并收回所有由该虚拟机动态分配产生的内存，在有些平台下我们不需要调用此函数，因为当主程序退出时，资源会被自然的释放掉，但是但一个长时间运行的程序，比如后台运行的web服务器，需要立即回收虚拟机资源以避免内存过高占用。</p></div>\n\n<h2 id=\"Lua虚拟机相关的数据结构与栈\"><a href=\"#Lua虚拟机相关的数据结构与栈\" class=\"headerlink\" title=\"Lua虚拟机相关的数据结构与栈\"></a>Lua虚拟机相关的数据结构与栈</h2><p>解释器要做的就是模拟计算机的执行，这主要分为以下两大块。</p>\n<blockquote>\n<p><code>CPU</code>：用于指令的执行。<br>内存：用于数据的存储。<br>指令执行的部分在<a href=\"https://github.com/losophy/losophy.github.io/issues/113\">lua虚拟机</a>（lua虚拟机工作流程）大体介绍过，即解释器分析<code>Lua</code>文件之后生成<code>Proto</code>结构体，最后到<code>luaV_execute</code>函数中依次取出指令来执行。<br>而“内存”部分，在<code>Lua</code>解释器中就存放在<code>Lua</code>栈中。 <code>Lua</code>中也是把栈的某一个位置称为寄存器（非真<code>CPU</code>中的寄存器）。<br>每个<code>Lua</code>虚拟机对应一个<code>lua_State</code>结构体，它使用<code>TValue</code>数组来模拟栈，其中包括几个与找相关的成员。<br><code>stack</code> ：栈数组的起始位置。<br><code>base</code> ： 当前函数栈的基地址 。<br><code>top</code> ： 当前栈的下一个可用位置 。<br>这些成员的初始化操作在<code>stack_init</code>函数中完成。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">stack_init</span> <span class=\"params\">(lua_State *L1, lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* initialize CallInfo array */</span></span><br><span class=\"line\">  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);</span><br><span class=\"line\">  L1-&gt;ci = L1-&gt;base_ci;</span><br><span class=\"line\">  L1-&gt;size_ci = BASIC_CI_SIZE;</span><br><span class=\"line\">  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - <span class=\"number\">1</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看看<code>lua_State</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_State</span> &#123;</span></span><br><span class=\"line\">  CommonHeader;</span><br><span class=\"line\">  lu_byte status;</span><br><span class=\"line\">  StkId top;  <span class=\"comment\">/* first free slot in the stack */</span></span><br><span class=\"line\">  StkId base;  <span class=\"comment\">/* base of current function */</span></span><br><span class=\"line\">  global_State *l_G;</span><br><span class=\"line\">  CallInfo *ci;  <span class=\"comment\">/* call info for current function */</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>lua_State</code>里面存放的是一个<code>Lua</code>虚拟机的全局状态，当执行到一个两数时，需要有对应的数据结构来表示函数相关的信息。这个数据结构就是<code>CallInfo</code>，这个结构体中同样有<code>top</code>、<code>base</code>这两个与栈相关的成员。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** informations about a call</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CallInfo</span> &#123;</span></span><br><span class=\"line\">  StkId base;  <span class=\"comment\">/* base for this function */</span></span><br><span class=\"line\">  StkId func;  <span class=\"comment\">/* function index in the stack */</span></span><br><span class=\"line\">  StkId\ttop;  <span class=\"comment\">/* top for this function */</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Instruction *savedpc;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nresults;  <span class=\"comment\">/* expected number of results from this function */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> tailcalls;  <span class=\"comment\">/* number of tail calls lost under this entry */</span></span><br><span class=\"line\">&#125; CallInfo;</span><br></pre></td></tr></table></figure>\n<p>无论函数怎么执行，有多少函数，最终它们引用到的栈都是当前<code>Lua</code>虚拟机的栈。 这好比一个操作系统中的进程无论有多少，最终引用的内存实际上都还是由操作系统内核来管理的。<br>在<code>lua_State</code>结构体中，有一个<code>base_ci</code>的<code>CallInfo</code>数组，存储的就是<code>CallInfo</code>的信息。而另一个<code>ci</code>成员，指向的就是当前函数的<code>CallInfo</code>指针。<br>在调用函数之前，一般会调用<code>luaD_precall</code>函数，它主要完成如下几个操作 。</p>\n<blockquote>\n<p>(1）保存当前虚拟机执行的指令<code>savedpc</code>到当前<code>CallInfo</code>的<code>savedpc</code>中。此处保存下来是为了后面调用完毕之后恢复执行<br>(2）分别计算出待调用函数的<code>base</code>、<code>top</code>值，这些值的计算依赖于函数的参数数量<br>(3）从<code>lua_State</code>的<code>base_ci</code>数组中分配一个新的<code>CallInfo</code>指针，存储前面两步计算出来的信息，切换到这个函数中准备调用。</p>\n</blockquote>\n<p>可以看到，<code>lua_State</code>结构体中的<code>top</code>、<code>base</code>指针是与函数执行相关的变量，在函数执行前后都会有所变化。</p>\n<div class=\"note warning\"><p>需要注意的是，前后调用的函数中Lua栈的大小是有限的，同时CallInfo数组的大小也是有限的。 栈的使用和函数的嵌套层次都不能过多，以防这些资源、用尽了。 这就好比操作系统内核不可能无限制新建进程，也不可能无限制分配内存，资源总是有限的。</p></div>\n\n<h2 id=\"从lua-5-1-1中分离出来的lua-State实现代码\"><a href=\"#从lua-5-1-1中分离出来的lua-State实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的lua_State实现代码\"></a>从lua-5.1.1中分离出来的lua_State实现代码</h2><p><a href=\"https://gist.github.com/losophy/08c1650be112a687df424d7e6eea0451\">lua_State</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/60\">Donde no hay harina, todo es mohina.</a></p>\n","tags":["lua"]},{"title":"lua与C/C++程序的整合","url":"/post/b165dcb7.html","content":"<p><code>lua</code>与<code>C/C++</code>交互，主要靠<code>lua API</code>和向<code>lua</code>注册好的函数。如下图<br><img src=\"https://user-images.githubusercontent.com/11263320/120053922-89b99880-c05f-11eb-86ab-408065bfa09d.jpg\" alt=\"20130816205205703\"><br><code>LuaGlue</code>就是让<code>Lua</code>脚本中可调用的<code>C++</code>函数的接口。即那些注册的函数。<br>这里起关键作用的要数<code>lua_State</code>的结构，这就得讲一下<code>Lua</code>环境和<code>Lua Stack</code>。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Lua环境\"><a href=\"#Lua环境\" class=\"headerlink\" title=\"Lua环境\"></a>Lua环境</h2><p><code>Lua</code>环境由所有可操作的数据构成，如编译好的函数、变量以及其他运行时内存。这些数据保存在一个称做<code>lua_State</code>的结构中。所有<code>Lua</code>应用程序都要求至少有一个<code>lua_State</code>，如果需要还可以有多个（如需要为两个不同的系统保存不同的数据时）。</p>\n<h2 id=\"Lua-Stack\"><a href=\"#Lua-Stack\" class=\"headerlink\" title=\"Lua Stack\"></a>Lua Stack</h2><p>对于我们来说，<code>Lua</code>环境是用来发送和接收数据的地方，它利用栈<code>（Lua Stack）</code>来达到该目的。所有的数据交换，无论是<code>Lua</code>到<code>C/C++</code>语言或<code>C/C++</code>语言到<code>Lua</code>都通过这个栈来完成。<code>Lua</code>栈不同于系统栈，它只能通过<code>Lua</code>的<code>API</code>函数访问。</p>\n<h2 id=\"注册到Lua中的函数\"><a href=\"#注册到Lua中的函数\" class=\"headerlink\" title=\"注册到Lua中的函数\"></a>注册到Lua中的函数</h2><p>所有注册到<code>Lua</code>中的函数都具有相同的原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*lua_Function)</span><span class=\"params\">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这个函数仅有一个参数，即<code>Lua</code>的状态。它返回一个整数，表示其压入栈中的返回值数量。因此函数无须在压入结果前清空栈。在它返回后，<code>Lua</code>会自动删除栈中结果之下的内容。</p>\n<p>在<code>Lua</code>使用这个函数前，必须注册这个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lua_pushcfunction</span> <span class=\"params\">(lua_State *L, lua_CFunction f)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>将一个<code>C</code>函数压入堆栈。 这个函数接收一个<code>C</code>函数指针，并将一个类型为<code>function</code>的<code>Lua</code>值压入堆栈。当这个栈顶的值被调用时，将触发对应的<code>C</code>函数。<br>这种方法需要重新编译<code>Lua</code>的执行程序，才能在<code>Lua</code>程序中使用这个新函数。但用下面的方法会更好，直接将<code>C</code>函数链接到<code>lua</code>。</p>\n<h2 id=\"Lua调用C函数\"><a href=\"#Lua调用C函数\" class=\"headerlink\" title=\"Lua调用C函数\"></a>Lua调用C函数</h2><p><code>Lua</code>调用<code>C</code>函数时，并不依赖于函数名、包的位置或可见性规则，而只依赖于注册时传入的函数地址。当用<code>C</code>函数扩展<code>Lua</code>时，最好将代码设计为一个<code>C</code>模块。因为现在只注册一个函数，但说之后可能会需要更多的函数。辅助库为这项工作提供了一个函数<code>luaL_register</code>，这个函数接收一些<code>C</code>函数及其名称，并将这些函数注册到一个与模块同名的<code>table</code>中。例如，假设创建一个模块，其中包含了这个<code>luaglue</code>函数。首先，必须定义这个模块函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">luaglue</span><span class=\"params\">(lua_state *L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，声明一个数组，其中包含模块中所有函数及名称。这个数组元素的类型为<code>luaL_Reg</code>结构，该结构有两个字段，一个字符串和一个函数指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">luaL_Reg</span> <span class=\"title\">mylib</span>[] =</span> &#123;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;dir&quot;</span>,l_dir&#125;,</span><br><span class=\"line\">&#123;<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>&#125;<span class=\"comment\">//结尾</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后，声明一个主函数，其中用到了<code>luaL_register</code>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaopen_mylib</span><span class=\"params\">(lua_State *L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     luaL_register(L,<span class=\"string\">&quot;mylib&quot;</span>,mylib);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>luaL_register</code>原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaL_register</span> <span class=\"params\">(lua_State *L,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *libname,<span class=\"keyword\">const</span> luaL_Reg *l)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>luaL_register</code>根据给定的名称（“mylib”）创建（或复用）一个<code>table</code>，并用数组<code>mylib</code>中的信息填充这个<code>table</code>。在<code>luaL_Register</code>返回时，会将这个<code>table</code>留在栈中。最后，<code>luaopen_mylib</code>函数返回1，表示将这个<code>table</code>返回给<code>Lua</code>。</p>\n<div class=\"note info\"><p>打开一个库，当libname为null时，该函数注册所有在luaL_Reg上的函数，不为null时，该函数会创建一个table，根据libname注册不与libname关联的函数。</p></div>\n\n<p>当写完<code>c</code>模块后，必须将其链接到解释器。如果<code>Lua</code>解释器支持动态链接的话，那么最简便的方法是使用动态链接机制。在这种情况中，必须将<code>c</code>代码编译成动态链接库，并将这个库放入<code>C</code>路径<code>（LUA_CPATH）</code>中。然后，便可以用<code>require</code>从<code>Lua</code>中加载这个模块：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span> <span class=\"string\">&quot;mylib&quot;</span></span><br></pre></td></tr></table></figure>\n<p>这名调用会将动态库<code>mylib</code>链接到<code>Lua</code>，并会寻找<code>luaopen_mylib</code>函数，将其注册为一个<code>Lua</code>函数，然后调用它以打开模块。<br>如果解释器不支持动态链接，那么就必须用新的模块来重新编译<code>Lua</code>。此外，还需要以某种方式来告诉解释器，它应在打开一个新状态的同时打开这个模块。最简单的做法是，将<code>luaopen_mylib</code>加到<code>luaL_openlibs</code>会打开的标准库列表中，这个列表在文件<code>linit.c</code>中。</p>\n<p>从<code>C++</code>程序员的观点来看，<code>Lua</code>像一个“黑盒子”，为一些服务处理命令和调用。<code>Lua</code>通常作为最上层接口直接和程序使用者和游戏玩家打交道，在核心程序处理之前接受并响应输入。</p>\n<h2 id=\"lua-tinker\"><a href=\"#lua-tinker\" class=\"headerlink\" title=\"lua_tinker\"></a>lua_tinker</h2><p>如果嫌麻烦，不想手动写这些代码的话，我推荐<code>lua_tinker</code>。也就只有两个文件，<code>lua_tinker.h</code>，<code>lua_tinker.cpp</code>。<br>环境配置，首先你需要搭建一个可以用<code>lua</code>的开发环境，这里网上有很多，我就不多说了。然后再将<code>lua_tinker</code>的<code>lua_tinker.h</code>和<code>lua_tinker.cpp</code>添加到你的工程中就可以了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">lua_tinker::def(L, <span class=\"string\">&quot;cpp_func&quot;</span>, cpp_func); <span class=\"comment\">//在L栈中注册C++函数</span></span><br><span class=\"line\">lua_tinker::dofile(L, <span class=\"string\">&quot;sample1.lua&quot;</span>); <span class=\"comment\">//加载lua文件</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> result = lua_tinker::call&lt;<span class=\"keyword\">int</span>&gt;(L, <span class=\"string\">&quot;lua_func&quot;</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">//调用lua中的function lua_func</span></span><br><span class=\"line\"></span><br><span class=\"line\">lua_tinker::class_add(L,<span class=\"string\">&quot;classA&quot;</span>);<span class=\"comment\">//在lua中注册类</span></span><br><span class=\"line\">lua_tinker::class_con(L,lua_tinker::constructor&lt;classA&gt;);<span class=\"comment\">//在lua中注册构造函数</span></span><br><span class=\"line\">lua_tinker::class_mem(L,<span class=\"string\">&quot;memName&quot;</span>,&amp;classA::memName);</span><br></pre></td></tr></table></figure>\n<p>用<code>lua_tinker::call</code>是要注意，参数不支持智能指针。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/63\">Hay tres tipos de personas: los que saben contar y los que no.</a></p>\n","tags":["lua"]},{"title":"lua与配置文件","url":"/post/fde3146b.html","content":"<p><code>lua</code>的一项重要用途就是作为一种配置语言<code>（configuration language）</code>。</p>\n<a id=\"more\"></a>\n\n<p>目前，我们常用的配置文件格式有<code>XML</code>和<code>ini</code>,  <code>XML</code>层次分明，但其缺点就是写起来太繁杂，对一些关键字如<code>&lt;&gt;</code>之类的处理比较特殊。而<code>ini</code>呢，配置不够灵活，只有简单的段-键-值模式，对于一些多层结构的配置，或者一些列表类型的配置，就显得力不从心了，往往需要编码人员自己分割字符串。<br><code>Lua</code>脚本非常简洁清晰，是非常适合做配置文件的，无论是映射表型配置，还是列表型配置，还是简单的键值配置，<code>lua</code>都可以完全胜任。而且<code>lua</code>格式清新简洁，一看就懂。</p>\n<p>下面的代码主要是读变量和<code>table</code>。<br><code>mycon.lua</code>：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--my config </span></span><br><span class=\"line\"></span><br><span class=\"line\">width = <span class=\"number\">300</span></span><br><span class=\"line\">height = <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\">luat_Test1=&#123;a=<span class=\"number\">123</span>, b=<span class=\"number\">456</span>, c=<span class=\"number\">789</span>&#125;</span><br><span class=\"line\">luat_Test2=&#123;<span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"number\">789</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>这里说个题外话，<code>Lua</code>不会根据一个范围的值来创建表，而是根据设定的单个值来创建表内容，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">textTable &#x3D; &#123;&#125;</span><br><span class=\"line\">textTable[2000] &#x3D; &quot;hello 2000!&quot;</span><br></pre></td></tr></table></figure>\n<p>这里虽然会生成许多未使用的<code>Key</code>，但不必担心这个方法会牺牲任何表的存储空间。<br><code>main.cpp</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;  </span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//如不用extern会出现连接错误，编译成了C++文件  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span>   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;lua.h&quot;</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;lauxlib.h&quot;</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;lualib.h&quot;</span>  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> comment(lib, <span class=\"meta-string\">&quot;lua5.1.lib&quot;</span>)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ReadVariable</span> <span class=\"params\">(lua_State *L,<span class=\"keyword\">int</span> *width,<span class=\"keyword\">int</span> *height)</span></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L,<span class=\"string\">&quot;width&quot;</span>);   <span class=\"comment\">//获得Lua中变量的值，将其放入栈中  </span></span><br><span class=\"line\">    lua_getglobal(L,<span class=\"string\">&quot;height&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!lua_isnumber(L,<span class=\"number\">-2</span>))     <span class=\"comment\">//栈顶为-1，然后依次减少  </span></span><br><span class=\"line\">        luaL_error(L,<span class=\"string\">&quot;`width&#x27; should be a number\\n&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!lua_isnumber(L,<span class=\"number\">-1</span>))  </span><br><span class=\"line\">        luaL_error(L,<span class=\"string\">&quot;`height&#x27; should be a number\\n&quot;</span>);  </span><br><span class=\"line\">    *width = (<span class=\"keyword\">int</span>)lua_tonumber(L,<span class=\"number\">-2</span>);    <span class=\"comment\">//将栈顶元素转化为数字  </span></span><br><span class=\"line\">    *height = (<span class=\"keyword\">int</span>)lua_tonumber(L,<span class=\"number\">-1</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;width is %d ,height is %d\\n\\n&quot;</span>,*width,*height);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ReadTableFromItem</span><span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableName, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableItem)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L, lpszTableName);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    lua_pushstring(L, lpszTableItem);<span class=\"comment\">//首先把元素的名字压入栈顶  </span></span><br><span class=\"line\">    lua_gettable(L, <span class=\"number\">-2</span>);<span class=\"comment\">//值会放在栈顶，同时刚才压入的元素名字被弹出  </span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s.%s=%d\\n&quot;</span>, lpszTableName, lpszTableItem, (<span class=\"keyword\">int</span>)lua_tonumber(L, <span class=\"number\">-1</span>));  </span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ReadTableFromIndex</span><span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableName, <span class=\"keyword\">int</span> index)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L, lpszTableName);  </span><br><span class=\"line\">    lua_rawgeti(L, <span class=\"number\">-1</span>, index);<span class=\"comment\">//获得第一个元素  </span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s[%d]=%d\\n&quot;</span>, lpszTableName, index, (<span class=\"keyword\">int</span>)lua_tonumber(L, <span class=\"number\">-1</span>));  </span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">EnumTableItem</span><span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableName)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L, lpszTableName);  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> it = lua_gettop(L);  </span><br><span class=\"line\">    lua_pushnil(L);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enum %s:&quot;</span>, lpszTableName);  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lua_next(L, it))<span class=\"comment\">//用lua_next可以遍历这个数组  </span></span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;  %d&quot;</span>, (<span class=\"keyword\">int</span>)lua_tonumber(L, <span class=\"number\">-1</span>));  </span><br><span class=\"line\">        lua_pop(L, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n\\n&quot;</span>);  </span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;param error!\\n&quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> *filename = argv[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    lua_State *L = lua_open();  </span><br><span class=\"line\">    luaL_openlibs(L);  <span class=\"comment\">//新版本库添加的方法  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(luaL_loadfile(L,filename) || lua_pcall(L,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>))&#123;  </span><br><span class=\"line\">        luaL_error(L,<span class=\"string\">&quot;loadfile error! %s \\n&quot;</span>,lua_tostring(L,<span class=\"number\">-1</span>));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> w=<span class=\"number\">1</span>,h=<span class=\"number\">2</span>;  </span><br><span class=\"line\">    ReadVariable(L,&amp;w,&amp;h);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ReadTableFromItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>, <span class=\"string\">&quot;a&quot;</span>);  <span class=\"comment\">// 等价与lua代码：print(luat_Test1.a)  </span></span><br><span class=\"line\">    ReadTableFromItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>, <span class=\"string\">&quot;b&quot;</span>);  </span><br><span class=\"line\">    ReadTableFromItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>, <span class=\"string\">&quot;c&quot;</span>);  </span><br><span class=\"line\">    EnumTableItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>);    <span class=\"comment\">// 枚举Table  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ReadTableFromIndex(L, <span class=\"string\">&quot;luat_Test2&quot;</span>, <span class=\"number\">1</span>);  <span class=\"comment\">// 等价与lua代码：print(luat_Test1[1])  </span></span><br><span class=\"line\">    ReadTableFromIndex(L, <span class=\"string\">&quot;luat_Test2&quot;</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\">    ReadTableFromIndex(L, <span class=\"string\">&quot;luat_Test2&quot;</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">    EnumTableItem(L, <span class=\"string\">&quot;luat_Test2&quot;</span>);  </span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于配置文件安全的问题，一般会将这些<code>lua</code>文件进行加密。</p>\n<h2 id=\"excel转lua\"><a href=\"#excel转lua\" class=\"headerlink\" title=\"excel转lua\"></a>excel转lua</h2><p>配置文件多数以<code>excel</code>转<code>lua</code>的方式配置，网上也有很多相关工具。例如用<code>xlrd</code>。</p>\n<h3 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h3><p>用[]表示数组，如</p>\n<ul>\n<li>[123456,123457]表示两个物品</li>\n<li>[1,1001001,1]表示物品的类型、<code>code</code>、数量</li>\n<li>如果要配置多种数据，可以使用<code>json</code><h3 id=\"多key配置\"><a href=\"#多key配置\" class=\"headerlink\" title=\"多key配置\"></a>多key配置</h3>这个要写个配置文件，明确是用哪些字段作<code>key</code>。<h3 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h3>可以按这个格式：<blockquote>\n<p>2019-1-1 1:00:00<br>再根据需求转时间戳。</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/61\">Todos los caminos llevan a Roma.</a></p>\n","tags":["lua"]},{"title":"lua使用优化","url":"/post/4d7ca723.html","content":"<p>这里记录下一些<code>lua</code>使用优化操作。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a>堆栈溢出</h2><p>我们在运行<code>lua</code>的时候，有可能遇到这样一种报错 “stack overflow”，先看看下面一段代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func_r</span><span class=\"params\">(a)</span></span></span><br><span class=\"line\">    a = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a &gt; <span class=\"number\">100000</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        func_r(a)</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"> </span><br><span class=\"line\">x = <span class=\"number\">1</span></span><br><span class=\"line\">func_r(x)</span><br></pre></td></tr></table></figure>\n<p>语法上的确没有任何问题，但在执行的时候就会出现<code>stack overflow</code>的报错。是什么原因导致堆栈溢出呢？这个就要追究到<code>Lua</code>源码：<code>Lua</code>虚拟机会对堆栈进行一系列的检查（函数：<code>luaL_checkstack</code>），错误类型就有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">“too many arguments”，</span><br><span class=\"line\">“assume array is smaller than 2^40 “，</span><br><span class=\"line\">“string slice too long”，</span><br><span class=\"line\">“too many captures”，</span><br><span class=\"line\">“too many arguments to script”，</span><br><span class=\"line\">“too many nested functions”</span><br></pre></td></tr></table></figure>\n<p>例如，上面的代码就属于递归嵌套次数太多，默认限制20000。</p>\n<h2 id=\"不支持边遍历表边删除表中字段\"><a href=\"#不支持边遍历表边删除表中字段\" class=\"headerlink\" title=\"不支持边遍历表边删除表中字段\"></a>不支持边遍历表边删除表中字段</h2><p>当在遍历表的时候为不存在的字段赋值时，<code>next</code>的遍历顺序是未知的，然而，你可以在遍历时修改已有的字段，或者，你可以删除已经存在的字段。</p>\n<h2 id=\"使用局部变量local\"><a href=\"#使用局部变量local\" class=\"headerlink\" title=\"使用局部变量local\"></a>使用局部变量local</h2><p>这是最基础也是最有用的策略，虽然使用全局变量并不能完全避免，但还是应该尽量避免，取而代之使用局部变量即<code>local</code>。这里的局部变量也包括函数<code>function</code>，因为在<code>Lua</code>里函数也是一个变量。局部变量的存取会更快，而且在生命周期之外就会释放掉。</p>\n<h2 id=\"尾调用消除\"><a href=\"#尾调用消除\" class=\"headerlink\" title=\"尾调用消除\"></a>尾调用消除</h2><p><code>Lua</code>中的函数调用有两种，一种是标准的函数调用，它会需要生成新的一层调用栈，执行函数流程，然后弹出调用栈返回。另一种叫做尾调用，它是对标准函数调用的优化。尾调用不生成新的调用栈，而不复用当前的。在大多数函数式编程语言中，都需要对尾调用做特别优化。因为函数式语言特别依赖函数的层层调用，甚至用尾调用的方式来做循环。传统方式每次函数调用都需要生成新的栈帧，容易造成栈溢出。 尾调用可以看作<code>C</code>中的<code>goto</code>。</p>\n<p>当一个函数调用是另一个函数的最后一个动作时，该调用才算是一条“尾调用”。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> g(x) <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">--不是尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x)</span></span> g(x) <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>也就是说，当<code>f</code>调用完<code>g</code>之后就再无其他事情可做了。因此在这种情况中，程序就不需要返回那个“尾调用”所在的函数了。所以在“尾调用”之后，程序也不需要保存任何关于该函数的栈信息了。当<code>g</code>返回时，执行控制权可以直接返回到调用<code>f</code>的那个点上。使得在进行“尾调用”时不耗费任何栈空间。将这种实现称为支持“尾调用消除”。</p>\n<h2 id=\"传参时，少用…\"><a href=\"#传参时，少用…\" class=\"headerlink\" title=\"传参时，少用…\"></a>传参时，少用…</h2><p>…用于可变参数。如果在传参数过多时，为了方便使用…，会降低代码可读性（寻找参数）。</p>\n<h2 id=\"少用字符串连接操作符\"><a href=\"#少用字符串连接操作符\" class=\"headerlink\" title=\"少用字符串连接操作符\"></a>少用字符串连接操作符</h2><p>从<code>lua</code>字符串的<a href=\"https://github.com/losophy/losophy.github.io/issues/112\">实现</a>可知，运用字符串连接操作符每一次都会生成一个新的字符串。可使用<code>table</code>来模拟字符串缓冲区，避免了大量使用连接操作符。<code>table.concat()</code>。</p>\n<h2 id=\"table使用预填充技术\"><a href=\"#table使用预填充技术\" class=\"headerlink\" title=\"table使用预填充技术\"></a>table使用预填充技术</h2><p><code>Lua</code>解释器背着我们会对表进行重新散列的动作， <a href=\"https://github.com/losophy/losophy.github.io/issues/110\">lua Table</a>新增元素有详细解释。一个整数的<code>key</code>在同一个表中不同的阶段可能被分配到数组或者散列桶部分。<br>而这个操作的代价是挺大的。<br>如下面的代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">1</span>,<span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    a[i] = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>最开始，<code>Lua</code>创建了一个空表<code>a</code>。在第一次迭代中，<code>a[1]</code>为<code> true</code>触发了一次重新散列操作，<code>Lua</code>将数组部分的长度设置为<code>2^0</code>，即<code>1</code>，散列表部分仍为空。在第二次迭代中，<code>a[2]</code>为true再次触发了重新散列操作，将数组部分长度设为<code>2^1</code>，即<code>2</code>。最后一次迭代又触发了一次重新散列操作，将数组部分长度设为<code>2^2</code>，即4。<br>只有三个元素的表会执行三次重新散列操作，然而有100万个元素的表仅仅只会执行20次重新散列操作而已，因为2^20 = 1048576 &gt; 1000000。 但是，如果创建了非常多的长度很小的表（比如坐标点： point = {x=0, y=0｝），这可能会造成巨大的影响。所以，当需要创建非常多的小表时，应预先填充好表的大小，减少解释器被动地进行重新散列操作的过程。<br>如果你有很多很小的表需要创建，就可以预先填充以避免重新散列操作。比如：｛true, true,true}，<code>Lua</code>知道这个表有3个元素，所以直接创建了3个元素的数组。 类似地，｛ X=l, y=2, z＝3，}，<code>Lua</code>会在其散列表部分中创建长度为3的数组。<br>所以，上述代码使用了预填充技术为：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a = &#123;<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=l,<span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    a[i] = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"限制require到别的模块\"><a href=\"#限制require到别的模块\" class=\"headerlink\" title=\"限制require到别的模块\"></a>限制require到别的模块</h2><p>手工编写服务表，防止<code>require</code>到别的服务的<code>lua</code>模块<br>REQUIRE_CHECK_LIST = {<br>    [“A”] = true,<br>    [“B”] = true,<br>}</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> realrequire = <span class=\"built_in\">require</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"built_in\">loaded</span> = <span class=\"built_in\">package</span>.<span class=\"built_in\">loaded</span></span><br><span class=\"line\"><span class=\"built_in\">require</span> = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">( moduleName )</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">local</span> loadedModule = <span class=\"built_in\">loaded</span>[moduleName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> loadedModule ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> loadedModule</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">local</span> header = moduleName:<span class=\"built_in\">match</span>(<span class=\"string\">&quot;([^%.]*)%..*&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>  REQUIRE_CHECK_LIST[header] <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">print</span>(try to <span class=\"built_in\">require</span> others service)</span><br><span class=\"line\">\t\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> realrequire(moduleName)</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"将全局函数首先加载到局部变量中\"><a href=\"#将全局函数首先加载到局部变量中\" class=\"headerlink\" title=\"将全局函数首先加载到局部变量中\"></a>将全局函数首先加载到局部变量中</h2><p>从局部变盘和全局变量的获取来看，如果针对的是全局变量，那么会比局部变量额外多一条<code>GETGLOBAL</code>指令，用于将这个全局变量加载到当前函数栈中。因此，一个经常使用的全局变量，可以优化为首先加载到一个局部变量中，再针对这个局部变量进行使用。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>,<span class=\"number\">10000000</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> x = <span class=\"built_in\">math</span>.<span class=\"built_in\">sin</span>(i)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>使用局部变量优化：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"built_in\">sin</span> = <span class=\"built_in\">math</span>.<span class=\"built_in\">sin</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>,<span class=\"number\">10000000</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> x = <span class=\"built_in\">sin</span>(i)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/103\">En nombrando al ruin de Roma , luego asoma. nran a porfía.</a></p>\n","tags":["lua"]},{"title":"lua元表和元方法","url":"/post/e141c56e.html","content":"<p><code>lua</code>中提供的元表<code>(metatable)</code>与元方法<code>(metamethod)</code>是一种非常重要的语法，<code>metatable</code>主要用于做一些类似于<code>C++</code>重载操作符式的功能。元表与元方法会影响<code>table</code>的访问行为。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"元表的由来\"><a href=\"#元表的由来\" class=\"headerlink\" title=\"元表的由来\"></a>元表的由来</h2><p><code>Lua2.1</code>灵活语义问世，极大的增加了<code>Lua</code>的表达能力，从此，灵活语义就变成了<code>Lua</code>的标志。</p>\n<p>灵活语义的一个目标是允许<code>table</code>作为对象和类的基础。为了实现这个目标，需要实现<code>table</code>的继承。另一个目标是将<code>userdata</code>变成应用数据的天然代理，可以作为函数参数而不只是一个句柄。<code>userdata</code>希望能够索引，就好像他们只是一个<code>table</code>，可供调用他们身上的方法。所以<code>fallback</code>机制的实现，让<code>Lua</code>把未定义行为交给程序员处理，而不是直接在语言本身实现这些特性。</p>\n<p><code>Lua2.1</code>提供了<code>fallback</code>机制，支持以下行为：<code>table</code>索引，算术操作符，字符串拼接，顺序比较，函数调用。当这些操作应用到“错误”的类型上，对应的<code>fallback</code>就会被调用到，允许程序员决定<code>Lua</code>如何处理。<code>table</code>索引<code>fallback</code>允许<code>userdata</code>和其它值类型表现的跟表一样。定义当<code>Key</code>不在<code>table</code>时的<code>fallback</code>，从而实现多种形式的继承（通过委托）。为了完善面向对象编程，添加了两个语法糖：<code>function a:foo(…)</code>就好比<code>function a.foo(self,…)</code>一样，以及<code>a:foo(…)</code>作为<code>a.foo(a, …)</code>的语法糖。</p>\n<p><code>Lua2.1</code>里引入的<code>fallback</code>机制，可以很好的支持灵活扩展的语义，但这个机制是全局的：每个事件只有一个钩子。这让共享或重用代码变的很艰难，因为同一事件的<code>fallback</code>在模块里只能定义一次，不能共存。<code>Lua 3.0</code>解决了<code>fallback</code>冲突问题。<code>fallback</code>替换为<code>tag</code>方法：钩子是以<code>(event, tag)</code>的形式挂在字典里的。<code>Tags</code>是在<code>Lua2.1</code>引入的整数标签，可以附在<code>userdata</code>上。最初的动机是希望同类的<code>C</code>对象，在<code>Lua</code>里都有相同的<code>tag</code>(不过，<code>Lua</code>没有强迫要对<code>Tag</code>提供解释)。<code>Lua3.0</code>里对所有值类型提供了<code>tag</code>支持，以支持对应的<code>tag</code>方法。</p>\n<p>标记方法机制工作的很好，一直存续到<code>Lua 5.0</code>为止。在<code>Lua 5.0</code>实现了元表和元方法来取代标记和标记方法。元表只是普通的<code>Lua table</code>，所以可以用<code>Lua</code>直接操作，不需要特殊函数。就像标记一样，元表可以用来表示<code>userdata</code>和<code>table</code>的用户定义类型：所有“同类”对象应该共享同一个元表。不像标记，元表和他们的内容会在所有引用消失后自动被回收掉。（相反，标记和标记方法会等到程序结束才会被回收。）元表的引入同时简化了实现：标记方法需要在<code>Lua</code>核心代码里添加特殊的私有表示方法，元表主要就是标准的<code>table</code>机制。<br>下面的代码展示了<code>Lua 5.0</code>里，继承是如何实现的。<code>index</code>元方法取代了<code>index</code>标记，元表里则是用<code>__index</code>域来表示。代码通过将<code>b</code>的元表里的<code>__index</code>域指向<code>a</code>，实现了<code>b</code>继承<code>a</code>。（一般情况下，<code>index</code>元方法都是函数，但允许它设为<code>table</code>，以直接支持简单的委托继承。）</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a=Window&#123;x=<span class=\"number\">100</span>, y=<span class=\"number\">200</span>, color=<span class=\"string\">&quot;red&quot;</span>&#125;</span><br><span class=\"line\">b=Window&#123;x=<span class=\"number\">300</span>, y=<span class=\"number\">400</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">setmetatable</span>(b, &#123;<span class=\"built_in\">__index</span> = a&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b.color) —&gt;red</span><br></pre></td></tr></table></figure>\n<h2 id=\"元方法\"><a href=\"#元方法\" class=\"headerlink\" title=\"元方法\"></a>元方法</h2><p>在<code>Lua</code>中有一个元表，也就是上面说的<code>metatable</code>，我们可以通过元表来修改一个值得行为，使其在面对一个非预定义的操作时执行一个指定的操作。比如，现在有两个<code>table</code>类型的变量<code>a</code>和<code>b</code>，我们可以通过<code>metatable</code>定义如何计算表达式<code>a+b</code>。<br>我们是使用<code>getmetatable</code>来获取一个<code>table</code>或<code>userdata</code>类型变量的元表，当创建新的<code>table</code>变量时，使用<code>getmetatable</code>去获得元表，将返回<code>nil</code>；同理，我们也可以使用<code>setmetatable</code>去设置一个<code>table</code>或<code>userdata</code>类型变量的元表。<br>在<code>table</code>中，我可以重新定义的元方法有以下几个：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">__add</span>(a, b) <span class=\"comment\">--加法</span></span><br><span class=\"line\"><span class=\"built_in\">__sub</span>(a, b) <span class=\"comment\">--减法</span></span><br><span class=\"line\"><span class=\"built_in\">__mul</span>(a, b) <span class=\"comment\">--乘法</span></span><br><span class=\"line\"><span class=\"built_in\">__div</span>(a, b) <span class=\"comment\">--除法</span></span><br><span class=\"line\"><span class=\"built_in\">__mod</span>(a, b) <span class=\"comment\">--取模</span></span><br><span class=\"line\"><span class=\"built_in\">__pow</span>(a, b) <span class=\"comment\">--乘幂</span></span><br><span class=\"line\"><span class=\"built_in\">__unm</span>(a) <span class=\"comment\">--相反数</span></span><br><span class=\"line\"><span class=\"built_in\">__concat</span>(a, b) <span class=\"comment\">--连接</span></span><br><span class=\"line\"><span class=\"built_in\">__len</span>(a) <span class=\"comment\">--长度</span></span><br><span class=\"line\"><span class=\"built_in\">__eq</span>(a, b) <span class=\"comment\">--相等</span></span><br><span class=\"line\"><span class=\"built_in\">__lt</span>(a, b) <span class=\"comment\">--小于</span></span><br><span class=\"line\"><span class=\"built_in\">__le</span>(a, b) <span class=\"comment\">--小于等于</span></span><br><span class=\"line\"><span class=\"built_in\">__index</span>(a, b) <span class=\"comment\">--索引查询</span></span><br><span class=\"line\"><span class=\"built_in\">__newindex</span>(a, b, c) <span class=\"comment\">--索引更新（PS：不懂的话，后面会有讲）</span></span><br><span class=\"line\"><span class=\"built_in\">__call</span>(a, ...) <span class=\"comment\">--执行方法调用</span></span><br><span class=\"line\"><span class=\"built_in\">__tostring</span>(a) <span class=\"comment\">--字符串输出</span></span><br><span class=\"line\"><span class=\"built_in\">__metatable</span> <span class=\"comment\">--保护元表</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"元表的实现\"><a href=\"#元表的实现\" class=\"headerlink\" title=\"元表的实现\"></a>元表的实现</h2><h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《The evolution of Lua》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/107\">Tierra tan rica en belleza, que incontables héroes la ho.</a></p>\n","tags":["lua"]},{"title":"lua函数与闭包","url":"/post/d1fa9805.html","content":"<p>在<code>lua</code>中，函数是一种第一类值，它们具有特定的词法域。<br><code>lua</code>当中函数是一个值，他可以存在变量中（无论全局变量还是局部变量）或<code>table</code>中，可以作为函数参数，可以作为返回值。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"upvalue\"><a href=\"#upvalue\" class=\"headerlink\" title=\"upvalue\"></a>upvalue</h2><p>词法域：当一个函数内嵌套另一个函数的时候，内函数可以访问外部函数的局部变量。这也意味着<code>lua</code>完全可以包含“λ演算（Lambda Calculus）”。<br>这个特性在以下场景特别有用：匿名函数作为高阶函数的参数，用于<code>table</code>遍历和模式匹配。</p>\n<p>在<code>lua</code>中，函数可以看作一个“值”，由一些表达式创建的。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> <span class=\"number\">2</span>*x <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>举个例子：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">network = &#123;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;grauna&quot;</span>, IP = <span class=\"string\">&quot;210.26.30.34&quot;</span>&#125;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;arraial&quot;</span>, IP = <span class=\"string\">&quot;210.26.30.23&quot;</span>&#125;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;lua&quot;</span>, IP = <span class=\"string\">&quot;210.26.23.12&quot;</span>&#125;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;derain&quot;</span>, IP = <span class=\"string\">&quot;210.26.23.20&quot;</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">sort</span>(network, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(a,b)</span></span> <span class=\"keyword\">return</span>(a.name&gt;b.name) <span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<p>这种用法叫匿名函数，在语句中显示出了极好的便捷性。</p>\n<h2 id=\"闭包-closure\"><a href=\"#闭包-closure\" class=\"headerlink\" title=\"闭包(closure)\"></a>闭包(closure)</h2><p>如果说<code>C++</code>式的面向对象编程是把一组函数绑定到特定数据类型上的话，那么闭包可以说是把一组数据绑定到特定函数上。<br>闭包通过调用含有一个内部函数加上该外部函数持有的外部局部变量<code>（upvalue）</code>的外部函数（就是工厂）产生的一个实例函数<br>闭包组成：外部函数+外部函数创建的<code>upvalue</code>+内部函数（闭包函数）</p>\n<p><code>Lua</code>中有闭包，函数是闭包一种特殊情况。</p>\n<h2 id=\"…\"><a href=\"#…\" class=\"headerlink\" title=\"…\"></a>…</h2><p>当一个变参函数被调用，对应…的参数将会收集到一个叫<code>arg</code>的<code>table</code>里。这种方式虽然很简单便捷，但是要把这些参数传给另一个函数，就需要解包这个<code>table</code>。因为程序员经常将参数传递给另一个函数，<code>Lua 5.1</code>允许…用于参数列表和赋值表达式的右值。这避免了没必要的创建<code>arg table</code>。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/68\">No se fundó Roma en una hora.Del dichoal hecho hay mucho trecho.</a></p>\n","tags":["lua"]},{"title":"lua协程","url":"/post/9ff34ca8.html","content":"<p>协同程序与线程差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时又与其他协同程序共享全局变量和其他大部分东西。<br>一个具有多个协同程序的程序在任意时刻只能运行一个协同程序。</p>\n<a id=\"more\"></a>\n\n<p><code>lua</code>将所有关于协同程序的函数放置在一个名为“coroutine”的<code>table</code>中。</p>\n<p>一个协同程序可以处于4种不同的状态：挂起、运行、死亡和正常。</p>\n<blockquote>\n<p>程序初创建：挂起<br>程序运行：运行<br>程序结束：死亡<br>程序被其实程序唤醒：正常</p>\n</blockquote>\n<p><code>co_create</code>传一个函数参数，用来创建协程。返回一个“thread”对象：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">co = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a,b)</span></span></span><br><span class=\"line\">        <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">yield</span>(a+b,a-b)</span><br><span class=\"line\">        <span class=\"keyword\">end</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">coroutine</span>.<span class=\"built_in\">resume</span>(co,<span class=\"number\">20</span>,<span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n<p>与协同程序之间的对称性区别相比，协同程序与<code>generator</code>（<code>Python</code>所提供的）之间的区别很大。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>协程实现的两个关键点在于：</p>\n<ul>\n<li>协程状态的保存</li>\n<li>不同协程之间的数据通信机制 </li>\n</ul>\n<p>在<code>Lua</code>代码中，使用的是<code>lua_State</code>结构体来表示协程，这与<code>Lua</code>虚拟机用的是同一个数据结构 。 这一点可以从创建协程的函数<code>lua_newthread</code>中看出来，唯一有区别的是， <code>Lua</code>协程的类型是<code>LUA_TTHREAD</code>。 换言之，在<code>Lua</code>源码的处理中， <code>Lua</code>协程与<code>Lua</code>虚拟机的表现形式并没有太大差异，也许这样做是为了实现方便。 前面提到过，一个协程有自己私有的环境，不会因为协程的切换而发生改变 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API lua_State *<span class=\"title\">lua_newthread</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  lua_State *L1;</span><br><span class=\"line\">  lua_lock(L);</span><br><span class=\"line\">  luaC_checkGC(L);</span><br><span class=\"line\">  L1 = luaE_newthread(L);</span><br><span class=\"line\">  setthvalue(L, L-&gt;top, L1);</span><br><span class=\"line\">  api_incr_top(L);</span><br><span class=\"line\">  lua_unlock(L);</span><br><span class=\"line\">  luai_userstatethread(L, L1);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> L1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">lua_State *<span class=\"title\">luaE_newthread</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State)));</span><br><span class=\"line\">  luaC_link(L, obj2gco(L1), LUA_TTHREAD);</span><br><span class=\"line\">  preinit_state(L1, G(L));</span><br><span class=\"line\">  stack_init(L1, L);  <span class=\"comment\">/* init stack */</span></span><br><span class=\"line\">  setobj2n(L, gt(L1), gt(L));  <span class=\"comment\">/* share table of globals */</span></span><br><span class=\"line\">  L1-&gt;hookmask = L-&gt;hookmask;</span><br><span class=\"line\">  L1-&gt;basehookcount = L-&gt;basehookcount;</span><br><span class=\"line\">  L1-&gt;hook = L-&gt;hook;</span><br><span class=\"line\">  resethookcount(L1);</span><br><span class=\"line\">  lua_assert(iswhite(obj2gco(L1)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> L1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们来看看如何在不同协程之间通信，或者说<code>Lua</code>协程间数据的交换。 前面提到过<code>resume</code>和<code>yield</code>函数的参数就是用来做协程数据交换的，现在来看看里面的实现 。 奥秘就在函数<code>lua_xmove</code>中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API <span class=\"keyword\">void</span> <span class=\"title\">lua_xmove</span> <span class=\"params\">(lua_State *from, lua_State *to, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (from == to) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  lua_lock(to);</span><br><span class=\"line\">  api_checknelems(from, n);</span><br><span class=\"line\">  api_check(from, G(from) == G(to));</span><br><span class=\"line\">  api_check(from, to-&gt;ci-&gt;top - to-&gt;top &gt;= n);</span><br><span class=\"line\">  from-&gt;top -= n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    setobj2s(to, to-&gt;top++, from-&gt;top + i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_unlock(to);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码做的事情就是，从<code>from</code>协程中移动<code>n</code>个数据到<code>to</code>协程中 。 当然在移动之前，数据要在<code>from</code>协程的栈顶上准备好。<br>创建协程在函数<code>luaB _cocreate</code>中进行．</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">luaB_cocreate</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  lua_State *NL = lua_newthread(L);<span class=\"comment\">//调用lua newthread创建lua State结构体</span></span><br><span class=\"line\">  luaL_argcheck(L, lua_isfunction(L, <span class=\"number\">1</span>) &amp;&amp; !lua_iscfunction(L, <span class=\"number\">1</span>), <span class=\"number\">1</span>,<span class=\"comment\">//检查当前栈顶的元素是不是一个函数对象，因为需要一个函数作为协程开始运行时的主函数。 这个主函数必须是Lua函数， C函数将会报错</span></span><br><span class=\"line\">    <span class=\"string\">&quot;Lua function expected&quot;</span>);</span><br><span class=\"line\">  lua_pushvalue(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* move function to top */</span><span class=\"comment\">//将协程主函数压入当前 lua State 的栈中</span></span><br><span class=\"line\">  lua_xmove(L, NL, <span class=\"number\">1</span>);  <span class=\"comment\">/* move function from L to NL */</span><span class=\"comment\">//调用 lua xmove 将该函数从当前的lua State移动到新创建的协程的 lua State栈中</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>了解了<code>Lua</code>协程实现相关的数据结构，接下来看看最核心的两个操作<code>resume</code>和<code>yield</code>是如何实现的 。<br><code>resume</code>操作在函数<code>luaB_coresume</code>中实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">luaB_coresume</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  lua_State *co = lua_tothread(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">  luaL_argcheck(L, co, <span class=\"number\">1</span>, <span class=\"string\">&quot;coroutine expected&quot;</span>);<span class=\"comment\">//检查当前栈顶元素是不是协程指针</span></span><br><span class=\"line\">  r = auxresume(L, co, lua_gettop(L) - <span class=\"number\">1</span>);<span class=\"comment\">//调用辅助函数auxresume进行实际的resume操作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//根据auxresume的返回值来做不同的处理。 当返回值小于0时，说明 resume操作出错，并且此时出错信息在栈顶，因此压入false以及出错消息</span></span><br><span class=\"line\">    lua_pushboolean(L, <span class=\"number\">0</span>);</span><br><span class=\"line\">    lua_insert(L, <span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;  <span class=\"comment\">/* return false + error message */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//否则， auxresume的返回值表示执行resume操作时返回的参数数量，这种情况下压入true以及这些返回参数</span></span><br><span class=\"line\">    lua_pushboolean(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">    lua_insert(L, -(r + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span>;  <span class=\"comment\">/* return true + `resume&#x27; returns */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>auxresume</code>函数的实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">auxresume</span> <span class=\"params\">(lua_State *L, lua_State *co, <span class=\"keyword\">int</span> narg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_checkstack(co, narg))<span class=\"comment\">//检查数据的合法性</span></span><br><span class=\"line\">    luaL_error(L, <span class=\"string\">&quot;too many arguments to resume&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lua_status(co) == <span class=\"number\">0</span> &amp;&amp; lua_gettop(co) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    lua_pushliteral(L, <span class=\"string\">&quot;cannot resume dead coroutine&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  <span class=\"comment\">/* error flag */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_xmove(L, co, narg);<span class=\"comment\">//将参数通过lua_xmove函数传递到待启动的协程中</span></span><br><span class=\"line\">  status = lua_resume(co, narg);<span class=\"comment\">//调用 lua_resume函数执行协程代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status == <span class=\"number\">0</span> || status == LUA_YIELD) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nres = lua_gettop(co);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lua_checkstack(L, nres))</span><br><span class=\"line\">      luaL_error(L, <span class=\"string\">&quot;too many results to resume&quot;</span>);</span><br><span class=\"line\">    lua_xmove(co, L, nres);  <span class=\"comment\">/* move yielded values */</span><span class=\"comment\">// 当 lua_resume函数返回时，说明该协程已经执行完毕，通过lua_xmove函数将yield传入的参数传递回启动该协程的协程</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nres;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    lua_xmove(co, L, <span class=\"number\">1</span>);  <span class=\"comment\">/* move error message */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  <span class=\"comment\">/* error flag */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>auxresume</code>函数会调用<code>lua resume</code>函数，在<code>lua resume</code>函数中进行一些检查，比如当前的状态是否合理，调用层次是否过多，最终使用<code>luaD_rawrunprotected</code>函数来保护调用<code>resume</code>函数 。<br><code>resume</code>函数的代码如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">resume</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">void</span> *ud)</span> </span>&#123;</span><br><span class=\"line\">  StkId firstArg = cast(StkId, ud);</span><br><span class=\"line\">  CallInfo *ci = L-&gt;ci;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;status == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">/* start coroutine? */</span><span class=\"comment\">//如果当前协程的状态是0 ，那么说明它是第一次执行 resume操作</span></span><br><span class=\"line\">    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (luaD_precall(L, firstArg - <span class=\"number\">1</span>, LUA_MULTRET) != PCRLUA)<span class=\"comment\">//调用 luaD_precall做函数调用前的准备工作</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;<span class=\"comment\">//如果luaD_precall函数的返回值不是PCRLUA ，说明是在C函数中进行resume操作的，此时并不需要后面的 luaV execute函数，就直接返回了</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* resuming from previous yield */</span><span class=\"comment\">//否则就从之前的 YIELD状态中继续执行</span></span><br><span class=\"line\">    lua_assert(L-&gt;status == LUA_YIELD);</span><br><span class=\"line\">    L-&gt;status = <span class=\"number\">0</span>;<span class=\"comment\">//首先将协程的状态置为0 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!f_isLua(ci)) &#123;  <span class=\"comment\">/* `common&#x27; yield? */</span><span class=\"comment\">//判断此时ci的类型</span></span><br><span class=\"line\">      <span class=\"comment\">/* finish interrupted execution of `OP_CALL&#x27; */</span></span><br><span class=\"line\">      lua_assert(GET_OPCODE(*((ci<span class=\"number\">-1</span>)-&gt;savedpc - <span class=\"number\">1</span>)) == OP_CALL ||</span><br><span class=\"line\">                 GET_OPCODE(*((ci<span class=\"number\">-1</span>)-&gt;savedpc - <span class=\"number\">1</span>)) == OP_TAILCALL);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (luaD_poscall(L, firstArg))  <span class=\"comment\">/* complete it... */</span><span class=\"comment\">//如果不是Lua函数，说明之前是被中断的函数调用，此时调用luaD_poscall函数继续完成未完的函数操作</span></span><br><span class=\"line\">        L-&gt;top = L-&gt;ci-&gt;top;  <span class=\"comment\">/* and correct top if not multiple results */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"comment\">/* yielded inside a hook: just continue its execution */</span></span><br><span class=\"line\">      L-&gt;base = L-&gt;ci-&gt;base;<span class=\"comment\">//否则只需要调整 base指针指向之前的ci的base指针即可</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));<span class=\"comment\">//以上的几种情况最终都会调用 luaV_execute 函数来进入 Lua虚拟机中执行 。 这里可以看到，由于使用了同样的结构lua State来表示Lua虚拟机和Lua协程，在表达Lua虚拟机的执行和协程的执行上，两者都是统一使用 luaV execute函数，方便了实现。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>yield</code>操作在函数<code>lua_yield</code>中进行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API <span class=\"keyword\">int</span> <span class=\"title\">lua_yield</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> nresults)</span> </span>&#123;</span><br><span class=\"line\">  luai_userstateyield(L, nresults);</span><br><span class=\"line\">  lua_lock(L);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;nCcalls &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    luaG_runerror(L, <span class=\"string\">&quot;attempt to yield across metamethod/C-call boundary&quot;</span>);</span><br><span class=\"line\">  L-&gt;base = L-&gt;top - nresults;  <span class=\"comment\">/* protect stack slots below */</span></span><br><span class=\"line\">  L-&gt;status = LUA_YIELD;</span><br><span class=\"line\">  lua_unlock(L);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数做的事情相比起来就简单多了，就是将协程执行状态至为<code>YIELD</code>，这样可以终止<code>luaV_execute</code>函数的循环。<br><img src=\"https://user-images.githubusercontent.com/11263320/113825795-fdec6400-97b3-11eb-8f8f-40a19ca2088f.JPG\" alt=\"捕获\"></p>\n<h2 id=\"从lua-5-1-1中分离出来的协程实现代码\"><a href=\"#从lua-5-1-1中分离出来的协程实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的协程实现代码\"></a>从lua-5.1.1中分离出来的协程实现代码</h2><p><a href=\"https://gist.github.com/losophy/f3db9c6959ce9c472719e3798b0b0baa\">lthread.c</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/69\">Quien siembra vientos , recoge tempestades.</a></p>\n","tags":["lua"]},{"title":"lua字符串","url":"/post/fd55994a.html","content":"<p><code>c</code>语言没有自带字符串类型，这导致有非常多的用<code>c</code>写的软件都自己实现一个处理字符串的类型。<br>一般来说，要表示一个字符串，核心就是以下两个数据：</p>\n<ul>\n<li>字符串长度 </li>\n<li>指向存放字符串内存数据的指针</li>\n</ul>\n<p><code>Lua</code>自己的字符串类型的实现也没有绕过这两个核心内容。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"内化的字符串\"><a href=\"#内化的字符串\" class=\"headerlink\" title=\"内化的字符串\"></a>内化的字符串</h2><ul>\n<li>在<code>Lua</code>虚拟机中存在一个<strong>全局的数据区</strong>，用来存放当前系统中的所有字符串 </li>\n<li>同一个字符串数据，在<code>Lua</code>虚拟机中<strong>只可能有一份副本</strong>，一个字符串一旦创建，将是不可变更的 </li>\n<li>变量<strong>存放的仅是字符串的引用</strong>，而不是其实际内容</li>\n</ul>\n<p><code>Lua</code>在字符串实现上使用内化这种方案<code>（hash）</code>的优点在于，进行字符串数据的比较和查找操作时，性能会提升不少，因为这两个操作的核心都是字符串的比较。传统的字符串比较算法是根据字符串长度逐位来进行对比，这个时间复杂度与字符串长度线性相关；而内化之后，在已知字符串散列值的情况下，只需要一次整数的比较即可（lua字符串的比较是检测字符串的hash是否一样来判断两个字符串是否相等）。这个实现还有另一大好处，那就是空间优化，多份。<br>相同的字符串在整个系统中只存在一份副本。<code>Lua</code>是一个在设计之初就把性能、资源占用等放在重要位置的语言，这里再一次得到了体现。<br>当然，这个实现并不是完全没有缺陷的。以前面描述的创建字符串的过程来说，在创建一个新的字符串时，首先会检查系统中是否有相同的数据，只有不存在的情况下才创建，这与直接创建字符串相比，多了一次查找过程。 </p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TString</span> &#123;</span></span><br><span class=\"line\">  L_Umaxalign dummy;  <span class=\"comment\">/* ensures maximum alignment for strings */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    CommonHeader;</span><br><span class=\"line\">    lu_byte reserved;<span class=\"comment\">//是否是Lua虚拟机中的保留字符串，1不会在GC阶段被回收</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">//字符串的散列值</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len;<span class=\"comment\">//字符串长度 </span></span><br><span class=\"line\">  &#125; tsv;</span><br><span class=\"line\">&#125; TString;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这是一个联合体，其目的是为了让<code>TString</code>数据类型按照<code>L_Umaxalign</code>类型来对齐。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUAI_USER_ALIGNMENT_T\tunion &#123; double u; void *s; long l; &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> LUAI_USER_ALIGNMENT_T L_Umaxalign;</span><br></pre></td></tr></table></figure>\n<p>在<code>C</code>语言中，<code>struct/union</code>这样的复合数据类型是按照这个类型中最大对齐量的数据来对齐的，所以这里就是按照<code>double</code>类型的对齐量来对齐的。 之所以要进行对齐操作，是为了在<code>CPU</code>读取数据时性能更高 。</p>\n<p><code>Lua</code>会把系统中的所有字符串存在一个全局的地方，这个全局变量就是<code>global_state</code>的<code>strt</code>成员。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_State</span> &#123;</span></span><br><span class=\"line\">  stringtable strt;  <span class=\"comment\">/* hash table for strings */</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; global_State;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stringtable</span> &#123;</span></span><br><span class=\"line\">  GCObject **hash;<span class=\"comment\">//这是一个散列数组，专门用于存放字符串</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; stringtable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">GCObject</span> &#123;</span></span><br><span class=\"line\">  GCheader gch;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TString</span> <span class=\"title\">ts</span>;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当新创建一个字符串<code>TString</code>时，首先根据散列算法算出散列值，这就是<code>strt</code>数组的索引值。如果这里已经有元素，则使用链表串接起来。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TString *<span class=\"title\">luaS_newlstr</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str, <span class=\"keyword\">size_t</span> l)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (l1=l; l1&gt;=step; l1-=step)  <span class=\"comment\">/* compute hash */</span></span><br><span class=\"line\">    h = h ^ ((h&lt;&lt;<span class=\"number\">5</span>)+(h&gt;&gt;<span class=\"number\">2</span>)+cast(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>, str[l1<span class=\"number\">-1</span>]));</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];</span><br><span class=\"line\">       o != <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       o = o-&gt;gch.next) &#123;<span class=\"comment\">//如果这里已经有元素，则使用链表串接起来</span></span><br><span class=\"line\">    TString *ts = rawgco2ts(o);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ts-&gt;tsv.len == l &amp;&amp; (<span class=\"built_in\">memcmp</span>(str, getstr(ts), l) == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* string may be dead */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isdead(G(L), o)) changewhite(o);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newlstr(L, str, l, h);  <span class=\"comment\">/* not found */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TString *<span class=\"title\">newlstr</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str, <span class=\"keyword\">size_t</span> l,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ts = cast(TString *, luaM_malloc(L, (l+<span class=\"number\">1</span>)*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>)+<span class=\"keyword\">sizeof</span>(TString)));</span><br><span class=\"line\">  ts-&gt;tsv.len = l;</span><br><span class=\"line\">  ts-&gt;tsv.hash = h;</span><br><span class=\"line\">  ts-&gt;tsv.marked = luaC_white(G(L));</span><br><span class=\"line\">  ts-&gt;tsv.tt = LUA_TSTRING;</span><br><span class=\"line\">  ts-&gt;tsv.reserved = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(ts+<span class=\"number\">1</span>, str, l*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));</span><br><span class=\"line\">  ((<span class=\"keyword\">char</span> *)(ts+<span class=\"number\">1</span>))[l] = <span class=\"string\">&#x27;\\0&#x27;</span>;  <span class=\"comment\">/* ending 0 */</span></span><br><span class=\"line\">  tb = &amp;G(L)-&gt;strt;</span><br><span class=\"line\">  h = lmod(h, tb-&gt;size);</span><br><span class=\"line\">  ts-&gt;tsv.next = tb-&gt;hash[h];  <span class=\"comment\">/* chain new entry */</span></span><br><span class=\"line\">  tb-&gt;hash[h] = obj2gco(ts);</span><br><span class=\"line\">  tb-&gt;nuse++;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/111952507-3afff780-8b20-11eb-8aa4-400918ef6e1d.JPG\" alt=\"捕获\"></p>\n<h2 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h2><p>当数据量非常大时，分配到每个桶上的数据也会非常多，这样一次查找也退化成了一次线性的查找过程。<code>Lua</code>中也考虑了这种情况，所以有一个重新散列<code>（ rehash ）</code>的过程，这就是当字符串数据非常多时，会重新分配桶的数量，降低每个桶上分配到的数据数量，这个过程在函数<code>luaS_resize</code>中。</p>\n<p>有两处关于<code>luaS_resize</code>函数的调用：</p>\n<ul>\n<li><code>lgc.c</code>的<code>checkSizes</code>函数：这里会进行检查，如果此时桶的数量太大，比如是实际存放的字符串数量的4倍，那么会将散列桶数组减少为原来的一半。</li>\n<li><code>lstring.c</code>的<code>newlstr</code>函数：如果此时字符串的数量大于桶数组的数量，且桶数组的数量小于<code>MAX_INT/2</code>，那么就进行翻倍的扩容。</li>\n</ul>\n<h2 id=\"从lua-5-1-1中分离出来的字符串实现代码\"><a href=\"#从lua-5-1-1中分离出来的字符串实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的字符串实现代码\"></a>从lua-5.1.1中分离出来的字符串实现代码</h2><p><a href=\"https://gist.github.com/losophy/2dab2916b752088ddb669aa6fed42450\">lstring</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《Lua设计与实现》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/112\">Ayúdate que Dios te ayudará. A quien madruga Dios le ayuda.</a></p>\n","tags":["lua"]},{"title":"lua数据类型","url":"/post/ac3dad1f.html","content":"<p><code>Lua</code>是动态类型语言,变量不要类型定义,只需要为变量赋值。 值可以存储在变量中,作为参数传递或结果返回。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"八种基本数据类型\"><a href=\"#八种基本数据类型\" class=\"headerlink\" title=\"八种基本数据类型\"></a>八种基本数据类型</h2><p><code>Lua</code>的类型系统是相对稳定的。很长时间里，<code>Lua</code>只有6个基本类型：<code>nil</code>，<code>number</code>，<code>string</code>，<code>table</code>，<code>function</code>和<code>userdata</code>（实际上，直到<code>Lua 3.0</code>为止，之前的<code>C</code>函数和<code>Lua</code>函数有不同的内部类型，但是这个差异对于调用者是透明的）。唯一真正的改变来自于<code>Lua 5.0</code>，这个版本引入了两个新类型：<code>thread</code>和<code>boolean</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TNONE\t(-1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TNIL\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TBOOLEAN\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TLIGHTUSERDATA\t2        <span class=\"comment\">//void *</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TNUMBER\t3                        <span class=\"comment\">//lua3后采用double精度表示数字整型</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TSTRING\t4                        <span class=\"comment\">//TString</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TTABLE\t5                        <span class=\"comment\">//Table</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TFUNCTION\t6                <span class=\"comment\">//CClosure、LClosure</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TUSERDATA\t7                <span class=\"comment\">//void *</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TTHREAD\t8                        <span class=\"comment\">//协程</span></span></span><br></pre></td></tr></table></figure>\n<p>变量第一次赋值之前，值为<code>nil</code>。</p>\n<h2 id=\"第一类值\"><a href=\"#第一类值\" class=\"headerlink\" title=\"第一类值\"></a>第一类值</h2><p><code>lua</code>中所有值都是第一类值，他们可以存在变量中（无论全局变量还是局部变量）或<code>table</code>中，可以作为函数参数，可以作为返回值。</p>\n<h2 id=\"Lua通用数据结构的实现\"><a href=\"#Lua通用数据结构的实现\" class=\"headerlink\" title=\"Lua通用数据结构的实现\"></a>Lua通用数据结构的实现</h2><h3 id=\"C语言中实现通用数据结构的一般做法\"><a href=\"#C语言中实现通用数据结构的一般做法\" class=\"headerlink\" title=\"C语言中实现通用数据结构的一般做法\"></a>C语言中实现通用数据结构的一般做法</h3><p>如果要使用一个通用的数据结构来表示不同的数据类型，一般的做法是：</p>\n<ul>\n<li>需要一个字段来存储数据的类型</li>\n<li>需要存储不同的数据类型的数据 </li>\n</ul>\n<p>这里有这两种<a href=\"https://stackoverflow.com/questions/61200681/what-are-the-pros-and-cons-of-these-twoa-common-data-structure-to-represent-dif\">实现方法</a></p>\n<blockquote>\n<ol>\n<li>定义一个公共的数据结构作为基础类型，里面存储的都是表达这个数据的基础信息，其他具体的类型是从这里派生出来的 。 这就是一般的面向对象的思路。</li>\n<li> 使用联舍<code>（ union ）</code>来将所有数据包进来</li>\n</ol>\n</blockquote>\n<p>上面两种做法各有利弊 。 在Lua代码中，一般采用两种做法相结合的方式。</p>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p><code>Lua</code>需要进行<code>GC</code>操作的数据类型都会有一个<code>CommonHeader</code>宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>\n<p>任何需要进行垃圾回收处理的<code>Lua</code>数据类型，必然以<code>CommonHeader</code>作为该结构体定义的最开始部分。如果熟悉C++类的实现原理，可以将<code>CommoHeader</code>这个成员理解为一个基类的所有成员，而其他需要回收处理的数据类型均从这个基类继承下来，所以它们的结构体定义的开始部分就是这个成员。</p>\n<p>还有一个名为<code>GCheader</code>的结构体，其中的成员只有<code>Common Header</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GCheader</span> &#123;</span></span><br><span class=\"line\">    CommonHeader;</span><br><span class=\"line\">&#125; GCheader;</span><br></pre></td></tr></table></figure>\n<p>于是，在<code>Lua</code>中就使用了<code>GCObject</code>联合体将所有需要进行垃圾回收的数据类型囊括了进来：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">GCObject</span> &#123;</span></span><br><span class=\"line\">  GCheader gch;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TString</span> <span class=\"title\">ts</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Udata</span> <span class=\"title\">u</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Closure</span> <span class=\"title\">cl</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Table</span> <span class=\"title\">h</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proto</span> <span class=\"title\">p</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UpVal</span> <span class=\"title\">uv</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_State</span> <span class=\"title\">th</span>;</span>  <span class=\"comment\">/* thread */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>GCObject</code>这个联合体，将所有需要进行垃圾回收的数据类型全部囊括其中，这样定位和查找不同类型的数据时就方便多了。</p>\n<p>还有几种数据类型是不需要进行垃圾回收的，<code>Lua</code>中将<code>GCObject</code>和它们一起放在了联合体<code>Value</code>中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">  GCObject *gc;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *p;<span class=\"comment\">//LUA_TLIGHTUSERDATA</span></span><br><span class=\"line\">  lua_Number n;<span class=\"comment\">//LUA_TNUMBER</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;<span class=\"comment\">//LUA_TBOOLEAN</span></span><br><span class=\"line\">&#125; Value;</span><br></pre></td></tr></table></figure>\n<p>到了这一步 ，差不多可以表示<code>Lua</code>中所有的数据类型了。但是还欠缺一点东西，那就是这些数据到底是什么类型的。于是<code>Lua</code>代码中又有了<code>TValue</code>，它用于将<code>Value</code>和类型结合在一起。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TValuefields\tValue value; int tt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_TValue</span> &#123;</span></span><br><span class=\"line\">  TValuefields;</span><br><span class=\"line\">&#125; TValue;</span><br></pre></td></tr></table></figure>\n<p>前面提到过， <code>Lua</code>同时采用了两种方式来做到数据统一。根据前面的分析，这表现在以下两个方面。</p>\n<ul>\n<li>具体类型中有<code>CommonHeader</code>用来存放所有数据类型都通用的字段</li>\n<li><code>TValue</code>作为统一表示所有数据的数据结构，内部使用了联合体<code>Value</code>将所有数据都包起来</li>\n</ul>\n<p>在具体的代码中，<code>TValue</code>用于统一地表示数据，而一旦知道了具体的类型，就需要使用具体的类型了。因此，代码中有不少涉及<code>TValue</code>与具体类型之间转换的代码，其主要逻辑都是将<code>TValue</code>中的<code>tt</code>、<code>value</code>与具体类型的数据进行转换。<br>如将<code>lua Number</code>转换为<code>TValue</code>的宏<code>setnvalue</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> setnvalue(obj,x) \\</span></span><br><span class=\"line\">  &#123; TValue *i_o=(obj); i_o-&gt;value.n=(x); i_o-&gt;tt=LUA_TNUMBER; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从lua-5-1-1中分离出来的动态类型实现代码\"><a href=\"#从lua-5-1-1中分离出来的动态类型实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的动态类型实现代码\"></a>从lua-5.1.1中分离出来的动态类型实现代码</h2><p><a href=\"https://gist.github.com/losophy/622673d3f42e2c830d348da63273ff1a\">ltypes</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《Lua设计与实现》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/109\">Debemos esforzarnos por vencer todas las dificultades y procurar el mejor resultado posibl.</a></p>\n","tags":["lua"]},{"title":"lua环境与模块","url":"/post/ceeb0073.html","content":"<p><code>Lua</code>实现了一个安全的运行环境、一套自动内存管理机制、优秀的字符串处理能力和动态大小数据的处理功能。</p>\n<a id=\"more\"></a>\n\n<p>我们都知道，只要应用程序加入<code>lua</code>解析器的功能，就能解析<code>lua</code>脚本。那<code>lua</code>脚本是怎样执行的？<br>我们通常用<code>dofile</code>去打开编译一个<code>lua</code>脚本。当应用程序调用<code>dofile</code>后，在执行完脚本后，才能后到主程序中，这<code>lua</code>脚本相当于一个函数。要等函数执行完才能回到主程序中。<br>在<code>lua</code>脚本中，一般有变量，函数，这些东西都保存在一个常规的<code>table</code>中，这个<code>table</code>称为“环境”。</p>\n<h2 id=\"loadfile、dofile、require\"><a href=\"#loadfile、dofile、require\" class=\"headerlink\" title=\"loadfile、dofile、require\"></a>loadfile、dofile、require</h2><blockquote>\n<p>loadfile——只加载编译，不运行<br>dofile——执行<br>require——只执行一次</p>\n</blockquote>\n<p>用<code>require</code>函数只能加载一次,因为它的特性是:</p>\n<blockquote>\n<p>1、require函数会搜索目录加载文件<br>2、require会判断是否文件已经加载避免重复加载同一文件</p>\n</blockquote>\n<p>但当有一些特殊的需求需要反复加载某个<code>lua</code>文件，那如何实现反复加载一个<code>lua</code>文件?<br>二次加载前加这一句：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">package</span>.<span class=\"built_in\">loaded</span>[luafile] = <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"环境相关的变量\"><a href=\"#环境相关的变量\" class=\"headerlink\" title=\"环境相关的变量\"></a>环境相关的变量</h2><p>这里首先分析几个与环境相关的特殊变量一<code>Global</code>表 、 <code>env</code>表 、 <code>registry</code>表以及<code>UpValue</code>。<br>关于前3个表，需要注意以下几点：</p>\n<ul>\n<li><code>Global</code>表存放在<code>lua State</code>结构体中也称为<code>G</code>表 。 每个<code>lua State</code>结构体都有一个对应的<code>G</code>表。 不用多说，这个表就是存放全局变量的。</li>\n<li><code>env</code>表存放在<code>Closure</code>结构体中，也就是每个函数有自己独立的一个环境 。</li>\n<li><code>registry</code>表是全局唯一的，它存放在<code>global_State</code>结构体中，这个结构体在整个运行环境中只有一个。</li>\n</ul>\n<p>查找一个全局变量的操作，其实更精确地说，是在当前函数的<code>env</code>表中查找 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> OP_GETGLOBAL: &#123;</span><br><span class=\"line\">        TValue g;</span><br><span class=\"line\">        TValue *rb = KBx(i);</span><br><span class=\"line\">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class=\"line\">        lua_assert(ttisstring(rb));</span><br><span class=\"line\">        Protect(luaV_gettable(L, &amp;g, rb, ra));</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"keyword\">case</span> OP_SETGLOBAL: &#123;</span><br><span class=\"line\">        TValue g;</span><br><span class=\"line\">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class=\"line\">        lua_assert(ttisstring(KBx(i)));</span><br><span class=\"line\">        Protect(luaV_settable(L, &amp;g, KBx(i), ra));</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这两个操作都是到函数对应的<code>Closure</code>指针中的<code>env</code>表去查询数据 。 这里仍然需要提醒一下前面提到的一点，即使对一个没有任何函数的代码而言，分析完毕之后都对应一个<code>Closure</code>。 因此，这里提到的“当前函数环境”，指的不一定是某一个具体的函数，也可能是一个<code>Lua</code>文件 。</p>\n<p><code>Lua</code>提供了几个<code>API</code>来读取当前函数的环境，分别是<code>getfenv</code>和<code>setfenv</code>。<br>因此，如果执行以下代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setfenv</span>(<span class=\"number\">1</span>,&#123;&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n<p>实际上找不到<code>Lua</code>标准库提供的<code>print</code>函数，并且会提示报错<code>attempt to call global ’a’（a nil value）</code> 。 原因就是首先使用 <code>setfenv</code>函数将当前函数的<code>env</code>表置为一个空表，此时在当前函数的<code>env</code>表中查找不到这个名字的函数。</p>\n<p>下面来看看函数的<code>env</code>表是如何创建的 。<br>在创建一个<code>Closure</code>对象时，都会调用<code>getcurrenv</code>函数来获取当前的环境表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Table *<span class=\"title\">getcurrenv</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;ci == L-&gt;base_ci)  <span class=\"comment\">/* no enclosing function? */</span><span class=\"comment\">//如果该函数不是内嵌函数，那么直接返回G表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hvalue(gt(L));  <span class=\"comment\">/* use global table as environment */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//再则，如果是内嵌函数，就返回其母函数的`env`表</span></span><br><span class=\"line\">    Closure *func = curr_func(L);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func-&gt;c.env;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建一个新的<code>Closure</code>时，会调用这个函数返回的结果，对新的<code>Closure</code>的环境进行赋值。这里可以看出，<code> env</code>表会逐层继承。</p>\n<p>接着来看看<code>registry</code>表的作用，该表存放在<code>global_State</code>结构体中，因此里面的内容可供多个<code>lua State</code>访问 。 另外，这个表只能由<code>C</code>代码访问，<code>Lua</code>代码不能访问 。 除此之外，它和普通的表没有什么区别 。</p>\n<p>但是需要注意的是，使用普通的对表进行赋值的<code>API</code>对<code>registry</code>表进行赋值时，应该使用字符串类型的键。<code>LuaAPI</code>中对外提供了接口<code>lua_ref</code>、<code>lua_unref</code>于和<code>lua_getref</code>，用于提供在<code>registry</code>表中存取唯一的数字键。 通过这组<code>API</code>，使用者不需要关心给某个需要存放到<code>registry</code>表的数据如何分配一个全局唯一的键，由<code>Lua</code>解释器自己来保证这一点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \\</span></span><br><span class=\"line\">      (lua_pushstring(L, <span class=\"string\">&quot;unlocked references are obsolete&quot;</span>), lua_error(L), <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))</span></span><br></pre></td></tr></table></figure>\n<p>接着来看看这里面<code>lual ref</code>和<code>luaL_unref</code>函数的实现。 需要说明的是，在调用<code>luaL_ref</code>函数之前，需要存放的数据已经位于栈顶：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">int</span> <span class=\"title\">luaL_ref</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ref;</span><br><span class=\"line\">  t = abs_index(L, t);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lua_isnil(L, <span class=\"number\">-1</span>)) &#123;</span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove from stack */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> LUA_REFNIL;  <span class=\"comment\">/* `nil&#x27; has a unique fixed reference */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_rawgeti(L, t, FREELIST_REF);  <span class=\"comment\">/* get first free element */</span></span><br><span class=\"line\">  ref = (<span class=\"keyword\">int</span>)lua_tointeger(L, <span class=\"number\">-1</span>);  <span class=\"comment\">/* ref = t[FREELIST_REF] */</span></span><br><span class=\"line\">  lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove it from stack */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ref != <span class=\"number\">0</span>) &#123;  <span class=\"comment\">/* any free element? */</span></span><br><span class=\"line\">    lua_rawgeti(L, t, ref);  <span class=\"comment\">/* remove it from list */</span></span><br><span class=\"line\">    lua_rawseti(L, t, FREELIST_REF);  <span class=\"comment\">/* (t[FREELIST_REF] = t[ref]) */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* no free elements */</span></span><br><span class=\"line\">    ref = (<span class=\"keyword\">int</span>)lua_objlen(L, t);</span><br><span class=\"line\">    ref++;  <span class=\"comment\">/* create new reference */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_rawseti(L, t, ref);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ref;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">void</span> <span class=\"title\">luaL_unref</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> ref)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ref &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    t = abs_index(L, t);</span><br><span class=\"line\">    lua_rawgeti(L, t, FREELIST_REF);</span><br><span class=\"line\">    lua_rawseti(L, t, ref);  <span class=\"comment\">/* t[ref] = t[FREELIST_REF] */</span></span><br><span class=\"line\">    lua_pushinteger(L, ref);</span><br><span class=\"line\">    lua_rawseti(L, t, FREELIST_REF);  <span class=\"comment\">/* t[FREELIST_REF] = ref */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的设计其实很巧妙，仅使用一个数组就模拟了一个链表的实现，其原理如下：</p>\n<ul>\n<li><code>FREELIST_REF</code>用于保存当前<code>registry</code>表中可用键的索引，每次需要存储之前，都会先到这里拿到当前存放的值。</li>\n<li>如果拿出来的值是0 ，说明当前的<code>hashlist</code>中还没有数据，直接返回当前<code>registry</code>表的数据量作为新的索引 。</li>\n<li>当调用<code>lual unref</code>释放一个索引值的时候，将该索引值返回<code>FREELIST REF</code>链表中 。</li>\n</ul>\n<p>下图演示了分配可用索引前后<code>freelist</code>的变化<br><img src=\"https://user-images.githubusercontent.com/11263320/113692378-126f2480-9700-11eb-99a2-8a8d4bbea09a.JPG\" alt=\"捕获\"><br>最后来看<code>UpValue</code>。 前面谈到，<code>registry</code>表提供的是全局变量的存储， <code>env</code>表提供的是函数内全局变量的存储，而<code>UpValue</code>用于提供函数内静态变量的存储，这些变量存储的地方，倒不是某个特殊的表，其实就是换算成对应的<code>UpValue</code>的索引值来访问函数的<code>UpValue</code>数组而已。<br>接着我们来看一个关键的函数<code>index2adr</code>，这个函数集中处理了所有索引值转换为栈地址值的操作，不论该索引是栈上元素的索引，还是前面这几种特殊变量的索引：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_REGISTRYINDEX\t(-10000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_ENVIRONINDEX\t(-10001)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_GLOBALSINDEX\t(-10002)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_upvalueindex(i)\t(LUA_GLOBALSINDEX-(i))</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TValue *<span class=\"title\">index2adr</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (idx &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    TValue *o = L-&gt;base + (idx - <span class=\"number\">1</span>);</span><br><span class=\"line\">    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o &gt;= L-&gt;top) <span class=\"keyword\">return</span> cast(TValue *, luaO_nilobject);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idx &gt; LUA_REGISTRYINDEX) &#123;</span><br><span class=\"line\">    api_check(L, idx != <span class=\"number\">0</span> &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L-&gt;top + idx;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">switch</span> (idx) &#123;  <span class=\"comment\">/* pseudo-indices */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_REGISTRYINDEX: <span class=\"keyword\">return</span> registry(L);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_ENVIRONINDEX: &#123;</span><br><span class=\"line\">      Closure *func = curr_func(L);</span><br><span class=\"line\">      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &amp;L-&gt;env;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_GLOBALSINDEX: <span class=\"keyword\">return</span> gt(L);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      Closure *func = curr_func(L);</span><br><span class=\"line\">      idx = LUA_GLOBALSINDEX - idx;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (idx &lt;= func-&gt;c.nupvalues)</span><br><span class=\"line\">                ? &amp;func-&gt;c.upvalue[idx<span class=\"number\">-1</span>]</span><br><span class=\"line\">                : cast(TValue *, luaO_nilobject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的逻辑主要是根据传人的<code>idx</code>的几种情况，分别返回不同的值。</p>\n<ul>\n<li>如果 idx &gt;O ，那么以 idx值为索引，返回基于 lua State的 base指针的值，也就是相对于战底向上的偏移值。</li>\n<li>如果 idx&gt;LUA_REGISTRYINDEX ，则以 idx值为索引，返回基于 l ua_State的top指针的值，也就是相对于钱顶向下的偏移值。</li>\n<li>如果是LUA_REGISTRYINDEX ，那么返回 registry表。</li>\n<li>如果是LUA ENVIRONINDEX ，那么返回当前函数的env表。</li>\n<li>如果是LUA GLOBALSINDEX ，那么返回Global表。</li>\n<li>如果以上都不符合，那么将根据情况返回当前函数的叩value数组中的值。</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>这一节将讲解<code>Lua</code>模块相关的知识点，首先介绍模块的加载、编写等原理，然后介绍热更新原理。</p>\n<h3 id=\"模块的加载\"><a href=\"#模块的加载\" class=\"headerlink\" title=\"模块的加载\"></a>模块的加载</h3><p>在<code>Lua</code>内部，所有模块的注册都在<code>linit.c</code>的函数<code>lual_openlibs</code>中提供。 可以看到，它依次访问<code>lualibs</code>数组中的成员，这些成员定义了每个模块的模块名及相应的模块注册函数，依次调用每个模块的注册函数完成模块的注册 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> luaL_Reg lualibs[] = &#123;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;&quot;</span>, luaopen_base&#125;,</span><br><span class=\"line\">  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,</span><br><span class=\"line\">  &#123;LUA_TABLIBNAME, luaopen_table&#125;,</span><br><span class=\"line\">  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class=\"line\">  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br><span class=\"line\">  &#123;LUA_STRLIBNAME, luaopen_string&#125;,</span><br><span class=\"line\">  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,</span><br><span class=\"line\">  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class=\"line\">  &#123;<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">void</span> <span class=\"title\">luaL_openlibs</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> luaL_Reg *lib = lualibs;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; lib-&gt;func; lib++) &#123;</span><br><span class=\"line\">    lua_pushcfunction(L, lib-&gt;func);</span><br><span class=\"line\">    lua_pushstring(L, lib-&gt;name);</span><br><span class=\"line\">    lua_call(L, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体<code>lual_Reg</code>有两个变量，分别是模块名以及模块初始化函数。 可以看到，第一个模块是<code>base</code>模块，其模块名是一个空字符串，因此访问这个模块的函数不需要加模块名前缀，比如我们熟悉的<code>print</code>函数就是属于这个模块的 。 这就是在调用<code>print</code>函数时，不需要在前面加模块名前缀的原因 。 这里就以<code>base</code>模块为例来讲解模块的注册过程。</p>\n<p>加载<code>base</code>模块最终会调用 <code>base_open</code>函数，下面我们看看这个函数里面最核心的几行代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">base_open</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* set global _G */</span></span><br><span class=\"line\">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class=\"line\">  lua_setglobal(L, <span class=\"string\">&quot;_G&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* open lib into global table */</span></span><br><span class=\"line\">  luaL_register(L, <span class=\"string\">&quot;_G&quot;</span>, base_funcs);</span><br></pre></td></tr></table></figure>\n<p>最开始的两句首先将 LUA_GLOBA LSINDEX对应的值压人拢中，接着调用 lua_setglobal(L ,二C ”） ; , e n 当在 lua_State 的 l_gt表中查找工C”时，查找到的是索引值为 LUA_GLOBALSINDEX的表 。如果觉得有点绕，可以简单理解为，在C表满足这个等式＿G = _G ［二G”］ 。 也就是这个叫＿G的表内部有一个key为二G”的表是指向自己的 。 可以在Lua命令行中执行print(_G ）和 print(_G ［”＿G”］）看看输出结果，来验证一下这个结论。</p>\n<p>我猜想这么处理的理由是 ： 为了让G表和其他表使用同样的机制 。 查找变量时，最终会一直顺着层次往上查到G表中，这是很自然的事情 。 所以，为了也能按照这个机制顺利地查找到自己，于是在G表中有一个同名成员指向自己 。</p>\n<p>好了，前两句的作用已经分析完毕，其结果有以下两个 ：</p>\n<ul>\n<li>＿G = _G [”_G”]</li>\n<li>G表的值压入函数枝中方便后面的调用 。</li>\n</ul>\n<p>所以，这个G表的注册操作需要在所有模块注册之前进行。</p>\n<p>在第63 1行中， base_fu n cs也是一个lual_Reg数组，上面的操作会将base_funcs数组中的函数注册到G表中，但是里面还有些细节需要看看。 这个操作最终会调用函数luaI←openlib:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">void</span> <span class=\"title\">luaI_openlib</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *libname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">const</span> luaL_Reg *l, <span class=\"keyword\">int</span> nup)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (libname) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = libsize(l);</span><br><span class=\"line\">    <span class=\"comment\">/* check whether lib already exists */</span></span><br><span class=\"line\">    luaL_findtable(L, LUA_REGISTRYINDEX, <span class=\"string\">&quot;_LOADED&quot;</span>, size);</span><br><span class=\"line\">    lua_getfield(L, <span class=\"number\">-1</span>, libname);  <span class=\"comment\">/* get _LOADED[libname] */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lua_istable(L, <span class=\"number\">-1</span>)) &#123;  <span class=\"comment\">/* not found? */</span></span><br><span class=\"line\">      lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove previous result */</span></span><br><span class=\"line\">      <span class=\"comment\">/* try global variable (and create one if it does not exist) */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        luaL_error(L, <span class=\"string\">&quot;name conflict for module &quot;</span> LUA_QS, libname);</span><br><span class=\"line\">      lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">      lua_setfield(L, <span class=\"number\">-3</span>, libname);  <span class=\"comment\">/* _LOADED[libname] = new table */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lua_remove(L, <span class=\"number\">-2</span>);  <span class=\"comment\">/* remove _LOADED table */</span></span><br><span class=\"line\">    lua_insert(L, -(nup+<span class=\"number\">1</span>));  <span class=\"comment\">/* move library table to below upvalues */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; l-&gt;name; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;nup; i++)  <span class=\"comment\">/* copy upvalues to the top */</span></span><br><span class=\"line\">      lua_pushvalue(L, -nup);</span><br><span class=\"line\">    lua_pushcclosure(L, l-&gt;func, nup);</span><br><span class=\"line\">    lua_setfield(L, -(nup+<span class=\"number\">2</span>), l-&gt;name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_pop(L, nup);  <span class=\"comment\">/* remove upvalues */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注册这些函数之前，首先会到registry ［二LOADED＂］表中查找该库，如果不存在，则在G表中查找这个库，若不存在则创建一个表。<br>因此，不管是Lua内部的库还是外部使用require引用的库，首先会到 registry ［”一LOADED ”］ 中存放该库的表。 最后，再遍历传进来的函数指针数组，完成库函数的注册。<br>比如，注册as . print时，首先将print函数绑定在一个函数指针上，再去l_registry[_LOADED]和G表中查询名为OS的库是否存在，不存在则创建一个表，即 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">G[”OS<span class=\"string\">&quot;] = &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>紧跟着注册print函数，即： G ［”os ”］［ ” print ”］＝待注册的函数指针。<br>这样在调用os . print(1）时，首先根据OS到G表中查找对应的表，再在这个表中查找print成员得到函数指针，最后完成函数的调用 。</p>\n<h3 id=\"模块的编写\"><a href=\"#模块的编写\" class=\"headerlink\" title=\"模块的编写\"></a>模块的编写</h3><p>在定义Lua模块时，第一句代码一般都是module(xxx ） 。 module调用的对应C函数是loadlib.c中的函数ll_module:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ll_module</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *modname = luaL_checkstring(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> loaded = lua_gettop(L) + <span class=\"number\">1</span>;  <span class=\"comment\">/* index of _LOADED table */</span></span><br><span class=\"line\">  lua_getfield(L, LUA_REGISTRYINDEX, <span class=\"string\">&quot;_LOADED&quot;</span>);</span><br><span class=\"line\">  lua_getfield(L, loaded, modname);  <span class=\"comment\">/* get _LOADED[modname] */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_istable(L, <span class=\"number\">-1</span>)) &#123;  <span class=\"comment\">/* not found? */</span></span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove previous result */</span></span><br><span class=\"line\">    <span class=\"comment\">/* try global variable (and create one if it does not exist) */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, modname, <span class=\"number\">1</span>) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> luaL_error(L, <span class=\"string\">&quot;name conflict for module &quot;</span> LUA_QS, modname);</span><br><span class=\"line\">    lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    lua_setfield(L, loaded, modname);  <span class=\"comment\">/* _LOADED[modname] = new table */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* check whether table already has a _NAME field */</span></span><br><span class=\"line\">  lua_getfield(L, <span class=\"number\">-1</span>, <span class=\"string\">&quot;_NAME&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_isnil(L, <span class=\"number\">-1</span>))  <span class=\"comment\">/* is table an initialized module? */</span></span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* no; initialize it */</span></span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">    modinit(L, modname);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">  setfenv(L);</span><br><span class=\"line\">  dooptions(L, loaded - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码的前半部分首先根据module(XXX）中的模块名去registry [“_LOADED”］表中查找，如果找不到，则创建一个新表，这个表为＿G ［” xxx叮＝ registry ［二LOADED ”］［ “XXX ＂］ 。 换言之，这个名为xxx 的模块本质上是一个表，这个表存储了这个模块中的所有变革－以及函数，它既可以通过一G ［” xxx”］来访问，也可以通过registry ［二 LOADED ”］［ “XXX ”］来访问 。<br>紧跟着，在modi nit 函数中，将这个表的成员 K NAME 、 PACKAGE分别赋值。<br>最后，调用 setfenv将该模块对应的环境置空 。 根据前面的分析， setfenv将该模块对应的环境置空就是将这个模块分析完毕之后返回的Closure对应的env环境表置空 。 这意味着，前面的所有全局变量都看不见了，比如下面的代码中 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">myprint=<span class=\"built_in\">print</span></span><br><span class=\"line\">myprint(”<span class=\"number\">1</span>”)</span><br><span class=\"line\"><span class=\"built_in\">module</span>(”test”)</span><br><span class=\"line\">myprint (” <span class=\"number\">2</span>”)</span><br></pre></td></tr></table></figure>\n<p>这里首先将全局函数printl赋值给全局变量myprint ，第二行代码可以正常调用这个函数。但当调用module声明 test模块之后，在此之前的全局变量myprint被清空，第四行代码调用myprint函数时就会报错，错误信息是attempt to call global ‘myprint’(a nil value），因为此时已经查不到这个变量了 。<br>如果写下的是module(xxx,package . seeall）呢？它将会调用后面的dooptions 函数并且最后调用 package.seeall对应的处理函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ll_seeall</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  luaL_checktype(L, <span class=\"number\">1</span>, LUA_TTABLE);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_getmetatable(L, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    lua_createtable(L, <span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">/* create new metatable */</span></span><br><span class=\"line\">    lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    lua_setmetatable(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class=\"line\">  lua_setfield(L, <span class=\"number\">-2</span>, <span class=\"string\">&quot;__index&quot;</span>);  <span class=\"comment\">/* mt.__index = _G */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数就两个作用 ： 一个是创建该模块对应表的metatable ， 另一个是将meta表的 index指向 G表。 也就是说，所有在该模块中找不到的变量都会去 G表中查找 。 可以看到，这里的操作并不会把环境表清空 。 因此，如果把前面的代码改成这样，就可以正确执行：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">myprint=<span class=\"built_in\">print</span></span><br><span class=\"line\">myprint(” test ”)</span><br><span class=\"line\">morlule (”test <span class=\"string\">&#x27;’, package. seeall)</span></span><br><span class=\"line\"><span class=\"string\">myprint(”test”) </span></span><br></pre></td></tr></table></figure>\n<p>根据前面对module函数的分析，得出以下几个结论。</p>\n<ul>\n<li>创建模块时会创建一个表，该表挂载在registry ［ ”一LOADED ＇ ’ ］、＿G ［模块名］下 。 自然而然地，该模块中的变量（函数也是一种变量）就会挂载到这个表里面 。</li>\n<li>在 module 函数的参数中写下 package.seeall将会创建该表的 metatable ，同时该表的index将指向 G表。 简单地说，这个模块将可以看到所有全局环境下的变量（这里再提醒一次，函数也是一种变量） 。</li>\n</ul>\n<p>明白了 module 背后的作用，再来看看 require 函数，它对应的处理函数是 loadlib.c 中的ll_require 函数，这个函数做了如下几件事情 。</p>\n<ul>\n<li>首先在 registry[ “_LOADED”］表中查找该库，如果已存在，说明是已经加载过的模块，不再重复加载直接返回。</li>\n<li>在当前环境表中查找 loaders变量，这里存放的是所有加载器组成的数组 。 在 Lua代码中，有4个loader :<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> lua_CFunction loaders[] =</span><br><span class=\"line\">  &#123;loader_preload, loader_Lua, loader_C, loader_Croot, <span class=\"literal\">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>\n加载时，会依次调用 loaders数组中的四种 loader 。 如果加载的结果在Lua找中返回的是函数（前面提过，分析完Lua源代码文件，返回的是Closure ），那么说明加载成功，不再继续往下调用其他的 loader加载模块 。<br>最后，调用lua call函数尝试加载该模块。 加载之前，在L回校中压入一个哨兵值sentinel,如果加载完毕之后这个值没有被改动过，则说明加载完毕，将registry ［ ”＿LOADED”］赋值为true表示加载成功 。</li>\n</ul>\n<h3 id=\"模块的热更新原理\"><a href=\"#模块的热更新原理\" class=\"headerlink\" title=\"模块的热更新原理\"></a>模块的热更新原理</h3><p>能很好地支持代码热更新机制，是开发时选择使用脚本语言的原因之一 。 热更新的好处很在于，能在不重启程序或者发布新版本的情况下更新脚本，给调试和线上解决问题带来很大的便利，对开发效率有很大的提升 。<br>下面就来谈谈如何实现热更新 。先简单回顾之前提过的模块和lrequire机制 。 Lua内部提供了一个require 函数来实现模块的加载，它做的事情主要有以下几个。</p>\n<ul>\n<li>在registry ［二LOADED”］表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码 。</li>\n<li>依次调用注册的 loader来加载模块 。</li>\n<li>将加载过的模块赋值给registry ［”一LOADED ＂］表。<br>而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua虚拟机认为它之前没有加载过。 查看Lua代码可以发现 ， registry ［”一LOADED ”］表实际上对应的是package.loaded表，这在以下函数中有体现：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">int</span> <span class=\"title\">luaopen_package</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"comment\">/* create new type _LOADLIB */</span></span><br><span class=\"line\">  luaL_newmetatable(L, <span class=\"string\">&quot;_LOADLIB&quot;</span>);</span><br><span class=\"line\">  lua_pushcfunction(L, gctm);</span><br><span class=\"line\">  lua_setfield(L, <span class=\"number\">-2</span>, <span class=\"string\">&quot;__gc&quot;</span>);</span><br></pre></td></tr></table></figure>\n因此，事情就很简单了，需要提供require_ex函数，可以把它理解为require的增强版 。 使用这个函数，可以动态更新某个模块的代码：<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">干unction require_ex( _mname )</span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"built_in\">string</span> .<span class=\"built_in\">format</span>(<span class=\"string\">&quot;require_ex ＝喃5 ”，＿mname) )</span></span><br><span class=\"line\"><span class=\"string\">if package.loaded[_mname] then</span></span><br><span class=\"line\"><span class=\"string\">print( string.format(”require_ex module[ %s] reload”,_mname))</span></span><br><span class=\"line\"><span class=\"string\">end</span></span><br><span class=\"line\"><span class=\"string\">package .loaded[_mname] = nil</span></span><br><span class=\"line\"><span class=\"string\">require( _mname )</span></span><br><span class=\"line\"><span class=\"string\">end</span></span><br></pre></td></tr></table></figure>\n这个函数做的事情一目了然 。 首先，判断是否曾经加载过这个模块，如果有，则打印一条日志，表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。</li>\n</ul>\n<p>一般热更新都是函数的实现，所以需要对全局变量做一些保护 。 比如，当前某全局变量为 100 ，表示某个操作已经进行了 100次，它不能因为热更新重置为0 ，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a <span class=\"keyword\">or</span> o</span><br></pre></td></tr></table></figure>\n<p>这个原理很简单，只有当前a这个变量没有初始值的时候才会赋值为0 ，而后面不管这个Lua文件被加载多少次， a者~J之会因为重新加载了Lua代码而发生改变 。</p>\n<h2 id=\"从lua-5-1-1中分离出来的lenv实现代码\"><a href=\"#从lua-5-1-1中分离出来的lenv实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的lenv实现代码\"></a>从lua-5.1.1中分离出来的lenv实现代码</h2><p><a href=\"https://gist.github.com/losophy/65926301c7d74e4503580117a26b9722\">lenv</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《lua设计与实现》<br>lua-5.1.1源码</p>\n","tags":["lua"]},{"title":"lua考古","url":"/post/e3bb7f2d.html","content":"<p>这里记录下lua的进化历史。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Lua版本的年表\"><a href=\"#Lua版本的年表\" class=\"headerlink\" title=\"Lua版本的年表\"></a>Lua版本的年表</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/111862027-7c13d280-898d-11eb-9cab-ab361a8372b6.png\" alt=\"timeline\"></p>\n<p><code>Lua</code>的<a href=\"https://www.lua.org/versions.html\">发行版</a>编号为<code>x.y.z</code>，其中<code>x.y</code>是版本，而<code>z</code>是发行版。<br>同一版本的不同发行版对应于错误修复。同一版本的不同发行版具有相同的参考手册，相同的虚拟机.<br><a href=\"https://www.lua.org/doc/hopl.pdf\">不同的版本</a>实际上是不同的。API可能略有不同。虚拟机在新版本中也很有可能会有所不同。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/111866533-1d5c5200-89a9-11eb-8a0b-66d34a0748b5.png\" alt=\"table1\"></p>\n<h2 id=\"Lua-1\"><a href=\"#Lua-1\" class=\"headerlink\" title=\"Lua 1\"></a>Lua 1</h2><p>1.1 这是<code>Lua</code>的第一个公开版本，已经具有强大的数据描述结构，简单的语法和字节码虚拟机。<br><code>Lua</code>中的所有语句都在全局环境中执行。<br>这个版本已经具有垃圾回收功能（标记-清除垃圾回收算法）。</p>\n<h2 id=\"Lua-2\"><a href=\"#Lua-2\" class=\"headerlink\" title=\"Lua 2\"></a>Lua 2</h2><p>2.1 ：通过<code>fallbacks</code>扩展语义以及对面向对象编程的支持。<br>2.2 ：长字符串，调试接口，更好的堆栈回溯，扩展的函数定义语法，函数的垃圾回收以及对管道的支持。<br>2.4 ：实现外部编译器<code>luac</code>，带有钩子的扩展调试接口以及“ getglobal”后备功能。<br>2.5 ：实现模式匹配和<code>vararg</code>函数。</p>\n<h2 id=\"Lua-3\"><a href=\"#Lua-3\" class=\"headerlink\" title=\"Lua 3\"></a>Lua 3</h2><p>3.0 ：<code>tag methods</code>替代<code>fallbacks</code>，可以作为后备功能的有力替代。引入<code>auxlib</code>（一个用于帮助编写Lua库的库），并支持条件编译。<br>3.1 ：实现匿名函数和通过“ upvalues”关闭函数。支持多种全局环境。代码重组和清理，大大减少了<code>module</code>之间的依赖性。采用<code>double</code>精度表示数字整型。<br>3.2 ：实现调试库和表的新功能。</p>\n<h2 id=\"Lua-4\"><a href=\"#Lua-4\" class=\"headerlink\" title=\"Lua 4\"></a>Lua 4</h2><p>4.0 ：实现多重状态，为那些需要多份<code>Lua state</code>的应用而设计的新API。设计了一个<code>for</code>循环，它有两种方式：一个数字式的循环以及一个表遍历的循环。对<code>C API</code>重新设计了，不再有任何内置函数，所有标准库都是基于<code>C API</code>实现，没有通过特别的后门去访问<code>Lua</code>内部结构。</p>\n<h2 id=\"Lua-5\"><a href=\"#Lua-5\" class=\"headerlink\" title=\"Lua 5\"></a>Lua 5</h2><p>5.0 ：实现协程，完善词法作用域（而不是<code>upvalues</code>）和元表（而不是<code>tags and tag methods</code>）。引入了布尔值，完善尾调用和弱表。对<code>packages</code>的更好支持，用于加载<code>Lua</code>块的新<code>API</code>，新的错误处理协议，更好的错误消息等等。<code>vm</code>改为基于寄存器的。<br>5.1 ：实现新的<code>module</code>系统，实现增量垃圾回收系统，新的<code>varargs</code>机制，新的长字符串和注释语法，<code>mod</code>和<code>length</code>运算符，所有类型的元表，通过<code>luaconf.h</code>配置方案和一个完全可重入的解析器。<br>5.2 ：实现可调用的<code>pcall</code>和元方法，用于全局变量的词法方案，暂时表，位运算新库，轻量级<code>C</code>函数，紧急垃圾回收器，<code>goto</code>语句和表的终结器。<br>5.3 ：实现整数，按位运算符，基本的<code>utf-8</code>库以及对64位和32位平台的支持。<br>5.4 ：实现新的增量垃圾回收，<code>const</code>，<code>close</code>变量。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/108\">En nombrando al ruin de Roma , luego asoma. nran a porfía.</a></p>\n","tags":["lua"]},{"title":"lua虚拟机","url":"/post/a563683a.html","content":"<p><code>Lua</code>的虚拟机核心部分，<strong>没有任何的系统调用</strong>，是一个纯粹的黑盒子，正确的使用<code>Lua</code>，不会对系统造成任何干扰。这其中最关键的一点是，<code>Lua</code>让用户自行定义内存管理器，在创建<code>Lua</code>虚拟机时传入，这保证了<code>Lua</code>的整个运行状态是用户可控的。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基于寄存器的虚拟机\"><a href=\"#基于寄存器的虚拟机\" class=\"headerlink\" title=\"基于寄存器的虚拟机\"></a>基于寄存器的虚拟机</h2><p><code>lua</code>从5.0开始，就把虚拟机改为基于寄存器的。<br>基于栈的虚拟机执行操作，要事先<code>pop</code>出数据，再将数据<code>push</code>入栈，字节码条数较多，但指令中不需要关心操作数的地址，在执行操作之前已经将操作数准备在栈顶上了。与基于栈的虚拟机不同，在基于寄存器的指令中，操作数是放在“CPU的寄存器”中（因为并不是物理意义上的寄存器，所以这里打了双引号）。因此，同样的操作不再需要<code>PUSH、POP</code>指令，取而代之的是在字节码中带上其体操作数所在的寄存器地址。 需要指令较少，但缺点是此时程序需要关注操作数所在的位置。</p>\n<p><code>Lua</code>使用的是基于寄存器的虚拟机实现方式，其中很大的原因是它的设计目标之一就是尽可能高效。</p>\n<h2 id=\"lua虚拟机工作流程\"><a href=\"#lua虚拟机工作流程\" class=\"headerlink\" title=\"lua虚拟机工作流程\"></a>lua虚拟机工作流程</h2><p><code>lua</code>代码是通过翻译成<code>Lua</code>虚拟机能识别的字节码运行的，以此它主要分为两大部分。</p>\n<h3 id=\"翻译代码以及编译为字节码\"><a href=\"#翻译代码以及编译为字节码\" class=\"headerlink\" title=\"翻译代码以及编译为字节码\"></a>翻译代码以及编译为字节码</h3><p>这部分代码负责将<code>lua</code>代码进行词法分析<code>（llex.c）</code>、语法分析等<code>（lparser.c）</code>，最终生成字节码<code>（lcode.c）</code>。<code>lopcodes.x</code>则定义了<code>lua</code>虚拟机相关的字节码指令的格式以及相关的<code>API</code>。</p>\n<h3 id=\"lua虚拟机相关（指令的执行）\"><a href=\"#lua虚拟机相关（指令的执行）\" class=\"headerlink\" title=\"lua虚拟机相关（指令的执行）\"></a>lua虚拟机相关（指令的执行）</h3><p>在第一步中，经过分析阶段后，生成了对应的字节码，第二步就是将这些字节码装载到虚拟机中执行。<code>Lua</code>虚拟机相关的代码在 <code>lvm.c</code>中，虚拟机执行的主函数是<code>luaV_execute</code>，不难想象这个函数是一个大的循环，依次从字节码中取出指令并执行。<code>Lua</code>虚拟机对外看到的数据结构是<code>lua_State</code>这个结构体将一直贯穿整个分析以及执行阶段 。 除了虚拟机的执行之外，Lua的核心部分还包括了进行函数调用和返回处理的相关代码，主要处理函数调用前后环境的准备和还原，这部分代码在<code>ldo.c</code>中，垃圾回收部分的代码在<code>lgc.c</code>中。<code>Lua</code>是一门嵌入式的脚本语言，这意味着它的设计目标之一必须满足能够与宿主系统进行交互，这部分代码在<code>lapi.c</code>中。</p>\n<p>总结一下，实现一个脚本语言的解释器，其核心问题有如下几个</p>\n<ul>\n<li>设计一套字节码，分析源代码文件生成字节码</li>\n<li>在虚拟机中执行字节码</li>\n<li>如何在整个执行过程中保存整个执行环境</li>\n</ul>\n<p>执行<code>Lua</code>文件调用的是<code>luaL_dofile</code>函数，它实际上是个宏，内部首先调用<code>luaL_loadfile</code>函数，再调用<code>lua_pcall</code>函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaL_dofile(L, fn) \\</span></span><br><span class=\"line\">\t(luaL_loadfile(L, fn) || lua_pcall(L, <span class=\"number\">0</span>, LUA_MULTRET, <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>其中<code>lual_loadfile</code>函数用于进行词法和语法分析，<code>lua_pcall</code>用于将第一步中分析的结果（也就是字节码）放到虚拟机中执行<br><code>lual_loadfile</code>函数最终会调用于<code>f_parser</code>函数，这是对代码进行分析的人口函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f_parser</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">void</span> *ud)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  Proto *tf;</span><br><span class=\"line\">  Closure *cl;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SParser</span> *<span class=\"title\">p</span> =</span> cast(struct SParser *, ud);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = luaZ_lookahead(p-&gt;z);</span><br><span class=\"line\">  luaC_checkGC(L);</span><br><span class=\"line\">  tf = ((c == LUA_SIGNATURE[<span class=\"number\">0</span>]) ? luaU_undump : luaY_parser)(L, p-&gt;z,</span><br><span class=\"line\">                                                             &amp;p-&gt;buff, p-&gt;name);</span><br><span class=\"line\">  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));</span><br><span class=\"line\">  cl-&gt;l.p = tf;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tf-&gt;nups; i++)  <span class=\"comment\">/* initialize eventual upvalues */</span></span><br><span class=\"line\">    cl-&gt;l.upvals[i] = luaF_newupval(L);</span><br><span class=\"line\">  setclvalue(L, L-&gt;top, cl);</span><br><span class=\"line\">  incr_top(L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成词法分析之后，返回了<code>Proto</code>类型的指针<code>tf</code>，然后将其绑定在新创建的<code>Closure</code>指针上，初始化<code>UpValue</code>，最后压入战中。不难想象，词法分析之后产生的字节码等相关数据都在这个<code>Proto</code>类型的结构体中，而这个数据又作为<code>Closure</code>保存了下来，留待下一步使用。<br>接着看看<code>lua_pcall</code>函数是如何将产生的字节码放入虚拟机中执行的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API <span class=\"keyword\">int</span> <span class=\"title\">lua_pcall</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> nargs, <span class=\"keyword\">int</span> nresults, <span class=\"keyword\">int</span> errfunc)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CallS</span> <span class=\"title\">c</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">  <span class=\"keyword\">ptrdiff_t</span> func;</span><br><span class=\"line\">  lua_lock(L);</span><br><span class=\"line\">  api_checknelems(L, nargs+<span class=\"number\">1</span>);</span><br><span class=\"line\">  checkresults(L, nargs, nresults);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (errfunc == <span class=\"number\">0</span>)</span><br><span class=\"line\">    func = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    StkId o = index2adr(L, errfunc);</span><br><span class=\"line\">    api_checkvalidindex(L, o);</span><br><span class=\"line\">    func = savestack(L, o);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  c.func = L-&gt;top - (nargs+<span class=\"number\">1</span>);  <span class=\"comment\">//获取需要调用的函数指针</span></span><br><span class=\"line\">  c.nresults = nresults;</span><br><span class=\"line\">  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);</span><br><span class=\"line\">  adjustresults(L, nresults);</span><br><span class=\"line\">  lua_unlock(L);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>nargs</code>是由函数参数传入的，在<code>luaL_dofile</code>中调用<code>lua_pcall</code>时，这里传入的参数是0，换句话说，这里得到的函数对象指针就是前面<code>f_parser</code>函数中最后两句代码放入<code>Lua</code>栈的<code>Closure</code>指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">setclvalue(L, L-&gt;top, cl);</span><br><span class=\"line\">incr_top(L);</span><br></pre></td></tr></table></figure>\n<p>继续往下执行，在调用函数<code>luaD_pcall</code>时， 最终会执行到<code>luaD_call</code>函数，这其中有这么一段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (luaD_precall(L, func, nResults) == PCRLUA)  <span class=\"comment\">/* is a Lua function? */</span></span><br><span class=\"line\">    luaV_execute(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* call it */</span></span><br></pre></td></tr></table></figure>\n<p>首先，调用<code>luaD_precall</code>函数进行执行前的准备工作：</p>\n<ul>\n<li>从<code>lua_State</code>的<code>CallInfo</code>数组中得到一个新的<code>CallInfo</code>结构体，设置它的<code>func</code>、 <code>base</code> 、 <code>top</code>指针</li>\n<li>从前面分析阶段生成的<code>Closure</code>指针中，取出保存下来的<code>Proto</code>结构体 。 前面提到过，这个结构体中保存的是分析过程完结之后生成的字节码等信息</li>\n<li>将这里创建的<code>CallInfo</code>指针的<code>top/base</code>指针赋值给<code>lua_State</code>结构体的<code>top</code> 、 <code>base</code>指针。 将<code>Proto</code>结构体的<code>code</code>成员赋值给 <code>lua_State</code>指针的<code>savedpc</code>字段，<code>code</code>成员保留的就是字节码</li>\n<li>把多余的函数参数赋值为<code>nil</code>；比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为nil。</li>\n</ul>\n<p>调用完<code>luaD_precall</code>函数之后，接着会进入<code>luaV_execute</code>函数，这里是虚拟机执行代码的主函数：<br>这里的<code>pc</code>指针存放的是虚拟机<code>OpCode</code>代码，它最开始从<code>L-&gt;savepc</code>初始化而来，而<code>L-&gt;savepc</code>在<code>luaD_precall</code>中赋值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">L-&gt;savedpc = p-&gt;code;  <span class=\"comment\">/* starting point */</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>luaV_execute</code>函数最主要的作用就是一个大循环，将当前传入的指令依次执行。<br>最后，执行完毕后，还会调用<code>luaD_poscall</code>函数恢复到上一次函数调用的环境：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaD_poscall</span> <span class=\"params\">(lua_State *L, StkId firstResult)</span> </span>&#123;</span><br><span class=\"line\">  StkId res;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> wanted, i;</span><br><span class=\"line\">  CallInfo *ci;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;hookmask &amp; LUA_MASKRET)</span><br><span class=\"line\">    firstResult = callrethooks(L, firstResult);</span><br><span class=\"line\">  ci = L-&gt;ci--;</span><br><span class=\"line\">  res = ci-&gt;func;  <span class=\"comment\">/* res == final position of 1st result */</span></span><br><span class=\"line\">  wanted = ci-&gt;nresults;</span><br><span class=\"line\">  L-&gt;base = (ci - <span class=\"number\">1</span>)-&gt;base;  <span class=\"comment\">/* restore base */</span></span><br><span class=\"line\">  L-&gt;savedpc = (ci - <span class=\"number\">1</span>)-&gt;savedpc;  <span class=\"comment\">/* restore savedpc */</span></span><br><span class=\"line\">  <span class=\"comment\">/* move results to correct place */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = wanted; i != <span class=\"number\">0</span> &amp;&amp; firstResult &lt; L-&gt;top; i--)</span><br><span class=\"line\">    setobjs2s(L, res++, firstResult++);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    setnilvalue(res++);</span><br><span class=\"line\">  L-&gt;top = res;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (wanted - LUA_MULTRET);  <span class=\"comment\">/* 0 iff wanted == LUA_MULTRET */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结下，大致的流程如下：</p>\n<ul>\n<li>1）在<code>f_parser</code>函数中，对代码文件的分析返回了<code>Proto</code>指针。 这个指针会保存在<code>Closure</code>指针中，留待后续继续使用</li>\n<li>2）在<code>luaD_precall</code>函数中，将<code>lua_state</code>的<code>saved pc</code>指针指向第1步中<code>Proto</code>结构体的<code>code</code>指针，同时准备好函数调用时的栈信息</li>\n<li>3）在<code>luaV_execute</code>函数中，<code>pc</code>指针指向第2步中的<code>saved pc</code>指针，紧眼着就是一个大的循环体，依次取出其中的<code>OpCode</code>执行</li>\n<li>4）执行完毕后，调用<code>luaD_poscall</code>函数恢复到上一个函数的环境</li>\n</ul>\n<p>因此，<code>Lua</code>虚拟机指令执行的两大入口函数如下：</p>\n<ul>\n<li>词法、语法分析阶段的<code>luaY_parser</code>。为了提高效率，<code>Lua</code>一次遍历脚本文件不仅完成了词法分析，还完成了语法分析，生成的<code>OpCode</code>存放在<code>Proto</code>结构体的<code>code</code>数组中</li>\n<li><code>luaV_execute</code>。它是虚拟机执行指令阶段的入口函数，取出第一步生成的<code>Proto</code>结构体中的指令执行</li>\n</ul>\n<p><code>Proto</code>是分析阶段的产物，执行阶段将使用分析阶段生成的<code>Proto</code>来执行虚拟机指令，在分析阶段会有许多数据结构参与其中，可它们都是临时用于分析阶段的，或者说最终是用来辅助生成<code>Proto</code>结构体的。</p>\n<div class=\"note info\"><p>可以看到，Proto结构体是分析阶段和执行阶段的纽带。只要抓住了Proto结构体这一个数据的流向，就能对从分析到执行的整个流程有大体的了解了luaY_parser->Proto->luaV_execute。</p></div>\n\n<p>到了这里，可以大致看看<code>Proto</code>结构体中都有哪些数据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Function Prototypes</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proto</span> &#123;</span></span><br><span class=\"line\">  CommonHeader;</span><br><span class=\"line\">  TValue *k;  <span class=\"comment\">//函数的常量数组</span></span><br><span class=\"line\">  Instruction *code;<span class=\"comment\">//编译生成的字节码信息，也就是前面提到的 code成员</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proto</span> **<span class=\"title\">p</span>;</span>  <span class=\"comment\">/* functions defined inside the function */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> *lineinfo;  <span class=\"comment\">/* map from opcodes to source lines */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LocVar</span> *<span class=\"title\">locvars</span>;</span>  <span class=\"comment\">//函数的局部变量信息</span></span><br><span class=\"line\">  TString **upvalues;  <span class=\"comment\">//保存upvalue的数组 </span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; Proto;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lua虚拟机相关的数据结构与栈\"><a href=\"#Lua虚拟机相关的数据结构与栈\" class=\"headerlink\" title=\"Lua虚拟机相关的数据结构与栈\"></a>Lua虚拟机相关的数据结构与栈</h2><p>请看<a href=\"https://github.com/losophy/losophy.github.io/issues/60\">lua_state</a>里的Lua虚拟机相关的数据结构与栈。</p>\n<h2 id=\"指令相关\"><a href=\"#指令相关\" class=\"headerlink\" title=\"指令相关\"></a>指令相关</h2><p><a href=\"https://github.com/losophy/losophy.github.io/issues/116\">lua指令相关</a></p>\n<h2 id=\"从lua-5-1-1中分离出来的vm实现代码\"><a href=\"#从lua-5-1-1中分离出来的vm实现代码\" class=\"headerlink\" title=\"从lua-5.1.1中分离出来的vm实现代码\"></a>从lua-5.1.1中分离出来的vm实现代码</h2><p><a href=\"https://gist.github.com/losophy/2a7afe87b4b4e685e849c3d04f738732\">lvm</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>《Lua设计与实现》</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/113\">Tonmar el destino en sus propias manos.</a></p>\n","tags":["lua"]},{"title":"lua面向对象","url":"/post/3e476df1.html","content":"<p><code>lua</code>中的table就是一种对象。<br><code>lua</code>中可以通过修改<a href=\"https://github.com/losophy/losophy.github.io/issues/107\">元表元方法</a>来实现面向对象。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h2><p><code>table</code>中的<code>self</code>相当于<code>this</code>。</p>\n<blockquote>\n<ul>\n<li><code>table</code>与对象一样可以拥有状态</li>\n<li><code>table</code>也与对象一样拥有一个独立于其值的标识（一个<code>self</code>）</li>\n<li><code>table</code>与对象一样具有独立于创建者和创建地的生命周期</li>\n</ul>\n</blockquote>\n<p>lua只需使用冒号，则能隐藏self参数：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account:withdraw</span><span class=\"params\">(dollar)</span></span></span><br><span class=\"line\">    <span class=\"built_in\">self</span>.balance = <span class=\"built_in\">self</span>.balance - dollar</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"__index\"></a>__index</h2><p>一个类就像是一个创建对象的模具。我们可以利用<code>__index</code>元方法构造继承。<br>当访问一个<code>table</code>中不存在的字段时，得到的结果为<code>nil</code>。这是对的，但并非完全正确。实际上，这些访问会促使解释器去查找一个叫<code>__index</code>的元方法。如果没有这个元方法，那么访问结果如前述的为<code>nil</code>。否则，就由这个元方法来提供最终结果。</p>\n<div class=\"note info\"><p>在lua中，将__index元方法用于继承很普遍，__index还可以是一个table。</p></div>\n\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account:new</span><span class=\"params\">(obj)</span></span></span><br><span class=\"line\">    obj = obj <span class=\"keyword\">or</span> &#123;&#125; <span class=\"comment\">--如果用户没有提供table继承，则创建一个</span></span><br><span class=\"line\">    <span class=\"built_in\">setmetatable</span>(obj,<span class=\"built_in\">self</span>)</span><br><span class=\"line\">    <span class=\"built_in\">self</span>.<span class=\"built_in\">__index</span> = <span class=\"built_in\">self</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<div class=\"note info\"><p>self.__index = self做这个操作是因为self作为元表返回了，也就是查找的时候会进入table创建时的3个步骤。</p></div>\n\n<h2 id=\"lua类的实现\"><a href=\"#lua类的实现\" class=\"headerlink\" title=\"lua类的实现\"></a>lua类的实现</h2><p>可以参考cocos2d-x自己给出的lua类的实现：<br><a href=\"https://gist.github.com/losophy/e8c97ec76fd9100b576ff158714eb9f7\">luaClass.lua</a></p>\n<p>创建对象时，可以通过<code>className.new</code>这种方式来创建，如：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> MySpriteClass = class(<span class=\"string\">&quot;MySpriteClass&quot;</span>,cc.Sprite)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MySpriteClass:ctor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> MySpriteClass</span><br></pre></td></tr></table></figure>\n<p><code>mySpriteClass</code>实例创建：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> mySprite = MySpriteClass.new(xxx.png)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/108814689-36622500-75ee-11eb-88a6-31a5d5bec388.png\" alt=\"1425134-20190408154553314-1254158238\"><br><code>classname.new()</code>生成的<code>instance</code>包含一个<code>class</code>属性。<code>class</code>指向了类原型，并具有<code>super,ctor,__cname</code>和<code>__ctype</code>4个属性。</p>\n<blockquote>\n<p>继承<code>C++</code>的类，<code>new</code>方法使用<code>__create</code>函数来创建实例<br>继承<code>lua</code>类，<code>new</code>方法使用<code>&#123; &#125;</code>来创建实例。</p>\n</blockquote>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/67\">Cada uno es hijo de sus obras.</a></p>\n","tags":["lua"]},{"title":"make","url":"/post/1acc766e.html","content":"<p>make是一条计算机指令，是在安装有GNU Make的计算机上的可执行指令。该指令是读入一个名为makefile的文件，然后执行这个文件中指定的指令。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/109392605-069d7f00-7958-11eb-9e01-51d10239f93a.jpg\" alt=\"makefile知识点\"><br><img src=\"https://user-images.githubusercontent.com/11263320/109392606-07361580-7958-11eb-9c6b-04b1574b57d4.jpg\" alt=\"makefile进阶\"></p>\n<h2 id=\"使用autotools来进行Makefile的自动生成\"><a href=\"#使用autotools来进行Makefile的自动生成\" class=\"headerlink\" title=\"使用autotools来进行Makefile的自动生成\"></a>使用autotools来进行Makefile的自动生成</h2><ul>\n<li>运行 autoscan , 自动创建两个文件： autoscan.log configure.scan<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# autoscan</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">autoscan.log configure.scan main.c</span><br></pre></td></tr></table></figure></li>\n<li>修改configure.scan的文件名为configure.in<br>修改configure.in:<br>  1.修改AC_INIT里面的参数: AC_INIT(main,1.0, <a href=\"mailto:&#x70;&#103;&#112;&#120;&#99;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;\">&#x70;&#103;&#112;&#120;&#99;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a>)<br>  2.添加宏AM_INIT_AUTOMAKE, 它是automake所必备的宏，也同前面一样，PACKAGE是所要产生软件套件的名称，VERSION是版本编号。<br>  3.在AC_OUTPUT后添加输出文件Makefile</li>\n</ul>\n<p>修改后的结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#                                               -*- Autoconf -*-</span><br><span class=\"line\"># Process this file with autoconf to produce a configure script.</span><br><span class=\"line\"></span><br><span class=\"line\">AC_PREREQ(2.61)</span><br><span class=\"line\">AC_INIT(main, 1.0, pgpxc@163.com)</span><br><span class=\"line\">AC_CONFIG_SRCDIR([main.c])</span><br><span class=\"line\">AC_CONFIG_HEADER([config.h])</span><br><span class=\"line\">AM_INIT_AUTOMAKE(main,1.0)</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for programs.</span><br><span class=\"line\">AC_PROG_CC</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for libraries.</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for header files.</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for typedefs, structures, and compiler characteristics.</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for library functions.</span><br><span class=\"line\"></span><br><span class=\"line\">AC_OUTPUT([Makefile])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行 aclocal, 生成一个“aclocal.m4”文件和一个缓冲文件夹autom4te.cache，该文件主要处理本地的宏定义。<br>此时的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# aclocal</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4 autom4te.cache autoscan.log configure.in configure.in~ main.c</span><br></pre></td></tr></table></figure></li>\n<li>运行 autoconf, 目的是生成 configure<br>此时的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# autoconf</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4      autoscan.log configure.in   main.c</span><br><span class=\"line\">autom4te.cache configure     configure.in~</span><br></pre></td></tr></table></figure></li>\n<li>运行 autoheader，它负责生成config.h.in文件。该工具通常会从“acconfig.h”文件中复制用户附加的符号定义，因此此处没有附加符号定义，所以不需要创建“acconfig.h”文件。<br>此时的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# autoheader</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4      autoscan.log configure     configure.in~</span><br><span class=\"line\">autom4te.cache config.h.in   configure.in main.c</span><br></pre></td></tr></table></figure></li>\n<li>下面即将运行 automake, 但在此之前应该做一下准备工作!<br>首先，创建一个 Makefile.am.这一步是创建Makefile很重要的一步，automake要用的脚本配置文件是Makefile.am，用户需要自己创建相应的文件。之后，automake工具转换成Makefile.in。<br>这个Makefile.am的内容如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class=\"line\">bin_PROGRAMS&#x3D;main</span><br><span class=\"line\">main_SOURCES&#x3D;main.c</span><br></pre></td></tr></table></figure>\n其次，使用automake对其生成“configure.in”文件，在这里使用选项“—adding-missing”可以让automake自动添加有一些必需的脚本文件。<br>运行后的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# automake --add-missing</span><br><span class=\"line\">configure.in:8: installing `./missing&#x27;</span><br><span class=\"line\">configure.in:8: installing `./install-sh&#x27;</span><br><span class=\"line\">Makefile.am: installing `./depcomp&#x27;</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4      config.h.in   configure.in~ main.c        Makefile.in</span><br><span class=\"line\">autom4te.cache configure     depcomp        Makefile.am missing</span><br><span class=\"line\">autoscan.log    configure.in install-sh     Makefile.am~</span><br></pre></td></tr></table></figure></li>\n<li>到这里，就是我们熟悉的环节了。<br>运行configure，在这一步中，通过运行自动配置设置文件configure，把Makefile.in变成了最终的Makefile。<br>运行make，根据Makefile操作。<br>运行make install，安装到指定目录。</li>\n</ul>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/115\">La Psiquiatría/psicología es el único negocio donde el cliente nunca ti ene la razón.</a></p>\n","tags":["linux"]},{"title":"mongodb的一些脚本","url":"/post/9ef4a41.html","content":"<p>这里记录下一些mongodb脚本，和sql表示的是一致的。</p>\n<a id=\"more\"></a>\n\n<p><code>select * from player</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).find(&#123;&#125;) </span><br></pre></td></tr></table></figure>\n<p><code>select checkIn from player</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).find(&#123;&quot;checkIn&quot;:&#123;&quot;$exists&quot;:true&#125;&#125;) </span><br></pre></td></tr></table></figure>\n<p><code>select boss.1001.night from player</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).find(&#123;&quot;boss.1001.night&quot;:&#123;&quot;$exists&quot;:true&#125;&#125;) </span><br></pre></td></tr></table></figure>\n<p><code>update player set checkIn = &quot;&quot;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).update(&#123;&#125;,&#123;$unset:&#123;&quot;checkIn&quot;:&quot;&quot;&#125;&#125;,false,true) </span><br></pre></td></tr></table></figure>\n<p><code>update player set boss.1001.night = &quot;&quot;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).update(&#123;&#125;,&#123;$unset:&#123;&quot;boss.1001.night&quot;:&quot;&quot;&#125;&#125;,false,true)</span><br></pre></td></tr></table></figure>\n<h2 id=\"Limit与Skip的用法\"><a href=\"#Limit与Skip的用法\" class=\"headerlink\" title=\"Limit与Skip的用法\"></a>Limit与Skip的用法</h2><p>查询文档中两条记录<br>第一个 {} 放 where 条件，为空表示返回集合中所有文档。<br>第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。<br><img src=\"https://user-images.githubusercontent.com/11263320/141882700-9e747097-c16d-4702-bc63-e6d932f45dc3.png\" alt=\"O1av56o\"></p>\n<p>查询显示第2、3条文档数据<br>skip()方法默认参数为 0 。<br>skip 和 limit 结合就能实现分页。<br><img src=\"https://user-images.githubusercontent.com/11263320/141942940-25f9194a-96c4-44da-b262-dcb38c1defb1.png\" alt=\"O1av56o\"></p>\n<h2 id=\"排序-sort-方法\"><a href=\"#排序-sort-方法\" class=\"headerlink\" title=\"排序 sort() 方法\"></a>排序 sort() 方法</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/141943031-74400ccd-fc0c-4d01-892d-2bb8d793c9d9.png\" alt=\"O1av56o\"></p>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/4\">Sé el cambio que quieres ver en el mundo.</a></p>\n","tags":["mongodb"]},{"title":"mysql事务","url":"/post/3d3705e1.html","content":"<p><code>MySQL</code>数据库中事务是用户一系列的数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。</p>\n<a id=\"more\"></a>\n\n<div class=\"note warning\"><p>mysql服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中使用多种存储引擎是不可靠的。</p></div>\n\n<h2 id=\"事务的四大特性-简称ACID\"><a href=\"#事务的四大特性-简称ACID\" class=\"headerlink\" title=\"事务的四大特性(简称ACID)\"></a>事务的四大特性(简称ACID)</h2><p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：</p>\n<h3 id=\"原子性（Atomicity）\"><a href=\"#原子性（Atomicity）\" class=\"headerlink\" title=\"原子性（Atomicity）\"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<h3 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>\n<h3 id=\"隔离性（Isolation）\"><a href=\"#隔离性（Isolation）\" class=\"headerlink\" title=\"隔离性（Isolation）\"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>\n<h3 id=\"持久性（Durability）\"><a href=\"#持久性（Durability）\" class=\"headerlink\" title=\"持久性（Durability）\"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p>\n<h2 id=\"事务实例\"><a href=\"#事务实例\" class=\"headerlink\" title=\"事务实例\"></a>事务实例</h2><p><code>MySQL</code>的<code>ROLLBACK</code>命令用来回退（撤销）<code>MySQL</code>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from ordertotals;</span><br><span class=\"line\">start transaction;</span><br><span class=\"line\">delete from ordertotals;</span><br><span class=\"line\">select * from ordertotals;</span><br><span class=\"line\">rollback;</span><br><span class=\"line\">select * from ordertotals;</span><br></pre></td></tr></table></figure>\n<p>养成书写<code>start tran + commit/rollback</code>的习惯，<code>exec</code>的时候不要离开现场。<br><code>rollback</code>是回滚事务，只要没有<code>commit</code>提交，还可以恢复之前的数据。<code>commit</code>是提交事务，你不提交事务，你之前所有更改的数据别人在查看是看不到只能看到之前的数据，<code>commit</code>提交以后，别人才可看到你更新后的数据。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/52\">No dejes para mañana lo que puedas hacer hoy.</a></p>\n","tags":["mysql"]},{"title":"mysql备份、复制","url":"/post/4bb2a065.html","content":"<p><code>MySQL</code>整体来看，其实就有两块：一块是<code>Server</code>层，它主要做的是<code>MySQL</code>功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。<code>InnoDB</code>引擎特有的日志是<code>redo log</code>，而<code>Server</code>层的日志称为<code>binlog</code>。<code>binlog</code>记录了对<code>MySQL</code>数据库执行更改的所有操作，<code>binlog</code>文件写到一定大小后会切换到下一个（但一个事务的操作肯定在一个文件中，即大事务引发大文件）。</p>\n<a id=\"more\"></a>\n\n<p>其大体作用：</p>\n<blockquote>\n<p>恢复：某些数据的恢复需要二进制日志。<br>复制<code>（replication）</code>：通过复制和执行二进制日志使一台远程的<code>MySQL</code>数据库（一般为<code>slave</code>或<code>standby</code>）与一台<code>MySQL</code>数据库（一般为<code>master</code>或<code>primary</code>）进行同步。(阿里<code>cannel</code>开源框架)<br>审计（<code>audit</code>）：用户可以通过二进制日志中的信息进行审计，判断是否有对数据库进行注入的攻击</p>\n</blockquote>\n<h2 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h2><p>将指定数据库备份到某dump文件（转储文件）中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqldump -uroot -p123 test &gt; test.dump</span><br></pre></td></tr></table></figure>\n<p>从备份文件恢复数据库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p123 test &lt; test.dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><p><code>mysql</code>支持两种复制方式：基于行的复制和基于语句的复制。基于语句的复制（也称为逻辑复制）。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。<br>这意味着，在同一时间点备库上的数据可能与主库存在不一致，并且无法保证主备之间的廷迟。一些大的语句可能导致备库产生几称、几分钟甚至几个小时的廷迟。<br>主库和备库使用不同的存储引擎（不推荐）</p>\n<p>基于行的复制不会受这个问题的影响。因为它记录的是数据的更改，而不是<code>SQL</code>语句。如果一条语句改变了一个<code>myisam</code>表和一个<code>innodb</code>表的某些行，然后主库上发生了一次死锁，<code>innodb</code>表的更新会被回滚，而<code>myisam</code>表的更新仍会被记录到日志中并在备库重放。<br>当使用基于语句的复制方式时，如果通过不确定的方式更改数据可能会导致主备不一致。</p>\n<h3 id=\"根据备份的方法不同可以将备份分为\"><a href=\"#根据备份的方法不同可以将备份分为\" class=\"headerlink\" title=\"根据备份的方法不同可以将备份分为\"></a>根据备份的方法不同可以将备份分为</h3><p>热备、冷备、温备。<br>热备是指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响。<br>冷备非常简单，只需要备份<code>mysql</code>数据库的<code>frm</code>文件，共享表空间文件，独立表空间文件，重做日志文件，配置文件。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/46\">A cada cerdo le llega su San Martín.</a></p>\n","tags":["mysql"]},{"title":"mysql数据结构","url":"/post/22e29991.html","content":"<p>从<code>InnoDB</code>存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间<code>（tablespace）</code>。表空间又由段<code>（segment）</code>、区<code>（extent）</code>、页<code>（page）</code>组成。页在一些文档中有时也称为块<code>（block）</code>。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"InnoDB存储引擎的逻辑存储结构\"><a href=\"#InnoDB存储引擎的逻辑存储结构\" class=\"headerlink\" title=\"InnoDB存储引擎的逻辑存储结构\"></a>InnoDB存储引擎的逻辑存储结构</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108633531-a61dc600-74af-11eb-97f9-4f2ba133705e.jpg\" alt=\"1425134-20190316171629020-1958519047\"></p>\n<h2 id=\"表空间\"><a href=\"#表空间\" class=\"headerlink\" title=\"表空间\"></a>表空间</h2><p>表空间可以看做是<code>InnoDB</code>存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>\n<h2 id=\"段\"><a href=\"#段\" class=\"headerlink\" title=\"段\"></a>段</h2><p>因为<code>InnoDB</code>存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶子节点<code>（Leaf node segment）</code>，索引段即为<code>B+</code>树的非索引节点<code>（Non-leaf node segment）</code>。</p>\n<h2 id=\"区\"><a href=\"#区\" class=\"headerlink\" title=\"区\"></a>区</h2><p>区是由连续页组成的空间。</p>\n<h2 id=\"页\"><a href=\"#页\" class=\"headerlink\" title=\"页\"></a>页</h2><p>页是<code>InnoDB</code>磁盘管理的最小单位。</p>\n<h2 id=\"行\"><a href=\"#行\" class=\"headerlink\" title=\"行\"></a>行</h2><p><code>InnoDB</code>存储引擎是面向列的，也就说数据是按行进行存放的。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/140\">No vendas la piel del oso antes de cazarlo.</a></p>\n","tags":["mysql"]},{"title":"mysql架构","url":"/post/2113b019.html","content":"<p><code>MySQL</code>是单进程多线程，而<code>Oracle</code>等是多进程。</p>\n<a id=\"more\"></a>\n\n<p>一般来说，关键的生产<code>DBMS</code>应该运行在自己的专用服务器上。 </p>\n<h2 id=\"mysql包括\"><a href=\"#mysql包括\" class=\"headerlink\" title=\"mysql包括\"></a>mysql包括</h2><blockquote>\n<ul>\n<li>DBMS数据库管理系统（实例）</li>\n<li>数据库（容器）<br>在<code>mysql</code>数据库中，实例与数据库的关系通常是一一对应的，但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。</li>\n</ul>\n</blockquote>\n<h2 id=\"mysql逻辑架构\"><a href=\"#mysql逻辑架构\" class=\"headerlink\" title=\"mysql逻辑架构\"></a>mysql逻辑架构</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108652560-6bdc1500-74ff-11eb-9f36-34d29dbcc2ef.jpg\" alt=\"1425134-20190311163049501-1910090477\"><br>上层是服务器层的服务和查询执行引擎，下层则是存储引擎。 </p>\n<p>除非需要用到某些<code>InnodDB</code>不具备的特性，并且没有其他办法可以替代，否则都应该优先选择<code>InnoDB</code>引擎。<br>除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题，以及一些潜在的<code>bug</code>和边界问题。存储引擎层和服务器层的交互已经比较复杂，更不用说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。</p>\n<p>因为<code>MySQL</code>是单进程多线程，所以每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个<code>CPU</code>核心或者<code>CPU中</code>运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>\n<h2 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108652613-86ae8980-74ff-11eb-97c2-3943134276da.jpg\" alt=\"1425134-20190315154442820-765166828\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><blockquote>\n<p>master：核心线程，主要负责将缓冲池中的数据异步刷新到磁盘<br>IO：负责IO请求的回调处理<br>purge：事务被提交台，其所使用的undolog可能不再需要，因此需要purge来回收已经使用并分配的undo页<br>page cleaner：脏页的刷新操作</p>\n</blockquote>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>缓冲池：<code>InnoDB</code>存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于<code>CPU</code>速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>\n<h2 id=\"InnoDB关键特性\"><a href=\"#InnoDB关键特性\" class=\"headerlink\" title=\"InnoDB关键特性\"></a>InnoDB关键特性</h2><blockquote>\n<p>插入缓冲<br>两次写<br>自适应哈希索引<br>异步IO<br>刷新邻接页</p>\n</blockquote>\n<p>关系型数据库系统和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束机制，该机制提供了一条强大而简易的途径来保证数据库中数据的完整性。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/47\">Consejo no pedido, consejo mal oído.</a></p>\n","tags":["mysql"]},{"title":"mysql索引","url":"/post/71014c5a.html","content":"<p>聚集索引以及非聚集索引用的是<code>B+</code>树索引。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h2><p>聚簇索引就是按照每张表的主键构造一颗B+树。单单从定义来看是不是显得有点抽象，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址。</p>\n<h2 id=\"非聚集索引\"><a href=\"#非聚集索引\" class=\"headerlink\" title=\"非聚集索引\"></a>非聚集索引</h2><p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。</p>\n<h2 id=\"为什么要创建索引\"><a href=\"#为什么要创建索引\" class=\"headerlink\" title=\"为什么要创建索引\"></a>为什么要创建索引</h2><p>这是因为，创建索引可以大大提高系统的性能。</p>\n<blockquote>\n<p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性<br>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义<br>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</p>\n</blockquote>\n<h2 id=\"深入浅出理解索引结构\"><a href=\"#深入浅出理解索引结构\" class=\"headerlink\" title=\"深入浅出理解索引结构\"></a>深入浅出理解索引结构</h2><p>实际上，您可以把索引理解为一种特殊的目录。微软的<code>SQL SERVER</code>提供了两种索引：聚集索引（<code>clustered index</code>，也称聚类索引、簇集索引）和非聚集索引（<code>nonclustered index</code>，也称非聚类索引、非簇集索引）。</p>\n<p>下面，我们举例来说明一下聚集索引和非聚集索引的区别：</p>\n<h3 id=\"聚集索引\"><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h3><p>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。</p>\n<h3 id=\"非聚集索引-1\"><a href=\"#非聚集索引-1\" class=\"headerlink\" title=\"非聚集索引\"></a>非聚集索引</h3><p>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。</p>\n<div class=\"note info\"><p>通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p></div>\n\n<h2 id=\"何时使用聚集索引或非聚集索引\"><a href=\"#何时使用聚集索引或非聚集索引\" class=\"headerlink\" title=\"何时使用聚集索引或非聚集索引\"></a>何时使用聚集索引或非聚集索引</h2><p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p>\n<h2 id=\"索引使用的误区\"><a href=\"#索引使用的误区\" class=\"headerlink\" title=\"索引使用的误区\"></a>索引使用的误区</h2><p>虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。</p>\n<h3 id=\"主键就是聚集索引\"><a href=\"#主键就是聚集索引\" class=\"headerlink\" title=\"主键就是聚集索引\"></a>主键就是聚集索引</h3><p>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然<code>SQL SERVER</code>默认是在主键上建立聚集索引的。<br>通常，我们会在每个表中都建立一个<code>ID</code>列，以区分每条数据，并且这个<code>ID</code>列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列<code>Gid</code>就是如此。此时，如果我们将这个列设为主键，<code>SQL SERVER</code>会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照<code>ID</code>进行物理排序，但笔者认为这样做意义不大。<br>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。<br>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为<code>ID</code>号是自动生成的，我们并不知道每条记录的<code>ID</code>号，所以我们很难在实践中用<code>ID</code>号来进行查询。这就使让<code>ID</code>号这个主键作为聚集索引成为一种资源浪费。其次，让每个<code>ID</code>号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。<br>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。<br>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的<code>where</code>语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。<br>在这里之所以提到“理论上”三字，是因为如果您的聚集索引还是盲目地建在<code>ID</code>这个主键上时，您的查询速度是没有这么高的，即使您在“日期”这个字段上建立的索引（非聚合索引）。</p>\n<h3 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h3><p>索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。<br>所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。<br>当然，在实践中，作为一个尽职的数据库管理员，您还要多测试一些方案，找出哪种方案效率最高、最为有效。</p>\n<p>有索引情况下，<code>insert</code>速度一定有影响，不过：</p>\n<ol>\n<li>你不大可能一该不停地进行<code>insert</code>, <code>SQL Server</code>能把你传来的命令缓存起来，依次执行，不会漏掉任何一个<code>insert</code>。</li>\n<li>你也可以建立一个相同结构但不做索引的表，<code>insert</code>数据先插入到这个表里，当这个表中行数达到一定行数再用<code>insert table1 select * from table2</code>这样的命令整批插入到有索引的那个表里。</li>\n</ol>\n<h2 id=\"InnoDB存储引擎支持以下几种常见的索引\"><a href=\"#InnoDB存储引擎支持以下几种常见的索引\" class=\"headerlink\" title=\"InnoDB存储引擎支持以下几种常见的索引\"></a>InnoDB存储引擎支持以下几种常见的索引</h2><h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>就是传统意义上的索引，<code>B+</code>树索引的构造类似于二叉树，根据键值快速找到数据。<code>B+</code>树索引并不能找到一个给定键值的具体行。<code>B+</code>树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>\n<h3 id=\"全文索引\"><a href=\"#全文索引\" class=\"headerlink\" title=\"全文索引\"></a>全文索引</h3><p>通过数值比较、范围过滤就可以完成绝大多数我们需要的查询了。但是，如果你希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p>\n<h3 id=\"哈希索引\"><a href=\"#哈希索引\" class=\"headerlink\" title=\"哈希索引\"></a>哈希索引</h3><p><code>InnoDB</code>存储引擎支持的哈希索引是自适应的，<code>InnoDB</code>存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>\n<h2 id=\"mysql-键值类型\"><a href=\"#mysql-键值类型\" class=\"headerlink\" title=\"mysql 键值类型\"></a>mysql 键值类型</h2><blockquote>\n<p>普通索引 index (id name sex age loves)<br>唯一索引 unique<br>主键 primary key<br>外键 foreign key<br>全文索引 fulltext </p>\n</blockquote>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/49\">Gobernar es prever.To govern is to foresee.</a></p>\n","tags":["mysql"]},{"title":"mysql维护","url":"/post/5ca7fcde.html","content":"<p>这里记录下，mysql维护的语句。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"查看mysql-的端口号\"><a href=\"#查看mysql-的端口号\" class=\"headerlink\" title=\"查看mysql 的端口号\"></a>查看mysql 的端口号</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;port&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow%&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow%&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<h2 id=\"连接数\"><a href=\"#连接数\" class=\"headerlink\" title=\"连接数\"></a>连接数</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;max_connections&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<h2 id=\"进程使用情况\"><a href=\"#进程使用情况\" class=\"headerlink\" title=\"进程使用情况\"></a>进程使用情况</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> ‘Thread<span class=\"operator\">%</span>’; </span><br></pre></td></tr></table></figure>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>mysql数据库常见的日志文件有：</p>\n<blockquote>\n<p>错误日志（error log）<br>二进制日志（binlog）<br>慢查询日志（slow query log）<br>查询日志（log）</p>\n</blockquote>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/48\">Obras son amores y no buenas razones.</a></p>\n","tags":["mysql"]},{"title":"mysql：锁","url":"/post/d620d60b.html","content":"<p>锁机制用于管理对共享资源的并发访问。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a>行级锁</h2><p>行级锁只在存储引擎层实现，在服务器层没有实现。</p>\n<h2 id=\"mysql乐观锁、悲观锁\"><a href=\"#mysql乐观锁、悲观锁\" class=\"headerlink\" title=\"mysql乐观锁、悲观锁\"></a>mysql乐观锁、悲观锁</h2><p><code>latch</code>门闩，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在<code>InnoDB</code>存储引擎中，<code>latch</code>又可以分为<code>mutex</code>（互斥量）和<code>rwlock</code>（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>\n<p><code>lock</code>的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务<code>commt</code>或<code>rollback</code>后进行释放（不同事务隔离级别释放的时间可能不同）。此外，<code>lock</code>，正如在大多数数据库中一样，是有死锁机制的。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。</p>\n<h2 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h2><p>锁升级是指将当前锁的粒度降低。比如，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表负。如果在数据库的设计中认为锁是一种稀有资源，而且想避免锁的开销，那数据库中会频繁出现锁升级现象。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/53\">Donde no hay harina, todo es mohina.</a></p>\n","tags":["mysql"]},{"title":"python高级字符串格式化","url":"/post/973a3d03.html","content":"<p>这里记录下，python高级字符串格式化。</p>\n<a id=\"more\"></a>\n\n<p>字符串的format()函数,该方法收集位置参数和关键字参数的任意集合,并使用它们的值来替换字符串中的占位符;<br>形式为{n}(n为整数)的占位符将被format()方法第n个参数所代替;<br>形式为{name}的占位符将被参数中为name的参数所替代;<br>如果要用format()输出{xx},必须使用,否则会因为找不到对应的参数值而报错;<br>可以指定格式说明符,对输出进行更加精确地控制.<br>给每个占位符添加可选的格式说明符号,如{name:format_spec}.这种说明符可指定列宽,小数位和对齐方式.<br>一般格式[fill,align,sign,0,width,.precision,type],每一处都是可选的.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;&#123;a&#125;&#125;&quot;</span>.<span class=\"built_in\">format</span>()                   <span class=\"comment\">#&#123;a&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;a&#125;&quot;</span>.<span class=\"built_in\">format</span>()                     <span class=\"comment\">#error,里面没有为a的参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;a&#125; - &#123;b&#125;&quot;</span>.<span class=\"built_in\">format</span>(a = <span class=\"number\">100</span>,b = <span class=\"number\">200</span>)<span class=\"comment\">#100 - 200</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0&#125;,&#123;0&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"number\">22</span>)            <span class=\"comment\">#11,11</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0&#125;,&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>) <span class=\"comment\"># 11,11,22,33  中括号里面的数代表第几个参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:3d&#125;,&#123;1:4s&#125;,&#123;1:5s&#125;,&#123;2&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"string\">&quot;a&quot;</span>,<span class=\"number\">33</span>) <span class=\"comment\"># &#x27; 11,a   ,a    ,33&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:=&gt;+011.3f&#125;;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">12.12345</span>)  <span class=\"comment\">#====+12.123;用=来填充,右对齐,因为已经用=来填充了,0无效,宽度11,小数点精度后精度为3,类型为浮点数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:&gt;+011.3f&#125;;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">12.12345</span>)   <span class=\"comment\">#0000+12.123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)                <span class=\"comment\">#test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0!s:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)              <span class=\"comment\">#test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0!r:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)              <span class=\"comment\">#&#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#通过下标也行</span></span><br><span class=\"line\">a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;&#123;0[0]&#125;,&#123;0[1]&#125;&#x27;</span>.<span class=\"built_in\">format</span>(a)          <span class=\"comment\">#1,2</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/22\">Dicen que cuando Piscis y Acuario se casan, el matrimonio naufraga.</a></p>\n","tags":["python"]},{"title":"redis单机数据库的实现","url":"/post/b7b3d1ea.html","content":"<p><code>redis</code>服务器将所有数据库都保存在服务器状态<code>db</code>数组中。<br><code>dbnum</code>由<code>conf</code>文件<code>database</code>选项决定。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *configfile;             <span class=\"comment\">// 配置文件的绝对路径</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hz;                       <span class=\"comment\">// serverCron() 每秒调用的次数</span></span><br><span class=\"line\">    redisDb *db;    <span class=\"comment\">// 数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>分析rdb文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">od -c dump.rdb</span><br></pre></td></tr></table></figure>\n<h2 id=\"redis事件驱动\"><a href=\"#redis事件驱动\" class=\"headerlink\" title=\"redis事件驱动\"></a>redis事件驱动</h2><p><code>redis</code>服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p>\n<blockquote>\n<p>文件事件：文件事件就是服务器对套接字操作的抽象<br>时间事件：时间事件就是服务器对这类定时操作的抽象</p>\n</blockquote>\n<p><code>redis</code>基于<code>reactor</code>模式开发了自己的网络事件处理器。<br>与<code>Memcached</code>不同，<code>Redis</code>并没有直接使用<code>Libevent</code>，而是自己完成了一个非常轻量级的对<code>select、epoll、evport、kqueue</code>这些通用的接口的实现。在不同的系统调用选用适合的接口，<code>linux</code>下默认是<code>epoll</code>。因为<code>Libevent</code>比较重更通用代码量也就很庞大，拥有很多<code>Redis</code>用不上的功能，<code>Redis</code>为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。</p>\n<h2 id=\"redis协议（aof文件写入也是这个格式）\"><a href=\"#redis协议（aof文件写入也是这个格式）\" class=\"headerlink\" title=\"redis协议（aof文件写入也是这个格式）\"></a>redis协议（aof文件写入也是这个格式）</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《redis 设计与实现》<br>Redis 2.9源码</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/10\">Algo es algo; menos es nada.</a></p>\n","tags":["redis"]},{"title":"redis在游戏开发中的应用","url":"/post/c718a52d.html","content":"<p><code>Redis</code>是一个新兴的<code>NoSql</code>数据缓存组件，与<code>memcache</code>类似，但是功能却比<code>memcache</code>多一些。<br>首先，<code>Redis</code>和<code>memcache</code>都是基于内存的，所以读取和写入速度都非常快。但是<code>memcache</code>只支持简单的<code>key-value</code>数据的存储方式，而<code>Redis</code>对<code>key-value ,hash,list,set,SortSet</code>等数据结构有很好的支持。</p>\n<a id=\"more\"></a>\n\n<p>下面就Redis在游戏的开发应用中做一些简单的介绍。</p>\n<h2 id=\"数据的缓存\"><a href=\"#数据的缓存\" class=\"headerlink\" title=\"数据的缓存\"></a>数据的缓存</h2><p>在这一点上，<code>redis</code>和<code>memcache</code>是一样的。都是把数据提前放入到内存中。当逻辑处理中需要用到数据时，先从内存中读取，相同的，写的时候也先向内存中写入，然后再操作数据库，以增加数据处理的速度。不同的是，<code>redis</code>带有把数据写入到硬盘的功能，具体的写入策略可以在<code>redis</code>的配置文件中配置。这样当主机突然出现故障时，比如断电，重启机器不会造成数据的丢失。这个在游戏的应用中特别重要。一般在游戏开发中，数据的处理会采用：缓存 + 持久化队列 + 数据库(<code>mysql</code>)的架构。执行的流程是先把数据写入到缓存，然后把需要持久化的数据放入到持久化队列中，启动一个守护线程，从持久化队列中不断的取出数据，并存入或更新到数据库。如果使用<code>memcache</code>这样没有写入到硬盘功能的缓存组件，出现故障时，持久人队列中如果还有没有处理完的数据，那么就会造成数据的丢失，引用玩家的数据出现短暂的回档。当然这些也可以自己开发一些功能去防止，但是增加了开发成本。</p>\n<h2 id=\"不丢失数据的持久化队列的实现\"><a href=\"#不丢失数据的持久化队列的实现\" class=\"headerlink\" title=\"不丢失数据的持久化队列的实现\"></a>不丢失数据的持久化队列的实现</h2><p>上面说过<code>Redis</code>具有把数据写入到硬盘的功能，而且支持多种数据结构。那么就可以利用<code>Redis</code>的<code>list</code>实现持久化队列，而且当机器出现故障时，不会出现队列中数据丢失的情况，重启之后，数据会自动加载到<code>redis</code>的<code>list</code>之中。<br>具体实现方法：</p>\n<blockquote>\n<p>（1）在<code>Redis</code>中构造一个<code>list</code>存储<br>（2）一个线程使用<code>Redis</code>的<code>lpush</code>方法，向<code>list</code>的左边加入数据<br>（3）另外一个线程使用<code>Redis</code>的<code>rpop</code>方法，从<code>list</code>取出数据进行处理，并且从<code>list</code>中删除了取出的数据。这样就实现了一个简单的生产者–消费者模式的队列</p>\n</blockquote>\n<h2 id=\"对并发操作的控制（跨房间）\"><a href=\"#对并发操作的控制（跨房间）\" class=\"headerlink\" title=\"对并发操作的控制（跨房间）\"></a>对并发操作的控制（跨房间）</h2><p>一般来说，我们操作一个数据的流程是这样的，取出–处理—存储，这样在单线程中操作是没有任务问题的，但是在多线程环境中就不适用了，我们必须考虑数据同步的问题，保证数据操作的原子性。如果在游戏中，对玩家战队的属性进行更新，一般在数据库中都会保存一个<code>TeamInfo</code>表，里面有玩家相应的属性，比如名字，等级，金币，钻石等等。在<code>memcache</code>中保存一个<code>TeamInfo</code>对象，这时玩家获得金币，我们就需要取出玩家所有的属性，然后<code>set</code>金币，完成后再存储整个对象。这个时候就得考虑数据的同步了，如果在操作的时候，另外一个线程<code>B</code>修改了钻石，并完成了存储，而这个时候我把金币修改完成之后，再存储，这时，就出现了数据混乱的结果。考虑数据同步无非也是加锁或乐观同步。不但增加了代码量，还增加了维护的难度。而在<code>Redis</code>中，它支持对<code>hash</code>数据结构的操作。我们可以把玩家的对象按每个字段存储到<code>redis</code>的<code>hash</code>中。</p>\n<p>当我需要更新金币时，比如增加或减少，我可以使用<code>Redis</code>自带的原子操作方法：<code>hincrby(String key,String field,int value)</code>进行操作，<code>value</code>是正为加，是负为减，这样就简化和避免了一些并发操作，而且这个操做还减少了对数据的操作步骤，因为没有取出，再操作的过程了，只有一次写入。而且在游戏中很少一次更新非常多的字段，如果有这样的情况，下面的方法可以解决。</p>\n<h2 id=\"对事务的支持\"><a href=\"#对事务的支持\" class=\"headerlink\" title=\"对事务的支持\"></a>对事务的支持</h2><p><code>redis</code>提供了一个事务操作的机制，<code>MULTI</code>命令用于开启一个事务，它总是返回<code>OK</code>。<br><code>MULTI</code>执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当<code>EXEC</code>命令被调用时， 所有队列中的命令才会被执行。<br>另一方面， 通过调用<code>DISCARD</code>， 客户端可以清空事务队列， 并放弃执行事务。<br>以下是一个事务例子， 它原子地增加了<code>foo</code>和<code>bar</code>两个键的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; INCR foo</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">&gt; INCR bar</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">&gt; EXEC</span><br><span class=\"line\">1) (integer) 1</span><br><span class=\"line\">2) (integer) 1</span><br></pre></td></tr></table></figure>\n<p><code>EXEC</code>命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。当客户端处于事务状态时， 所有传入的命令都会返回一个内容为<code>QUEUED</code>的状态回复<code>（status reply）</code>， 这些被入队的命令将在<code>EXEC</code>命令被调用时执行。从<code>Redis 2.6.5</code>开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 <code>EXEC</code>命令时，拒绝执行并自动放弃这个事务。</p>\n<h2 id=\"提供外部的CAS行为，实现乐观锁机制\"><a href=\"#提供外部的CAS行为，实现乐观锁机制\" class=\"headerlink\" title=\"提供外部的CAS行为，实现乐观锁机制\"></a>提供外部的CAS行为，实现乐观锁机制</h2><p>在游戏开发中，有时候需要我们自己在外部实现乐观锁机制，<code>WATCH</code>命令可以为<code>Redis</code>事务提供<code>check-and-set （CAS）</code>行为，被<code>WATCH</code>的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在<code>EXEC</code>执行之前被修改了， 那么整个事务都会被取消， <code>EXEC</code>返回空多条批量回复<code>（null multi-bulk reply）</code>来表示事务已经失败。<br>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设<code>INCR</code>不存在）。<br>首先我们可能会这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">val &#x3D; GET mykey</span><br><span class=\"line\">val &#x3D; val + 1</span><br><span class=\"line\">SET mykey $val</span><br></pre></td></tr></table></figure>\n<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。<br>举个例子， 如果客户端<code>A</code>和<code>B</code>都读取了键原来的值， 比如10， 那么两个客户端都会将键的值设为11， 但正确的结果应该是12 才对。<br>有了<code>WATCH</code>， 我们就可以轻松地解决这类问题了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">WATCH mykey</span><br><span class=\"line\">val &#x3D; GET mykey</span><br><span class=\"line\">val &#x3D; val + 1</span><br><span class=\"line\">MULTI</span><br><span class=\"line\">SET mykey $val</span><br><span class=\"line\">EXEC</span><br></pre></td></tr></table></figure>\n<p>使用上面的代码， 如果在<code>WATCH</code>执行之后，<code>EXEC</code>执行之前， 有其他客户端修改了<code>mykey</code>的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>\n<h2 id=\"缓存生命周期的控制\"><a href=\"#缓存生命周期的控制\" class=\"headerlink\" title=\"缓存生命周期的控制\"></a>缓存生命周期的控制</h2><p>在游戏服务器中，为了节省性能，我们没有必要把所有玩家的信息都缓存到内存中。比如有一些不常登陆的玩家，那么他的信息就没必要一直呆在缓存中了，需要清除。<code>Redis</code>为这个功能提供了一个方法：<code>expire</code>，它可以为<code>key</code>设置以秒为单位的生命周期，比如设置为300s，那么五分钟之后，这条记录就会在内存中删除。这样不仅可以节省内存，而且增加了服务器的性能</p>\n<h2 id=\"排行榜\"><a href=\"#排行榜\" class=\"headerlink\" title=\"排行榜\"></a>排行榜</h2><p>游戏服务器中涉及到很多排行信息，比如玩家等级排名、金钱排名、战斗力排名等。<br>一般情况下仅需要取排名的前N名就可以了，这时可以利用数据库的排序功能，或者自己维护一个元素数量有限的top集合。<br>但是有时候我们需要每一个玩家的排名，玩家的数量太多，不能利用数据库（全表排序压力太大），自己维护也会比较麻烦。<br>使用<code>Redis</code>可以很好的解决这个问题。它提供的有序Set，支持每个键值（比如玩家<code>id</code>）拥有一个分数<code>（score）</code>，每次往这个<code>set</code>里添加元素，<code>Redis</code>会对其进行排序，修改某一元素的<code>score</code>后，也会更新排序，在获取数据时，可以指定排序范围。<br>更重要的是，这个排序结果会被保存起来，不用在服务器启动时重新计算。<br>通过它，排行榜的实时刷新、全服排行都不再成为麻烦事。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/45\">El mundo es un pañuelo.</a></p>\n","tags":["redis"]},{"title":"redis多机数据库的实现","url":"/post/f2066cc0.html","content":"<p>这里分别对<code>Redis</code>的复制、<code>Sentinel</code>、集群三个多机功能进行介绍。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p><code>redis 2.8</code>版本之前是主发送rdb文件给从实现复制的。效率较低。重连后同步，耗时。<br>新版本分完整同步和部分同步。完整同步和旧版一样，而部分同步则处理断线后重复制情况。</p>\n<p>分部同步由三部分组成：</p>\n<blockquote>\n<p>offset偏移量<br>复制积压缓冲区<br>服务器运行id</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> runid[REDIS_RUN_ID_SIZE+<span class=\"number\">1</span>];  <span class=\"comment\">// 本服务器的 RUN ID</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> master_repl_offset;   <span class=\"comment\">// 全局复制偏移量（一个累计值）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ...  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Sentinel\"><a href=\"#Sentinel\" class=\"headerlink\" title=\"Sentinel\"></a>Sentinel</h2><p><code>Sentinel</code>是特殊状态下的<code>redis</code>服务器，本质不用数据库。<br><code>Sentinel</code>有它自己的命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisCommand</span> <span class=\"title\">sentinelcmds</span>[] =</span> &#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ping&quot;</span>,pingCommand,<span class=\"number\">1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;sentinel&quot;</span>,sentinelCommand,<span class=\"number\">-2</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;subscribe&quot;</span>,subscribeCommand,<span class=\"number\">-2</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;unsubscribe&quot;</span>,unsubscribeCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;psubscribe&quot;</span>,psubscribeCommand,<span class=\"number\">-2</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;punsubscribe&quot;</span>,punsubscribeCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;publish&quot;</span>,sentinelPublishCommand,<span class=\"number\">3</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;info&quot;</span>,sentinelInfoCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;shutdown&quot;</span>,shutdownCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>sentinel</code>中的<code>master</code>字典记录所有被监视的主服务器相关信息</p>\n<blockquote>\n<p>字典的键是主服务器的信息<br>字典的值是主服务器对应的这个结构</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sentinelRedisInstance</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;      <span class=\"comment\">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;     </span><br><span class=\"line\">    <span class=\"keyword\">char</span> *runid;      <span class=\"comment\">// 实例的运行 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个<code>Sentinel</code>会进行协商，选举出一个领头<code>Sentinel</code>，并由领头<code>Sentinel</code>对下线主服务器执行故障转移操作。</p>\n<blockquote>\n<ul>\n<li>每个发现主服务器进入客观下线的<code>Sentinel</code>都会要求其他<code>Sentinel</code>将自己设置为局部领头<code>Sentinel</code></li>\n<li><code>Sentinel</code>设置局部领头<code>Sentinel</code>的规则是先到先得：最先向目标<code>Sentinel</code>发送设置的，会成为其局部领头<code>Sentinel</code></li>\n<li>如果有某个<code>Sentinel</code>被半数以上的<code>Sentinel</code>设置成了局部领头<code>Sentinel</code>，那么这个<code>Sentinel</code>成为领头<code>Sentinel</code></li>\n</ul>\n</blockquote>\n<h3 id=\"选出新的主服务器\"><a href=\"#选出新的主服务器\" class=\"headerlink\" title=\"选出新的主服务器\"></a>选出新的主服务器</h3><p>使用如下条件筛选备选<code>node</code>：</p>\n<blockquote>\n<p>1、<code>slave</code>节点状态处于<code>S_DOWN,O_DOWN,DISCONNECTED</code>的除外<br>2、最近一次<code>ping</code>应答时间不超过5倍<code>ping</code>的间隔（假如<code>ping</code>的间隔为1秒，则最近一次应答延迟不应超过5秒，<code>redis sentinel</code>默认为1秒）<br>3、<code>info_refresh</code>应答不超过3倍<code>info_refresh</code>的间隔（原理同2,r<code>edis sentinel</code>默认为10秒）<br>4、<code>slave</code>节点与<code>master</code>节点失去联系的时间不能超过<code>（ (now - master-&gt;s_down_since_time) + (master-&gt;down_after_period * 10)）</code>。总体意思是说，<code>slave</code>节点与<code>master</code>同步太不及时的（比如新启动的节点），不应该参与被选举。<br>5、<code>Slave priority</code>不等于0（这个是在配置文件中指定，默认配置为100）。</p>\n</blockquote>\n<p>从备选<code>node</code>中，按照如下顺序选择新的<code>master</code></p>\n<blockquote>\n<p>1、较低的<code>slave_priority</code>（这个是在配置文件中指定，默认配置为100）<br>2、较大的<code>replication offset</code>（每个<code>slave</code>在与<code>master</code>同步后<code>offset</code>自动增加）<br>3、较小的<code>runid</code>（每个<code>redis</code>实例，都会有一个<code>runid</code>,通常是一个40位的随机字符串,在<code>redis</code>启动时设置，重复概率非常小）<br>4、如果以上条件都不足以区别出唯一的节点，则会看哪个<code>slave</code>节点处理之前<code>master</code>发送的<code>command</code>多，就选谁。</p>\n</blockquote>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《redis 设计与实现》<br>Redis 2.9源码</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/11\">No hay que ahogarse en un vaso de agua.</a></p>\n","tags":["redis"]},{"title":"redis持久化","url":"/post/dcfaa904.html","content":"<p><code>Redis</code>由于支持非常丰富的内存数据结构类型，如何把这些复杂的内存组织方式持久化到磁盘上是一个难题，所以<code>Redis</code>的持久化方式与传统数据库的方式有比较多的差别。<br><code>Redis</code>主要支持下面两种持久化方式，分别是：</p>\n<blockquote>\n<p>定时快照方式<code>(RDB)</code><br>基于语句追加文件的方式<code>(AOF)</code></p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p><code>Redis</code>还可以同时使用<code>AOF</code>持久化和<code>RDB</code>持久化。 在这种情况下， 当<code>Redis</code>重启时， 它会优先使用<code>AOF</code>文件来还原数据集， 因为<code>AOF</code>文件保存的数据集通常比<code>RDB</code>文件所保存的数据集更完整。</p>\n<h2 id=\"定时快照方式-snapshot，RDB快照\"><a href=\"#定时快照方式-snapshot，RDB快照\" class=\"headerlink\" title=\"定时快照方式(snapshot，RDB快照)\"></a>定时快照方式(<code>snapshot</code>，<code>RDB</code>快照)</h2><p>该持久化方式实际是在<code>Redis</code>内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则 通过操作系统<code>fork</code>调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页<code>(page)</code>为单位来进行<code>copy-on-write</code>保证父子进程之间不会互相影响。</p>\n<div class=\"note warning\"><p>该持久化的主要缺点是定时快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。</p></div>\n\n<p>在默认情况下，<code>Redis</code>将数据库快照保存在名字为<code>dump.rdb</code>的二进制文件中。<br>可以在<code>.conf</code>文件中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#   save &quot;&quot;</span><br><span class=\"line\">save 60 1000</span><br><span class=\"line\"></span><br><span class=\"line\"># The filename where to dump the DB</span><br><span class=\"line\">dbfilename &quot;dump.rdb&quot;</span><br></pre></td></tr></table></figure>\n<p>你也可以通过调用<code>SAVE</code>或者<code>BGSAVE</code> ， 手动让<code>Redis</code>进行数据集保存操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis&gt; SAVE</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; BGSAVE</span><br><span class=\"line\">Background saving started</span><br></pre></td></tr></table></figure>\n<h3 id=\"Redis恢复数据\"><a href=\"#Redis恢复数据\" class=\"headerlink\" title=\"Redis恢复数据\"></a>Redis恢复数据</h3><p>只要覆盖一下<code>dump.rdb</code>，再重启下<code>redis</code>就可以了。</p>\n<h2 id=\"基于语句追加方式-AOF\"><a href=\"#基于语句追加方式-AOF\" class=\"headerlink\" title=\"基于语句追加方式(AOF)\"></a>基于语句追加方式(AOF)</h2><p><code>aof</code>方式实际类似<code>mysql</code>的基于语句的<code>binlog</code>方式，即每条会使<code>Redis</code>内存数据发生改变的命令都会追加到一个<code>log</code>文件中，也就是说这个<code>log</code>文件就是<code>Redis</code>的持久化数据。</p>\n<p><code>aof</code>的方式的主要缺点是追加<code>log</code>文件可能导致体积过大，当系统重启恢复数据时如果是<code>aof</code>的方式则加载数据会非常慢，几十G的数据可能需要几小 时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写<code>log</code>,所以使用<code>aof</code>的方式，<code>Redis</code>的读写性能也会有所下降。</p>\n<p><code>AOF</code>重写和<code>RDB</code>创建快照一样，都巧妙地利用了写时复制机制。 打开只需要写入<code>conf</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n<h2 id=\"RDB-和-AOF，应该用哪一个\"><a href=\"#RDB-和-AOF，应该用哪一个\" class=\"headerlink\" title=\"RDB 和 AOF，应该用哪一个\"></a>RDB 和 AOF，应该用哪一个</h2><p>一般来说， 如果想达到足以媲美<code>PostgreSQL</code>的数据安全性， 你应该同时使用两种持久化功能。</p>\n<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用<code>RDB</code>持久化。</p>\n<p>有很多用户都只使用<code>AOF</code>持久化， 但我们并不推荐这种方式： 因为定时生成<code>RDB 快照（snapshot）</code>非常便于进行数据库备份， 并且<code>RDB</code>恢复数据集的速度也要比<code>AOF</code>恢复的速度要快， 除此之外， 使用<code>RDB</code>还可以避免之前提到的<code>AOF</code>程序的<code>bug</code>。</p>\n<h2 id=\"实验阶段\"><a href=\"#实验阶段\" class=\"headerlink\" title=\"实验阶段\"></a>实验阶段</h2><h3 id=\"虚拟内存方式\"><a href=\"#虚拟内存方式\" class=\"headerlink\" title=\"虚拟内存方式\"></a>虚拟内存方式</h3><p>虚拟内存方式是<code>Redis</code>来进行用户空间的数据换入换出的一个策略，此种方式在实现的效果上比较差，主要问题是代码复杂，重启慢，复制慢等等，目前已经被作者放弃。</p>\n<h3 id=\"diskstore方式：\"><a href=\"#diskstore方式：\" class=\"headerlink\" title=\"diskstore方式：\"></a>diskstore方式：</h3><p><code>diskstore</code>方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的<code>B-tree</code>的方式，目前仍在实验阶段，后续是否可用我们可以拭目以待。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/42\">Qué bonito es ver la lluvia y no mojarse.</a></p>\n","tags":["redis"]},{"title":"redis数据结构与对象","url":"/post/d2255048.html","content":"<p><code>redis</code>数据库每个键值对都是由对象组成。</p>\n<a id=\"more\"></a>\n\n<p>数据库键总是一个字符串对象；<br>而数据库键的值则可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p><code>redis</code>没有直接使用<code>c</code>语言传统字符串，而是自己构建了一种名为简单动态字符串<code>（SDS）</code>的抽象类型。主要是为了解决<code>&#39;\\0&#39;</code>的问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> len;         <span class=\"comment\">// buf 中已占用空间的长度 0</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;       <span class=\"comment\">// buf 中剩余可用空间的长度 5</span></span><br><span class=\"line\">　　<span class=\"keyword\">char</span> buf[];   <span class=\"comment\">// 数据空间，最后一个字节保存空字符 &#x27;r&#x27;&#x27;e&#x27;&#x27;d&#x27;&#x27;i&#x27;&#x27;s&#x27;&#x27;%0&#x27;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处（长度、结束都由<code>len</code>判断，分配预留<code>free</code>）:</p>\n<blockquote>\n<ul>\n<li>可以常数复杂度获取字符串长度</li>\n<li>杜绝缓冲区溢出</li>\n<li>减少修改字符串时带来的内存重分配次数</li>\n<li>二进制安全（二进制安全就是输入任何字节都能正确处理, 即使包含零值字节）</li>\n<li>兼容部分c字符串函数</li>\n</ul>\n</blockquote>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表提供了高效和节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。</p>\n<p>链表在<code>redis</code>中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，<code>redis</code>就会使用链表为列表键的底层实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span>     <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span>     <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;                  <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);      <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);       <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);      <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *head;        <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *tail;          <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;         <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p><code>redis</code>的链表实现的特性：</p>\n<blockquote>\n<ul>\n<li>双端， 获取某个节点的前置节点和后置节点的复杂度都是O(1)</li>\n<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</li>\n<li>带表头表尾指针，获取俩复杂度为O(1)</li>\n<li>带链表长度计数器，获取节点数量的复杂度为O(1)</li>\n<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>\n</ul>\n</blockquote>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p><code>redis</code>的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>\n<p>除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都比较长的字符串时，redis就会使用字典作为哈希键的底层实现。</p>\n<h3 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;        <span class=\"comment\">// 键</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;                   <span class=\"comment\">// 值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span>     <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;        <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;      <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;     <span class=\"comment\">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;        <span class=\"comment\">// 该哈希表已有节点的数量</span></span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字典-1\"><a href=\"#字典-1\" class=\"headerlink\" title=\"字典\"></a>字典</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;         <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;         <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];             <span class=\"comment\">// 哈希表    </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx;    <span class=\"comment\">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators;     <span class=\"comment\">// 目前正在运行的安全迭代器的数量</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p><code>type</code>属性和<code>privdata</code>属性是针对不同类型的键值对，为创建多态字典而设置的。<br><code>ht</code>属性是一个包含两个项的数组，数组中的每个项都是一个<code>dictht</code>哈希表，一般情况下，字典只使用<code>ht[0]</code>哈希表，<code>ht[1]</code>哈希表只会在对<code>ht[0]</code>哈希表进行<code>rehash</code>时使用。<br><code>rehashidx</code>它记录了<code>rehash</code>目前的进度，如果目前没有在进行<code>rehash</code>，那么它的值为-1。</p>\n<h2 id=\"跳跃表-skiplist\"><a href=\"#跳跃表-skiplist\" class=\"headerlink\" title=\"跳跃表(skiplist)\"></a>跳跃表(skiplist)</h2><p><a href=\"https://github.com/losophy/losophy.github.io/issues/148\">跳跃表</a>是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均<code>O(logN)</code>、最坏<code>O(N)</code>复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p>\n<p><code>redis</code>使用跳跃表作为有序集合键的底层实现之一。<br>和链表、字曲等数据结构被广泛地应用在<code>redis</code>内部不同，<code>redis</code>只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    robj *obj;     <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span>    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span>     </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span>         <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;                         <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">    &#125; level[];                                         <span class=\"comment\">// 层</span></span><br><span class=\"line\">&#125; zskiplistNode;                </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span>      <span class=\"comment\">// 表头节点和表尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;                        <span class=\"comment\">// 表中节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;                                         <span class=\"comment\">// 表中层数最大的节点的层数</span></span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n<h2 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，<code>redis</code>就会使用整数集合作为集合键的底层实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;    <span class=\"comment\">// 编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;    <span class=\"comment\">// 集合包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];    <span class=\"comment\">// 保存元素的数组</span></span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<h2 id=\"压缩列表（为了节约内存）\"><a href=\"#压缩列表（为了节约内存）\" class=\"headerlink\" title=\"压缩列表（为了节约内存）\"></a>压缩列表（为了节约内存）</h2><p>压缩列表是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项，并且每个列表要么就是小整数值，要么就是长度比较短的字符串，那么<code>redis</code>就会使用压缩列表来做列表键的底层实现。<br>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点<code>（entry）</code>，每个节点可以保存一个字节数组或者一个整数值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *<span class=\"title\">ziplistNew</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class=\"number\">1</span>; <span class=\"comment\">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小， 1 字节是表末端 ZIP_END 的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zmalloc(bytes);    <span class=\"comment\">// 为表头和表末端分配空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);    <span class=\"comment\">// 初始化表属性</span></span><br><span class=\"line\">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class=\"line\">    ZIPLIST_LENGTH(zl) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    zl[bytes<span class=\"number\">-1</span>] = ZIP_END;    <span class=\"comment\">// 设置表末端</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>redis</code>并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。<br><code>redis</code>还在这对象系统中构建了一个引用计数技术实现的内存回收机制。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS;    <span class=\"comment\">// 对象最后一次被访问的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;    <span class=\"comment\">// 指向实际值的指针</span></span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《redis 设计与实现》<br>Redis 2.9源码</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/9\">A beber y a tragar, que el mundo se va a acabar.</a></p>\n","tags":["redis"]},{"title":"redis模式","url":"/post/66f0b82.html","content":"<p>下文主要介绍各种模式的概念，以及不同模式的适用场景。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"单节点模式\"><a href=\"#单节点模式\" class=\"headerlink\" title=\"单节点模式\"></a>单节点模式</h2><p>执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis-server.exe redis6379.conf</span><br></pre></td></tr></table></figure>\n<p>该命令指定了配置文件，不指定的情况下默认读取的配置文件是<code>redis.conf</code>配置文件。</p>\n<h2 id=\"主从模式（数据备份）\"><a href=\"#主从模式（数据备份）\" class=\"headerlink\" title=\"主从模式（数据备份）\"></a>主从模式（数据备份）</h2><blockquote>\n<ul>\n<li>主节点和从节点使用完全相同的服务器实现， 它们的功能<code>（functionally）</code>也完全一样， 但从节点通常仅用于替换失效的主节点</li>\n<li>不过， 如果不需要保证“先写入，后读取”操作的一致性<code>（read-after-write consistency）</code>， 那么可以使用从节点来执行只读查询</li>\n</ul>\n</blockquote>\n<p>配置一主二从模式，拷贝两份<code>redis6379.conf</code>，分别命名<code>redis6380.conf</code>、<code>redis6381.conf</code>。<br>修改<code>redis6380.conf</code>配置文件的如下几个参数，参数前面不要出现空格：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1</span><br><span class=\"line\">port 6380</span><br><span class=\"line\">slaveof 127.0.0.1 6379  &#x2F;&#x2F; 设置该slave的master服务器为6379</span><br></pre></td></tr></table></figure>\n<p>同理修改<code>redis6381.conf</code>。<br>分别启动<code>master</code>、<code>slave1</code>、<code>slave2</code>，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis-server.exe redis6379.conf</span><br><span class=\"line\">redis-server.exe redis6380.conf</span><br><span class=\"line\">redis-server.exe redis6381.conf</span><br></pre></td></tr></table></figure>\n<p>所有节点启动后，可以在<code>master</code>界面看到挂载两个<code>slave</code>节点的日志信息。</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><p>哨兵模式是主从模式的升级版，他会在后台有一个监控，监控当前的主机，巡逻主机下面的从机，如果某一时刻主机挂掉了，那么他会通过一种投票的机制从从机之中选举一台作为新的主机，并且，其余的从机将会连接到这个新的主机上面。</p>\n<p>配置一主二从三<code>sentinel</code>模式，<code>redis</code>的配置文件同主从模式下的文件配置。<br>创建三份<code>sentinel.conf</code>文件，分别命名为<code>sentinel26379.conf</code>、<code>sentinel26380.conf</code>、<code>sentinel26381.conf</code>。</p>\n<p>文件中的配置参数如下(另外两个配置文件同样配置)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">port 26379 &#x2F;&#x2F; 当前Sentinel服务运行的端口  </span><br><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 2   &#x2F;&#x2F; 去监视一个名为mymaster的主redis实例，这个主实例的IP地址为本机地址127.0.0.1，端口号为6379，而将这个主实例判断为失效至少需要2个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行</span><br><span class=\"line\">sentinel down-after-milliseconds mymaster 5000  &#x2F;&#x2F; 指定了Sentinel认为Redis实例已经失效所需的毫秒数。当 实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。只有一个 Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行</span><br><span class=\"line\">sentinel parallel-syncs mymaster 1  &#x2F;&#x2F; 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br><span class=\"line\">sentinel failover-timeout mymaster 15000 &#x2F;&#x2F; 如果在该时间（ms）内未能完成failover操作，则认为该failover失败</span><br></pre></td></tr></table></figure>\n<p>分别启动<code>redis</code>服务器同主从模式下一样。<br>分别启动<code>sentinel</code>服务器，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis-server.exe sentinel26379.conf --sentinel  </span><br><span class=\"line\">redis-server.exe sentinel26380.conf --sentinel  </span><br><span class=\"line\">redis-server.exe sentinel26381.conf --sentinel</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/44\">Los árboles no están dejando ver el bosque.</a></p>\n","tags":["redis"]},{"title":"skynet cluster","url":"/post/e9005ae.html","content":"<p>skynet跟mq扮演的角色类似，每个skynet进程维护了一个MQ，会dispatch msg到每个skynet_context的私有mq。有skynet就没必要再在自己项目里引入MQ了。<br>skynet 支持两种集群模式。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"master-slave-模式（局域网）\"><a href=\"#master-slave-模式（局域网）\" class=\"headerlink\" title=\"master/slave 模式（局域网）\"></a>master/slave 模式（局域网）</h2><p>当单台机器的处理能力达到极限后，可以考虑通过内置的 master/slave 机制来扩展。具体的配置方法见 Config 。<br>集群服务用到的配置项：</p>\n<ul>\n<li>cluster 它决定了集群配置文件的路径。</li>\n<li>standalone 如果把这个 skynet 进程作为主进程启动（skynet 可以由分布在多台机器上的多个进程构成网络），那么需要配置standalone 这一项，表示这个进程是主节点，它需要开启一个控制中心，监听一个端口，让其它节点接入。</li>\n<li>master 指定 skynet 控制中心的地址和端口，如果你配置了 standalone 项，那么这一项通常和 standalone 相同。</li>\n</ul>\n<p>每个 skynet 进程都是一个 slave 节点。但其中一个 slave 节点可以通过配置 standalone 来多启动一个 cmaster 服务，用来协调 slave 组网。对于每个 slave 节点，都内置一个 harbor 服务用于和其它 slave 节点通讯。<br>每个 skynet 服务都有一个全网唯一的地址，这个地址是一个 32bit 数字，其高 8bit 标识着它所属 slave 的号码。即 harbor id 。在 master/slave 网络中，id 为 0 是保留的。所以最多可以有 255 个 slave 节点。<br>在 master/slave 模式中，节点内的消息通讯和节点间的通讯是透明的。skynet 核心会根据目的地址的 harbor id 来决定是直接投递消息，还是把消息转发给 harbor 服务。<br>不要把这个模式用于跨机房的组网。所有 slave 节点都应该在同一局域网内（最好在同一交换机下）。不应该把系统设计成可以任意上线或下线 slave 的模式。<br>slave 的组网机制也限制了这一点。如果一个 slave 意外退出网络，这个 harbor id 就被废弃，不可再使用。这样是为了防止网络中其它服务还持有这个断开的 slave 上的服务地址；而一个新的进程以相同的 harbor id 接入时，是无法保证旧地址和新地址不重复的。</p>\n<p>cluster 模式<br>cluster 模块，它大部分用 lua 编写，只有通讯协议处理的部分涉及一个很小的 C 模块。<br>它的工作原理是这样的：<br>在每个 skynet 节点（单个进程）内，启动一个叫 clusterd 的服务。所有需要跨进程的消息投递都先把消息投递到这个服务上，再由它来转发到网络。</p>\n<p>要使用它之前，你需要编写一个 cluster 配置文件，配置集群内所有节点的名字和对应的监听端口。并将这个文件事先部署到所有节点</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">db = <span class=\"string\">&quot;127.0.0.1:2528&quot;</span></span><br></pre></td></tr></table></figure>\n<p>接下来，你需要在 db 的启动脚本里写上 cluster.open “db”<br>有两种方式可以访问到这个节点</p>\n<ul>\n<li>可以通过 cluster.call(nodename, service, …) 提起请求。这里 nodename 就是在配置表中给出的节点名。service 可以是一个字符串，或者直接是一个数字地址（如果你能从其它渠道获得地址的话）。当 service 是一个字符串时，只需要是那个节点可以见到的服务别名，可以是全局名或本地名。但更推荐是 . 开头的本地名，因为使用 cluster 模式时，似乎没有特别的理由还需要在那个节点上使用 master/slave 的架构（全局名也就没有特别的意义）。cluster.call 有可能因为 cluster 间连接不稳定而抛出 error 。但一旦因为 cluster 间连接断开而抛出 error 后，下一次调用前 cluster 间会尝试重新建立连接。</li>\n<li>可以通过 cluster.proxy(nodename, service) 生成一个本地代理。之后，就可以像访问一个本地服务一样，和这个远程服务通讯。但向这个代理服务 send 消息，有可能因为 cluster 间的连接不稳定而丢失。详见 cluster.send 的说明。</li>\n<li>如果想单向推送消息，可以调用 cluster.send(nodename, service, …) 。但注意，跨越节点推送消息有丢失消息的风险。因为 cluster 基于 tcp 连接，当 cluster 间的连接断开，cluster.send 的消息就可能丢失。而这个函数会立刻返回，所以调用者没有机会知道发送出错。</li>\n</ul>\n<p>Cluster 是去中心化的，所以需要在每台机器上都放置一份配置文件（通常是相同的）。通过调用 cluster.reload 可以让本进程重新加载配置。如果你修改了每个节点名字对应的地址，那么 reload 之后的请求都会发到新的地址。而之前没有收到回应的请求还是会在老地址上等待。如果你老的地址已经无效（通常是主动关闭了进程）那么请求方会收到一个错误。</p>\n<h2 id=\"某个节点配置多个通道\"><a href=\"#某个节点配置多个通道\" class=\"headerlink\" title=\"某个节点配置多个通道\"></a>某个节点配置多个通道</h2><p>在skynet框架中使用cluster模式，经常有消息在节点之间传递。大部分情况，我们在节点A和节点B之间只需要建立一个连接通道，但是在有些时候我们希望让一些比较独立的业务能占用一条单独的通道进行处理，不希望跟到正常的业务逻辑去抢通道资源。这个时候，我们就需要为某个节点配置多个通道了。</p>\n<p>比如，我们要在节点A中再开辟一条连接连通节点B的通道，由于一条通道就是一条tcp连接，所以我们需要为节点B再配置一个端口。我们打开集群的cluster配置文件，添加一个节点B的记录，新分配一个端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nodea &#x3D; &quot;127.0.0.1:50653&quot;</span><br><span class=\"line\">nodeb &#x3D; &quot;127.0.0.1:50654&quot;</span><br><span class=\"line\">nodeb2&#x3D; &quot;127.0.0.1:50655&quot;</span><br></pre></td></tr></table></figure>\n<p>然后重新启动节点，在节点B的启动脚本中，我们也需要在集群中打开nodeb2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cluster.open(&quot;nodeb2&quot;)</span><br></pre></td></tr></table></figure>\n<p>然后，在节点A中，我们就可以进行跨节点访问了，这个时候，我们可以分别用nodeb和nodeb2进行访问，框架将使用2条tcp通道进行分别处理。你也可以使用netsta命令，查看nodeb和nodeb2的连接情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cluster.call(&quot;nodeb&quot;,&quot;.main&quot;,&quot;xxxxxx&quot;)</span><br><span class=\"line\">cluster.call(&quot;nodeb2&quot;,&quot;.main&quot;,&quot;xxxxxx&quot;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于cluster的实现\"><a href=\"#关于cluster的实现\" class=\"headerlink\" title=\"关于cluster的实现\"></a>关于cluster的实现</h2><p>为什么要cluster：<br>除非你的业务本来就是偏重 IO 的，也就是你根本不打算利用单台硬件的多核心优势来增强计算力，抹平本机和网络的差异是没有意义的。无论硬件怎样发展，你都不可能看到主板上的总线带宽和 TCP 网络的带宽工作在同一数量级的那一天，因为这是物理基本规律决定的。<br>当你的业务需要高计算力，把 actor 放在一台机器上才可以正常的发挥 CPU 能力去合作；如果你的系统又需要分布式扩展，那么一定是有很多组独立无关的业务可以平行处理。这两类工作必须由构架系统的人自己想清楚，规划好怎么部署这些 actor ，而不可能随手把 actor 扔在分布式系统中，随便挑台硬件运行就够了。<br>恰巧网络游戏服务就是这种业务类型。多组服务器、多个游戏场景之间交互很弱，但其中的个体又需要很强的计算力。这就是 skynet 切合的应用场景。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>skynet 的核心层之上，设计了 cluster 模块。它大部分用 lua 编写，只有通讯协议处理的部分涉及一个很小的 C 模块。用 Lua 编写可以提高系统的可维护性，和网络通讯的带宽相比，Lua 相对 C 在处理数据包的性能降低是微不足道的。<br>在每个 skynet 节点（单个进程）内，启动一个叫 clusterd 的服务。所有需要跨进程的消息投递都先把消息投递到这个服务上，再由它来转发到网络。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/77\">Toda cuestion tiene dos puntos de vista: El equivocado y el nuestro. </a></p>\n","tags":["skynet"]},{"title":"skynet module","url":"/post/577e23ed.html","content":"<p>之前已经说过skynet的是做什么的，现在开始从模块上研究skynet的源码。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"重要模块\"><a href=\"#重要模块\" class=\"headerlink\" title=\"重要模块\"></a>重要模块</h2><p>gate.so：为整个skynet提供socket功能（解决外部连接数据读取的问题）<br>snlua.so：启动多个lua服务，skynet自带的模块中有一个重要的模块是snlua.so模块，通过snlua.so和指定lua脚本文件可以启动多个lua编写的服务，不用每个服务都是用c来编写，而且大部分逻辑都是在 lua 脚本下开发，只有需要考虑性能的模块才用 C 语言开发成库，直接提供给 lua 调用。<br>logger.so：日志模块，一个简单的日志系统,可以用来记录服务的相关信息。<br>harbar.so：（集群模块）节点服务,每个Skynet运行都是一个节点</p>\n<h2 id=\"重要服务\"><a href=\"#重要服务\" class=\"headerlink\" title=\"重要服务\"></a>重要服务</h2><p>launcher.lua：在lua中启动服务<br>skynet.lua：lua常用功能封装<br>skynet.so：lua调用skynet功能</p>\n<h2 id=\"模块加载\"><a href=\"#模块加载\" class=\"headerlink\" title=\"模块加载\"></a>模块加载</h2><p>skynet模块加载相关在skynet-module.c skynet-module.h这两个文件里。这里的模块在linux下指的是so，在windows下指的是dll，在skynet中指的是config中配置的cpath下的文件。</p>\n<p>每个模块需要实现四个最基本的函数，create/init/release/signal。create做内存分配。init做初始化，它可能会做一些其它的事情，比如打开网络，打开文件，函数回调挂载等等。relase做资源回收，包括内存资源，文件资源，网络资源等等，signal是发信号，比如kill信号，告诉模块该停了。</p>\n<h2 id=\"自定c-module\"><a href=\"#自定c-module\" class=\"headerlink\" title=\"自定c module\"></a>自定c module</h2><p>如果想用其它协议(或自定义c代码)，可以模仿以上模块，自定义so。在从lua中读这个so。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/72\">Arreglar los problemas económicos es fácil, lo único que se necesita es dinero.</a></p>\n","tags":["skynet"]},{"title":"skynet monitor","url":"/post/a40f5bf.html","content":"<p>监控系统能帮助我们分析节点的服务存在的问题，例如：服务死循环、服务内存溢出、cpu耗时过长等问题。</p>\n<a id=\"more\"></a>\n\n<p>skynet对服务的监控做得比较简陋，从设计原则上来说，这样做也是对的，因为框架层能做的，基本就是上报和打日志，上层的业务是变化万千的，不论怎么写，都可能满足不了上层的业务需求。skynet中对服务的监控实现在skynet_monitor.c和skynet_monitor.h中，当服务可能陷入死循环的时候，就打一条日志。<br>每次消息派发，都会调用skynet_monitor_trigger，一共调两次，第一次参数source和destination是真实的值，也就是不为0。第二次调是在消息派发完成的时候，source和destination都赋0。<br><strong>如果第一次trigger调用以后，消息派发迟迟不完成，monitor线程第一次检查，会将check_version的值赋为version。然后monitor线程第二次检查，这个时候version和check_version就会相等，而且这时候destination也不为0，就会进入释放目标服务和打印报警的流程。</strong></p>\n<h2 id=\"监控相关\"><a href=\"#监控相关\" class=\"headerlink\" title=\"监控相关\"></a>监控相关</h2><p>关于服务上下文的一些核心已经在上面基本介绍的差不多了，最后介绍一下 context 的一些小细节或辅助功能，它们会关联在结构体 struct skynet_context 上的一个或多个字段，利用好这些功能，对我们分析查找问题有很大的帮助。</p>\n<h3 id=\"服务日志\"><a href=\"#服务日志\" class=\"headerlink\" title=\"服务日志\"></a>服务日志</h3><p>这个功能可以把服务处理过的消息都导出到一个文件中，配合 debug console 的 logon 和 logoff 两个命令使用，这个功能可以帮助我们对某个指定的服务进行问题查找</p>\n<h3 id=\"性能指标\"><a href=\"#性能指标\" class=\"headerlink\" title=\"性能指标\"></a>性能指标</h3><p>这些性能指标包括服务已经处理的消息总数、服务处理消息的 cpu 总耗时、是否出现死循环等，可以配合 debug console 的 stat 命令使用（都是调用了底层的 cmd_stat），下面是所有性能指标的名称和作用：</p>\n<blockquote>\n<p>cpu，表示这个服务处理消息消耗的 cpu 总耗时，毫秒为单位，由 profile 字段控制，默认开启，数值越大表示这个服务越繁忙；<br>message，表示已经被这个服务处理过的消息总数；<br>time，这个指标可以计算出某个服务当前正在处理的消息已耗时长，可以用来检测一个服务的某个逻辑耗时是不是过长，一般情况为 0，如果值较大就需要注意了，是不是由业务逻辑有问题，可能死循环或者逻辑计算过大；<br>endless，若为 1 则表示服务长时间没有进行消息处理，可能出现了死循环，也可能是出现 endless 的前一个逻辑耗时超过 5s，它的值是由监控线程设置；<br>mqlen，表示服务当前还未处理的消息数量，如果消息堆积过多，会出现 May overload， message queue lenght=xxx 的错误日志，详细机制会在后面的消息处理部分详细讲解；<br>task，这一个指标较为特殊，它不是由底层提供，它的值需要在 lua 层获取，表示某个服务当前挂起的 coroutine 数量。</p>\n</blockquote>\n<h2 id=\"分离代码\"><a href=\"#分离代码\" class=\"headerlink\" title=\"分离代码\"></a>分离代码</h2><p><a href=\"https://gist.github.com/losophy/6be78f27a5e4d514d57cd577fcf17c46\">skynet_monitor</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>监控相关 详见：<a href=\"https://domicat.me/_posts/2020-05-10-learn-skynet-service/\">https://domicat.me/_posts/2020-05-10-learn-skynet-service/</a></p>\n","tags":["skynet"]},{"title":"skynet mq","url":"/post/933b71d7.html","content":"<p>skynet跟mq扮演的角色类似，每个skynet进程维护了一个MQ，会dispatch msg到每个skynet_context的私有mq。有skynet就没必要再在自己项目里引入MQ了。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"消息队列mq\"><a href=\"#消息队列mq\" class=\"headerlink\" title=\"消息队列mq\"></a>消息队列mq</h2><p>消息队列是skynet的核心功能之一，它的功能说白了就是入队出队，先进先出，这个数据结构都有讲过。源码实现在skynet_mq.h和skynet_mq.c中。</p>\n<p>skynet的消息队列实际上是有两种，一种是全局消息队列，一种是服务消息队列。每个服务都有自己的消息队列，每个服务消息队列中都有服务的handle标识。这个涉及到消息的派发，这里就不展开了。每个服务消息队列被全局消息队列引用。<br><strong>全局消息队列用的是经典的链表来实现的，而服务的消息队列用的是比较不直观，可能对有些人来说理解起来特别困难的循环数组来实现的</strong>。而且数组空间不够的时候，会动态扩展，容量扩展为当前容量的2倍。<br>消息队列的出队入队函数名都比较简单而且明了，push/pop。这个名字可能会带来一定的误解，如果改成enqueue/dequeue的话，就更符合它的实际功能。</p>\n<h2 id=\"消息的封装\"><a href=\"#消息的封装\" class=\"headerlink\" title=\"消息的封装\"></a>消息的封装</h2><p>网络库的一个核心功能就是收发网络消息(内部命令也可以看成是一类网络消息)，且收发流程都会对原始数据做封装处理，对于收包流程来说，需要网络库把收到的数据封装成服务能够处理的数据结构，同时还需要附加一些额外的数据；而对于发包流程而言，同样需要进行数据封装处理。</p>\n<h2 id=\"消息注册\"><a href=\"#消息注册\" class=\"headerlink\" title=\"消息注册\"></a>消息注册</h2><p>skynet的消息注册，C服务和lua服务设置回调走的函数是不同的。C的回调可以直接调，但是lua的回调不行，它需要一个默认的回调C函数，将返回参数转换为lua能理解的格式，遵循lua的api协议，传递到lua层。<br>当服务是lua实现的时候，skynet底层核心框架在处理完消息以后，回调lua层服务的回调函数时，要先经过一次lua api协议的处理，将参数准备好以后，然后调用lua服务中的回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">skynet.dispatch(callback)----------------------&gt;proto[typename].dispach &#x3D; callback</span><br><span class=\"line\">                                                                                                                    |</span><br><span class=\"line\">skynet.core.call(skynet.dispatch_message)----&gt;tbl[k] &#x3D; skynet.dispatch_message</span><br><span class=\"line\">                                                                                                                    |</span><br><span class=\"line\">                                                                                                                    |</span><br><span class=\"line\">C dispatch_message-&gt;_cb---------------------------------------------------|</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息机制之消息处理\"><a href=\"#消息机制之消息处理\" class=\"headerlink\" title=\"消息机制之消息处理\"></a>消息机制之消息处理</h2><p>skynet的消息机制准备拆成三个部分来讲，第一部分是收包，第二部分是发包，第三部分是事件的处理。</p>\n<h3 id=\"收包\"><a href=\"#收包\" class=\"headerlink\" title=\"收包\"></a>收包</h3><p>先总结一下，skynet_context_message_dispatch这个函数实际上就是不停地从全局消息队列里取工作队列，取到了以后呢，就一直处理这个队列里的消息。为了避免某个队列占用太多cpu，当前队列处理到一定的量，就把机会让给全局消息队列里的其它工作队列，把自己又放回全局消息队列。而这个处理的量是根据创建线程时thread_param里的weight权重来判定的，权重越大，流转的就越快，也就是说处理某个队列的消息数量就越少。这就是消息处理的主流程机制。<br>在主流程之外，还有monitor的触发和取消，每次处理前，触发monitor的检查。处理完了，取消monitor的检查。</p>\n<p>我们知道，skynet 是一个 actor 模型的框架，actor 之间使用“消息”进行通讯，且“消息”遵循一个统一的格式，就像信封一样，大家都用一套统一通用的格式，才能相互顺畅通信。<br>在 skynet 服务间流通的消息被封装为 skynet_message，其结构体定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_message</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> source; \t\t<span class=\"comment\">// 消息源的服务id</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> session;\t\t\t<span class=\"comment\">// 消息的session id</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> * data;\t\t\t<span class=\"comment\">// 消息的payload（指针）</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> sz;\t\t\t\t<span class=\"comment\">// payload 大小</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>skynet_message 是 skynet 服务能处理消息的唯一格式，即其他模块派发给服务的通知都需要封装成 skynet_message，以便服务能够处理，例如：<strong>定时器模块的定时消息、网络模块的内部命令结果和外部网络消息，都转换成 skynet_message，然后发送给对应的服务</strong>，可谓“殊途同归”。</p>\n<p>在转换过程中，我们需要关注很多细节，包括消息负载数据是否需要拷贝，确定消息类型等等。下图展示了收包过程中数据的封装及数据的流向：<br><img src=\"https://user-images.githubusercontent.com/11263320/121925171-376ebc00-cd6f-11eb-8113-8079b7af0653.jpg\" alt=\"ay1aq-inlky\"></p>\n<h3 id=\"发包\"><a href=\"#发包\" class=\"headerlink\" title=\"发包\"></a>发包</h3><p>消息的处理实际上就是对工作队列里的消息不停地调回调函数。那么消息是怎么放进消息队列的呢。带着这个疑问，让我们从lua层开始追根溯源。<br>在lua层有两个api，一个是skynet.send，这个是非阻塞发消息。另一个是skynet.call，这个是阻塞式发完消息等回应。skynet.call使用一个session来实现等待，这个session实际就是一个自增的数字，溢出了以后又从1开始。<br>skynet.send实际上就是往目标服务的消息队列里增加一条消息。</p>\n<p>这里所说的发包是指向一个外部网络连接发送数据，需要注意的是，发包可能需要依赖内部命令，因为需要把在工作线程无法直接发送的数据，透过内部管道，将这部分数据转交给网络线程发送（发送流程我在下面会有更加详细的描述）。<br>任何需要交由网络模块发送的数据，都会封装为 socket_sendbuffer，其结构体定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_BUFFER_MEMORY 0 \t\t<span class=\"comment\">// 内存块，能明确知道内存大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_BUFFER_OBJECT 1\t\t<span class=\"comment\">// 内存指针，需要做相应处理(send_object_init)才能知道数据的真实大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_BUFFER_RAWPOINTER 2\t<span class=\"comment\">// 原始内存，对应lua userdata</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">socket_sendbuffer</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> id;\t\t\t\t\t<span class=\"comment\">// socket id</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> type;\t\t\t\t<span class=\"comment\">// 要发送的数据类型（参见上面的宏定义）</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buffer;\t\t<span class=\"comment\">// 数据指针（这里并非是真实要发送的数据的内存指针）</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> sz;\t\t\t\t<span class=\"comment\">// 数据大小</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 sendbuffer 这个结构体中，buffer是一个指向待发送数据的指针，type则用来区分这个指针的类型。类型分为一下三种：</p>\n<ul>\n<li>MEMORY，表示大小已知的内存指针，例如通过 concat_table 得到的字符串数据；</li>\n<li>OBJECT，表示大小未知的数据对象指针，其真实发送的数据(最终往 fd 中写入的数据)需要二次提取，例如 lua 的 lightuserdata；</li>\n<li>RAWPOINTER，特指 lua userdata，当该类型的数据透传给网络库时，需要进行内存数据拷贝；</li>\n</ul>\n<p>此外，在发包过程中，skynet 还做了一些优化，会优先在工作线程直接发送，若无法直发，则透传给网络线程发送。下图展示了发包过程中数据封装和流向：<br><img src=\"https://user-images.githubusercontent.com/11263320/121925470-89174680-cd6f-11eb-9169-7b7fb1b8f672.jpg\" alt=\"ac0pt-9dpgn\"></p>\n<h2 id=\"poll-流程\"><a href=\"#poll-流程\" class=\"headerlink\" title=\"poll 流程\"></a>poll 流程</h2><p>在前面已经介绍过网络线程的主要逻辑，在这一节我将“庖丁解牛”般的拆解网络库的 event poll 流程，即socket_server_poll接口，对其进行梳理后，可以分为三个部分：内部处理、事件捕获、事件处理，以下是经过简化后的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> </span><br><span class=\"line\">socket_server_poll(struct socket_server *ss, struct socket_message * result, <span class=\"keyword\">int</span> * more) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ss-&gt;checkctrl) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 内部命令处理</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (has_cmd(ss)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> type = ctrl_cmd(ss, result);</span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tss-&gt;checkctrl = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ss-&gt;event_index == ss-&gt;event_n) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 事件wait</span></span><br><span class=\"line\">\t\t\tss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);</span><br><span class=\"line\">\t\t\tss-&gt;checkctrl = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 事件处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (s-&gt;type) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> SOCKET_TYPE_CONNECTING:</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 主动连接</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> report_connect(ss, s, &amp;l, result);</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> SOCKET_TYPE_LISTEN: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 被动连接</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> ok = report_accept(ss, s, result);</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> SOCKET_TYPE_INVALID:</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 非法socket</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;socket-server: invalid socket\\n&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e-&gt;read) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 读取处理</span></span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e-&gt;write) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 写入处理</span></span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (e-&gt;error) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(e-&gt;eof) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 文件尾(for kqueue)</span></span><br><span class=\"line\">\t\t\t\t...</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内部命令处理是指在进程内的服务与网络库之间的通讯，例如在 lua 服务中监听一个端口，或发起一个 TCP 连接。这些内部命令，通过网络库提供的管道传递到网络库，最终由网络线程执行命令。网络线程在捕获到事件后，会优先处理所有的内部命令（如果有内部消息的话），具体的命令处理流程可查阅 ctrl_cmd 函数，这里不再详述，需要注意该函数的返回值 type，当 type = -1 表示内部命令还不能返回确切的结果（例如命令’L’），或者这个内部命令不需要返回结果（例如命令’T’），当 type &gt; -1 则表示该命令已经执行成功且能返回明确的结果给服务。</p>\n<p>关于返回值 type 的宏定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_DATA 0   \t\t<span class=\"comment\">// socket 接收到了数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_CLOSE 1\t\t\t<span class=\"comment\">// socket 被关闭</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_OPEN 2\t\t\t<span class=\"comment\">// socket 连接成功（主动连接、被动连接等），返回此值也就表示连接已经真正可用</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_ACCEPT 3\t\t\t<span class=\"comment\">// 接收到新的连接（需要后续 start 才能使用）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_ERR 4\t\t\t<span class=\"comment\">// socket 错误，需要关闭</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_EXIT 5\t\t\t<span class=\"comment\">// 退出网络线程</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_UDP 6\t\t\t<span class=\"comment\">// 收到 UDP 包</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_WARNING 7 \t\t<span class=\"comment\">// socket 报警（待发送的数据过大）</span></span></span><br></pre></td></tr></table></figure>\n<p>此外，当 type 为SOCKET_CLOSE或SOCKET_ERR(向一个已关闭的fd发送数据)时，表示连接已经关闭，则需要回收这个 socket 。</p>\n<p>事件捕获部分就较为简单，对于 epoll 就是 epoll_wait，对于 kqueue 就是 kenvet，唯一需要注意的点是 wait api 使用的无限期阻塞，即没有事件则一直阻塞。</p>\n<p>事件处理主要负责网络连接的处理，包括对外的主动连接和外部的被动连接。有事件的 socket 依据其状态有不同的事件处理流程，如对于 CONNECTING 的 socket 连接，则会完成之前发起的主动连接请求并上报给服务；对于 LISTEN 的 socket，则接收新连接（未start）并上报给服务；对于其他已经建立好连接，则对其进行读、写以及错误处理。</p>\n<h2 id=\"内部命令\"><a href=\"#内部命令\" class=\"headerlink\" title=\"内部命令\"></a>内部命令</h2><p><strong>内部命令是指进程内服务发送给网络库有关网络操作的消息</strong>，这些消息经由管道透传到网络库，这里主要介绍各个内部命令的功能及其封装结构。<br>我们知道，在一个通道上要实现信息通信，那么在这个通道上流通的消息就需要遵循统一格式的消息封装。就像 skynet 中两个服务之间进行通讯，就需要把消息封装成 skynet_message; 再如当和 mysql 数据库进行交互时，就需要消息包遵循 mysql 数据包格式；同样，内部命令也会封装成统一的格式在管道上传递，其封装结构体定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_package</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint8_t</span> header[<span class=\"number\">8</span>];\t<span class=\"comment\">// 6 bytes dummy，头部，前6个字节预留，第7个字节表示命令类型，第8个字节表示命令内容的长度</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> buffer[<span class=\"number\">256</span>];</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_open</span> <span class=\"title\">open</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_send</span> <span class=\"title\">send</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_send_udp</span> <span class=\"title\">send_udp</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_close</span> <span class=\"title\">close</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_listen</span> <span class=\"title\">listen</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_bind</span> <span class=\"title\">bind</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_start</span> <span class=\"title\">start</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_setopt</span> <span class=\"title\">setopt</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_udp</span> <span class=\"title\">udp</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">request_setudp</span> <span class=\"title\">set_udp</span>;</span></span><br><span class=\"line\">\t&#125; u;</span><br><span class=\"line\">\t<span class=\"keyword\">uint8_t</span> dummy[<span class=\"number\">256</span>];\t<span class=\"comment\">// 预留256字节</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>所有的命令内容都封装在一个大小为 256 字节的联合体 u 内，具体的消息长度由 char header[7] 控制，这就是为什么联合体需要一个 char buffer[256] 的字符数组；命令类型由 char header[6] 控制，一个大写字母代表一种内部命令。下面列出了目前支持的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">S Start socket</span><br><span class=\"line\">B Bind socket</span><br><span class=\"line\">L Listen socket</span><br><span class=\"line\">K Close socket</span><br><span class=\"line\">O Connect to (Open)</span><br><span class=\"line\">X Exit</span><br><span class=\"line\">D Send package (high)</span><br><span class=\"line\">P Send package (low)</span><br><span class=\"line\">A Send UDP package</span><br><span class=\"line\">T Set opt</span><br><span class=\"line\">U Create UDP socket</span><br><span class=\"line\">C set udp address</span><br></pre></td></tr></table></figure>\n<p>为什么会使用一个 char header[8] 作为头部，而只使用最后两个字节，这样做的原因是要考虑结构体的内存对齐问题。假如我们只用 char header[2] 来作为头部，那么会在往管道写入数据时，会因为内存对齐的原因，导致写入的命令头部和内容之间存在6个“未初始化”的字节。<br>下图展示了内部命令的内存结构以及管道的工作流程：<br><img src=\"https://user-images.githubusercontent.com/11263320/121983190-7fb7c980-cdc3-11eb-9524-4b09b9295607.jpg\" alt=\"a2vwr-4myvo\"></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><p>网络线程在捕获到事件后，若是管道的事件，则走内部命令处理流程，而剩下的网络事件，则根据不同的 socket 状态(或类型)做不同的处理。</p>\n<h3 id=\"主动连接\"><a href=\"#主动连接\" class=\"headerlink\" title=\"主动连接\"></a>主动连接</h3><p>其核心逻辑在 open_socket 函数中，这里我抠出关键部分的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// return -1 when connecting</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">open_socket(struct socket_server *ss, struct request_open * request, struct socket_message *result) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sock= <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ai_ptr = ai_list; ai_ptr != <span class=\"literal\">NULL</span>; ai_ptr = ai_ptr-&gt;ai_next ) &#123;</span><br><span class=\"line\">\t\tsock = socket( ai_ptr-&gt;ai_family, ai_ptr-&gt;ai_socktype, ai_ptr-&gt;ai_protocol );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( sock &lt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsocket_keepalive(sock);</span><br><span class=\"line\">\t\tsp_nonblocking(sock); <span class=\"comment\">// 设置为非阻塞</span></span><br><span class=\"line\">\t\tstatus = connect( sock, ai_ptr-&gt;ai_addr, ai_ptr-&gt;ai_addrlen);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( status != <span class=\"number\">0</span> &amp;&amp; errno != EINPROGRESS) &#123;</span><br><span class=\"line\">\t\t\tclose(sock);</span><br><span class=\"line\">\t\t\tsock = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(status == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tns-&gt;type = SOCKET_TYPE_CONNECTED;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SOCKET_OPEN;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tns-&gt;type = SOCKET_TYPE_CONNECTING;</span><br><span class=\"line\">\t\tsp_write(ss-&gt;event_fd, ns-&gt;fd, ns, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码是一个标准的非阻塞 connect，我们需要关注 connect(sock, …) api 的返回值 status，如果返回 0，则表示连接已经建立，这通常是在服务器和客户在同一台主机上时发生；如果返回 -1，则需要关注 errno，若 errno = EINPROGRESS，表示连接建立，建立启动但是尚未完成，则需要把这个 sock 注册到 epoll 中，并关注该描述符的可写事件，当 epoll/kqueue 捕获到可写事件时，且该 socket 的状态为 CONNECTING，就表示连接已经建立。</p>\n<h2 id=\"接收新连接\"><a href=\"#接收新连接\" class=\"headerlink\" title=\"接收新连接\"></a>接收新连接</h2><p>该事件处理主要为监听 fd 服务，当 listen_fd 收到新连接到来时，则生成一个新的 socket 实例，然后上报给 listen_fd 所绑定的那个服务，处理流程较为简单。可能需要注意的点是，新接收到的 socket 需要服务对其 start，才能把新连接注册到 epoll/kqueue 中。</p>\n<h2 id=\"消息读取\"><a href=\"#消息读取\" class=\"headerlink\" title=\"消息读取\"></a>消息读取</h2><p>网络库读取网络消息的流程非常简单，它并没有提供组包功能（组包功能由上层自己实现，我会在下一篇文章深入探讨），其处理流程就是从有读事件的 socket 实例中的 fd 读取固定字节长度的数据，然后经过一系列的封装和转换，最终把这些读取到的数据封装成 skynet_message（具体的封装流程在本文消息的封装一节已经有详细的叙述）并插入到与该 socket 实例所绑定服务的消息队列中去。</p>\n<p>关于 TCP 连接每次读取数据的容量(即socket结构体的p.size字段)大小有以下规则：每个 socket 的初始的读取容量为 64 字节，在接下来的读取中，若读取到的数据大小等于读取容量，则将读取容量扩大一倍；若读取到的数据大小小于容量的一半且容量大小大于初始容量，则将容量缩小一倍。其具体实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n=本次读取到的数据大小；sz=该socket当前的读取容量</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (n == sz) &#123;</span><br><span class=\"line\">\ts-&gt;p.size *= <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sz &gt; MIN_READ_BUFFER &amp;&amp; n*<span class=\"number\">2</span> &lt; sz) &#123;</span><br><span class=\"line\">\ts-&gt;p.size /= <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于 UDP 连接的数据读取则不需要关心读取容量的变化，接收到的 UDP 包数据会先暂存在 socket_server 的 udpbuffer 字段中，该字段是一个长度为 65535 的字节数组。</p>\n<h3 id=\"消息写入\"><a href=\"#消息写入\" class=\"headerlink\" title=\"消息写入\"></a>消息写入</h3><p>网络库对于发送网络数据有一系列优化，其中主要有：工作线程直接写入（direct write）和 高低优先级写入队列。<br>在早前的版本，网络数据的收发都是在网络线程中处理的，后来云风做了优化，在写入数据时(服务发起网络写入请求，而服务又是由工作线程驱动)，先尝试直接在工作线程发送，若能直接发送则在工作线程直接向 fd 写入数据，这里有个细节需要注意，若数据无法一次性全部写入，则需要把当前发送的数据整个 clone 并保存到 dw_buffer，同时记录下已经写入的数据大小到 dw_offset，这些未发送完的数据会在网络线程发送数时插入到高优先级队列中，所以不用担心数据丢失或发送乱序。关于直接发送的具体流程，可参考云风文章中的描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当每次要写数据时，先检查一下该 fd 中发送队列是否为空，如果为空的话，就尝试直接在当前工作线程发送（这往往是大多数情况）。发送成功就皆大欢喜，如果失败或部分发送，则把没发送的数据放在 socket 结构中，并开启 epoll 的可写事件。</span><br><span class=\"line\"></span><br><span class=\"line\">网络线程每次发送待发队列前，需要先检查有没有直接发送剩下的部分，有则加到队列头，然后再依次发送。</span><br><span class=\"line\"></span><br><span class=\"line\">当然 udp 会更简单一些，一是 udp 包没有部分发送的可能，二是 udp 不需要保证次序。所以 udp 立即发送失败后，可以直接按原流程扔到发送队列尾即可。</span><br></pre></td></tr></table></figure>\n<p>一个优化是将 socket 的发送队列由一个队列拆分成高优先级、低优先级两个队列，消息要插入到哪个队列由上层自行控制。例如：游戏拍卖行的数据、排行榜数据就可以放入低优先级队列中，因为这些消息的实时性不需要那么高；而心跳包、战斗包就需要放入高优先级队列。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tEach socket has two write buffer list, high priority and low priority.</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t1. send high list as far as possible.</span></span><br><span class=\"line\"><span class=\"comment\">\t2. If high list is empty, try to send low list.</span></span><br><span class=\"line\"><span class=\"comment\">\t3. If low list head is uncomplete (send a part before), move the head of low list to empty high list (call raise_uncomplete) .</span></span><br><span class=\"line\"><span class=\"comment\">\t4. If two lists are both empty, turn off the event. (call check_close)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">send_buffer_(struct socket_server *ss, struct socket *s, struct socket_lock *l, struct socket_message *result) &#123;</span><br><span class=\"line\">\tassert(!list_uncomplete(&amp;s-&gt;low));</span><br><span class=\"line\">\t<span class=\"comment\">// step 1，优先发送高优先级队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (send_list(ss,s,&amp;s-&gt;high,l,result) == SOCKET_CLOSE) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SOCKET_CLOSE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s-&gt;high.head == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// step 2，高优先级队列为空，则发送低优先级队列</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s-&gt;low.head != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (send_list(ss,s,&amp;s-&gt;low,l,result) == SOCKET_CLOSE) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> SOCKET_CLOSE;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// step 3，若低优先级队列未发送完，则提升一个头部的包到高优先级队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (list_uncomplete(&amp;s-&gt;low)) &#123;</span><br><span class=\"line\">\t\t\t\traise_uncomplete(s);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s-&gt;low.head)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// step 4，两个队列都发送完，则关闭写事件</span></span><br><span class=\"line\">\t\tassert(send_buffer_empty(s) &amp;&amp; s-&gt;wb_size == <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tsp_write(ss-&gt;event_fd, s-&gt;fd, s, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s-&gt;type == SOCKET_TYPE_HALFCLOSE) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 若 socket 为半关闭状态，发送完数据后完全关闭并回收该 socket</span></span><br><span class=\"line\">\t\t\tforce_close(ss, s, l, result);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> SOCKET_CLOSE;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s-&gt;warn_size &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\ts-&gt;warn_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tresult-&gt;opaque = s-&gt;opaque;</span><br><span class=\"line\">\t\t\tresult-&gt;id = s-&gt;id;</span><br><span class=\"line\">\t\t\tresult-&gt;ud = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tresult-&gt;data = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> SOCKET_WARNING;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>深入理解skynet —— 网络库(二) 详见：<a href=\"https://domicat.me/_posts/2020-05-21-learn-skynet-network2/\">https://domicat.me/_posts/2020-05-21-learn-skynet-network2/</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/71\">Todos te dan un consejo, cuando lo que necesitas es guita.</a></p>\n","tags":["skynet"]},{"title":"skynet socket","url":"/post/5ebf6d7e.html","content":"<p>网络部分是一个服务器最基础最核心的部分，这个技术也已经是非常成熟了，现在已经很少有人自己实现一个网络相关的库了。</p>\n<a id=\"more\"></a>\n\n<p>skynet的网络库是自己实现的。<br>skynet 网络层的设计目的是，把操作系统层面的 socket 数据从系统内核复制到用户空间，然后再把用户空间的数据地址交给各个不同的服务使用，同时也把用户空间需要发送的数据转移到系统内核中。<br>只不过一个优秀的网络框架会提供更多的功能和细节优化，例如：socket 的管理、网络读写分离、读写数据缓存等等。</p>\n<p>还需要特别注意一点的是，因为 skynet 是一个消息驱动的模型，所以 skynet 的网络模块使用了一种叫 self pipe trick 1的技巧来唤醒异步调用，实现细节是利用了 pipe() 的“半双工”管道 + select，为了解决可在网络线程在即时处理网络事件的同时，也能即时处理来自非网络（比如内部消息队列）的其它消息。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/128183899-edffac1d-8019-41e0-ba0c-ce58ca7cd30d.jpg\" alt=\"121575990-8d372180-ca5a-11eb-88ce-6125a229cfff\"></p>\n<h2 id=\"epoll和kqueue\"><a href=\"#epoll和kqueue\" class=\"headerlink\" title=\"epoll和kqueue\"></a>epoll和kqueue</h2><p>实际上云风只实现了epoll和kqueue，windows上的变种请自行搜索吧。</p>\n<p>epoll和kqueue的实现分别在socket_epoll.h和socket_kqueue.h当中。epoll的函数其实就是epoll_create/epoll_ctl/epoll_del/epoll_wait这几个，要注意的是skynet中的epoll_create的参数是1024。所以连接数上不去的话很可能就是这里限制了。<br>skynet在socket_poll.h中根据平台的不同包含了不同的头文件，屏蔽了平台相关性。然后在socket_server.c中实现了网络服务的逻辑。<br>然后skynet在skynet_socket.c中对socket_server.c中的逻辑再次做了一个封装，还添加了socket客户端相关的函数，就是connect/send/close之类的函数。<br>为了方便lua层使用socket，在lua-socket.c中再将对skynet_socket.c进行了一次封装。这个封装就是c语言层和lua语言层的相互转换。目前只支持tcp和udp，基于tcp上的http/websocket之类统统是不支持的。</p>\n<p>为什么操作一个网络要费这么大的劲呢，绕来绕去非常的不直观。因为skynet是基于消息的，而且每个服务都有一个monitor,每个消息处理的时候要尽可能的短，这样才不会阻塞服务里其它的请求。而connect这种明显是阻塞的，当然也可以写成非阻塞的，但是非阻塞的话，你需要不断地挂起，因为非阻塞实际上是基于select技术来实现的。而不断地挂起，这个就很麻烦，写起来很痛苦而且很容易出错。因此云风把这些都放到网络线程中来做，这样就不会影响工作线程。但是这样做也有它的缺点，那就是网络线程可能会被阻塞，网络线程被阻塞就会导致服务无响应。或者导致大量的数据包积累，引起波峰。</p>\n<h2 id=\"epoll封装层\"><a href=\"#epoll封装层\" class=\"headerlink\" title=\"epoll封装层\"></a>epoll封装层</h2><p> ./skynet-src/socket_poll.h<br>网络服务模块通常会有一个大的循环来读取网络消息，skynet也不例外，socket_server_poll函数就是来干这事的。在这个循环中将会有两个不同来源的消息系统，一个是管道消息，另一个则是网络消息了。管道消息后面会提到。网络消息是通过epoll模型的epoll_wait来读取的，采用默认的<strong>水平触发模式</strong>，这样连续读取数据较为简单。</p>\n<h2 id=\"运行流程：\"><a href=\"#运行流程：\" class=\"headerlink\" title=\"运行流程：\"></a>运行流程：</h2><p>1.在skynet_start（） 中 调用 skynet_socket_init() 初始化socket服务<br>2.每个socket 服务都有 写缓存队列，所以框架会异步的实现读写。<br>3.socket 的open close listen apect 等操作是通过给 socket_server 的管道写入请求信息，在server_poll循环中再去处理他。<br>4.socket 在发送数据时 会尝试的直接发送数据！如果不能直接发送数据 才会把数据写入 socket 对应的写缓存 。<br><img src=\"https://user-images.githubusercontent.com/11263320/108930911-b4bbd700-7681-11eb-8dcd-ffad5e00237f.png\" alt=\"1425134-20190404141706446-2018988792\"></p>\n<h2 id=\"以-PTYPE-SOCKET-类型的消息发送给发起请求服务\"><a href=\"#以-PTYPE-SOCKET-类型的消息发送给发起请求服务\" class=\"headerlink\" title=\"以 PTYPE_SOCKET 类型的消息发送给发起请求服务\"></a>以 PTYPE_SOCKET 类型的消息发送给发起请求服务</h2><p>skynet 的 C API 采用异步读写，你可以使用 C 调用，监听一个端口，或发起一个 TCP 连接。但具体的操作结果要等待 skynet 的事件回调。skynet 会把结果以 PTYPE_SOCKET 类型的消息发送给发起请求的服务。（参考skynet_socket.h）<br>在处理实际业务中，这样的 API 很难使用，所以又提供了一组阻塞模式的 lua API 用于 TCP socket 的读写。它是对 C API 的封装。<br>所谓阻塞模式，实际上是利用了 lua 的 coroutine 机制。当你调用 socket api 时，服务有可能被挂起（时间片被让给其他业务处理)，待结果通过 socket 消息返回，coroutine 将延续执行。</p>\n<h2 id=\"网络管理器\"><a href=\"#网络管理器\" class=\"headerlink\" title=\"网络管理器\"></a>网络管理器</h2><p>管理器对应了网络库中的 socket_server 实例（或称对象），这里只简单阐述下它的作用，我会在后面分别做详细的剖析。</p>\n<p>它主要作用大致可分为两个部分：</p>\n<ul>\n<li>socket 的管理，包括 socket的存储、socket 的id分配以及socket 状态的维护等等</li>\n<li>网络事件的处理，包括 efd 的创建、管道的创建与读写处理（用于内部命令）、外部网络事件的捕获与读写处理等。关于网络（内部和外部）的读写处理封装在 socket_server_poll 接口中，供网络线程调用</li>\n</ul>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>在 skynet 中，管道配合 select 使用，管道为“服务”操控网络模块提供了支持。那我们要思考一下，为什么在已经有了 epoll/kqueue 后，还需要配置使用 pipe + select？</p>\n<p>这里就涉及到了我之前文章提到的 self pipe trick 技巧，也就是 pipe 的异步使用场景。以 epoll 举例（本文后面都以epoll为例），一般我们使用 epoll 做网络开发时，基本遵循以下套路：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">events = epoll_wait(efd, timeout);</span><br><span class=\"line\"><span class=\"keyword\">for</span> fd, event in events &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> event &amp; EPOLLIN &#123;</span><br><span class=\"line\">        读取数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> event &amp; EPOLLOUT &#123;</span><br><span class=\"line\">        写入数据</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> event &amp; EPOLLERR &#123;</span><br><span class=\"line\">        错误处理</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在单线程模式下，以上的处理流程是完全没有问题的，但是在多线程的模式下，问题就出现了。就拿 skynet 来说，当一个工作线程中的 lua 服务需要对网络模块执行一些操作时，例如关闭某个socket，在工作线程发出请求后，网络线程却正处于 epoll wait 状态，也就是网络线程阻塞了，epoll 没有网络事件的话，只能等待 wait 超时后，才能有机会处理工作线程发来的请求，而且若 timeout = -1 时，则会导致 epoll_wait 无限期阻塞，这显然很有可能会导致工作线程的请求长时间不被处理，“不幸的是”，skynet 就是将 timeout 设为 -1。<br>为了解决上面的问题，管道就派上用场，它是半双工的，一端写入，另一端读取，我们只需要把读端 fd 注册到 epoll 中，这就解决了内部请求的唤醒问题，倘如外部网络连接一直没有收据到达，epoll 则会阻塞 wait，此时工作线程写入数据到管道中，就可以“激活” epoll 并处理内部命令。</p>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><p>一般来说，在使用多路复用IO模型时，会对事件进行二次封装或者二次处理。例如 skynet 中 epoll wait 流程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> </span><br><span class=\"line\">sp_wait(<span class=\"keyword\">int</span> efd, struct event *e, <span class=\"keyword\">int</span> max) &#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">ev</span>[<span class=\"title\">max</span>];</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = epoll_wait(efd , ev, max, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;n;i++) &#123;</span><br><span class=\"line\">\t\te[i].s = ev[i].data.ptr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> flag = ev[i].events;</span><br><span class=\"line\">\t\te[i].write = (flag &amp; EPOLLOUT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\te[i].read = (flag &amp; (EPOLLIN | EPOLLHUP)) != <span class=\"number\">0</span>; <span class=\"comment\">// 需关注EPOLLHUP</span></span><br><span class=\"line\">\t\te[i].error = (flag &amp; EPOLLERR) != <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\te[i].eof = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由 epoll 捕获的事件，会被封装成 struct event，然后把这些封装过的事件交由网络线程处理。它的结构体定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> * s; \t\t<span class=\"comment\">// socket 实例指针，若s为null，表示是管道事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> read;\t\t<span class=\"comment\">// 可读事件标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> write;\t\t<span class=\"comment\">// 可写事件标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> error;\t\t<span class=\"comment\">// 错误事件标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> eof;\t\t<span class=\"comment\">// 文件尾(end-of-file)标识，kqueue专用</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里需注意两个小细节：</p>\n<ul>\n<li>事件的用户数据指针<em>s。当把一个 fd 注册到 event poll 中时，若该 fd 是一个外部网络连接则 <em>s 指向一个 socket 实例；若该 fd 是管道的读端则 *s 为null，这样在线程调用socket_server_poll时就能根据 *s 的值把内部消息流程和外部消息流程分隔，</em></em>即管道的内部命令处理都使用 select，而外部网络消息使用 epoll/kqueue**。</li>\n<li>read 标识需要关注 EPOLLHUP。该事件是一个“不可标记的事件”，也就是说不需要手动注册事件，该事件被触发的核心原则是收到了对端发送过来的 RST 包，例如：向一个对端已经close的 fd 写入数据。实验代码贴在了gist。</li>\n</ul>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>skynet 把网络连接都封装成 struct socket，其结构体定义如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">socket</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 基础信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;\t\t\t\t\t<span class=\"comment\">// 网络 fd</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> id;\t\t\t\t\t<span class=\"comment\">// 自增，范围在 0x01 ~ 0x7fffffff</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint8_t</span> protocol;\t\t<span class=\"comment\">// 协议类型，支持TCP和UDP</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint8_t</span> type;\t\t\t<span class=\"comment\">// socket类型(称为“状态”更合适)</span></span><br><span class=\"line\">\t<span class=\"keyword\">uintptr_t</span> opaque;\t\t<span class=\"comment\">// 与之关联的服务id</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> size;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint8_t</span> udp_address[UDP_ADDRESS_SIZE];</span><br><span class=\"line\">\t&#125; p; <span class=\"comment\">// 联合体，tcp使用size表示每次读取数据的字节数；udp使用udp_address表示远端地址信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 写入队列</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wb_list</span> <span class=\"title\">high</span>;</span>\t<span class=\"comment\">// 高优先级写入队列</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wb_list</span> <span class=\"title\">low</span>;</span>\t\t<span class=\"comment\">// 低优先级写入队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">int64_t</span> wb_size;\t\t<span class=\"comment\">// 待写入的字节数，0表示没有数据需要写入，过大则会发出报警</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 统计和警告</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">socket_stat</span> <span class=\"title\">stat</span>;</span>\t<span class=\"comment\">// 读写统计信息(读写的字节总数、最后读写时间)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int64_t</span> warn_size;\t\t\t<span class=\"comment\">// 待写入数据过大时报警的阈值</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 直接写入</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">dw_lock</span>;</span>\t<span class=\"comment\">// 直接写入的锁（后面会详细解释）</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> dw_offset;\t\t\t\t<span class=\"comment\">// 已经直接写入的数据大小</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * dw_buffer; \t<span class=\"comment\">// 直接写入的数据指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> dw_size;\t\t\t\t<span class=\"comment\">// 直接写入的数据总量</span></span><br><span class=\"line\">\t<span class=\"keyword\">volatile</span> <span class=\"keyword\">uint32_t</span> sending;\t<span class=\"comment\">// 是否正在发送数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint16_t</span> udpconnecting; \t<span class=\"comment\">// udp 正在连接标识</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到一个 socket 携带了很多信息，这些字段整理后可以分为四部分：</p>\n<ul>\n<li>基础信息，例如 socket fd、socket id、协议类型等信息</li>\n<li>写入队列相关，包括高优先级和低优先级两种写入队列</li>\n<li>直接写入(direct write)，包括锁(dw_lock)、直接写入的数据指针、大小和偏移量等等</li>\n<li>统计和警告，包括读写数据、读写时间的统计以及待写入数据过载时的警告</li>\n</ul>\n<p>每当 accept 函数获得一个新的 socket id 后，并不会立即收到这个 socket 上的数据。这是因为，我们有时会希望把这个 socket 的操作权转让给别的服务去处理。<br>socket 的 id 对于整个 skynet 节点都是公开的。也就是说，你可以把 id 这个数字通过消息发送给其它服务，其他服务也可以去操作它。任何一个服务只有在调用 socket.start(id) 之后，才可以收到这个 socket 上的数据。skynet 框架是根据调用 start 这个 api 的位置来决定把对应 socket 上的数据转发到哪里去的。<br>向一个 socket id 写数据也需要先调用 start ，但写数据不限制在调用 start 的同一个服务中。也就是说，你可以在一个服务中调用 start ，然后在另一个服务中向其写入数据。skynet 可以保证一次 write 调用的原子性。即，如果你有多个服务同时向一个 socket id 写数据，每个写操作的串不会被分割开。</p>\n<p>接下来我会对我认为需要深入的部分做更仔细的剖析，它们包括：socket id 的生成规则、socket 的状态以及状态的切换、socket 数据发送（直接发送和队列发送）。</p>\n<h2 id=\"ID-生成\"><a href=\"#ID-生成\" class=\"headerlink\" title=\"ID 生成\"></a>ID 生成</h2><p>通常，应用层不会直接使用内核返回的 fd 作为一个 socket 连接的唯一id，因为内核会复用 fd，因此内核的 fd 并不具有唯一性，例如服务器收到两个了连接，fd 分别是 1 和 2，当连接 2 被关闭后，此时新的连接到来，内核可能复用 fd = 2 分配给新的连接，这就引发一个问题，若应用层还需要对之前关闭的连接 2 做一些收尾操作，而新的连接又复用的连接 2 的 fd，新旧连接的冲突就发生了。<br>为了解决以上问题，一般服务器都有一套自己的 socket id 生成规则，大部分都是自增 id 作为一个连接的唯一 id。skynet 采用的也是类似方式，且 skynet 把 socket 实例的 id 与 socket 实例所在的数组下标做了哈希映射，其哈希算法也非常简单，就是对 id 做取模运算，取模后的值即为 socket 实例的数组下标。具体代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 哈希映射</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HASH_ID(id) (((unsigned)id) % MAX_SOCKET)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成socket id</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">reserve_id(struct socket_server *ss) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;MAX_SOCKET;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> id = ATOM_INC(&amp;(ss-&gt;alloc_id));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (id &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tid = ATOM_AND(&amp;(ss-&gt;alloc_id), <span class=\"number\">0x7fffffff</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">socket</span> *<span class=\"title\">s</span> =</span> &amp;ss-&gt;slot[HASH_ID(id)];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s-&gt;type == SOCKET_TYPE_INVALID) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ATOM_CAS(&amp;s-&gt;type, SOCKET_TYPE_INVALID, SOCKET_TYPE_RESERVE)) &#123;</span><br><span class=\"line\">\t\t\t\ts-&gt;id = id;</span><br><span class=\"line\">\t\t\t\ts-&gt;protocol = PROTOCOL_UNKNOWN;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// socket_server_udp_connect may inc s-&gt;udpconncting directly (from other thread, before new_fd), </span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// so reset it to 0 here rather than in new_fd.</span></span><br><span class=\"line\">\t\t\t\ts-&gt;udpconnecting = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\ts-&gt;fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// retry</span></span><br><span class=\"line\">\t\t\t\t--i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单易懂，其核心逻辑：循环查找 slot 数组中的 socket 实例，同时自增 alloc_id 并通过 HASH_ID 计算得到 slot 数组下标，直到找到一个处于空闲状态的的 socket 实例。该算法计算得到的 id 分部如下图所示：<br><img src=\"https://user-images.githubusercontent.com/11263320/120341663-a7ba1e00-c329-11eb-9c17-8344a3958e37.JPG\" alt=\"捕获\"></p>\n<h2 id=\"socket状态\"><a href=\"#socket状态\" class=\"headerlink\" title=\"socket状态\"></a>socket状态</h2><p>socket 的状态目前一共有 9 种，其宏定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_INVALID 0\t\t<span class=\"comment\">// 初始状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_RESERVE 1\t\t<span class=\"comment\">// 保留状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_PLISTEN 2\t\t<span class=\"comment\">// 监听前状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_LISTEN 3\t\t<span class=\"comment\">// 监听中状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_CONNECTING 4\t<span class=\"comment\">// 连接中状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_CONNECTED 5\t\t<span class=\"comment\">// 已连接状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_HALFCLOSE 6\t\t<span class=\"comment\">// 半关闭状态（能写入但会丢弃读取的数据）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_PACCEPT 7 \t\t<span class=\"comment\">// 已接收，但是未添加到epoll（需要start）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCKET_TYPE_BIND 8\t\t\t<span class=\"comment\">// 绑定系统fd(stdin、stdout、stderr)</span></span></span><br></pre></td></tr></table></figure>\n<p>这些状态有的属于公共状态，每个 socket 实例都能适用，例如 INVALID 和 RESERVE；有的状态则只适用于与之对应的网络操作，例如 PLISTEN 和 LISTEN 属于与监听(listen)关联的状态。<br>首先介绍下两个公共状态的作用和意义：</p>\n<ul>\n<li>INVALID 是一个 socket 的初始状态，表示这个 socket 实例暂时未被使用，即可用状态，可用参考上面的 ID 生成 那一节内容</li>\n<li>RESERVE 保留状态，它表示一个 socket 实例正处于某些网络操作(例如listen、connect)的开始和正式结束的“中间”状态</li>\n</ul>\n<p>这里我们思考一个问题，为什么需要 RESERVE 中间状态呢？<br>这是因为 skynet 是一个多线程框架，为了保证工作线程尽量少的出现阻塞调用（服务都是由工作线程驱动），就需要把网络操作中的阻塞部分交由网络线程处理，当网络线程处理完阻塞逻辑后，抛出消息异步通知给服务，而 RESERVE 状态则确保了工作线程在发起网络调用后能立即返回一个可用的 socket 实例并保留住，以便异步消息的回调。正如云风所说：</p>\n<blockquote>\n<p>目前的设计是，所有网络请求，都通过把指令写到一个进程内的 pipe ，串行化到网络处理线程，依次处理，然后再把结果投&gt; 递到 skynet 的其它服务中。</p>\n</blockquote>\n<p>除了公共状态，其余的状态与网络调用相对应，这些网络调用包括：监听连接、被动连接、主动连接、关闭连接。</p>\n<ul>\n<li>监听，skynet 把监听操作分成两个步骤：建立监听socket、绑定并监听(有阻塞，如 getaddrinfo)；手动将监听 fd 注册到 epoll/kqueue 中<br><img src=\"https://user-images.githubusercontent.com/11263320/120348568-e18e2300-c32f-11eb-94c5-83fcb19f95df.jpg\" alt=\"adc3x-9j2im\"></li>\n<li>被动连接，同样分为两个步骤：发起主动连接请求；注册连接 fd 到 epoll/kqueue 中<br><img src=\"https://user-images.githubusercontent.com/11263320/120358666-54e86280-c339-11eb-9d98-673121d6761a.jpg\" alt=\"a2gj4-3mpt0\"></li>\n<li>主动连接，同样分为两个步骤：发起主动连接请求；注册连接 fd 到 epoll/kqueue 中。<br><img src=\"https://user-images.githubusercontent.com/11263320/120581931-34fe8f00-c45e-11eb-91d1-c487071d7570.jpg\" alt=\"aky9g-917zw\"></li>\n<li>关闭连接，分为正常关闭(close)和强制停止(shutdown)<br><img src=\"https://user-images.githubusercontent.com/11263320/120582027-58c1d500-c45e-11eb-8bbb-1bb258a4acfd.jpg\" alt=\"ajhg1-e8j3q\"><br>从上面这些网络操作的时序图中，我们可以看到它们都采用了异步消息通知的机制，网络调用由服务发起，通过内部命令管道转发给网络库，最终由网络线程执行具体的逻辑。这也印证了RESERVE状态的必要性。</li>\n</ul>\n<p>需要注意的是，skynet 网络库使用的系统网络 API 基本都是非阻塞的，除了 getaddrinfo，它是一个阻塞 API，linux 提供的各DNS API函数都是阻塞式的，无法设置超时时间等（关于此 api，官方的wiki也有说明）；另外，由 socket() 创建的 fd 也基本会设置成非阻塞(nonblocking)模式，包括 connect 的 fd，只有 listen fd 为阻塞。</p>\n<h2 id=\"写入队列\"><a href=\"#写入队列\" class=\"headerlink\" title=\"写入队列\"></a>写入队列</h2><p>一个 socket 实例有两个发送队列：高优先级队列、低优先级队列。它们的结构相同，只是在网络线程发送数据时有优先顺序，高优先级队列中的数据会优先发送。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">write_buffer</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">write_buffer</span> * <span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buffer;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> sz;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> userobject;</span><br><span class=\"line\">\t<span class=\"keyword\">uint8_t</span> udp_address[UDP_ADDRESS_SIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送队列</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wb_list</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">write_buffer</span> * <span class=\"title\">head</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">write_buffer</span> * <span class=\"title\">tail</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>关于这两个队列的处理规则，可参考云风《对 skynet 的 gate 服务的重构》文中所述：<br>socket 发送规则如下：</p>\n<blockquote>\n<p>如果 socket 可写，且两个队列都为空，立即发送。<br>如果上一次有一个数据包没有发送完，无论它在哪个队列里，都确保先将其发送完。<br>如果高优先级队列有数据包，先保证发送高优先级队列上的数据。<br>如果高优先级队列为空，且低优先级队列不为空，发送一个低优先级队列上的数据包。</p>\n</blockquote>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>深入理解skynet —— 网络库(一)  详见：<a href=\"https://domicat.me/_posts/2020-05-20-learn-skynet-network1/\">https://domicat.me/_posts/2020-05-20-learn-skynet-network1/</a><br>pipe异步使用场景 详见：<a href=\"https://www.zhihu.com/question/39752285/answer/82906915\">https://www.zhihu.com/question/39752285/answer/82906915</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/79\">En la vida hay dos palabras que te abrirán muchas puertas…?? ???TIRE y EMPUJE!!!</a></p>\n","tags":["skynet"]},{"title":"skynet timer","url":"/post/ee7b06a5.html","content":"<p>skynet定时器模块提供了服务定时消息的支持，实现算法为时间轮算法。它提供的功能包括两点：定时消息的添加和定时消息的派发。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h2><p>skynet的设计思想参考Linux内核动态定时器的机制。</p>\n<p>使用时间轮（time wheel）算法来实现定时器模块。<br>定时器的逻辑由专门的线程（thread_timer）进行负责，节点中的服务向定时器注册定时消息，然后由 timer 线程每隔一段时间转动一次时间轮（在 skynet 中，每隔 10 ms 转动一次时间轮），由此触发该轮下的定时消息，并派发定时事件到对应的服务。</p>\n<div class=\"note info\"><p>关于定时器的实现算法主要有两种：最小堆和时间轮。redis 使用了最小堆；linux 内核使用了时间轮。</p></div>\n\n<h3 id=\"为什么用时间轮\"><a href=\"#为什么用时间轮\" class=\"headerlink\" title=\"为什么用时间轮\"></a>为什么用时间轮</h3><p>相比传统的队列形式的调度器来说，时间轮能够批量高效的管理各种延时任务、周期任务、通知任务等等。</p>\n<h2 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"时间轮\"></a>时间轮</h2><p>时间轮算法的本质就是用有限的刻度实现时间的无限轮回，一次时间轮回的长度就是该时间轮能表达的最大时长。其实现方式就是模拟了我们生活中的手表（机械手表），只不过手表把时、分、秒三个轮盘合并成了一个轮盘，而把刻度指针分为了三个。<br>现在，我们把手表的轮盘按照时、分、秒拆分成三个，它们的轮盘刻度分为为：12（时）、60（分）、60（秒），因此手表的时间轮模型一共有 12 + 60 + 60 = 132 个刻度，走完一整轮的时长为 12 * 60 * 60 = 43200 秒。<br><img src=\"https://user-images.githubusercontent.com/11263320/121156613-6cfd3c00-c87b-11eb-9335-bdddc6ab6f2c.png\" alt=\"2020-05-17-01\"><br>像手表这样的时间轮模型分了时、分、秒三层的，属于分层时间轮，每一层的轮回时间都是逐层递增，例如：走完一整圈『秒轮』，需要 60 秒；再提升一层，走完一圈『分轮』就需要 60<em>60 秒；再往上一层就需要 12</em>60*60 秒，也就是上面所说的这个手表的时间轮最大轮回时长。</p>\n<h3 id=\"为什么需要时间轮\"><a href=\"#为什么需要时间轮\" class=\"headerlink\" title=\"为什么需要时间轮\"></a>为什么需要时间轮</h3><p>首先，我们假设要编写这样一个程序：每隔 1 秒打印一个数字，一直打印 12 小时（43200 秒），且这些数字预先就确定并排好了顺序，例如第 1 秒打印数字 100，第 2 秒打印数字 200 … 那该怎么设计这个定时器呢？一个最简单粗暴的方式是创建一个容量为 43200 的数组，并把要打印的对应数字填入到数组中，然后以 1 秒为间隔，循环这个数组。</p>\n<p>虽然上面的实现方式可以满足需求，且时间复杂度为 O(1)，但是存在两个问题：</p>\n<blockquote>\n<p>定时器数组占用的连续内存空间会随着最大定时时长的增大而增大，若需要这个定时程序运行 365 天，数组的长度就是 86400 * 365，假如一个数字用 4byte 来表示，就需要 120+ Mb 的连续内存空间，这种方式显然是不可取的；<br>根据上一条的问题，这种方式不能实现无限循环的定时器，因为我们的连续内存空间是有限的；</p>\n</blockquote>\n<p>注意，为什么这里一直在强调是连续内存空间，是因为不管采用数组或是链表的方式，最终用于存储定时数字的内存总空间并不会减少，只不过为了能快速索引到对应的时间轮刻度，使用的数组的方式来存储数据，而为了实现定时器，耗费大块的连续内存空间是不划算的；而如果采用链表的方式，又会导致链表查询耗时增加。</p>\n<p>而时间轮模型就很好的解决了上面的问题，它的核心思想是：把最近一轮要到期的定时事件放到最外的轮盘（我称之为“工作轮盘”）中，且定时器只会从最外的轮盘中触发定时消息；若最外层轮盘走完一轮后，则向内一层的轮盘（我称之为“发散轮盘”）取出一批定时数据；若内一层轮盘也走完一轮后，则向内内一层取一批，以此类推。</p>\n<p>为了彻底弄懂时间轮的工作流程，我们来看一个生活中的例子：每一年绝大部分的中国人都会经历春运，我们历经千辛万苦抢到一张高铁票，只等春节放假开开心心、安安全全回家。等到了回家那天，我们提早到达了高铁站， 接下来从到达车站到进入候车室会经过下面几个步骤：入站、验票、安检。现在假设高铁站的最大容量有 3000 人（站内 1000 + 站外广场 2000），且只有一个安检机，车站工作人员为了快速有序的安检，采用了时间轮模型对乘客进行了排队分组，大概的模型如下:<br><img src=\"https://user-images.githubusercontent.com/11263320/121286454-72f22c00-c912-11eb-98dc-16ee5b9dc3db.jpg\" alt=\"ag227-fhoqz\"><br>从上图可以得知，不同层级的分组容量是不一样的，层级越高分组容量越大，例如广场上一组的容量为 1000人，验票通道每个分组的容量为 100 人，且它们存在如下关系：广场分组容量(1000) = 验票分组容量(100) x 验票分组个数(10)。现在对车站的 3000 个乘客进行编号并排队分组，他们的初始分布情况如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">安检通道（工作轮盘）：1-10 号</span><br><span class=\"line\"></span><br><span class=\"line\">安检排队（第一层发散轮盘）：</span><br><span class=\"line\">    - 排队分组1 ：虚空分组（已发散到安检通道）</span><br><span class=\"line\">    - 排队分组2 ：11-20  号</span><br><span class=\"line\">    - 排队分组3 ：21-30  号</span><br><span class=\"line\">    - 排队分组4 ：31-40  号</span><br><span class=\"line\">    - 排队分组5 ：41-50  号</span><br><span class=\"line\">    - 排队分组6 ：51-60  号</span><br><span class=\"line\">    - 排队分组7 ：61-70  号</span><br><span class=\"line\">    - 排队分组8 ：71-80  号</span><br><span class=\"line\">    - 排队分组9 ：81-90  号</span><br><span class=\"line\">    - 排队分组10：91-100 号</span><br><span class=\"line\"></span><br><span class=\"line\">验票排队（第二层发散轮盘）：</span><br><span class=\"line\">    - 排队分组1 ：虚空分组（已发散到安检排队）</span><br><span class=\"line\">    - 排队分组2 ：101-200  号</span><br><span class=\"line\">    - 排队分组3 ：201-300  号</span><br><span class=\"line\">    - 排队分组4 ：301-400  号</span><br><span class=\"line\">    - 排队分组5 ：401-500  号</span><br><span class=\"line\">    - 排队分组6 ：501-600  号</span><br><span class=\"line\">    - 排队分组7 ：601-700  号</span><br><span class=\"line\">    - 排队分组8 ：701-800  号</span><br><span class=\"line\">    - 排队分组9 ：801-900  号</span><br><span class=\"line\">    - 排队分组10：901-1000 号</span><br><span class=\"line\"></span><br><span class=\"line\">进站排队（第三层发散轮盘）：</span><br><span class=\"line\">    - 排队分组1 ：虚空分组（已发散到验票排队）</span><br><span class=\"line\">    - 排队分组2 ：1001-2000  号</span><br><span class=\"line\">    - 排队分组3 ：2001-3000  号</span><br><span class=\"line\">安检通道（工作轮盘）：1-10 号</span><br></pre></td></tr></table></figure>\n<p>上面提到的“虚空分组”对应了上图中被涂成黄色的的分组，在实际应用中，这个分组其实是不需要的，因为这个分组会在第一次发散轮盘进行跨层级发散时发散到上一个层级中，这不过为了方便理解，我把这些“虚空分组”画了出来。<br>至此，车站已经初始化好了这个“时间轮”模型，现在开始转动“时间轮”，即安检机开始逐个安检，大致过程如下：</p>\n<blockquote>\n<p>当 1-10 号乘客完成安检后，则向『安检排队』获取下一个排队分组 2，即 11-20 号乘客，以此类推；<br>当安检排队中的最后一个（第100号）乘客通过安检后，则向『验票通道』获取下一个排队分组 2，即 101-200 号乘客，并将这 100 个乘客做一次发散处理（101-110 发撒到『安检通道』，111-200分别发散到『安检排队』分组2-10）；<br>当第 1000 号乘客通过安检后，则发散 1001-2000 号乘客，处理方式与步骤 2 类似；</p>\n</blockquote>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/128179421-443d5277-0308-4131-bea7-0ca1b0c5b5ee.jpg\" alt=\"121575990-8d372180-ca5a-11eb-88ce-6125a229cfff\"><br>skynet 的定时器实现属于分层时间轮，分为了 4 个发散轮盘（64个槽位）和 1 个工作轮盘（256个槽位），因此它的最大能表示的轮回时间为：64x64x64x64x256 = 4294967296，刚好为一个 uint32 能表示的数字的个数（0 ~ 0xFFFFFFFF）。需要注意一点，在 skynet 中，框架层只提供了定时器的添加，并没有提供定时器撤销的接口。</p>\n<p>先看一下timer结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">link_list</span> <span class=\"title\">near</span>[<span class=\"title\">TIME_NEAR</span>];</span><span class=\"comment\">//// 工作轮盘</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">link_list</span> <span class=\"title\">t</span>[4][<span class=\"title\">TIME_LEVEL</span>];</span><span class=\"comment\">// 发散轮盘</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> time;<span class=\"comment\">//表示时间轮转动次数，当时间轮走完一整个轮回后，该字段会重置为 0，继续轮回；</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> starttime;<span class=\"comment\">//表示定时器初始化时的时间戳（单位为秒），该时间戳获取后将不会变化；</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> current;<span class=\"comment\">//表示从 starttime 开始，经过了多少厘秒（1/100 秒），只增不减；</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> current_point;<span class=\"comment\">//表示以厘秒为单位的本机当前时间戳，可增（本机时间往前调）可减（本机时间往回调）；</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意后面四个跟时间相关的字段，根据这四个字段，可以得到下面几个信息</p>\n<blockquote>\n<p>1.在 skynet 进程中获取当前时间戳(秒)的公式为 timer-&gt;starttime + timer-&gt;current/100；<br>2.在 skynet 进程中获取的当前时间戳只增不减，且不一定等于物理机上的当前时间戳（物理机的时间可能被人为修改）；<br>3.若物理机的时间被往前调大后，定时器会在一个逻辑帧内快速 tick，以此弥补定时事件，例如物理机时间从 0s 修改为 1s，则定时器则在一帧内快速 tick 100次；<br>4.若物理机的时间被往回调小后，定时器不会做任何回退操作，之前被触发的定时事件不会因为时间回退而再次被触发；</p>\n</blockquote>\n<p>在 skynet 中，定时器的转动由 thread_timer 驱动，时间轮 tick(或称“滴答”) 一次的时间间隔为 10ms，timer 线程的处理逻辑如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *</span><br><span class=\"line\">thread_timer(<span class=\"keyword\">void</span> *p) &#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">monitor</span> * <span class=\"title\">m</span> =</span> p;</span><br><span class=\"line\">\tskynet_initthread(THREAD_TIMER);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\tskynet_updatetime();</span><br><span class=\"line\">\t\tskynet_socket_updatetime();</span><br><span class=\"line\">\t\tCHECK_ABORT</span><br><span class=\"line\">\t\twakeup(m,m-&gt;count<span class=\"number\">-1</span>); <span class=\"comment\">// 贪婪唤醒工作线程</span></span><br><span class=\"line\">\t\tusleep(<span class=\"number\">2500</span>);         <span class=\"comment\">// 睡眠 2.5 ms</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (SIG) &#123;</span><br><span class=\"line\">\t\t\tsignal_hup();</span><br><span class=\"line\">\t\t\tSIG = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// wakeup socket thread</span></span><br><span class=\"line\">\tskynet_socket_exit();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// wakeup all worker thread</span></span><br><span class=\"line\">\tpthread_mutex_lock(&amp;m-&gt;mutex);</span><br><span class=\"line\">\tm-&gt;quit = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tpthread_cond_broadcast(&amp;m-&gt;cond);</span><br><span class=\"line\">\tpthread_mutex_unlock(&amp;m-&gt;mutex);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，虽然在定时器内是 10ms tick 一次，但是在 timer 线程中执行间隔为 2.5ms。</p>\n<h3 id=\"添加定时消息\"><a href=\"#添加定时消息\" class=\"headerlink\" title=\"添加定时消息\"></a>添加定时消息</h3><p>当往定时器中添加一个定时事件时，这个定时事件的结构体该如何定义呢？在 skynet 中，一个定时事件由两个结构体合作表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定时事件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_event</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> handle;    <span class=\"comment\">// 注册该事件的服务 handle id</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> session;        <span class=\"comment\">// 该定时消息的 session</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 事件节点，插入到定时列表中</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> expire;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>反应到内存布局上时，一个封装的定时事件对象结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">+----------+------------+------------------------+</span><br><span class=\"line\">|          |            | +--------------------+ |</span><br><span class=\"line\">|   next   |   expire   | |  handle  | session | |</span><br><span class=\"line\">|          |            | +--------------------+ |</span><br><span class=\"line\">+----------+------------+------------------------+</span><br></pre></td></tr></table></figure>\n<p>当我们添加一个定时事件时，一般会传入事件的到期时间间隔或者 tick，那么，如何找到正确的槽位来添加这个定时节点呢？这就要用到前面提到的 timer-&gt;time 字段了，将定时节点的到期时间 timer_node-&gt;expire 与 time 逐层级对比，先找到合适的层级 level，再计算出正确的槽位索引 index。具体的添加逻辑如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">add_node(struct timer *T,struct timer_node *node) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> time=node-&gt;expire;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> current_time=T-&gt;time;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 这里我替换了 宏定义，方便阅读代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((time|<span class=\"number\">255</span>)==(current_time|<span class=\"number\">255</span>)) &#123;</span><br><span class=\"line\">\t\tlink(&amp;T-&gt;near[time&amp;<span class=\"number\">255</span>],node);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> mask=<span class=\"number\">256</span> &lt;&lt; <span class=\"number\">6</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((time|(mask<span class=\"number\">-1</span>))==(current_time|(mask<span class=\"number\">-1</span>))) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmask &lt;&lt;= TIME_L6EVEL_SHIFT;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (time &gt;&gt; (<span class=\"number\">8</span> + i*<span class=\"number\">6</span>)) &amp; <span class=\"number\">63</span>;</span><br><span class=\"line\">\t\tlink(&amp;T-&gt;t[i][index], node);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">timer_add(struct timer *T,<span class=\"keyword\">void</span> *arg,<span class=\"keyword\">size_t</span> sz,<span class=\"keyword\">int</span> time) &#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_node</span> *<span class=\"title\">node</span> =</span> (struct timer_node *)skynet_malloc(<span class=\"keyword\">sizeof</span>(*node)+sz);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(node+<span class=\"number\">1</span>,arg,sz);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSPIN_LOCK(T);</span><br><span class=\"line\">        <span class=\"comment\">// assert(time&lt;=0xFC000000); //超时tick不能超过 0xFC000000</span></span><br><span class=\"line\">\t\tnode-&gt;expire=time+T-&gt;time;</span><br><span class=\"line\">\t\tadd_node(T,node);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSPIN_UNLOCK(T);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的逻辑中，有一个小细节需要多多体会一下，当一个 timer_node 的到期时间发生溢出时，最终的 node 会被存放在 T-&gt;t[3][0] 这个槽位中，这里还有一个隐藏的条件约束：传入给 timer_add 函数的 time 参数的值不能大于 0xFC000000，这也是为什么这个参数的数据类型是 int 而不是 uint 的原因（因为 int 能表达的最大正数为 0x7FFFFFFF）。<br>为什么会有这个限制，通过下面的例子就一目了然了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">设：T-&gt;time &#x3D; 0xFFFFFFFF;</span><br><span class=\"line\"></span><br><span class=\"line\">现添加一个超时time &#x3D; 0xFFFFFFFE 的定时事件，则：</span><br><span class=\"line\">    node-&gt;expire &#x3D; time + T-&gt;time &#x3D; 0xFFFFFFFD; </span><br><span class=\"line\">    </span><br><span class=\"line\">执行 add_node 逻辑，得到的槽位为：T-&gt;near[0xFD] &#x3D; T-&gt;near[253];</span><br></pre></td></tr></table></figure>\n<p>显然，上面的添加逻辑出现了错误！为了保证逻辑正确性，就需要保证溢出后的 node-&gt;expre 不能超过 0xFBFFFFFF，由此反推出超时间隔 time &lt;= 0xFC000000。<br>此外，在添加定时器时，还有一个细节优化，即当传入一个超时间隔为 0 的定时事件时，会直接派发定时消息到对应的服务中，不再添加到时间轮中。这里也可以思考一下，如果没有这个过滤优化，定时器该如何处理 timeout 0 的定时器事件呢？</p>\n<h2 id=\"触发定时事件\"><a href=\"#触发定时事件\" class=\"headerlink\" title=\"触发定时事件\"></a>触发定时事件</h2><p>在前面已经提到了定时器会以频率 1tick / 10ms 来转动时间轮，每转动一次会触发工作轮盘中对应槽位的定时事件，当工作轮盘转动完一整轮后，则触发发散操作。具体操作的代码实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了方便阅读代码，便于理解，我对代码做了一些简单处理</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">timer_update(struct timer *T) &#123;</span><br><span class=\"line\">\tSPIN_LOCK(T);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// try to dispatch timeout 0 (rare condition)</span></span><br><span class=\"line\">\t<span class=\"comment\">//timer_execute(T);</span></span><br><span class=\"line\">    <span class=\"comment\">// 派发定时消息</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = T-&gt;time &amp; <span class=\"number\">255</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T-&gt;near[idx].head.next) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_node</span> *<span class=\"title\">current</span> =</span> link_clear(&amp;T-&gt;near[idx]);</span><br><span class=\"line\">\t\tSPIN_UNLOCK(T);</span><br><span class=\"line\">\t\t<span class=\"comment\">// dispatch_list don&#x27;t need lock T</span></span><br><span class=\"line\">\t\tdispatch_list(current);</span><br><span class=\"line\">\t\tSPIN_LOCK(T);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">// shift time first, and then dispatch timer message</span></span><br><span class=\"line\">    <span class=\"comment\">// 转动轮盘，可能触发发散逻辑</span></span><br><span class=\"line\">\ttimer_shift(T);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//timer_execute(T);</span></span><br><span class=\"line\">    <span class=\"comment\">// 派发定时消息</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx = T-&gt;time &amp; <span class=\"number\">255</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T-&gt;near[idx].head.next) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer_node</span> *<span class=\"title\">current</span> =</span> link_clear(&amp;T-&gt;near[idx]);</span><br><span class=\"line\">\t\tSPIN_UNLOCK(T);</span><br><span class=\"line\">\t\t<span class=\"comment\">// dispatch_list don&#x27;t need lock T</span></span><br><span class=\"line\">\t\tdispatch_list(current);</span><br><span class=\"line\">\t\tSPIN_LOCK(T);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSPIN_UNLOCK(T);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个执行逻辑的伪代码大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lock1(T);</span><br><span class=\"line\">清空 T-&gt;near[T-&gt;time &amp; 255], 并返回链表头部指针 current1;</span><br><span class=\"line\">unlock1(T);</span><br><span class=\"line\"></span><br><span class=\"line\">派发 current1 链表中的定时消息;</span><br><span class=\"line\"></span><br><span class=\"line\">lock2(T);</span><br><span class=\"line\">转动轮盘(++T-&gt;time);</span><br><span class=\"line\">清空 T-&gt;near[T-&gt;time &amp; 255], 并返回链表头部指针 current2;</span><br><span class=\"line\">unlock2(T);</span><br><span class=\"line\"></span><br><span class=\"line\">派发 current2 链表中的定时消息;</span><br><span class=\"line\"></span><br><span class=\"line\">lock3(T);</span><br><span class=\"line\">unlock3(T);</span><br></pre></td></tr></table></figure>\n<p>为什么会执行两次 timer_execute 呢？<br>回到上一节最后留下的那个疑问了，因为 timer 模块并不对 timeout 0 消息的处理做出承诺，也就说 timer 模块需要支持对 timeout 0 的正确处理，虽然 skynet 确实对 timeout 0 的消息做了过滤优化。下面还是通过一个示例来解释具体原因：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">0                  1                  2                   3</span><br><span class=\"line\">+                  +                  +                   +</span><br><span class=\"line\">|                  |                  |                   |</span><br><span class=\"line\">+---------------------------------------------------------+</span><br><span class=\"line\">|                  |                  |                   |</span><br><span class=\"line\">|      10ms        |      10ms        |       10ms        |</span><br><span class=\"line\">+                  +                  +                   +</span><br></pre></td></tr></table></figure>\n<p>假设当前 T-&gt;time = 2，即时间轮转动了 2 次，经过 10ms 后，再次转动时间轮，即 T-&gt;time 从 2 变为 3，按照正常逻辑会进行如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lock(T);</span><br><span class=\"line\">转动轮盘(转动后 T-&gt;time &#x3D; 3);</span><br><span class=\"line\">清空 T-&gt;near[3], 并返回链表头部指针 current;</span><br><span class=\"line\">unlock(T);</span><br><span class=\"line\">派发 current 链表中的定时消息;</span><br></pre></td></tr></table></figure>\n<p>但是，在这次 tick 过程中，一个细节处理就出现了！<br>因为 skynet 是一个多线程框架，在前一次时间轮转动（T-&gt;time 从 1 变为 2）之后，槽位 2 上的定时事件都会被处理完毕并清空，然后时间轮再等待 10ms 进行下一次转动，但是在这等待的 10ms 中，可能其他的工作线程会添加一些 timeout 0 的定时消息（假设 skynet 没有过滤掉 timeout 0 消息），而此时 T-&gt;time = 2，因此这些新添加的定时消息又会插入到槽位 2 中，当下一次转动发生后(T-&gt;time=3)，槽位 2 上的那些定时消息就失去了触发的机会，从而导致定时事件丢失。这就是为什么 timer_execute 需要执行两次的原因。</p>\n<h2 id=\"从skynet-1-4-0中分离出来的timer实现代码\"><a href=\"#从skynet-1-4-0中分离出来的timer实现代码\" class=\"headerlink\" title=\"从skynet-1.4.0中分离出来的timer实现代码\"></a>从skynet-1.4.0中分离出来的timer实现代码</h2><p><a href=\"https://gist.github.com/losophy/f12f340a3a016b4385ccb30a31d7b989\">skynet_timer</a></p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>深入理解skynet —— 定时器 详见：<a href=\"https://domicat.me/_posts/2020-05-17-learn-skynet-timer/\">https://domicat.me/_posts/2020-05-17-learn-skynet-timer/</a></p>\n<hr>\n","tags":["skynet"]},{"title":"skynet worker","url":"/post/c4e8baa7.html","content":"<p>这里介绍下skynet的线程。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"4种线程\"><a href=\"#4种线程\" class=\"headerlink\" title=\"4种线程\"></a>4种线程</h2><p>skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，从全局消息队列中pop出一个次级消息队列时，其他线程是拿不到同一个服务，并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的<br>socket线程、timer线程甚至是worker线程，都有可能会往指定服务的次级消息队列中push消息，<strong>push函数内有加一个自旋锁，避免同时多条线程同时向一个次级消息队列push消息的惨局</strong>。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/121575990-8d372180-ca5a-11eb-88ce-6125a229cfff.jpg\" alt=\"a0bsd-b804l\"></p>\n<h2 id=\"skynet运行机制\"><a href=\"#skynet运行机制\" class=\"headerlink\" title=\"skynet运行机制\"></a>skynet运行机制</h2><p>skynet每个服务最重要的是设置一个callback函数，服务向另一个服务发消息都会压入这个服务的消息队列，等待_worker线程从全局队列取出一个服务的消息队列，然后再从这个消息队列取出一个消息使用这个服务的callback处理<br>游戏服务器一般会启动一个socket服务教给gate.so管理，socket服务可以接受外部msg传递到内部服务来处理。</p>\n<p>1.main函数<br>main函数是skynet进程的入口点，它需要一个配置文件的路径作为参数。main函数先做一些内存分配工作，然后加载配置文件里的内容。再把配置文件里的内容设置到lua环境变量_ENV。然后从_ENV里读取配置到c配置中。最后调用skynet_start。<br>2.skynet_start函数<br>skynet_start函数根据配置确定服务是不是以后台方式启动，然后初始化timer/socket/module/mq这些数据结构，给它们分配内存，填充一些必要的字段。下一步创建和注册日志logger服务，这个logger服务是C层实现的。然后创建注册snax服务，做bootstrap操作。最后调用start函数。<br>3.start函数<br>这个函数会启动timer/socket/monitor/worker线程，timer/socket/monitor线程都只有一个，唯独worker线程是多个，在配置文件中以thread=num来配置的。如果配置文件中没有配，就是8个。第个worker线程都有自己的权重值，权重值越大的，给单个服务的时间片越小。<br>线程都启动完以后，就进入pthread_join，等待线程的终止。所有线程终止以后，skynet就会退出。</p>\n<p>例如：<br>在网络游戏中，你可以为每个在线用户创建一个 lua 虚拟机（skynet 称之为 lua 服务），姑且把它称为 agent 。用户在不和其它用户交互而仅仅自娱自乐时，agent 完全可以满足要求。agent 在用户上线时，从数据库加载关联于它的所有数据到 lua vm 中，对用户的网络请求做出反应。当然你也可以让一个 lua 服务管理多个在线用户，每个用户是 lua 虚拟机内的一个对象。<br>你还可以用独立的服务处理网络游戏中的副本（或是战场），处理玩家和玩家间，玩家协同对战 AI 的战斗。agent 会和副本服务通过消息进行交互，而不必让用户客户端直接与副本通讯。<br>我们通常建议使用一个网关服务（gate），专门监听端口，接受新连接。在用户身份确定后，再把真正的业务数据转交给特定的服务来处理。同时，网关还会负责按约定好的协议，把 TCP 连接上的数据流切分成一个个的包，而不需要业务处理服务来分割 TCP 数据流。业务处理的服务不必直接面对 socket 句柄，而由 skynet 正常的内部消息驱动即可。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/73\">No te tomes la vida en serio, al fin y al cabo no saldrás vivo de ella.</a></p>\n","tags":["skynet"]},{"title":"skynet与actor","url":"/post/3da22f02.html","content":"<p><code>skynet</code>是一个为网络游戏服务器设计的轻量框架，采用单进程，多线程架构。底层是<code>c</code>，中间层和上层都是<code>lua</code>。基于<code>actor</code>模型，使用消息队列进行内部通信。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"总体思路\"><a href=\"#总体思路\" class=\"headerlink\" title=\"总体思路\"></a>总体思路</h2><p><code>skynet</code>是一个很好的<a href=\"https://github.com/losophy/losophy.github.io/issues/138\">actor</a>实例。通过给每个<code>worker</code>分配<code>lua vm</code>，有效地实现了<code>actor</code>的思路。</p>\n<p>简单说，可以把<code>skynet</code>理解为一个简单的操作系统，它可以用来调度数千个<code>lua</code>虚拟机，让它们并行工作。每个<code>lua</code>虚拟机都可以接收处理其它虚拟机发送过来的消息，以及对其它虚拟机发送消息。每个<code>lua</code>虚拟机，可以看成<code>skynet</code>这个操作系统下的独立进程，你可以在<code>skynet</code>工作时启动新的进程、销毁不再使用的进程、还可以通过调试控制台监管它们。<code>skynet</code>同时掌控了外部的网络数据输入，和定时器的管理；它会把这些转换为一致的（类似进程间的消息）消息输入给这些进程。<br><img src=\"https://user-images.githubusercontent.com/11263320/127138301-450b1e7a-a9d5-4d56-9909-933d2dad4549.jpg\" alt=\"120056311-e459f100-c06d-11eb-8117-af58ad15e2bc\"></p>\n<p>上图其实就是 Actor 模型，Actor 模型是一个概念模型，用于处理并发计算。它定义了一系列系统组件应该如何动作和交互的通用规则，即 Actor 的参与者 = {消息队列, 处理逻辑(服务)}。</p>\n<h2 id=\"Actor实现\"><a href=\"#Actor实现\" class=\"headerlink\" title=\"Actor实现\"></a>Actor实现</h2><p>那在 skynet 底层中，如何描述一个 Actor 参与者呢？ 通过上面的结构体关系图可知，其实在 skynet 底层使用了结构体 struct skynet_context 来描述一个 Actor 参与者，这个结构体的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> * instance; \t\t\t<span class=\"comment\">// 它是一个指针，指向了一个服务对象，它是由服务模板 struct skynet_module * mod 创建出来的</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_module</span> * <span class=\"title\">mod</span>;</span>\t<span class=\"comment\">// 动态库</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> * cb_ud;\t\t\t\t<span class=\"comment\">// 一个被回调函数真实调用的服务实例对象的指针</span></span><br><span class=\"line\">\tskynet_cb cb;\t\t\t\t<span class=\"comment\">// 服务的回调函数，是消息被服务对象执行的唯一通道，这个回调函数可以重新设置</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">message_queue</span> *<span class=\"title\">queue</span>;</span> <span class=\"comment\">// 它是一个指针，指向了消息队列对象，这个对象中的 q-&gt;queue 字段才真正存放了消息数组</span></span><br><span class=\"line\">\tFILE * logfile; \t\t\t<span class=\"comment\">// for 服务日志</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> cpu_cost;\t\t\t<span class=\"comment\">// in microsec，for cpu 性能指标</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> cpu_start;\t\t\t<span class=\"comment\">// in microsec，for cpu 性能指标 &amp; 当前消息处理耗时</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> result[<span class=\"number\">32</span>]; \t\t\t<span class=\"comment\">// 存放性能指标的查询结果</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> handle; \t\t\t<span class=\"comment\">// 服务的id</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> session_id; \t\t\t<span class=\"comment\">// 消息的session id分配器</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ref;\t\t\t\t\t<span class=\"comment\">// 服务引用计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> message_count; \t\t\t<span class=\"comment\">// 已处理过的消息总数</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> init;\t\t\t\t\t<span class=\"comment\">// 初始化成功的标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> endless;\t\t\t\t<span class=\"comment\">// 死循环标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> profile;\t\t\t\t<span class=\"comment\">// cpu 性能指标开启开关</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCHECKCALLING_DECL</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>instance，cb，queue，cb_ud。这四个字段，构成了一个 Actor 核心骨架，消息队列内的消息被服务的回调函数 cb 执行，这也是为什么说 skynet 是消息驱动的。一个大致的流程是：一个消息通过服务的回调函数，然后传递给服务实例，最终被消费处理掉。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回调函数类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*skynet_cb)</span><span class=\"params\">(struct skynet_context * context, <span class=\"keyword\">void</span> *ud, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> session, <span class=\"keyword\">uint32_t</span> source , <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * msg, <span class=\"keyword\">size_t</span> sz)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意下，在服务实例第一次初始化并设置回调后，cb_ud 与 instance 是同一个东西，即ctx-&gt;instance = ctx-&gt;cb_ud，但是对于 snlua 服务启动后，会重新设置一次回调，这里就产生了两个区别的：</p>\n<blockquote>\n<p>1.cb_ud 指向由原来的 ctx-&gt;instance 变成了 lua vm（lua 主线程），它们存在这样的一个关系：ctx-&gt;instance-&gt;L = ctx-&gt;cb_ud = luavm；<br>2.cb 回调函数变成了一个封装了 lua 调用的函数；</p>\n</blockquote>\n<p>具体的更改流程的代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">lcallback(lua_State *L) &#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * <span class=\"title\">context</span> =</span> lua_touserdata(L, lua_upvalueindex(<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> forward = lua_toboolean(L, <span class=\"number\">2</span>);</span><br><span class=\"line\">\tluaL_checktype(L,<span class=\"number\">1</span>,LUA_TFUNCTION);</span><br><span class=\"line\">\tlua_settop(L,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tlua_rawsetp(L, LUA_REGISTRYINDEX, _cb);</span><br><span class=\"line\"></span><br><span class=\"line\">\tlua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);</span><br><span class=\"line\">\tlua_State *gL = lua_tothread(L,<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (forward) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cb_ud=gL </span></span><br><span class=\"line\">\t\t<span class=\"comment\">// cb = forward_cb，消息派发后不free掉，用于转发消息</span></span><br><span class=\"line\">\t\tskynet_callback(context, gL, forward_cb);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// cb = _cb，消息派发后free掉</span></span><br><span class=\"line\">\t\tskynet_callback(context, gL, _cb);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/78\">El amor eterno dura aproximadamente tres meses.</a></p>\n","tags":["skynet"]},{"title":"skynet各文件功能","url":"/post/6b9da80.html","content":"<p>分析一个程序的源代码，前期除了研究该程序的历史外，还可以细分下各文件所表达的功能。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"skynet各文件功能\"><a href=\"#skynet各文件功能\" class=\"headerlink\" title=\"skynet各文件功能\"></a>skynet各文件功能</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108858906-a5a83b00-7627-11eb-9ce1-223d08f02aa8.png\" alt=\"20180315154138758\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">└─skynet-1.4.0</span><br><span class=\"line\">    ├─3rd</span><br><span class=\"line\">    │  ├─jemalloc  内存分配器</span><br><span class=\"line\">    │  ├─lpeg  一个供lua使用的基于 Parsing Expression Grammars 的模式匹配库</span><br><span class=\"line\">    │  │      lpcap.c</span><br><span class=\"line\">    │  │      lpcap.h</span><br><span class=\"line\">    │  │      lpcode.c</span><br><span class=\"line\">    │  │      lpcode.h</span><br><span class=\"line\">    │  │      lpeg-128.gif</span><br><span class=\"line\">    │  │      lpeg.html</span><br><span class=\"line\">    │  │      lpprint.c</span><br><span class=\"line\">    │  │      lpprint.h</span><br><span class=\"line\">    │  │      lptree.c</span><br><span class=\"line\">    │  │      lptree.h</span><br><span class=\"line\">    │  │      lptypes.h</span><br><span class=\"line\">    │  │      lpvm.c</span><br><span class=\"line\">    │  │      lpvm.h</span><br><span class=\"line\">    │  │      makefile</span><br><span class=\"line\">    │  │      re.html</span><br><span class=\"line\">    │  │      re.lua</span><br><span class=\"line\">    │  │      test.lua</span><br><span class=\"line\">    │  │      </span><br><span class=\"line\">    │  ├─lua  lua语言文件改</span><br><span class=\"line\">    │  │      </span><br><span class=\"line\">    │  └─lua-md5  lua md5加密库</span><br><span class=\"line\">    │          compat-5.2.c</span><br><span class=\"line\">    │          compat-5.2.h</span><br><span class=\"line\">    │          md5.c</span><br><span class=\"line\">    │          md5.h</span><br><span class=\"line\">    │          md5lib.c</span><br><span class=\"line\">    │          README</span><br><span class=\"line\">    │          </span><br><span class=\"line\">    ├─lualib</span><br><span class=\"line\">    │  │  loader.lua</span><br><span class=\"line\">    │  │  md5.lua</span><br><span class=\"line\">    │  │  skynet.lua</span><br><span class=\"line\">    │  │  sproto.lua</span><br><span class=\"line\">    │  │  sprotoloader.lua</span><br><span class=\"line\">    │  │  sprotoparser.lua</span><br><span class=\"line\">    │  │  </span><br><span class=\"line\">    │  ├─compat10</span><br><span class=\"line\">    │  │      cluster.lua</span><br><span class=\"line\">    │  │      crypt.lua</span><br><span class=\"line\">    │  │      datacenter.lua</span><br><span class=\"line\">    │  │      dns.lua</span><br><span class=\"line\">    │  │      memory.lua</span><br><span class=\"line\">    │  │      mongo.lua</span><br><span class=\"line\">    │  │      mqueue.lua</span><br><span class=\"line\">    │  │      multicast.lua</span><br><span class=\"line\">    │  │      mysql.lua</span><br><span class=\"line\">    │  │      netpack.lua</span><br><span class=\"line\">    │  │      profile.lua</span><br><span class=\"line\">    │  │      redis.lua</span><br><span class=\"line\">    │  │      sharedata.lua</span><br><span class=\"line\">    │  │      sharemap.lua</span><br><span class=\"line\">    │  │      snax.lua</span><br><span class=\"line\">    │  │      socket.lua</span><br><span class=\"line\">    │  │      socketchannel.lua</span><br><span class=\"line\">    │  │      socketdriver.lua</span><br><span class=\"line\">    │  │      stm.lua</span><br><span class=\"line\">    │  │      </span><br><span class=\"line\">    │  ├─http</span><br><span class=\"line\">    │  │      httpc.lua</span><br><span class=\"line\">    │  │      httpd.lua</span><br><span class=\"line\">    │  │      internal.lua</span><br><span class=\"line\">    │  │      sockethelper.lua</span><br><span class=\"line\">    │  │      tlshelper.lua</span><br><span class=\"line\">    │  │      url.lua</span><br><span class=\"line\">    │  │      websocket.lua</span><br><span class=\"line\">    │  │      </span><br><span class=\"line\">    │  ├─skynet</span><br><span class=\"line\">    │  │  │  cluster.lua</span><br><span class=\"line\">    │  │  │  coroutine.lua</span><br><span class=\"line\">    │  │  │  datacenter.lua</span><br><span class=\"line\">    │  │  │  debug.lua</span><br><span class=\"line\">    │  │  │  dns.lua</span><br><span class=\"line\">    │  │  │  harbor.lua</span><br><span class=\"line\">    │  │  │  inject.lua</span><br><span class=\"line\">    │  │  │  injectcode.lua</span><br><span class=\"line\">    │  │  │  manager.lua</span><br><span class=\"line\">    │  │  │  mqueue.lua</span><br><span class=\"line\">    │  │  │  multicast.lua</span><br><span class=\"line\">    │  │  │  queue.lua</span><br><span class=\"line\">    │  │  │  remotedebug.lua</span><br><span class=\"line\">    │  │  │  service.lua</span><br><span class=\"line\">    │  │  │  sharedata.lua</span><br><span class=\"line\">    │  │  │  sharemap.lua</span><br><span class=\"line\">    │  │  │  sharetable.lua</span><br><span class=\"line\">    │  │  │  snax.lua</span><br><span class=\"line\">    │  │  │  socket.lua</span><br><span class=\"line\">    │  │  │  socketchannel.lua</span><br><span class=\"line\">    │  │  │  </span><br><span class=\"line\">    │  │  ├─datasheet</span><br><span class=\"line\">    │  │  │      builder.lua</span><br><span class=\"line\">    │  │  │      dump.lua</span><br><span class=\"line\">    │  │  │      init.lua</span><br><span class=\"line\">    │  │  │      </span><br><span class=\"line\">    │  │  ├─db</span><br><span class=\"line\">    │  │  │  │  mongo.lua</span><br><span class=\"line\">    │  │  │  │  mysql.lua</span><br><span class=\"line\">    │  │  │  │  redis.lua</span><br><span class=\"line\">    │  │  │  │  </span><br><span class=\"line\">    │  │  │  └─redis</span><br><span class=\"line\">    │  │  │          cluster.lua</span><br><span class=\"line\">    │  │  │          crc16.lua</span><br><span class=\"line\">    │  │  │          </span><br><span class=\"line\">    │  │  └─sharedata</span><br><span class=\"line\">    │  │          corelib.lua</span><br><span class=\"line\">    │  │          </span><br><span class=\"line\">    │  └─snax</span><br><span class=\"line\">    │          gateserver.lua</span><br><span class=\"line\">    │          hotfix.lua</span><br><span class=\"line\">    │          interface.lua</span><br><span class=\"line\">    │          loginserver.lua</span><br><span class=\"line\">    │          msgserver.lua</span><br><span class=\"line\">    │          </span><br><span class=\"line\">    ├─lualib-src</span><br><span class=\"line\">    │  │  lsha1.c  SHA-1加密算法文件</span><br><span class=\"line\">    │  │  ltls.c</span><br><span class=\"line\">    │  │  lua-bson.c</span><br><span class=\"line\">    │  │  lua-clientsocket.c</span><br><span class=\"line\">    │  │  lua-cluster.c</span><br><span class=\"line\">    │  │  lua-crypt.c</span><br><span class=\"line\">    │  │  lua-datasheet.c</span><br><span class=\"line\">    │  │  lua-debugchannel.c</span><br><span class=\"line\">    │  │  lua-memory.c</span><br><span class=\"line\">    │  │  lua-mongo.c</span><br><span class=\"line\">    │  │  lua-multicast.c</span><br><span class=\"line\">    │  │  lua-netpack.c</span><br><span class=\"line\">    │  │  lua-seri.c</span><br><span class=\"line\">    │  │  lua-seri.h</span><br><span class=\"line\">    │  │  lua-sharedata.c</span><br><span class=\"line\">    │  │  lua-sharetable.c</span><br><span class=\"line\">    │  │  lua-skynet.c</span><br><span class=\"line\">    │  │  lua-socket.c</span><br><span class=\"line\">    │  │  lua-stm.c</span><br><span class=\"line\">    │  │  </span><br><span class=\"line\">    │  └─sproto</span><br><span class=\"line\">    │          lsproto.c  Sproto序列化库</span><br><span class=\"line\">    │          msvcint.h</span><br><span class=\"line\">    │          README</span><br><span class=\"line\">    │          README.md</span><br><span class=\"line\">    │          sproto.c</span><br><span class=\"line\">    │          sproto.h</span><br><span class=\"line\">    │          </span><br><span class=\"line\">    ├─service</span><br><span class=\"line\">    │      bootstrap.lua</span><br><span class=\"line\">    │      cdummy.lua</span><br><span class=\"line\">    │      clusteragent.lua</span><br><span class=\"line\">    │      clusterd.lua</span><br><span class=\"line\">    │      clusterproxy.lua</span><br><span class=\"line\">    │      clustersender.lua</span><br><span class=\"line\">    │      cmaster.lua</span><br><span class=\"line\">    │      cmemory.lua</span><br><span class=\"line\">    │      console.lua</span><br><span class=\"line\">    │      cslave.lua</span><br><span class=\"line\">    │      datacenterd.lua</span><br><span class=\"line\">    │      dbg.lua</span><br><span class=\"line\">    │      debug_agent.lua</span><br><span class=\"line\">    │      debug_console.lua</span><br><span class=\"line\">    │      gate.lua</span><br><span class=\"line\">    │      launcher.lua</span><br><span class=\"line\">    │      multicastd.lua</span><br><span class=\"line\">    │      service_cell.lua</span><br><span class=\"line\">    │      service_mgr.lua</span><br><span class=\"line\">    │      service_provider.lua</span><br><span class=\"line\">    │      sharedatad.lua</span><br><span class=\"line\">    │      snaxd.lua</span><br><span class=\"line\">    │      </span><br><span class=\"line\">    ├─service-src</span><br><span class=\"line\">    │      databuffer.h</span><br><span class=\"line\">    │      hashid.h</span><br><span class=\"line\">    │      service_gate.c</span><br><span class=\"line\">    │      service_harbor.c</span><br><span class=\"line\">    │      service_logger.c</span><br><span class=\"line\">    │      service_snlua.c</span><br><span class=\"line\">    │      </span><br><span class=\"line\">    ├─skynet-src</span><br><span class=\"line\">    │      atomic.h 原子性操作函数</span><br><span class=\"line\">    │      malloc_hook.c  malloc钩子</span><br><span class=\"line\">    │      rwlock.h 读写锁相关</span><br><span class=\"line\">    │      skynet_daemon.c  守护模式实现</span><br><span class=\"line\">    │      skynet_env.c  环境操作（对lua环境操作的封装）</span><br><span class=\"line\">    │      skynet_error.c  错误处理</span><br><span class=\"line\">    │      skynet_handle.c  句柄管理</span><br><span class=\"line\">    │      skynet_harbor.c  集群间的内部通讯节点港口</span><br><span class=\"line\">    │      skynet_log.c  log操作</span><br><span class=\"line\">    │      skynet_module.c  模块相关</span><br><span class=\"line\">    │      skynet_monitor.c  监视器实现</span><br><span class=\"line\">    │      skynet_mq.c  队列实现</span><br><span class=\"line\">    │      skynet_server.c  服务管理</span><br><span class=\"line\">    │      skynet_socket.c  socket(socket_server.c)相关skynet封装</span><br><span class=\"line\">    │      skynet_start.c  启动相关</span><br><span class=\"line\">    │      skynet_timer.c  定时器实现</span><br><span class=\"line\">    │      spinlock.h 自旋锁相关</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/144\">Me emborraché para olvidarte.. y ahora te veo doble.</a></p>\n","tags":["skynet"]},{"title":"skynet控制台管理","url":"/post/7f9f1e3d.html","content":"<p>skynet 自带了一个控制台服务，可以很方便获取和调试 skynet 运行数据，而且可以热更新代码，所以，弄明白skynet控制台管理可以让你更好地使用skynet，甚至改进这个控制台服务，以满足不同业务需求。</p>\n<a id=\"more\"></a>\n\n<p>这个服务默认不会启动，需要你手动启动它，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">skynet.newservice(&quot;debug_console&quot;, 8000)</span><br></pre></td></tr></table></figure>\n<p>设计原因，调试控制台只监听本地地址 127.0.0.1 ，如果需要远程使用，需要先登录到本机，然后再连接。</p>\n<p>使用时，通过 telnet 或 nc 登录调试控制台，启动后显示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br></pre></td></tr></table></figure>\n<p>表示连接成功。</p>\n<p>注：skynet控制台不能使用上下键回溯历史命令，退格键也不能使用（改用删除键）等等，这是由于 skynet 使用了自己的 IO 库，很难接入 libreadline （不能在 readline 的 hook 中 yield）。如果希望在控制台中使用 readline 的 history 等特性，可以自己使用 rlwrap 。</p>\n<p>这时，你可以输入调试指令，输入 help 可以列出目前支持的所有指令。（不同版本结果不同）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">help</span><br><span class=\"line\">clearcache      clear lua code cache</span><br><span class=\"line\">cmem    Show C memory info</span><br><span class=\"line\">debug   debug address : debug a lua service</span><br><span class=\"line\">exit    exit address : kill a lua service</span><br><span class=\"line\">gc      gc : force every lua service do garbage collect</span><br><span class=\"line\">help    This help message</span><br><span class=\"line\">info    Info address : get service infomation</span><br><span class=\"line\">inject  inject address luascript.lua</span><br><span class=\"line\">kill    kill address : kill service</span><br><span class=\"line\">list    List all the service</span><br><span class=\"line\">logoff  logoff address</span><br><span class=\"line\">logon   logon address</span><br><span class=\"line\">mem     mem : show memory status</span><br><span class=\"line\">service List unique service</span><br><span class=\"line\">signal  signal address sig</span><br><span class=\"line\">snax    lanuch a new snax service</span><br><span class=\"line\">start   lanuch a new lua service</span><br><span class=\"line\">stat    Dump all stats</span><br><span class=\"line\">task    task address : show service task detail</span><br></pre></td></tr></table></figure>\n<p>命令的一般格式是 命令 地址 ，有些命令不带地址，会针对所有的服务。当输入地址时，可以使用 :01000001 这样的格式指代一个服务地址：由冒号开头的 8 位 16 进制数字，也可以省略前面两个数字的 harbor id 以及接下来的连续 0 ，比如 :01000001 可以简写为 1 。所有活动的服务可以输入 list 列出。</p>\n<p>常用的通用指令：<br>list 列出所有服务，以及服务的启动参数。<br>gc 对所有 lua 服务执行gc，并列出gc后所有服务的内存情况。<br>mem 列出所有 lua 服务的内存占用情况。（注：只获取 lua 服务的 lua vm 内存占用情况，如果需要 C 模块中内存使用情况，使用cmem。）<br>stat 列出所有 lua 服务的消息队列长度，以及被挂起的请求（协程）数量。<br>service 列出所有的唯一 lua 服务。<br>注意，由于这些指令是逐个向每个服务发送消息并等待回应，所以当某个 lua 服务过载时，可能需要等待很长时间才有返回。</p>\n<p>针对单个 lua 服务的指令：<br>exit address 退出指定 lua 服务<br>kill address 强制中止指定 lua 服务。<br>info address 让指定 lua 服务输出自己的内部信息（数据通过回调服务内 skynet.info_func 生成）<br>signal address sig 向服务发送一个信号，sig 默认为 0 。当一个服务陷入死循环时，默认信号会打断正在执行的 lua 字节码，并抛出 error 显示调用栈。这是针对 endless loop 的 log 的有效调试方法。（注：这里的信号并非系统信号。）<br>task address 显示一个服务中所有被挂起的请求的调用栈。<br>debug address 针对一个 lua 服务启动内置的单步调试器。<br>logon/logoff address 记录一个服务所有的输入消息（source, type, session, data, size）到文件。（生成文件的路径地址取配置 logpath） 。<br>inject address script 将 script 对应的脚本插入到指定服务中运行（通常可用于热更新补丁）。</p>\n<p>这里重点说下 info address 和 inject address script，这两个命令很重要。</p>\n<h2 id=\"获取服务内部数据-info-address\"><a href=\"#获取服务内部数据-info-address\" class=\"headerlink\" title=\"获取服务内部数据 - info address\"></a>获取服务内部数据 - info address</h2><p>前面提到，这个命令让指定 lua 服务输出自己的内部信息，数据通过回调服务内 skynet.info_func 生成。<br>下面以 example/simpledb.lua做说明，这是个典型的skynet服务。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> skynet = <span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet.manager&quot;</span>    <span class=\"comment\">-- import skynet.register</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> db = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> command = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">command.GET</span><span class=\"params\">(key)</span></span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> db[key]</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">command.SET</span><span class=\"params\">(key, value)</span></span></span><br><span class=\"line\">  <span class=\"keyword\">local</span> last = db[key]</span><br><span class=\"line\">  db[key] = value</span><br><span class=\"line\">  <span class=\"keyword\">return</span> last</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 新增的代码 -- start</span></span><br><span class=\"line\">skynet.info_func(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello mycwq!&quot;</span> <span class=\"keyword\">end</span>)</span><br><span class=\"line\"><span class=\"comment\">-- 新增的代码 -- end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">skynet.start(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">  skynet.dispatch(<span class=\"string\">&quot;lua&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(session, address, cmd, ...)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> f = command[<span class=\"built_in\">string</span>.<span class=\"built_in\">upper</span>(cmd)]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f <span class=\"keyword\">then</span></span><br><span class=\"line\">      skynet.ret(skynet.pack(f(...)))</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"built_in\">error</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;Unknown command %s&quot;</span>, <span class=\"built_in\">tostring</span>(cmd)))</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span>)</span><br><span class=\"line\">  skynet.register <span class=\"string\">&quot;SIMPLEDB&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<p>启动example例子，连接控制台</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:00000004       snlua cmaster</span><br><span class=\"line\">:00000005       snlua cslave</span><br><span class=\"line\">:00000007       snlua datacenterd</span><br><span class=\"line\">:00000008       snlua service_mgr</span><br><span class=\"line\">:0000000a       snlua protoloader</span><br><span class=\"line\">:0000000b       snlua console</span><br><span class=\"line\">:0000000c       snlua debug_console 8000</span><br><span class=\"line\">:0000000d       snlua simpledb</span><br><span class=\"line\">:0000000e       snlua watchdog</span><br><span class=\"line\">:0000000f       snlua gate</span><br><span class=\"line\">OK</span><br><span class=\"line\">info :0000000d</span><br><span class=\"line\">hello mycwq!</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码热更新-inject-address-script\"><a href=\"#代码热更新-inject-address-script\" class=\"headerlink\" title=\"代码热更新 - inject address script\"></a>代码热更新 - inject address script</h2><p>前面提到，这个命令将 script 对应的脚本插入到指定服务中运行<br>下面写个简单的inject例子，保存为 example/inject_simpledb.lua</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> _P <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span> <span class=\"string\">&quot;inject error!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> command = _P.lua.command</span><br><span class=\"line\">command.TEST = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">return</span> <span class=\"string\">&quot;TEST&quot;</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;inject ok!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>启动example例子，连接控制台</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:00000004       snlua cmaster</span><br><span class=\"line\">:00000005       snlua cslave</span><br><span class=\"line\">:00000007       snlua datacenterd</span><br><span class=\"line\">:00000008       snlua service_mgr</span><br><span class=\"line\">:0000000a       snlua protoloader</span><br><span class=\"line\">:0000000b       snlua console</span><br><span class=\"line\">:0000000c       snlua debug_console 8000</span><br><span class=\"line\">:0000000d       snlua simpledb</span><br><span class=\"line\">:0000000e       snlua watchdog</span><br><span class=\"line\">:0000000f       snlua gate</span><br><span class=\"line\">OK</span><br><span class=\"line\">inject :0000000d example/inject_simpledb.lua</span><br><span class=\"line\">inject ok!</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-rlwrap-强化-skynet-控制台\"><a href=\"#使用-rlwrap-强化-skynet-控制台\" class=\"headerlink\" title=\"使用 rlwrap 强化 skynet 控制台\"></a>使用 rlwrap 强化 skynet 控制台</h2><p>前面提到了skynet控制台不能使用上下键回溯历史命令，退格键也不能使用等，为了弥补这个不足，可以使用 rlwrap<br>这里以 centos做说明， rlwrap依赖 readline，系统必须装有 readline ，在现有很多linux系统，readline都可自动化安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum -y install readline-devel  </span><br></pre></td></tr></table></figure>\n<p>rlwrap则需要手动安装，如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zxf rlwrap-0.37.tar.gz </span><br><span class=\"line\">cd rlwrap-0.37</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>以后，skynet控制台的连接方式改成这样，就可以回溯命令了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rlwrap nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:01000004       snlua cmaster</span><br><span class=\"line\">:01000005       snlua cslave</span><br><span class=\"line\">:01000007       snlua datacenterd</span><br><span class=\"line\">:01000008       snlua service_mgr</span><br><span class=\"line\">:0100000a       snlua protoloader</span><br><span class=\"line\">:0100000b       snlua console</span><br><span class=\"line\">:0100000c       snlua debug_console 8000</span><br><span class=\"line\">:0100000d       snlua simpledb</span><br><span class=\"line\">:0100000e       snlua watchdog</span><br><span class=\"line\">:0100000f       snlua gate</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>最后，这里列举 rlwrap常用的快捷键：<br>Ctrl+L 清屏，实际是将当前行置顶<br>Ctrl+P 上一条命令<br>Ctrl+N 下一条命令<br>Ctrl+U 从光标处删除到行首<br>Ctrl+W 向前删除一个单词<br>Ctrl+B 光标向前移动一个位置<br>Ctrl+T 光标处字符与前一个字符交换位置<br>Ctrl+Z 后台运行，使用fg调出<br>Ctrl+H 相当于删除键<br>Ctrl+J 相当于回车键<br>Ctrl+O 相当于回车键<br>Ctrl+M 相当于回车键</p>\n<p>追踪业务逻辑<br>skynet.trace() </p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>目前在 skynet 的内存分配 API 预埋了调试接口。可以通过在 make 时加上预定义宏 MEMORY_CHECK 打开。<br>例如，在 linux 下，可以用 make linux SKYNET_DEFINES=-DMEMORY_CHECK 打开。<br>btw，还有一些同学用 C 编写 lua 扩展模块没有经验，导致 lua 堆栈溢出，最终致使程序崩溃。推荐在编译 lua 的时候加上宏定义：LUA_USE_APICHECK 。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/75\">Se está muriendo gente que antes no se moría.</a></p>\n","tags":["skynet"]},{"title":"skynet服务","url":"/post/41698708.html","content":"<p>首先，要了解 skynet 内的一个非常重要的概念 ———『服务』。所谓的服务，本质就是一个接收消息然后处理消息的过程，它跟我们日常生活中所说的服务（例如：外卖服务、快递服务等等）是一样的，它不是一个真实可见的物体，而是一个抽象的逻辑过程，它需要一个执行者来执行并完成它。这其实就是<a href=\"https://github.com/losophy/losophy.github.io/issues/78\">skynet实现的Actor</a>模型。</p>\n<a id=\"more\"></a>\n\n<p>了解了“服务”后，现在，我们把上面的银行场景套用在 skynet 框架上，可以做出下面的转换关系：</p>\n<blockquote>\n<p>服务 = 银行提供的业务（个人业务、对公业务…）<br>工作线程 = 办事窗口（负责处理客户业务需求并完成需求）<br>CPU 核心 = 银行柜员（需要在办事窗口上工作）<br>网络线程 = 大堂接待（也相当于一个办事窗口）<br>定时器线程 = 银行的排队叫号系统</p>\n</blockquote>\n<p>有了这一层转换后，我们再转入到 skynet 的代码框架中，就清晰很多了。比如，对于工作线程的抢占执行，就类似银行柜员工作人员不足，导致有一些办事窗口没人工作，从而导致银行等待的人增多；在办理某一个业务时，可能会涉及到其他业务，就需要多个窗口沟通合作，这就类似 skynet 的服务间消息传递。</p>\n<h2 id=\"服务的本质\"><a href=\"#服务的本质\" class=\"headerlink\" title=\"服务的本质\"></a>服务的本质</h2><p>每个skynet服务都是一个lua state，也就是一个lua虚拟机实例。而且，每个服务都是隔离的，各自使用自己独立的内存空间，服务之间通过发消息来完成数据交换。</p>\n<p>lua state本身没有多线程支持的，为了实现cpu的摊分，skynet实现上在一个线程运行多个lua state实例。而同一时间下，调度线程只运行一个服务实例。为了提高系统的并发性，skynet会启动一定数量的调度线程。同时，为了提高服务的并发性，就利用lua协程并发处理。</p>\n<p>所以，skynet的并发性有3点：<br>1、多个调度线程并发<br>2、lua协程并发处理<br>3、服务调度的切换</p>\n<p>skynet服务的设计基于Actor模型。有两个特点：</p>\n<ol>\n<li>每个Actor依次处理收到的消息</li>\n<li>不同的Actor可同时处理各自的消息<br>实现上，cpu会按照一定规则分摊给每个Actor，每个Actor不会独占cpu，在处理一定数量消息后主动让出cpu，给其他进程处理消息。</li>\n</ol>\n<p>skynet刚开始是单进程多线程的，它是由一个一个的服务组成的。在skynet上做开发，实际上就是在写服务。服务与服务之间通过消息队列进行通信。<br>一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。</p>\n<h2 id=\"服务是怎么调用的\"><a href=\"#服务是怎么调用的\" class=\"headerlink\" title=\"服务是怎么调用的\"></a>服务是怎么调用的</h2><p>调用\\lualib\\skynet.lua 文件内的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">simpledb.lua： skynet.register “SIMPLEDB” 向skynet里注册一个服务 </span><br><span class=\"line\">agent.lua： skynet.call(“SIMPLEDB”, “text”, text) 调用相应的服务 </span><br><span class=\"line\">main.lua： skynet.newservice(“simpledb”) 启动一个服务</span><br></pre></td></tr></table></figure>\n<p>以下是几个写服务时经常要用到的函数</p>\n<blockquote>\n<p>newservice(name, …) 启动一个名为 name 的新服务。<br>uniqueservice(name, …) 启动一个唯一服务，如果服务该服务已经启动，则返回已启动的服务地址。<br>queryservice(name) 查询一个由 uniqueservice 启动的唯一服务的地址，若该服务尚未启动则等待。<br>localname(name) 返回同一进程内，用 register 注册的具名服务的地址。</p>\n</blockquote>\n<blockquote>\n<p>newservice可以在一个进程里启动多个服务，这适用于无状态的服务。<br>uniqueservice则是类似于设计模式中的单件(singleton)，这适用于需要唯一性的服务。举个例子，比如写日志，只想写一份。或者是全局共享的数据。</p>\n</blockquote>\n<h2 id=\"服务的实现\"><a href=\"#服务的实现\" class=\"headerlink\" title=\"服务的实现\"></a>服务的实现</h2><p>接下来，我会分成服务的创建、消息的处理以及服务的回收三个部分来深入服务模块。</p>\n<h3 id=\"服务创建流程\"><a href=\"#服务创建流程\" class=\"headerlink\" title=\"服务创建流程\"></a>服务创建流程</h3><p>服务上下文与actor的关系密切，具体看<a href=\"https://github.com/losophy/losophy.github.io/issues/78\">skynet与actor</a>文中的Actor参与者部分。</p>\n<h4 id=\"创建上下文\"><a href=\"#创建上下文\" class=\"headerlink\" title=\"创建上下文\"></a>创建上下文</h4><p>接下来看下服务上下文的创建和初始化流程，下图是一个服务上下文的详细创建过程：<br><img src=\"https://user-images.githubusercontent.com/11263320/121668104-89001800-cadd-11eb-9f52-bf47bcebb1b3.jpg\" alt=\"a4knd-2myjp\"></p>\n<p>整个流程都封装在 skynet_context_new 这个函数中，函数实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">skynet_context_new</span>(<span class=\"title\">const</span> <span class=\"title\">char</span> * <span class=\"title\">name</span>, <span class=\"title\">const</span> <span class=\"title\">char</span> *<span class=\"title\">param</span>) &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_module</span> * <span class=\"title\">mod</span> =</span> skynet_module_query(name);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mod == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *inst = skynet_module_instance_create(mod);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inst == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * <span class=\"title\">ctx</span> =</span> skynet_malloc(<span class=\"keyword\">sizeof</span>(*ctx));</span><br><span class=\"line\">\tCHECKCALLING_INIT(ctx)</span><br><span class=\"line\"></span><br><span class=\"line\">\tctx-&gt;mod = mod;</span><br><span class=\"line\">\tctx-&gt;instance = inst;</span><br><span class=\"line\">\tctx-&gt;ref = <span class=\"number\">2</span>; <span class=\"comment\">// 思考为什么是 2</span></span><br><span class=\"line\">\tctx-&gt;cb = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tctx-&gt;cb_ud = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tctx-&gt;session_id = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tctx-&gt;logfile = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tctx-&gt;init = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tctx-&gt;endless = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tctx-&gt;cpu_cost = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tctx-&gt;cpu_start = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tctx-&gt;message_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tctx-&gt;profile = G_NODE.profile;</span><br><span class=\"line\">\t<span class=\"comment\">// Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle</span></span><br><span class=\"line\">\tctx-&gt;handle = <span class=\"number\">0</span>;\t</span><br><span class=\"line\">\tctx-&gt;handle = skynet_handle_register(ctx);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">message_queue</span> * <span class=\"title\">queue</span> =</span> ctx-&gt;<span class=\"built_in\">queue</span> = skynet_mq_create(ctx-&gt;handle);</span><br><span class=\"line\">\t<span class=\"comment\">// init function maybe use ctx-&gt;handle, so it must init at last</span></span><br><span class=\"line\">\tcontext_inc();</span><br><span class=\"line\"></span><br><span class=\"line\">\tCHECKCALLING_BEGIN(ctx)</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);</span><br><span class=\"line\">\tCHECKCALLING_END(ctx)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化成功</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * <span class=\"title\">ret</span> =</span> skynet_context_release(ctx);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">\t\t\tctx-&gt;init = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tskynet_globalmq_push(<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">\t\t\tskynet_error(ret, <span class=\"string\">&quot;LAUNCH %s %s&quot;</span>, name, param ? param : <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化失败，回收 ctx</span></span><br><span class=\"line\">\t\tskynet_error(ctx, <span class=\"string\">&quot;FAILED launch %s&quot;</span>, name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> handle = ctx-&gt;handle;</span><br><span class=\"line\">\t\tskynet_context_release(ctx);</span><br><span class=\"line\">\t\tskynet_handle_retire(handle);</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">drop_t</span> <span class=\"title\">d</span> =</span> &#123; handle &#125;;</span><br><span class=\"line\">\t\tskynet_mq_release(<span class=\"built_in\">queue</span>, drop_message, &amp;d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此函数一共有三个地方调用，其中有两处是在 skynet 启动过程中（skynet_start）调用，这两个函数调用会创建两个重要的服务：</p>\n<blockquote>\n<p>logger 服务，用来输出 skynet 的日志信息到文件（由配置字段 logger 指定）或标准输出（stdout），当然，我们可以重载 skynet 自带的 logger 服务，修改配置字段 logservice 即可。<br>bootstrap 服务，是一个 lua 服务，它负责引导基础服务，例如 launcher 服务等，它的作用类似于电脑开机时的引导程序一样。<br>前面两处调用都是用来初始化 skynet 进程所需的核心服务，而第三处调用是为了支持在已经启动的服务实例中能方便的启动其他服务，skynet 底层进一步对上面的流程进行封装，然后把封装好的接口暴露个上层使用，类似于 linux 内核暴露出的系统调用。<br>封装的服务启动接口原型如下：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *</span><br><span class=\"line\">cmd_launch(struct skynet_context * context, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * param);</span><br></pre></td></tr></table></figure>\n<p>这个接口接收一个 const char *param 的参数，它用来控制skynet 应该启动一个什么服务，以及服务启动时的参数，服务类型名称和服务参数用空格分隔。例如，传递参数是 “snlua launcher”，则表示启动一个 launcher 的 lua 服务（这个服务专门负责 lua 层的服务启动，是一个非常重要的服务）。</p>\n<p>下图是 launcher 服务创建一个新服务的调用图：<br><img src=\"https://user-images.githubusercontent.com/11263320/121674426-a08ecf00-cae4-11eb-9564-a1f96020ec41.jpg\" alt=\"awgiu-8r86o\"><br>创建好的 context 会被注册到服务仓库 handle_storage *H 中，如果注册成功，会给 context 分配一个 handle (即服务上下文的id，类似与文件描述符id)，handle 是一个无符号 32 位整型，高 8 位用来表示 harbor_id，低 24 位则表示 context 的索引号 index，即：handle=(harbor_id&lt;&lt;24)|index。需要注意的是，这两部分值都需要大于 0，即：harbor_id&gt;0 &amp;&amp; index&gt;01；然后创建服务的消息队列 queue，至此，服务已经创建完成，接下来便是服务的初始化过程。<br>服务初始化过程，其实是一个服务差异化的过程，每个创建好的服务实例通过传入参数的不同，会有不同的设置，这一部分会在接下来的汽车工厂的例子有更多详细的讲解。 然后设置服务的回调，最后把服务的消息队列 push 到全局消息队列中，以被工作线程消费、执行。</p>\n<h4 id=\"服务模板\"><a href=\"#服务模板\" class=\"headerlink\" title=\"服务模板\"></a>服务模板</h4><p>所谓的服务模板，有点像一个工厂类，一个服务模板可以创建和初始化一个或多个服务实例，同时在创建服务实例时传递一些参数，对其进行一些定制操作。<br>套用现实生活场景中，一个汽车工厂可以生产很多辆汽车，每一辆生产出来的汽车就相当于一个服务实例，当然，工厂可以在生产汽车时，为了满足客户需求，提供一些可控的定制化服务，例如：车身颜色定制、配件增加等，而其中用来生产汽车的流水线就是一个服务模板。<br>在 skynet 中，这些模板是以动态库的形式存在，这些服务模板动态库编译后存放在 cservice 目录，目前，skynet 已有四个服务模板，它们分别是：</p>\n<blockquote>\n<p>logger，日志服务模板，在上面已经有提到；<br>gate，网关服务模板，最新版的 skynet 已经有另外一套 lua gate 实现方案；<br>harbor，提供 master/slave 模式的集群方案；<br>snlua，所有的 lua 服务都由它负责。</p>\n</blockquote>\n<p>当然，所有的服务模板都需要遵守一些约定，它们需要提供以下 4 个 api:</p>\n<blockquote>\n<p>create，必须，此 api 用来创建对应的服务实例；<br>init，必须，此 api 用来对服务实例进行初始化，同时还会设置 context 的回调实例和回调函数；<br>release，必须，用来释放服务实例，做一些清理工作；<br>signal，可选，用来跳出 lua 服务的死循环2。</p>\n</blockquote>\n<p>以上的这些接口定义可以在 skynet_module.h 头文件中找到。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// api 原型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span> * (*skynet_dl_create)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*skynet_dl_init)</span><span class=\"params\">(<span class=\"keyword\">void</span> * inst, struct skynet_context *, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * parm)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*skynet_dl_release)</span><span class=\"params\">(<span class=\"keyword\">void</span> * inst)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*skynet_dl_signal)</span><span class=\"params\">(<span class=\"keyword\">void</span> * inst, <span class=\"keyword\">int</span> signal)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务模板结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_module</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> * <span class=\"keyword\">module</span>;</span><br><span class=\"line\">\tskynet_dl_create create;</span><br><span class=\"line\">\tskynet_dl_init init;</span><br><span class=\"line\">\tskynet_dl_release release;</span><br><span class=\"line\">\tskynet_dl_signal signal;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h4><p>一个服务实例一定有一个服务消息队列（很多人称之为次级消息队列）与之对应，它的实现方式是一个环形队列。<br><img src=\"https://user-images.githubusercontent.com/11263320/121778933-df4b8480-cbcb-11eb-9df5-d67d8bd5a313.JPG\" alt=\"65436345\"><br>消息队列的容量默认是 64，若容量不足则以 2 倍的方式进行增长，另外，当消息队列中堆积的消息过载，则每次达到 1024 的整数倍时，由监控线程发出警报。</p>\n<h3 id=\"消息处理流程\"><a href=\"#消息处理流程\" class=\"headerlink\" title=\"消息处理流程\"></a>消息处理流程</h3><p>注意，先停一停，从 skynet 的代码世界中跳出来，先思考一个现实生活中快递站点的场景：<br>有一个快递配送点，每天会把要派送的包裹分成多堆存放在不同仓库或角落，每一堆表示这个站点配送范围内的一个片区，且每一堆包裹由一个快递小哥负责用三轮车进行配送，假如你是这个配送站的负责人，你当然是希望快递尽可能快速、合理的被配送，那应该采用什么方案呢？</p>\n<p>最直接的办法是让一个快递员固定负责一个片区，但是如果负责的片区过多，需要的快递员就会增多，这样人力成本就会上升。改进的办法是让快递员不固定在一个片区内，而是在送完一个片区的包裹后，如果其他片区还没有人在负责配送，则动态分配到其他片区，不过这里还是会存在一个问题，如果某个快递员在派送其中一个片区的快递时，又有新的包裹添加进来，这时问题产生了：这个片区一直在进行包裹的配送，而其他片区因为快递员不足导致包裹滞留（即“线程饿死”）。</p>\n<p>我们对上面的方案再次进行改进：每个片区按照先后顺序排列，每个快递员按照顺序取出片区队列中的第一个片区并派送固定数量的包裹，配送完一批包裹后，如果这个片区还有未配送的包裹，就把这个片区重新插入到片区队列尾部，以此循环配送，每次的配送数量可以按照一定的规则来决定，例如三轮车大一点、动力好一点就配送多一些包裹。以这样的方式进行配送，既能保证每个片区的包裹都能得到派送，不至于长时间滞留，又能节约人力成本。</p>\n<p>好，现在再回到 skynet 中的消息处理流程，它其实就是采用了类似快递配送的最后的改良方案，我对其进行一次转换，就一目了然。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">片区队列 &#x3D; 全局消息队列</span><br><span class=\"line\">片区仓库 &#x3D; 服务消息队列</span><br><span class=\"line\">配送数量 &#x3D; 一次派发的消息数量</span><br><span class=\"line\">分配派送流程 &#x3D; 工作线程</span><br></pre></td></tr></table></figure>\n<p>要注意的是：消息并不存放在全局消息队列中，类似于包裹是被堆积在不同的片区仓库内，只是这个片区被插入到片区队列内，真正的消息是存放在服务消息队列（或称次级消息队列）中；另外，关于派发消息数量，skynet 用一套权重 weight 规则来计算，后面会详细讲解</p>\n<h4 id=\"工作线程\"><a href=\"#工作线程\" class=\"headerlink\" title=\"工作线程\"></a>工作线程</h4><p>skynet 有四类线程，其中只有工作线程创建多个，它由配置中的 thread 字段控制，如果不配置默认为 8。此线程负责的逻辑非常简单，就是从全局消息队列中 pop 出一个服务消息队列，然后派发一定数量的消息。它的大致流程如下图所示：<br><img src=\"https://user-images.githubusercontent.com/11263320/121795692-c67fb500-cc45-11eb-8eec-923835c58f97.jpg\" alt=\"aqj54-9j2is\"><br>具体的代码实现在函数 skynet_context_message_dispatch 中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">message_queue</span> * </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">skynet_context_message_dispatch</span>(<span class=\"keyword\">struct</span> <span class=\"title\">skynet_monitor</span> *<span class=\"title\">sm</span>, <span class=\"keyword\">struct</span> <span class=\"title\">message_queue</span> *<span class=\"title\">q</span>, <span class=\"title\">int</span> <span class=\"title\">weight</span>) &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (q == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\tq = skynet_globalmq_pop();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (q==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> handle = skynet_mq_handle(q);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * <span class=\"title\">ctx</span> =</span> skynet_handle_grab(handle);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ctx == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">drop_t</span> <span class=\"title\">d</span> =</span> &#123; handle &#125;;</span><br><span class=\"line\">\t\tskynet_mq_release(q, drop_message, &amp;d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> skynet_globalmq_pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,n=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_message</span> <span class=\"title\">msg</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>;i&lt;n;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;</span><br><span class=\"line\">\t\t\tskynet_context_release(ctx);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> skynet_globalmq_pop();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i==<span class=\"number\">0</span> &amp;&amp; weight &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tn = skynet_mq_length(q);</span><br><span class=\"line\">\t\t\tn &gt;&gt;= weight;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> overload = skynet_mq_overload(q);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (overload) &#123;</span><br><span class=\"line\">\t\t\tskynet_error(ctx, <span class=\"string\">&quot;May overload, message queue length = %d&quot;</span>, overload);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tskynet_monitor_trigger(sm, msg.source , handle);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ctx-&gt;cb == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">\t\t\tskynet_free(msg.data);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tdispatch_message(ctx, &amp;msg);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tskynet_monitor_trigger(sm, <span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tassert(q == ctx-&gt;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">message_queue</span> *<span class=\"title\">nq</span> =</span> skynet_globalmq_pop();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nq) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// If global mq is not empty , push q back, and return next queue (nq)</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Else (global mq is empty or block, don&#x27;t push q back, and return q again (for next dispatch)</span></span><br><span class=\"line\">\t\tskynet_globalmq_push(q);</span><br><span class=\"line\">\t\tq = nq;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\tskynet_context_release(ctx);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然整体逻辑较为简单，不过在其实现过程中还是有几个点可以拿出来研究一番。<br>动态唤醒<br>首先要知道一个原则：全局消息队列内是存放的诸多不为空的服务消息队列，也就是说没有消息的服务是不会把它的消息队列 push 进全局队列中的3（除了服务创建时的第一次 push）。那我们思考一个问题：因为工作线程数量有限，而活跃的服务（有消息且在全局队列中）数量是不定的，当它们的比例关系 m(工作线程):n(活跃服务) 小于等于 1 时，表示每个线程都处于工作中；而如果这个比例大于 1 时，则表示工作线程有空余，套用上面快递员的例子，就是存在一些快递员没有包裹需要派送，处于休息状态。<br>此时，如果不对这些空闲线程做挂起操作，就会浪费 CPU 资源，进而浪费电(→_→)。skynet 采取的策略是在全局消息队列为空时，使用条件变量（pthread_cond_t）来挂起工作线程，而对于线程的唤醒，一共有两处地方：</p>\n<ul>\n<li>网络线程唤醒，采用“懒惰唤醒”，即只有在所有工作线程都挂起时，才会唤醒一个。举个栗子，如果有 8 个工作线程，其中 7 个都处于挂起状态，那么在网络线程收到网络消息后，也不会进行唤醒，除非 8 个工作线程都被挂起；</li>\n<li>定时器线程唤醒，采用“贪婪唤醒”，即只要有工作线程处于挂起状态，就会唤醒一次；另外在定时器线程结束后，还会广播唤醒所有挂起的工作线程；</li>\n</ul>\n<p>均衡派发<br>均衡派发是指在处理多个服务的消息队列时，尽量做到“雨露均沾”，以此来解决上面提到的“线程饿死”的情况。skynet 会给每个工作线程一个权重值 weight，根据这个权重值计算出工作线程每次应该处理的消息数量 n，计算方式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> weight &gt; <span class=\"number\">0</span> then</span><br><span class=\"line\">    n = 消息队列当前容量 &gt;&gt; weight</span><br><span class=\"line\">elseif weight == <span class=\"number\">0</span> then</span><br><span class=\"line\">    n = 消息队列当前容量</span><br><span class=\"line\">elseif weight &lt; <span class=\"number\">0</span> then</span><br><span class=\"line\">    n = <span class=\"number\">1</span></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>也就是说，当 weight&lt;0时，每次处理一个消息，当 weight==0 时，每次会处理完“当前队列”中的所有消息，而当 weight&gt;0 时，每次处理“当前队列”容量的 1/(2^weight)，权重值越大，每次处理的消息越少。注意：这里所说的“当前队列”容量是指在处理第一个消息时，该时刻服务消息队列的消息容量，本质上是一个“过去时”的值，这也是为什么“当前队列”要加引号的原因。</p>\n<h4 id=\"插入消息\"><a href=\"#插入消息\" class=\"headerlink\" title=\"插入消息\"></a>插入消息</h4><p>在 skynet 中，服务之间传递的消息都被封装成统一的格式，不论是网络消息还是定时器消息，消息结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_message</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> source;<span class=\"comment\">//表示发出这个消息的服务 handle id，如果一个服务收到了一个 source=0 的消息，则表示这个消息是不是从一个服务实例中发出的，例如定时器消息和网络消息，或者发出这个消息的服务实例已经被销毁；</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> session;<span class=\"comment\">//表示这个消息的序列号，类似 TCP 数据报(segment)的 SEQ，需要注意的是每一个请求包才需要生成一个新的 session，而返回包是不需要生成新的 session，只需要把请求包的 session 在返回时赋值给返回包即可，当然，需要标识这个包是一个返回包，接下来就会说到消息包的类型，一个消息包session的生成规则会涉及到 ctx 的 session_id 字段</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> * data;它是一个指针，指向了消息携带数据真正的内存地址，可以为空指针，即没有消息数据，对于一个从 lua 服务中传递过来的消息数据（在 lua 中使用了 c.send），可以是 LUA_TSTRING 和 LUA_TLIGHTUSERDATA，前者必须做一次内存拷贝（原因请查阅 lua_tolstring 的说明文档），而后者则不需要。</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> sz;<span class=\"comment\">//sz 字面意思是消息数据的长度，但其实该字段除了包含了数据的长度，还携带了另外一个信息，就是这个消息的类型，消息类型的定义可以在 skynet.h 头文件中找到，它用 sz 的高 8 位（1 byte）来表示，例如在 64 位系统下 sz = 消息类型&lt;&lt;56 | 数据长度。</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面已经对 skynet 的消息结构有了一个全方位的了解，对于如何把一个消息插入到目的服务的消息队列中，已经没有太多需要深入的细节。可能唯一需要注意的是，当一个消息插入到服务的消息队列中时，如果这个服务处于“非活跃”状态（即没有加入到全局消息队列），那么会将该服务重新触发为“活跃”状态，实现细节在 skynet_mq_push。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> </span><br><span class=\"line\">skynet_mq_push(struct message_queue *q, struct skynet_message *message) &#123;</span><br><span class=\"line\">\tassert(message);</span><br><span class=\"line\">\tSPIN_LOCK(q)</span><br><span class=\"line\"></span><br><span class=\"line\">\tq-&gt;<span class=\"built_in\">queue</span>[q-&gt;tail] = *message;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (++ q-&gt;tail &gt;= q-&gt;cap) &#123;</span><br><span class=\"line\">\t\tq-&gt;tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (q-&gt;head == q-&gt;tail) &#123;</span><br><span class=\"line\">\t\texpand_queue(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (q-&gt;in_global == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tq-&gt;in_global = MQ_IN_GLOBAL;</span><br><span class=\"line\">\t\tskynet_globalmq_push(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tSPIN_UNLOCK(q)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息消费\"><a href=\"#消息消费\" class=\"headerlink\" title=\"消息消费\"></a>消息消费</h4><p>消息处理的过程已经在前面讲解的差不多了，其过程也较为简单，即服务通过注册的回调函数来处理收到的消息，回调函数（skynet_cb）的定义可以在 skynet.h 中找到（在前面也已经提到），它接收 7 个参数：<br>context，表示处理该消息的服务上下文；<br>ud，表示真正处理该消息的服务实体指针（不一定是服务实例，也可以是服务实例内的其他元素，例如 snlua 服务实例的 lua 虚拟机指针）；<br>type，消息的类型（上文已提到）；<br>session，消息的序列号；<br>source，发生消息的源服务 handle id；<br>msg，消息数据的指针；<br>sz，消息数据的长度；<br>关于消息处理的一个原则是：一个消息的数据必须由最后处理该消息的服务进行回收处理。这是什么意思呢？下面通过一个例子来解释这条原则。<br>假如你的朋友小明给你送一盒橘子，你会有两种方式收到这一盒橘子并吃掉它们：</p>\n<ul>\n<li>小明直接亲自送到你手上</li>\n<li>小明用快递邮寄，通过快递员送到你的手上</li>\n</ul>\n<p>不管通过哪一种方式，最终你会收到一盒橘子，然后吃掉它们，那吃完后剩下的橘子皮肯定是由你自己负责清扫，不可能让朋友小明或者快递员来给你处理（除非你想被打），在这一个流程中，你就是最后处理消息的人，你就需要负责最后的数据回收，快递员虽然也处理过这条消息，但是他是不能吃掉盒子内的橘子（即消息包中携带的数据）。<br>理解了上面的例子后，现在回头看看 skynet 的消息处理流程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">dispatch_message(struct skynet_context *ctx, struct skynet_message *msg) &#123;</span><br><span class=\"line\">\tassert(ctx-&gt;init);</span><br><span class=\"line\">\tCHECKCALLING_BEGIN(ctx)</span><br><span class=\"line\">\tpthread_setspecific(G_NODE.handle_key, (<span class=\"keyword\">void</span> *)(<span class=\"keyword\">uintptr_t</span>)(ctx-&gt;handle));</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> type = msg-&gt;sz &gt;&gt; MESSAGE_TYPE_SHIFT;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> sz = msg-&gt;sz &amp; MESSAGE_TYPE_MASK;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ctx-&gt;logfile) &#123;</span><br><span class=\"line\">\t\tskynet_log_output(ctx-&gt;logfile, msg-&gt;source, type, msg-&gt;session, msg-&gt;data, sz);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t++ctx-&gt;message_count;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\treserve_msg : 回调函数的返回值</span></span><br><span class=\"line\"><span class=\"comment\">\t\treserve_msg = 1，表示不能释放消息数据 msg-&gt;data，只是做转发处理，在 clusterproxy 中有使用，lua 接口为 skynet.forward_type()</span></span><br><span class=\"line\"><span class=\"comment\">\t\treserve_msg = 0，表示需要释放消息数据 msg-&gt;data，也说明这次是消息的终点</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> reserve_msg;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ctx-&gt;profile) &#123;</span><br><span class=\"line\">\t\tctx-&gt;cpu_start = skynet_thread_time();</span><br><span class=\"line\">\t\treserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint64_t</span> cost_time = skynet_thread_time() - ctx-&gt;cpu_start;</span><br><span class=\"line\">\t\tctx-&gt;cpu_cost += cost_time;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\treserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!reserve_msg) &#123;</span><br><span class=\"line\">\t\tskynet_free(msg-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tCHECKCALLING_END(ctx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意回调函数 ctx-&gt;cb 的返回值，当 reserve_msg = 1 时，表示不需要 free 消息数据，只是负责转发这个消息；当 reserve_msg = 0 时，在回调结束后，会 free 消息数据。而对于 snlua 服务来说，是否开启转发是由 api c.callback 的第二个参数决定的，例如 c.callback(func, true) 则表示开启转发（具体参见 skynet.forward_type）。</p>\n<p>这里还涉及到了一个多线程的知识点：线程局部存储(Thread-Local Storage)，用于在工作线程中获取当前正在处理的服务 handle：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uint32_t</span> </span><br><span class=\"line\">skynet_current_handle(<span class=\"keyword\">void</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (G_NODE.init) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> * handle = pthread_getspecific(G_NODE.handle_key);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">uint32_t</span>)(<span class=\"keyword\">uintptr_t</span>)handle;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">uint32_t</span> v = (<span class=\"keyword\">uint32_t</span>)(-THREAD_MAIN);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务回收流程\"><a href=\"#服务回收流程\" class=\"headerlink\" title=\"服务回收流程\"></a>服务回收流程</h3><p>服务的回收过程可以分为三个部分：服务实例的回收、服务消息队列的回收以及服务上下文（ctx）的回收，整个回收过程在 delete_context 函数中实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">delete_context(struct skynet_context *ctx) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果服务有日志文件，先关闭该日志文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ctx-&gt;logfile) &#123;</span><br><span class=\"line\">\t\tfclose(ctx-&gt;logfile);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 回收服务实例</span></span><br><span class=\"line\">\tskynet_module_instance_release(ctx-&gt;mod, ctx-&gt;instance);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 标记服务消息队列为“可回收(release)”</span></span><br><span class=\"line\">\tskynet_mq_mark_release(ctx-&gt;<span class=\"built_in\">queue</span>);</span><br><span class=\"line\">\tCHECKCALLING_DESTROY(ctx)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 回收ctx</span></span><br><span class=\"line\">\tskynet_free(ctx);</span><br><span class=\"line\">\tcontext_dec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要指出的是，服务消息队列的回收方式稍微特殊一点，消息队列的内存并不会立即被 free 掉，还需要处理回收前遗留在队列中的消息，我会在接下来章节详细展开。</p>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>skynet 使用引用计数的方式来决定是否销毁一个服务上下文，这有点类似 C++ 的智能指针，当 ctx-&gt;ref = 0 时，则会触发服务 ctx 的销毁流程。在代码中会发现 skynet_handle_grab 和 skynet_context_release 基本都是成对出现，前者引用一次 ctx（引用次数 +1），后者释放一次引用（引用次数 -1）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">skynet_handle_grab</span>(<span class=\"title\">uint32_t</span> <span class=\"title\">handle</span>) &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">handle_storage</span> *<span class=\"title\">s</span> =</span> H;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * <span class=\"title\">result</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\trwlock_rlock(&amp;s-&gt;lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> hash = handle &amp; (s-&gt;slot_size<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * <span class=\"title\">ctx</span> =</span> s-&gt;slot[hash];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ctx &amp;&amp; skynet_context_handle(ctx) == handle) &#123;</span><br><span class=\"line\">\t\tresult = ctx;</span><br><span class=\"line\">\t\tskynet_context_grab(result); <span class=\"comment\">// ctx 引用次数 +1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trwlock_runlock(&amp;s-&gt;lock);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> * </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">skynet_context_release</span>(<span class=\"keyword\">struct</span> <span class=\"title\">skynet_context</span> *<span class=\"title\">ctx</span>) &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ATOM_DEC(&amp;ctx-&gt;ref) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tdelete_context(ctx); <span class=\"comment\">// ctx 引用次数等于0，则触发回收流程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ctx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里回顾一下前面提到的服务 ctx 创建过程，思考一下为什么初始的 ctx-&gt;ref 要设置为 2，为什么不是 0 或者 1 呢？<br>首先，若 ref 设置为 0，肯定是错误的，因为在 ctx 注册到服务仓库 handler_storage *H中时，ctx 其实就已经被引用一次了，也就是说创建并注册成功的 ctx，其引用计数至少是 1。那为什么不直接设置 ctx 的 ref 为 1，而要设置为 2 呢？原因是 skynet 需要在 ctx 初始化后再次确保其是否是真实可用状态，举个例子：一个新的 ctx 在工作线程 A 中被创建，在 ctx 执行初始化操作后，若它在工作线程 B 中意外被减少一次引用（例如被执行了 kill），此时就会在线程 A 中出现一个已经被回收的 ctx 被 push 到全局消息队列的情况。</p>\n<h4 id=\"回收消息队列\"><a href=\"#回收消息队列\" class=\"headerlink\" title=\"回收消息队列\"></a>回收消息队列</h4><p>服务消息队列的回收过程与服务实例回收和服务 ctx 回收相比会稍微复杂一点，不仅仅需要回收消息队列的内存，还需要处理队列中遗留的消息，要给这些遗留的消息的发送服务一个错误反馈，这就像你从一家公司离职后，当有之前的老客户和你联系时，你需要告知别人“我已经离职了”，而不是没有任何反馈信息。</p>\n<p>消息队列的回收过程分为两个步骤：</p>\n<blockquote>\n<p>标记要回收的消息队列(skynet_mq_mark_release)，并把它 push 到全局消息队列中；<br>工作线程执行 skynet_mq_release，使用指定的丢弃函数(drop_message)来处理队列中遗留的消息包；</p>\n</blockquote>\n<p>回收函数 skynet_mq_release 和丢弃函数 drop_message 的函数定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> </span><br><span class=\"line\">skynet_mq_release(struct message_queue *q, message_drop drop_func, <span class=\"keyword\">void</span> *ud) &#123;</span><br><span class=\"line\">\tSPIN_LOCK(q)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (q-&gt;release) &#123;</span><br><span class=\"line\">\t\tSPIN_UNLOCK(q)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 循环pop剩余的消息，并drop掉</span></span><br><span class=\"line\">\t\t_drop_queue(q, drop_func, ud);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tskynet_globalmq_push(q);</span><br><span class=\"line\">\t\tSPIN_UNLOCK(q)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">drop_message(struct skynet_message *msg, <span class=\"keyword\">void</span> *ud) &#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">drop_t</span> *<span class=\"title\">d</span> =</span> ud;</span><br><span class=\"line\">\tskynet_free(msg-&gt;data);</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> source = d-&gt;handle;</span><br><span class=\"line\">\tassert(source);</span><br><span class=\"line\">\t<span class=\"comment\">// report error to the message source</span></span><br><span class=\"line\">\tskynet_send(<span class=\"literal\">NULL</span>, source, msg-&gt;source, PTYPE_ERROR, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，整个回收过程就是一个把遗留的消息一个个 pop 出来，再由丢弃函数向消息源服务发送一个错误消息，最后释放掉消息队列的内存。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p>深入理解skynet —— 服务 详见：<a href=\"https://domicat.me/_posts/2020-05-10-learn-skynet-service/\">https://domicat.me/_posts/2020-05-10-learn-skynet-service/</a></p>\n","tags":["skynet"]},{"title":"skynet热更新lua代码","url":"/post/eb9dcede.html","content":"<p>skynet有两种方法热更新lua代码，clearcache和inject，文章分别对这两种方法做说明。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"clearcache热更新\"><a href=\"#clearcache热更新\" class=\"headerlink\" title=\"clearcache热更新\"></a>clearcache热更新</h2><p>讲这个前，先说明下skynet代码加载的事情。因为skynet的每个服务都是一个独立的lua虚拟机，对于同一份lua代码，N个服务就要加载lua文件N次，所以，skynet做了优化，代码文件只需要加载一次到内存，其他服务复制这份内存就可以了，省了读取lua文件和解析lua语法的过程。</p>\n<p>clearcache 使用很简单，启动skynet，连接到其控制台：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">clearcache</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>但clearcache有个不可忽视的问题，每次clearcache后，不管代码有没有用到，skynet不会清理旧的内存。这会导致了多次clearcache后，skynet内存使用会越来越大<br>这是为什么？因为clearcache后，只有新起的服务会用到新代码，旧的服务还引用着旧代码。而skynet没有做引用GC的复杂逻辑，在旧服务销毁时，没有清理用不到的旧代码。</p>\n<p>或许你会很好奇，clearcache 没清的内存到底是啥？<br>这要从skynet代码共享说起，skynet加载lua代码时，对于一个代码文件使用了一个新的vm加载，然后以文件名作为key将代码索引到全局的vm中。这样，当有服务需要代码了，就从全局vm找到代码，复制一份到服务。而clearcache，就是删除这个全局的vm，然后再重建一个。这么做的好处是，执行clearcache后，不影响已有服务的运行。问题是，全局vm删了，这个vm索引的所有代码没有清理，这样，那些加载代码用的vm没做清理。</p>\n<h2 id=\"inject热更新\"><a href=\"#inject热更新\" class=\"headerlink\" title=\"inject热更新\"></a>inject热更新</h2><p>inject命令相当于注入代码到服务中，原理就是让指定服务执行某个代码文件，通过修改模块及其函数的upvalue，完成对lua模块代码或变量的替换。这个命令我在前面的文章[1]有详细介绍。<br>inject用法很简单，启动skynet，连接到其控制台:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:00000004       snlua cmaster</span><br><span class=\"line\">:00000005       snlua cslave</span><br><span class=\"line\">:00000007       snlua datacenterd</span><br><span class=\"line\">:00000008       snlua service_mgr</span><br><span class=\"line\">:0000000a       snlua protoloader</span><br><span class=\"line\">:0000000b       snlua console</span><br><span class=\"line\">:0000000c       snlua debug_console 8000</span><br><span class=\"line\">:0000000d       snlua simpledb</span><br><span class=\"line\">OK</span><br><span class=\"line\">inject :0000000d example/inject_simpledb.lua</span><br></pre></td></tr></table></figure>\n<p>inject命令的难点是，这个要注入的lua代码该怎么写。<br>下面直接改写skynet自带的example做说明：</p>\n<h1 id=\"cat-examples-simpledb-lua\"><a href=\"#cat-examples-simpledb-lua\" class=\"headerlink\" title=\"cat examples/simpledb.lua\"></a>cat examples/simpledb.lua</h1><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> skynet = <span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet.manager&quot;</span> </span><br><span class=\"line\"><span class=\"keyword\">local</span> db = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">local</span> command = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 增加了这里</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">(msg)</span></span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(msg)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 增加了这里</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">command.do_test</span><span class=\"params\">(msg)</span></span></span><br><span class=\"line\">        test(msg)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">skynet.start(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">        skynet.dispatch(<span class=\"string\">&quot;lua&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(session, address, cmd, ...)</span></span></span><br><span class=\"line\">                <span class=\"keyword\">local</span> f = command[<span class=\"built_in\">string</span>.<span class=\"built_in\">upper</span>(cmd)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> f <span class=\"keyword\">then</span></span><br><span class=\"line\">                        skynet.ret(skynet.pack(f(...)))</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"built_in\">error</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;Unknown command %s&quot;</span>, <span class=\"built_in\">tostring</span>(cmd)))</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span>)</span><br><span class=\"line\">        <span class=\"comment\">-- 增加了这里</span></span><br><span class=\"line\">        skynet.fork(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">                        skynet.sleep(<span class=\"number\">100</span>)</span><br><span class=\"line\">                        command.do_test(<span class=\"string\">&quot;itest!&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span>)</span><br><span class=\"line\">        skynet.register <span class=\"string\">&quot;SIMPLEDB&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<p>假设以上的 command.do_test 就是我们要热更改掉的函数。那用于inject的lua代码如下：</p>\n<h1 id=\"cat-inject-test-lua\"><a href=\"#cat-inject-test-lua\" class=\"headerlink\" title=\"cat inject_test.lua\"></a>cat inject_test.lua</h1><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> _P <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hotfix fail, no _P define&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;hotfix begin&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 用于获取函数变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get_up</span><span class=\"params\">(f)</span></span></span><br><span class=\"line\">        <span class=\"keyword\">local</span> u = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> f <span class=\"keyword\">then</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> u</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">local</span> i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"keyword\">local</span> name, value = <span class=\"built_in\">debug</span>.<span class=\"built_in\">getupvalue</span>(f, i)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> u</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                u[name] = value</span><br><span class=\"line\">                i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> u</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 获取原来的函数地址，及函数变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> command = _P.lua.command</span><br><span class=\"line\"><span class=\"keyword\">local</span> upvs = get_up(command.do_test)</span><br><span class=\"line\"><span class=\"keyword\">local</span> test = upvs.test</span><br><span class=\"line\"></span><br><span class=\"line\">command.do_test = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(msg)</span></span></span><br><span class=\"line\">    test(<span class=\"string\">&#x27;New &#x27;</span> .. msg)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;hotfix end&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>启动控制台，执行inject后，就会看到类似下面的skynet的日志：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ./skynet examples/config</span></span><br><span class=\"line\">[:00000001] LAUNCH logger </span><br><span class=\"line\">[:00000002] LAUNCH snlua bootstrap</span><br><span class=\"line\">[:00000003] LAUNCH snlua launcher</span><br><span class=\"line\">[:00000004] LAUNCH snlua cmaster</span><br><span class=\"line\">[:00000005] LAUNCH snlua cslave</span><br><span class=\"line\">[:00000006] LAUNCH harbor 1 16777221</span><br><span class=\"line\">[:00000007] LAUNCH snlua datacenterd</span><br><span class=\"line\">[:00000008] LAUNCH snlua service_mgr</span><br><span class=\"line\">[:00000009] LAUNCH snlua main</span><br><span class=\"line\">[:0000000a] LAUNCH snlua protoloader</span><br><span class=\"line\">[:0000000b] LAUNCH snlua console</span><br><span class=\"line\">[:0000000c] LAUNCH snlua debug_console 8000</span><br><span class=\"line\">[:0000000d] LAUNCH snlua simpledb</span><br><span class=\"line\">[:0000000e] LAUNCH snlua watchdog</span><br><span class=\"line\">[:0000000f] LAUNCH snlua gate</span><br><span class=\"line\">[:0000000f] Listen on 0.0.0.0:8888</span><br><span class=\"line\">Watchdog listen on      8888</span><br><span class=\"line\">[:00000009] KILL self</span><br><span class=\"line\">[:00000002] KILL self</span><br><span class=\"line\">itest!</span><br><span class=\"line\">itest!</span><br><span class=\"line\">itest!</span><br><span class=\"line\">New itest!</span><br><span class=\"line\">New itest!</span><br></pre></td></tr></table></figure>\n<p>通过前面的分析，我们知道了，clearcache和inject两种方法都可以热更代码。clearcache比较简单，但这种方法对于已有的服务是没有效果的，只有在新的服务才生效。而inject可以热更已有的服务，但不管是inject脚本的编写，还是inject命令的执行，都相对比较繁琐。所以要根据实际的需求，选择适合的方法热更lua代码。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/76\">Las pirámides son el mejor ejemplo de que en cualquier tiempo y lugar los obreros tienden a trabajar menos cada vez.</a></p>\n","tags":["skynet"]},{"title":"skynet考古","url":"/post/33b1eb02.html","content":"<p>研究一个程序的进化历史，是一件很有趣的事。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"skynet版本的年表\"><a href=\"#skynet版本的年表\" class=\"headerlink\" title=\"skynet版本的年表\"></a>skynet版本的年表</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/114987859-397be200-9ec8-11eb-9d47-d0cb15c4a4b2.JPG\" alt=\"捕获\"></p>\n<h2 id=\"skynet-1\"><a href=\"#skynet-1\" class=\"headerlink\" title=\"skynet 1\"></a>skynet 1</h2><p>1.0 : 第一版<code>released</code>，实现了服务器的一些基本功能。<br>1.1 : 增加<code>socket.disconnected()</code><br>1.2 : 改进<code>cluster</code>支持，<code>mongodb driver</code>，<code>redis driver</code>，<code>socket</code>并发写，<code>socket channel</code>，<code>service gate</code>，<code>udp</code>支持，<code>skynet.wait/wakeup</code>。加入<code>skynet.ignoreret</code>，<code>skynet.trace</code>，<code>skynet.context</code>，<code>socket.netstat</code>，<code>socketchannel.overload</code>。升级<code>Lua</code>到5.3.5，升级<code>jemalloc</code>到5.1.0。<br>1.3 : 改进<code>mysql driver</code>，<code>cluster</code>，<code>lua shared proto</code>，<code>socket.write</code>。增加<code>lua sharetable</code>，<code>https</code>支持，<code>websocket</code>支持。升级<code>jemalloc</code>到5.2.1。<br>1.4 : 升级<code>Lua</code>到5.4.2。改进<code>mysql driver</code>，<code>websocket</code>，<code>ssl</code>，<code>sproto</code>。增加<code>skynet.select</code>，增加<code>PKCS7</code>加密算法，调试终端加入<code>jmem</code>，加入<code>skynet_socket_pause</code>，对日志增加时间戳。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/119\">El amor eterno dura aproximadamente tres meses.</a></p>\n","tags":["skynet"]},{"title":"svn项目相关问题","url":"/post/ba3259ee.html","content":"<p>这里记录下使用svn时的问题。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"删除svn冲突\"><a href=\"#删除svn冲突\" class=\"headerlink\" title=\"删除svn冲突\"></a>删除svn冲突</h2><p>一般遇到svn冲突时，我们都下意识clean下。其实，有更加好的方法。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">G:\\project\\.svn<span class=\"operator\">&gt;</span>sqlite3.exe wc.db</span><br><span class=\"line\">SQLite version <span class=\"number\">3.7</span><span class=\"number\">.15</span><span class=\"number\">.2</span> <span class=\"number\">2013</span><span class=\"number\">-01</span><span class=\"number\">-09</span> <span class=\"number\">11</span>:<span class=\"number\">53</span>:<span class=\"number\">05</span></span><br><span class=\"line\">Enter &quot;.help&quot; <span class=\"keyword\">for</span> instructions</span><br><span class=\"line\">Enter <span class=\"keyword\">SQL</span> statements terminated <span class=\"keyword\">with</span> a &quot;;&quot;</span><br><span class=\"line\">sqlite<span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> work_queue;</span><br><span class=\"line\"><span class=\"number\">5046</span><span class=\"operator\">|</span>(file<span class=\"operator\">-</span>install Resources<span class=\"operator\">/</span>pc<span class=\"operator\">/</span>base<span class=\"operator\">/</span>effects<span class=\"operator\">/</span><span class=\"number\">500000001.</span>unity3d <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">sqlite<span class=\"operator\">&gt;</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> work_queue;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/104\">Ahorra agua. No te duches solo.</a></p>\n","tags":["svn"]},{"title":"vim快捷键","url":"/post/e47927c.html","content":"<h2 id=\"前方\"><a href=\"#前方\" class=\"headerlink\" title=\"前方\"></a>前方</h2><p>vim是裸机linux，最顺手的编辑工具。用好vim，修改文件就会事半功倍。</p>\n<h2 id=\"跳转查看\"><a href=\"#跳转查看\" class=\"headerlink\" title=\"跳转查看\"></a>跳转查看</h2><p>跳到文本的最后一行：按“G”,即“shift+g”<br>跳到第一行的第一个字符：先按两次“g”</p>\n","tags":["linux"]},{"title":"vscode+vps调试c程序","url":"/post/17b7b9fb.html","content":"<p>当运行的程序出现问题时，我们通常通过调试来追踪和定位问题。但是，当运行错误的机器上没有调试工具，我们就需要实现远程调试。简单地说，就是要调试的程序和调试器不在一台机器上。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"使用ssh实现vscode远程连接\"><a href=\"#使用ssh实现vscode远程连接\" class=\"headerlink\" title=\"使用ssh实现vscode远程连接\"></a>使用ssh实现vscode远程连接</h2><p>在vscode安装插件remote-ssh，安装完后可以看到这个图标<br><img src=\"https://user-images.githubusercontent.com/11263320/110116260-37673380-7df2-11eb-8b71-7f0520d4c01c.JPG\" alt=\"fgfsdgs\"><br>输入vps ip就可以直接连上了</p>\n<h2 id=\"vscode调试c程序\"><a href=\"#vscode调试c程序\" class=\"headerlink\" title=\"vscode调试c程序\"></a>vscode调试c程序</h2><p>这时候如果直接debug，选择chrome，在工作目录下会出现.vscode文件夹。<br>将下面这两个文件复制到vscode下，就可以远程调试了。<br>launch.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class=\"line\">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class=\"line\">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class=\"line\">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">    &quot;configurations&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;(gdb) Launch&quot;,</span><br><span class=\"line\">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class=\"line\">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;skynet&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [&quot;examples&#x2F;config&quot;],</span><br><span class=\"line\">            &quot;stopAtEntry&quot;: false,</span><br><span class=\"line\">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class=\"line\">            &quot;environment&quot;: [],</span><br><span class=\"line\">            &quot;externalConsole&quot;: false,</span><br><span class=\"line\">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class=\"line\">            &quot;setupCommands&quot;: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class=\"line\">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class=\"line\">                    &quot;ignoreFailures&quot;: true</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            &quot;preLaunchTask&quot;: &quot;build-debug&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tasks.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class=\"line\">    &quot;tasks&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;label&quot;: &quot;build&quot;,</span><br><span class=\"line\">            &quot;command&quot;: &quot;make&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [&quot;linux&quot;],</span><br><span class=\"line\">            &quot;type&quot;: &quot;shell&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;label&quot;: &quot;build-debug&quot;,</span><br><span class=\"line\">            &quot;command&quot;: &quot;make&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [&quot;linux&quot;],</span><br><span class=\"line\">            &quot;type&quot;: &quot;shell&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;label&quot;: &quot;clean&quot;,</span><br><span class=\"line\">            &quot;command&quot;: &quot;make&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [&quot;clean&quot;],</span><br><span class=\"line\">            &quot;type&quot;: &quot;shell&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据不同程序的需求，需要改写一些参数。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/101\">La raíz de todos los males es el amor al dinero. </a></p>\n","tags":["gdb"]},{"title":"一些sql语句","url":"/post/c251f772.html","content":"<p>这里记录一些<code>sql</code>复杂的语句。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"GROUP分组\"><a href=\"#GROUP分组\" class=\"headerlink\" title=\"GROUP分组\"></a>GROUP分组</h2><p><code>GROUP BY</code>聚合函数在聚合行的时候顺序是不确定的，多次运行的结果都有可能会不同。<br>必须要用子查询或者程序逻辑来获取特定的行的结果。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> `test` <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> b <span class=\"keyword\">desc</span> limit <span class=\"number\">999999</span>) T <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T.a</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@i</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"variable\">@i</span><span class=\"operator\">=</span><span class=\"number\">1</span></span><br><span class=\"line\">while <span class=\"variable\">@i</span><span class=\"operator\">&lt;</span><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test (userid) <span class=\"keyword\">values</span>(<span class=\"variable\">@i</span>)</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"variable\">@i</span><span class=\"operator\">=</span><span class=\"variable\">@i</span><span class=\"operator\">+</span><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"用临时表加While循环的方法-对Customers表中的CompanyName列进行遍历\"><a href=\"#用临时表加While循环的方法-对Customers表中的CompanyName列进行遍历\" class=\"headerlink\" title=\"用临时表加While循环的方法, 对Customers表中的CompanyName列进行遍历\"></a>用临时表加<code>While</code>循环的方法, 对<code>Customers</code>表中的<code>CompanyName</code>列进行遍历</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> #temp</span><br><span class=\"line\">(</span><br><span class=\"line\">  id <span class=\"type\">int</span> <span class=\"keyword\">identity</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>),</span><br><span class=\"line\">  customer nvarchar(<span class=\"number\">50</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@customer</span> nvarchar(<span class=\"number\">50</span>)</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@n</span>        <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@rows</span>     <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@n</span><span class=\"operator\">=</span><span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> #temp(customer) <span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> companyname <span class=\"keyword\">from</span> customers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@rows</span> <span class=\"operator\">=</span> @<span class=\"variable\">@rowcount</span></span><br><span class=\"line\"></span><br><span class=\"line\">while <span class=\"variable\">@n</span> <span class=\"operator\">&lt;=</span> <span class=\"variable\">@rows</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@customer</span> <span class=\"operator\">=</span> companyname</span><br><span class=\"line\"><span class=\"keyword\">from</span> customers</span><br><span class=\"line\">     <span class=\"keyword\">where</span> companyname<span class=\"operator\">=</span>(<span class=\"keyword\">select</span> customer <span class=\"keyword\">from</span> #temp <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"variable\">@n</span>)</span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> companyname <span class=\"keyword\">desc</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"variable\">@customer</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@n</span> <span class=\"operator\">=</span> <span class=\"variable\">@n</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/43\">Nadie da palos de balde.</a></p>\n","tags":["mysql"]},{"title":"事件驱动模型与观察者模式","url":"/post/efed7d66.html","content":"<p>你有一件事情，做这件事情的过程包含了许多职责单一的子函数。当这些子函数有如下特点时，我们应该考虑设计一种合适的框架，让框架来完成一些业务无关的事情，从而使得各个子过程的开发可以专注于自己的业务。降低程度耦合程度。</p>\n<a id=\"more\"></a>\n<blockquote>\n<ul>\n<li>这些子过程有一定的执行次序</li>\n<li>这些子过程之间需要较灵活的跳转</li>\n<li>这些子过程也许需要围绕同一个上下文做操作</li>\n</ul>\n</blockquote>\n<p>此时可以考虑使用事件驱动的方式来组织这些子过程，此时这些子函数可以被称之为事件处理器（或监听器），而将事件处理器组织起来的管理者，叫做事件中心。最显而易见的实现方式，是观察者模式，或者监听者模式。作为一个例子，考虑一个消息转发系统，它从上游接收消息，然后转发给正确的下游用户。整个过程可以拆分为消息解析、消息存储、消息发送等步骤。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<h2 id=\"事件处理器\"><a href=\"#事件处理器\" class=\"headerlink\" title=\"事件处理器\"></a>事件处理器</h2><h3 id=\"事件使用\"><a href=\"#事件使用\" class=\"headerlink\" title=\"事件使用\"></a>事件使用</h3><p>在一个对象中发送事件：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventMgr.DispatchEvent(<span class=\"string\">&quot;MobRefresh&quot;</span>,ring,mobRefreshConfig)</span><br></pre></td></tr></table></figure>\n<p>先在一个对象中订阅，当另一个对象发送事件时再作处理：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventMgr.RegEvent(<span class=\"string\">&quot;MobRefresh&quot;</span>, <span class=\"built_in\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Scene:MobRefresh</span><span class=\"params\">(ring, config)</span></span></span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;MobRefresh&quot;</span>,ring)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"事件分发器的实现\"><a href=\"#事件分发器的实现\" class=\"headerlink\" title=\"事件分发器的实现\"></a>事件分发器的实现</h3><p><a href=\"https://gist.github.com/losophy/fa1bdd0e9229507b81248f566d8016c2\">GEventMgr.lua</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/142\">¡Qué suerte que tienes con tu nuevo matrimonio!, si es que te va de película.</a></p>\n","tags":["design"]},{"title":"二叉树","url":"/post/e85d694a.html","content":"<p>之前写了一些链表和排序的<code>blog</code>，其中有说到多链表，堆，其中提到了一种特殊的数据结构：树。<br>人们发明树结构，用于储存和搜索海量的数据。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"树的种类\"><a href=\"#树的种类\" class=\"headerlink\" title=\"树的种类\"></a>树的种类</h2><p>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树。<br>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；<br>二叉树：每个节点最多含有两个子树的树称为二叉树；<br>完全二叉树：二叉树的所有子树要么没有孩子，要么一定有左孩子。堆是一种完全二叉树。<br><img src=\"https://user-images.githubusercontent.com/11263320/118101667-6a3d3180-b40a-11eb-8e03-9bc7a20000a2.JPG\" alt=\"捕获\"><br>红黑树：红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。在<code>STL</code>中，<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>等数据结构都是基于红黑树实现的。<br>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点（最后一层上的无子结点的结点为叶子结点）。<br>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树。</p>\n<p>如果二叉树不是平衡的，那么它就退化为一个链表，而搜索时间也退化为一个线性函数。</p>\n<h2 id=\"树的深度\"><a href=\"#树的深度\" class=\"headerlink\" title=\"树的深度\"></a>树的深度</h2><p>定义一棵树的根结点层次为1，其他节点的层次是其父结点层次加1。一棵树中所有结点的层次的最大值称为这棵树的深度。</p>\n<h2 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h2><p>所谓遍历<code>(Traversal)</code>是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问 题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础。</p>\n<h2 id=\"遍历命名\"><a href=\"#遍历命名\" class=\"headerlink\" title=\"遍历命名\"></a>遍历命名</h2><p>根据访问结点操作发生位置命名：</p>\n<blockquote>\n<p>① NLR：前序遍历(<code>Preorder Traversal</code>亦称（先序遍历））<br>——访问根结点的操作发生在遍历其左右子树之前。如10、6、4、8、14、12、16。<br>② LNR：中序遍历(<code>Inorder Traversal</code>)<br>——访问根结点的操作发生在遍历其左右子树之中（间）。如4、6、8、10、12、14、16。<br>③ LRN：后序遍历(<code>Postorder Traversal</code>)<br>——访问根结点的操作发生在遍历其左右子树之后。如4、8、6、12、16、14、10。</p>\n</blockquote>\n<h2 id=\"中序遍历的投影法\"><a href=\"#中序遍历的投影法\" class=\"headerlink\" title=\"中序遍历的投影法\"></a>中序遍历的投影法</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115009313-c03bb980-9ede-11eb-9df9-6ee7e3546184.JPG\" alt=\"捕获\"></p>\n<h2 id=\"一般二叉树的定义\"><a href=\"#一般二叉树的定义\" class=\"headerlink\" title=\"一般二叉树的定义\"></a>一般二叉树的定义</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;</span><br><span class=\"line\">    BiTNode *lchild,*rchild;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的遍历操作\"><a href=\"#二叉树的遍历操作\" class=\"headerlink\" title=\"二叉树的遍历操作\"></a>二叉树的遍历操作</h2><h3 id=\"先序遍历（DLR）\"><a href=\"#先序遍历（DLR）\" class=\"headerlink\" title=\"先序遍历（DLR）\"></a>先序遍历（DLR）</h3><p>先序遍历的递归过程为：</p>\n<blockquote>\n<p>（1） 访问根结点<br>（2） 先序遍历根结点的左子树<br>（3） 先序遍历根结点的右子树<br>若二叉树为空，遍历结束。</p>\n</blockquote>\n<p>先序遍历二叉树的递归算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*先序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">/*递归调用的结束条件*/</span></span><br><span class=\"line\">      Visite(bt-&gt;data);     <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\">      PreOrder(bt-&gt;lchild); <span class=\"comment\">/*先序递归遍历bt 的左子树*/</span></span><br><span class=\"line\">      PreOrder(bt-&gt;rchild); <span class=\"comment\">/*先序递归遍历bt 的右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"中序遍历（LDR）\"><a href=\"#中序遍历（LDR）\" class=\"headerlink\" title=\"中序遍历（LDR）\"></a>中序遍历（LDR）</h3><p>中序遍历的递归过程为：</p>\n<blockquote>\n<p>（1）中序遍历根结点的左子树；<br>（2）访问根结点；<br>（3）中序遍历根结点的右子树。<br>若二叉树为空，遍历结束。</p>\n</blockquote>\n<p>中序遍历二叉树的递归算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*中序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">/*递归调用的结束条件*/</span></span><br><span class=\"line\">     InOrder(bt-&gt;lchild); <span class=\"comment\">/*中序递归遍历bt 的左子树*/</span></span><br><span class=\"line\">     Visite(bt-&gt;data);     <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\">     InOrder(bt-&gt;rchild); <span class=\"comment\">/*中序递归遍历bt 的右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后序遍历（LRD）\"><a href=\"#后序遍历（LRD）\" class=\"headerlink\" title=\"后序遍历（LRD）\"></a>后序遍历（LRD）</h3><p>后序遍历的递归过程为：</p>\n<blockquote>\n<p>（1）后序遍历根结点的左子树<br>（2）后序遍历根结点的右子树<br>（3）访问根结点<br>若二叉树为空，遍历结束。</p>\n</blockquote>\n<p>后序遍历二叉树的递归算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*后序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">/*递归调用的结束条件*/</span></span><br><span class=\"line\">     PostOrder(bt-&gt;lchild); <span class=\"comment\">/*后序递归遍历bt 的左子树*/</span></span><br><span class=\"line\">     PostOrder(bt-&gt;rchild); <span class=\"comment\">/*后序递归遍历bt 的右子树*/</span></span><br><span class=\"line\">     Visite(bt-&gt;data); <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从表面上看，从代码中，遍历语句的位置可以看出是什么遍历。</p>\n<h3 id=\"层次遍历（宽度优先遍历）\"><a href=\"#层次遍历（宽度优先遍历）\" class=\"headerlink\" title=\"层次遍历（宽度优先遍历）\"></a>层次遍历（宽度优先遍历）</h3><p>由层次遍历的定义可以推知，在进行层次遍历时，对一层结点访问完后，再按照它们的访问次序对各个结点的左孩子和右孩子顺序访问，这样一层一层进行，先遇到的结点先访问，这与队列的操作原则比较吻合。因此，在进行层次遍历时，可设置一个队列结构，遍历从二叉树的根结点开始，首先将根结点指针入队列，然后从对头取出一个元素，每取一个元素，执行下面两个操作：</p>\n<blockquote>\n<p>（1） 访问该元素所指结点<br>（2） 若该元素所指结点的左、右孩子结点非空，则将该元素所指结点的左孩子指针和右孩子指针顺序入队<br>此过程不断进行，当队列为空时，二叉树的层次遍历结束。</p>\n</blockquote>\n<p>在下面的层次遍历算法中，二叉树以二叉链表存放，一维数组<code>Queue[MAXNODE]</code>用以实现队列，变量<code>front</code>和<code>rear</code>分别表示当前对首元素和队尾元素在数组中的位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*层次遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    BiTree Queue[MAXNODE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> front,rear;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    front=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    rear=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>[rear]=bt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(front!=rear)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        front++;</span><br><span class=\"line\">        Visite(<span class=\"built_in\">queue</span>[front]-&gt;data); <span class=\"comment\">/*访问队首结点的数据域*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[front]-&gt;lchild!=<span class=\"literal\">NULL</span>) <span class=\"comment\">/*将队首结点的左孩子结点入队列*/</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            rear++;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>[rear]=<span class=\"built_in\">queue</span>[front]-&gt;lchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[front]-&gt;rchild!=<span class=\"literal\">NULL</span>) <span class=\"comment\">/*将队首结点的右孩子结点入队列*/</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            rear++;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>[rear]=<span class=\"built_in\">queue</span>[front]-&gt;rchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树遍历的非递归实现\"><a href=\"#二叉树遍历的非递归实现\" class=\"headerlink\" title=\"二叉树遍历的非递归实现\"></a>二叉树遍历的非递归实现</h3><p>从二叉树各种遍历来说，各种遍历都是从根结点开始的，且在遍历过程中经过结点的路线是一样的，只是访问的时机不同而已。这一路线都是从根结点开始沿左子树深入下去，当深入到最左端，无法再深入下去时，则返回，再逐一进入刚才深入时遇到结点的右子树，再进行如此的深入和返回，直到最后从根结点的右子树返回到根结点为止。先序遍历是在深入时遇到结点就访问，中序遍历是在从左子树返回时遇到结点访问，后序遍历是在从右子树返回时遇到结点访问。</p>\n<p>这种路线可以用栈来实现。其实递归在本质上就是一个栈结构。</p>\n<p>在这一过程中，返回结点的顺序与深入结点的顺序相反，即后深入先返回，正好符合栈结构后进先出的点。因此，可以用栈来帮助实现这一遍历路线。其过程如下。在沿左子树深入时，深入一个结点入栈一个结点，若为先序遍历，则在入栈之前访问之；当沿左分支深入不下去时，则返回，即从堆栈中弹出前面压入的结点，若为中序遍历，则此时访问该结点，然后从该结点的右子树继续深入；若为后序遍历，则将此结点再次入栈，然后从该结点的右子树继续深入，与前面类同，仍为深入一个结点入栈一个结点，深入不下去再返回，直到第二次从栈里弹出该结点，才访问之。</p>\n<h4 id=\"先序遍历的非递归实现\"><a href=\"#先序遍历的非递归实现\" class=\"headerlink\" title=\"先序遍历的非递归实现\"></a>先序遍历的非递归实现</h4><p>在下面算法中，二叉树以二叉链表存放，一维数组<code>stack[MAXNODE]</code>用以实现栈，变量<code>top</code>用来表示当前栈顶的位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NRPreOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*非递归先序遍历二叉树*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BiTree <span class=\"built_in\">stack</span>[MAXNODE],p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    top=<span class=\"number\">0</span>;</span><br><span class=\"line\">    p=bt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!(p==<span class=\"literal\">NULL</span>&amp;&amp;top==<span class=\"number\">0</span>))</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            Visite(p-&gt;data);   <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top&lt;MAXNODE<span class=\"number\">-1</span>) <span class=\"comment\">/*将当前指针p 压栈*/</span></span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[top]=p;</span><br><span class=\"line\">                top++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈溢出&quot;</span>)；</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            p=p-&gt;lchild; <span class=\"comment\">/*指针指向p 的左孩子*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (top&lt;=<span class=\"number\">0</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">/*栈空时结束*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            top--;</span><br><span class=\"line\">            p=<span class=\"built_in\">stack</span>[top]; <span class=\"comment\">/*从栈中弹出栈顶元素*/</span></span><br><span class=\"line\">            p=p-&gt;rchild; <span class=\"comment\">/*指针指向p 的右孩子结点*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"中序遍历的非递归实现\"><a href=\"#中序遍历的非递归实现\" class=\"headerlink\" title=\"中序遍历的非递归实现\"></a>中序遍历的非递归实现</h4><p>中序遍历的非递归算法的实现，只需将先序遍历的非递归算法中的<code>Visite(p-&gt;data)</code>移到<code>p=stack[top]</code>和<code>p=p-&gt;rchild</code>之间即可。</p>\n<h4 id=\"后序遍历的非递归实现\"><a href=\"#后序遍历的非递归实现\" class=\"headerlink\" title=\"后序遍历的非递归实现\"></a>后序遍历的非递归实现</h4><p>由前面的讨论可知，后序遍历与先序遍历和中序遍历不同，在后序遍历过程中，结点在第一次出栈后，还需再次入栈，也就是说，结点要入两次栈，出两次栈，而访问结点是在第二次出栈时访问。因此，为了区别同一个结点指针的两次出栈，设置一标志<code>flag</code>，令：</p>\n<blockquote>\n<p>flag = 1 -&gt; 第一次出栈，结点不能访问<br>flag = 2 -&gt; 第二次出栈，结点可以访问<br>当结点指针进、出栈时，其标志<code>flag</code>也同时进、出栈。因此，可将栈中元素的数据类型定义为指针和标志<code>flag</code>合并的结构体类型。定义如下：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BiTree link;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag;</span><br><span class=\"line\">&#125; stacktype;</span><br></pre></td></tr></table></figure>\n<p>后序遍历二叉树的非递归算法如下。在算法中，一维数组<code>stack[MAXNODE]</code>用于实现栈的结构，指针变量<code>p</code>指向当前要处理的结点，整型变量<code>top</code>用来表示当前栈顶的位置，整型变量<code>sign</code>为结点<code>p</code>的标志量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NRPostOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*非递归后序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    stacktype <span class=\"built_in\">stack</span>[MAXNODE];</span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top,sign;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    top=<span class=\"number\">-1</span>   <span class=\"comment\">/*栈顶位置初始化*/</span></span><br><span class=\"line\">    p=bt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!(p==<span class=\"literal\">NULL</span> &amp;&amp; top==<span class=\"number\">-1</span>))</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p!=<span class=\"literal\">NULL</span>)    <span class=\"comment\">/*结点第一次进栈*/</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            top++;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[top].link=p;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[top].flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">            p=p-&gt;lchild;   <span class=\"comment\">/*找该结点的左孩子*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            p=<span class=\"built_in\">stack</span>[top].link;</span><br><span class=\"line\">            sign=<span class=\"built_in\">stack</span>[top].flag;</span><br><span class=\"line\">            top--;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sign==<span class=\"number\">1</span>)   <span class=\"comment\">/*结点第二次进栈*/</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                top++;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[top].link=p;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[top].flag=<span class=\"number\">2</span>;   <span class=\"comment\">/*标记第二次出栈*/</span></span><br><span class=\"line\">                p=p-&gt;rchild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                Visite(p-&gt;data);   <span class=\"comment\">/*访问该结点数据域值*/</span></span><br><span class=\"line\">                p=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/30\">A lo hecho, pecho.</a></p>\n","tags":["algorithm"]},{"title":"代码整洁之道","url":"/post/2f4d2249.html","content":"<p>代码既是写给机器看的，也是写给别人看的。写出优美，让人阅读友好的代码，十分重要。以下是一些整洁代码的心德。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"使用数组代替switch分支语句降低圈复杂度\"><a href=\"#使用数组代替switch分支语句降低圈复杂度\" class=\"headerlink\" title=\"使用数组代替switch分支语句降低圈复杂度\"></a>使用数组代替switch分支语句降低圈复杂度</h2><p>在服务器开发时，很多时间会采用数组代替<code>switch</code>分支语句，用来降低圈复杂度。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerCallbackFunc</span> <span class=\"params\">(code, func)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> code == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> func == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    callbackFuncMgr[code] = func</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"圈复杂度\"><a href=\"#圈复杂度\" class=\"headerlink\" title=\"圈复杂度\"></a>圈复杂度</h3><p>在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。<br>如果一段源码中不包含控制流语句（条件或决策点），那么这段代码的圈复杂度为1，因为这段代码中只会有一条路径；如果一段代码中仅包含一个<code>if</code>语句，且<code>if</code>语句仅有一个条件，那么这段代码的圈复杂度为2；包含两个嵌套的<code>if</code>语句，或是一个<code>if</code>语句有两个条件的代码块的圈复杂度为3。</p>\n<h2 id=\"缩写习惯\"><a href=\"#缩写习惯\" class=\"headerlink\" title=\"缩写习惯\"></a>缩写习惯</h2><p>尽量不要用自定义的缩写，可读性排第一位，但可以用一些约定俗成的常见缩写。</p>\n<h2 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h2><p>作判断时尽量用&lt;判断</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">1000</span> &lt; check <span class=\"keyword\">and</span> check &lt; <span class=\"number\">100000</span>  <span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>这样做可以对照时间线，习惯一目了然<br><img src=\"https://user-images.githubusercontent.com/11263320/110576898-8d462d80-819c-11eb-993f-b7734c2ff5c3.JPG\" alt=\"捕获\"></p>\n<h2 id=\"一个函数只做一件事情\"><a href=\"#一个函数只做一件事情\" class=\"headerlink\" title=\"一个函数只做一件事情\"></a>一个函数只做一件事情</h2><p>不要把所有鸡蛋放到一个篮子里，减少段和段之间耦合联系性。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/26\">Al mejor escribano se le va un borrón.</a></p>\n","tags":["design"]},{"title":"使用ChunkSpy反编译Lua文件","url":"/post/258de02f.html","content":"<p>ChunkSpy的工作原理是根据 luac编译之后的二进制文件格式进行解析 。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"具体的用法\"><a href=\"#具体的用法\" class=\"headerlink\" title=\"具体的用法\"></a>具体的用法</h2><p>首先，需要使用 luac编译生成二进制文件 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">luac test.lua</span><br></pre></td></tr></table></figure>\n<p>默认情况下，上面指令执行之后的结果是生成一个叫 luac.out的文件。 这就是Lua脚本文件编译之后的二进制文件，然后再使用ChunkSpy脚本进行反编译：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">lua ChunkSpy .lua luac.out test.lua <span class=\"comment\">--brief</span></span><br></pre></td></tr></table></figure>\n<p>其中 test.lua是原始的脚本文件，加上brief参数是为了生成的内容更精简一些 。</p>\n<h3 id=\"对64位系统支持\"><a href=\"#对64位系统支持\" class=\"headerlink\" title=\"对64位系统支持\"></a>对64位系统支持</h3><p>需要说明的是， ChunkSpy在2006年之后就不怎么更新，对现在的 64位系统支持的可能不够好。<br>如果在执行的时候，发现提示如下的报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ChunkSpy.lua :1120: mismatch in size_t size (needs 4 but read 8)</span><br></pre></td></tr></table></figure>\n<p>那么，可以尝试把代码中两个定义 size size t的地方由4改为8。</p>\n<h2 id=\"ChunkSpy-lua\"><a href=\"#ChunkSpy-lua\" class=\"headerlink\" title=\"ChunkSpy.lua\"></a>ChunkSpy.lua</h2><p><a href=\"https://github.com/losophy/some.notes/files/6284024/ChunkSpy.zip\">ChunkSpy.zip</a></p>\n","tags":["lua"]},{"title":"使用Lua处理游戏数据","url":"/post/f68e1d0f.html","content":"<p>在之前<code>lua</code>学习：<code>lua</code>作配置文件里，我们学会了用<code>lua</code>作配置文件。<br>其实<code>lua</code>在游戏开发中可以作为一个强大的保存、载入游戏数据的工具。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"载入游戏数据\"><a href=\"#载入游戏数据\" class=\"headerlink\" title=\"载入游戏数据\"></a>载入游戏数据</h2><p>比如说，现在我有一份表单：<code>data.xls</code>。</p>\n<p>用什么工具解析这个<code>Excel</code>文件并将数据载入游戏？<br>我们可以使用<code>Lua</code>来完成这个工作。不过要先将表单保存为<code>csv</code>文件（数值用逗号隔开的文件）。<br>从表单中，我们可以得知第一行是键名，剩下的行是数值。我们可以用下面的<code>lua</code>函数载入该<code>csv</code>文件并保存到表中。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetLines</span><span class=\"params\">(fileName)</span></span></span><br><span class=\"line\">    index = <span class=\"number\">0</span></span><br><span class=\"line\">    myLines = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">io</span>.<span class=\"built_in\">lines</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;%s%s&quot;</span>, <span class=\"string\">&quot;./&quot;</span>, fileName)) <span class=\"keyword\">do</span></span><br><span class=\"line\">        index = index + <span class=\"number\">1</span></span><br><span class=\"line\">        myLines[index] = line</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> index, myLines <span class=\"comment\">--返回文件的行数和一个包括所有行的表</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p><code>io.lines ([filename])</code>：打开指定的文件<code>filename</code>为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回<code>nil</code>,并自动关闭文件。<br>然后，可以再创建一个函数解析每行的字符，并创建表格保存该行的所有数据。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetValues</span><span class=\"params\">(myString)</span></span></span><br><span class=\"line\">    num = <span class=\"number\">0</span></span><br><span class=\"line\">    values = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> myString ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(myString,<span class=\"string\">&quot;,&quot;</span>) ~= <span class=\"literal\">nil</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">            i,j = <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(myString,<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">            num = num + <span class=\"number\">1</span></span><br><span class=\"line\">            values[num] = <span class=\"built_in\">string</span>.<span class=\"built_in\">sub</span>(myString,<span class=\"number\">1</span>, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">            myString = <span class=\"built_in\">string</span>.<span class=\"built_in\">sub</span>(myString, j+<span class=\"number\">1</span>, <span class=\"built_in\">string</span>.<span class=\"built_in\">len</span>(myString))</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        num = num + <span class=\"number\">1</span> <span class=\"comment\">--接着对第二行数据</span></span><br><span class=\"line\">        values[num] = myString</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num, values</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p><code>string.find(s, pattern, pos)</code>：从源字符串<code>s</code>找到匹配<code>pattern</code>返回，<code>pos</code>参数可选， 表示起始位置，如果匹配不成功，返回<code>nil</code>。<br><code>string.sub()</code>：函数截取字符串<code>s</code>的从第<code>i</code>个字符到第<code>j</code>个字符之间的串。<br>在这个函数中，我们传入字符。通过调用<code>string.find()</code>和<code>string.sub</code>，返回数值的个数和包含了所有数值的表。通过这两个简单的处理步骤可以让用户解析几乎所有的<code>csv</code>文件，不论简单还是复杂的文件。</p>\n<p>我们可以写个函数测试一下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoadDatas</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    myCharacters = &#123;&#125;</span><br><span class=\"line\">    numLines, allLines = GetLines(<span class=\"string\">&quot;data.csv&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">--读第一行的键值</span></span><br><span class=\"line\">    count, myLabels = GetValues(allLines[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"comment\">--忽略第一行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">2</span>, numLines <span class=\"keyword\">do</span></span><br><span class=\"line\">        count, charHold = GetValues(allLines[index])</span><br><span class=\"line\">        myCharacters[index<span class=\"number\">-1</span>] = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> index2 = <span class=\"number\">1</span>, count <span class=\"keyword\">do</span></span><br><span class=\"line\">            myCharacters[index<span class=\"number\">-1</span>][index2] = charHold[index2]</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"comment\">--now print them</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">1</span>, <span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> index2 = <span class=\"number\">1</span>, <span class=\"built_in\">table</span>.<span class=\"built_in\">getn</span>(myLabels) <span class=\"keyword\">do</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(myLabels[index2], myCharacters[index][index2])</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"保存游戏数据\"><a href=\"#保存游戏数据\" class=\"headerlink\" title=\"保存游戏数据\"></a>保存游戏数据</h2><p>我们可以利用<code>lua</code>内建的<code>I/O</code>功能来处理数据输出。只要确保输出的数据是采用合适的语法，就可以使用<code>dofile()</code>载入数据了。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">save</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    myFile = <span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;save_data.lua&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> myFile ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"string\">&quot;-- 游戏数据保存文件&quot;</span>)</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;%s%s&quot;</span>, <span class=\"string\">&quot;-- 文件创建于: &quot;</span>, <span class=\"built_in\">os</span>.<span class=\"built_in\">date</span>()))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"string\">&quot;myValue = 5&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">io</span>.<span class=\"built_in\">close</span>(myFile)</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"载入保存的数据\"><a href=\"#载入保存的数据\" class=\"headerlink\" title=\"载入保存的数据\"></a>载入保存的数据</h2><p>利用<code>dofile()</code>操作就可以恢复游戏的数据了。</p>\n<h2 id=\"用lua处理log-筛取信息\"><a href=\"#用lua处理log-筛取信息\" class=\"headerlink\" title=\"用lua处理log,筛取信息\"></a>用lua处理log,筛取信息</h2><p>其实也就是一些<code>io</code>，<code>string</code>操作，没什么新的东西。<br>把旧的<code>log</code>中想的筛取信息，写到新的文件中，具体可以参加以下代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find_player</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> logfile = <span class=\"built_in\">assert</span>(<span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;房间201.log&quot;</span>,<span class=\"string\">&quot;r&quot;</span>)) <span class=\"comment\">--打开旧文件</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> findfile = <span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;find_player.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>) <span class=\"comment\">--打开新文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">local</span> text = logfile:<span class=\"built_in\">read</span>(<span class=\"string\">&quot;*all&quot;</span>) <span class=\"comment\">--读入所有内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">gmatch</span>(text,<span class=\"string\">&quot;.-,&quot;</span>) <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(w,<span class=\"string\">&quot;player userid = (%d+) level=(%d+) enter&quot;</span>) ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span> <span class=\"comment\">--查找写入相关内容到新文件</span></span><br><span class=\"line\">            findfile:<span class=\"built_in\">write</span>(w)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(w,<span class=\"string\">&quot;player userid = (%d+) leave&quot;</span>) ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">            findfile:<span class=\"built_in\">write</span>(w)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    logfile:<span class=\"built_in\">close</span>() <span class=\"comment\">--关闭文件</span></span><br><span class=\"line\">    findfile:<span class=\"built_in\">close</span>()</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">find_player()</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/64\">Estudiar es desconfiar de la inteligencia de tu compa?ero de al lado.</a></p>\n","tags":["lua"]},{"title":"使用pdb调试","url":"/post/27ac9cb.html","content":"<p><code>pdb</code>是<code>python</code>内置的一个调试库，是调试<code>python</code>代码的好帮手</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import pdb</span><br><span class=\"line\">pdb.set_trace()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(Pdb) h</span><br><span class=\"line\">Documented commands (type help &lt;topic&gt;):</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">EOF    bt         cont      enable  jump  pp       run      unt</span><br><span class=\"line\">a      c          continue  exit    l     q        s        until</span><br><span class=\"line\">alias  cl         d         h       list  quit     step     up</span><br><span class=\"line\">args   clear      debug     help    n     r        tbreak   w</span><br><span class=\"line\">b      commands   disable   ignore  next  restart  u        whatis</span><br><span class=\"line\">break  condition  down      j       p     return   unalias  where</span><br><span class=\"line\"></span><br><span class=\"line\">(Pdb) h c</span><br><span class=\"line\">c(ont(inue))</span><br><span class=\"line\">Continue execution, only stop when a breakpoint is encountered.</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/5\">Arroz que no se menea,se quema.</a></p>\n","tags":["python"]},{"title":"单例模式","url":"/post/f1601c3e.html","content":"<p>游戏中用到单例模式的例子很多，几乎适用于系统资源管理类中，如聊天，道具，日志等等。</p>\n<a id=\"more\"></a>\n\n<p>单例模式<code>（Singleton）</code>，保证了全局有且只有一个实例对象，保证自动地初始化该对象，使得程序在任何时候任何地方都可以访问、获取该对象。</p>\n<p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是让类自身保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p>\n<h2 id=\"基本类图\"><a href=\"#基本类图\" class=\"headerlink\" title=\"基本类图\"></a>基本类图</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/118207973-5b04c500-b498-11eb-907d-fb58ff9f1dfd.jpg\" alt=\"15102221-3340ff6dde434ed0b8f2a0a3340cfa88\"></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>这里把构造函数定义为<code>private</code>或<code>protected</code>，可以防止外界利用<code>new</code>创建此类实例。而且<code>GetInstance</code>是一个静态的函数，主要负责创建自己的唯一实例。而且<code>GetInstance</code>是一个静态的函数，主要负责创建自己的唯一实例。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取某个类的单例</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetClassInstance( classname ) static_cast<span class=\"meta-string\">&lt;classname*&gt;( CMySingleton&lt;classname&gt;::GetInstance() )</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单例模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMySingleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CMySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~CMySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取全局唯一实例对象。如果还没有创建，创建她。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            m_pInstance= <span class=\"keyword\">new</span> T();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 消除全局唯一实例对象。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_pInstance;</span><br><span class=\"line\">            m_pInstance = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> T* m_pInstance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但有时候，在多线程的程序中，多个线程同时访问<code>Singleton</code>，调用<code>GetInstance()</code>方法，会有可能造成创建多个实例。这时候就要给程序加锁。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取某个类的单例</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetClassInstance( classname ) static_cast<span class=\"meta-string\">&lt;classname*&gt;( CMySingleton&lt;classname&gt;::GetInstance() )</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单例模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMySingleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CMySingleton()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_init(&amp;m_mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~CMySingleton()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_destory(&amp;m_mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取全局唯一实例对象。如果还没有创建，创建她。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;m_mutex);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_pInstance == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                m_pInstance= <span class=\"keyword\">new</span> T();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;m_mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 消除全局唯一实例对象。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;m_mutex);<span class=\"comment\">//此处无需双重检测，因为delete null并不会导致bug.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_pInstance;</span><br><span class=\"line\">            m_pInstance = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> T* m_pInstance;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> m_mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个疑惑，为什么在<code>lock</code>后，还需要做一次<code>instance</code>实例是否存在的判断？<br>当<code>instance</code>为<code>null</code>并且同时有两个纯种调用<code>GetInstance()</code>方法时，它们将都可以通过第一重判断。然后由于<code>lock</code>机制，这两个线程则只有一个进入，另一个在外排队等候，必须要其中的一个进入并出来后，另一个才能进入。而此时如果没有了第二重的判断，则第一个线程创建了实例，而第二个线程还是可以继续再创建新的实例，这就没有达到单例的目的了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>单例模式有以下的特点： </p>\n<blockquote>\n<p>1 单例类只可有一个实例<br>2 单例类必须自己创建自己这惟一的实例<br>3 单例类必须给所有其他对象提供这一实例<br>4 在大并发程序里，可能有多个线程同时访问单例，所以一定要记得加锁</p>\n</blockquote>\n<p>多线程时：<br>单例模式主要有2中形式，一种是饿汉式，一种是懒汉式。<br>饿汉式：程序一加载单例模式就已经创建了，也就很饥饿嘛。因为是静态属性进行单例初始化，所以优点是线程是安全的，缺点是无论用户是否使用单例对象都会创建单例对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态属性类外初始化</span></span><br><span class=\"line\">Singleton_Hungry* Singleton_Hungry::singleton = <span class=\"keyword\">new</span> Singleton_Hungry;</span><br></pre></td></tr></table></figure>\n<p>懒汉式：当用户使用单例对象时，才去创建单例对象，所以很懒惰嘛。优点是用户不使用就不会创建对象，缺点是 当遇到多线程是，是线程不安全的，但是我们可以使用加强版的也就是线程安全的懒汉式。（上面用到的是这个）。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/33\">A otro perro con ese hueso.</a></p>\n","tags":["design"]},{"title":"反应器模式Reactor和Proactor","url":"/post/65736bcc.html","content":"<p>反应器模式（Reactor Pattern）是一种为处理服务请求并发提交到一个或者多个服务处理程序的事件设计模式。反应器模式与观察都模式相似。但观察者模式与单个事件源关联，而反应器模式则与多个事件源关联。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"先介绍两种高性能服务器模式Reactor、Proactor\"><a href=\"#先介绍两种高性能服务器模式Reactor、Proactor\" class=\"headerlink\" title=\"先介绍两种高性能服务器模式Reactor、Proactor\"></a>先介绍两种高性能服务器模式Reactor、Proactor</h2><p>这里用收快递作比喻。<code>reactor</code>就像快速能收的时候，快递员会通知你拿快递。<code>proactor</code>就像使用菜鸟驿站，<code>内核</code>帮你代收了这个快递。</p>\n<h3 id=\"Reactor模型\"><a href=\"#Reactor模型\" class=\"headerlink\" title=\"Reactor模型\"></a>Reactor模型</h3><p>在<code>Reactor</code>中实现读：</p>\n<blockquote>\n<p>1 向事件分发器注册事件回调<br>2 事件分发器等待事件<br>3 事件分发器调用之前注册的函数<br>4 在回调函数中读取数据，对数据进行后续处理<br><code>Reactor</code>模型实例：<code>libevent</code>，<code>Redis</code>、<code>ACE</code>。</p>\n</blockquote>\n<h3 id=\"Proactor模型\"><a href=\"#Proactor模型\" class=\"headerlink\" title=\"Proactor模型\"></a>Proactor模型</h3><p>在<code>Proactor</code>中实现读：</p>\n<blockquote>\n<p>1 向事件分发器注册事件回调<br>2 事件分发器等待事件发生<br>3 操作系统读取数据，并放入应用缓冲区，然后通知事件分发器<br>4 事件分发器调用之前注册的函数<br>5 在回调函数中对数据进行后续处理<br>Preactor模型实例：ASIO。</p>\n</blockquote>\n<h3 id=\"reactor和proactor的主要区别\"><a href=\"#reactor和proactor的主要区别\" class=\"headerlink\" title=\"reactor和proactor的主要区别\"></a>reactor和proactor的主要区别</h3><h4 id=\"主动和被动\"><a href=\"#主动和被动\" class=\"headerlink\" title=\"主动和被动\"></a>主动和被动</h4><p>以主动写为例：<br><code>Reactor</code>将<code>handle</code>放到<code>select()</code>，等待可写就绪，然后调用<code>write()</code>写入数据；写完处理后续逻辑。<br><code>Proactor</code>调用<code>aoi_write</code>后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑。</p>\n<p>可以看出，<code>Reactor</code>被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待<code>handler</code>可用时再进行操作。<br><code>Proactor</code>直接调用异步读写操作，调用完后立刻返回。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p><code>Reactor</code>实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。<br><code>Proactor</code>实现了一个主动的事件分离和分发模型，这种设计允许多个任务并发的执行，从而提高吞吐量，并可执行耗时长的任务（各个任务间互不影响）。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><code>Reactor</code>实现相对简单，对于耗时短的处理场景处理高效。操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性。事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁。事务分离，将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来。</p>\n<p><code>Proactor</code>性能更高，能够处理耗时长的并发场景。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p><code>Reactor</code>处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；<br><code>Proactor</code>实现逻辑复杂。依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如<code>windows IOCP</code>，但由于其<code>windows</code>系统用于服务器的局限性，目前应用范围较小。而<code>Unix/Linux</code>系统对纯异步的支持有限，应用事件驱动的主流还是通过<code>select/epoll</code>来实现。</p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p><code>Reactor</code>：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序。<br><code>Proactor</code>：异步接收和同时处理多个服务请求的事件驱动程序。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/20\">El amor todo lo puede.</a></p>\n","tags":["design"]},{"title":"堆与堆排序","url":"/post/d4ce124c.html","content":"<p>堆排序与快速排序，归并排序一样都是时间复杂度为<code>O(N*logN)</code>的几种常见排序方法。<br>堆排序是就地排序，辅助空间为<code>O(1）</code>。<br>它是不稳定的排序方法（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前和排序后他们的相对位置不发生变化）。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"什么是堆\"><a href=\"#什么是堆\" class=\"headerlink\" title=\"什么是堆\"></a>什么是堆</h2><p>堆通常是一个可以被看做一棵树的数组对象。满足下列性质：</p>\n<blockquote>\n<p>1.堆中某个节点的值总是不大于（或不小于）其父节点的值；<br>2.堆总是一棵完全二叉树（完全二叉树叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部，详见<a href=\"https://github.com/losophy/losophy.github.io/issues/30\">二叉树</a>中的完全二叉树）。</p>\n</blockquote>\n<h3 id=\"各种堆\"><a href=\"#各种堆\" class=\"headerlink\" title=\"各种堆\"></a>各种堆</h3><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。</p>\n<h2 id=\"堆的结构\"><a href=\"#堆的结构\" class=\"headerlink\" title=\"堆的结构\"></a>堆的结构</h2><p>一般都用数组来表示堆，i结点的父结点下标就为<code>(i – 1) / 2</code>。它的左右子结点下标分别为<code>2 * i + 1</code>和<code>2 * i + 2</code>。如第0个结点左右子结点下标分别为1和2。</p>\n<h2 id=\"堆的操作\"><a href=\"#堆的操作\" class=\"headerlink\" title=\"堆的操作\"></a>堆的操作</h2><h3 id=\"建立堆\"><a href=\"#建立堆\" class=\"headerlink\" title=\"建立堆\"></a>建立堆</h3><p>一般情况下，树并不满足堆的条件，通过重新排列元素，可以建立一棵”堆化“的树。如初始表：55 12 16，堆化后为：12 55 16。</p>\n<p>堆化数组：<br>关于怎样把一个数据进行堆化。可能很多人会想，要一个一个的从数组中取出数据来建立堆？不用。<br>比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int A[0] &#x3D; &#123;8,11,16,29,49,19,59,64,3,18&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果把这个数组看成是一棵树，那么它的叶子结点19,59,64,3,18都分别是一个合法的堆。只要把49开始向下调整就可以了。然后再取29，16，11，9结点分别作一次向下调整操作就可以了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//建立最小堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeMinHeap</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t\tMinHeapFixdown(a, i, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆的插入\"><a href=\"#堆的插入\" class=\"headerlink\" title=\"堆的插入\"></a>堆的插入</h3><p>每次插入都是将新数据放在数组最后。然后树被更新以恢复堆次序。如初始表：12 22 7，插入新数据后，数组为12 22 7 16，然后重排树的顺序，数组为12 16 7 22。<br>可以发现从这个新数据的父结点到根结点必然为一个有序的数列。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  新加入i结点  其父结点为(i - 1) / 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapFixup</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, temp;</span><br><span class=\"line\">\ttemp = a[i];</span><br><span class=\"line\">\tj = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;      <span class=\"comment\">//父结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[j] &lt;= temp)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ta[i] = a[j];     <span class=\"comment\">//把较大的子结点往下移动,替换它的子结点</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t\tj = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ta[i] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在最小堆中加入新的数据nNum</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapAddNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> nNum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    a[n] = nNum;</span><br><span class=\"line\">    MinHeapFixup(a, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆的删除\"><a href=\"#堆的删除\" class=\"headerlink\" title=\"堆的删除\"></a>堆的删除</h3><p>堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p>\n<p>如初始表：12 16 50 22，删除第0个数据后，数组为22 16 50 _，然后重排树的顺序，数组为16 22 50。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapFixdown</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemp = a[i];</span><br><span class=\"line\">\tj = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt; n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n &amp;&amp; a[j + <span class=\"number\">1</span>] &lt; a[j]) <span class=\"comment\">//在左右孩子中找最小的</span></span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[j] &gt;= temp)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ta[i] = a[j];     <span class=\"comment\">//把较小的子结点往上移动,替换它的父结点</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t\tj = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ta[i] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在最小堆中删除数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapDeleteNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSwap(a[<span class=\"number\">0</span>], a[n - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\tMinHeapFixdown(a, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>根据堆的性质，堆建好之后。堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。<br>由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinheapsortTodescendarray</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSwap(a[i], a[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\tMinHeapFixdown(a, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意使用最小堆排序后是递减数组，要得到递增数组，可以使用最大堆。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p><code>libevent</code>中的定时事件管理就是用一个以时间作为<code>key</code>的小根堆结构做的，放弃了原来的红黑树，大概就是堆比红黑树简单吧。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/17\">Borra con el codo lo que escribe con la mano.</a></p>\n","tags":["algorithm"]},{"title":"工厂模式","url":"/post/54788f73.html","content":"<p>现在的网游更新很快，要延长网络游戏生命周期的方法是，更新，不断地更新，不断的将新内容呈现于玩家面前。这要求游戏程序的设计要有弹性，代码的重用至关重要。</p>\n<a id=\"more\"></a>\n\n<p>使用工厂模式，把对象的创建和使用的过程分开，降低代码重复。因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。</p>\n<p>今天就说说游戏中的工厂模式。说到工厂模式，有简单工厂模式，工厂方法模式，抽象工厂模式。</p>\n<h2 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h2><p>简单工厂模式主要用于创建对象。新添加类时，不会影响以前的系统代码。核心思想是用一个工厂来根据输入的条件产生不同的类，然后根据不同类的virtual函数得到不同的结果。</p>\n<div class=\"note info\"><p>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。</p></div>\n\n<p>工厂类与基类为关联关系：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">COperation</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">GetResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;基类&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddOperation</span> :</span> <span class=\"keyword\">public</span> COperation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">GetResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;加法&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CCalculatorFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> COperation* <span class=\"title\">Create</span><span class=\"params\">(<span class=\"keyword\">char</span> cOperator)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">COperation* <span class=\"title\">CCalculatorFactory::Create</span><span class=\"params\">(<span class=\"keyword\">char</span> cOperator)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    COperation *oper;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cOperator)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">        oper=<span class=\"keyword\">new</span> AddOperation();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        oper=<span class=\"keyword\">new</span> AddOperation();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用者：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">COperation * op=CCalculatorFactory::Create(<span class=\"string\">&#x27;+&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;op-&gt;GetResult()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优：适用于不同情况创建不同的类时<br>劣：使用者必须要知道基类和工厂类，耦合性差</p>\n</blockquote>\n<h2 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h2><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeiFeng</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Sweep</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;雷锋扫地&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volenter</span>:</span> <span class=\"keyword\">public</span> LeiFeng</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Sweep</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;志愿者&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeiFengFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> LeiFeng* <span class=\"title\">CreateLeiFeng</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LeiFeng();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolenterFactory</span> :</span> <span class=\"keyword\">public</span> LeiFengFactory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> LeiFeng* <span class=\"title\">CreateLeiFeng</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Volenter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用者：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">VolenterFactory*sf = <span class=\"keyword\">new</span> VolenterFactory();</span><br><span class=\"line\">Volenter *s = sf-&gt;CreateLeiFeng();</span><br><span class=\"line\">s-&gt;Sweep();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优：修正了简单工厂模式中不遵守开放－封闭原则。工厂方法模式把选择判断移到了使用者去实现，如果想添加新功能就不用修改原来的类，直接修改使用者实现即可<br>劣：但简单工厂模式中不遵守开放－封闭原则。代码耦合性差</p>\n</blockquote>\n<h2 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h2><p>提供一个创建一系列相关或相互依赖的接口，而无需指定它们的具体类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IUser</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetUser</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertUser</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSqlUser</span> :</span> <span class=\"keyword\">public</span> IUser</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Sql User&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Sql User&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IUser* <span class=\"title\">CreateUser</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlFactory</span> :</span> <span class=\"keyword\">public</span> IFactory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IUser* <span class=\"title\">CreateUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span>  CSqlUser();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用者：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">IFactory* factory= <span class=\"keyword\">new</span> SqlFactory();</span><br><span class=\"line\">IUser* user=factory-&gt;CreateUser();</span><br><span class=\"line\">user-&gt;GetUser();</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/32\">Nunca es tarde para aprender. </a></p>\n","tags":["design"]},{"title":"快速排序","url":"/post/ff8068c0.html","content":"<p><strong>快速排序,说白了就是给基准数据找其正确索引位置的过程。</strong></p>\n<p>快速排序的基本思想是：通过一次排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一不部分的所有数据都要小，然后再按次方法对这两部分数据分别进行快速排序，整个排序过程可以递归或者非递归进行，以此达到整个数据变成有序序列。</p>\n<a id=\"more\"></a>\n\n<p><strong>像合并排序一样，快速排序也是基于分治模式的。</strong></p>\n<ul>\n<li>在数据集之中，选择一个元素作为”基准”（pivot）（第一个元素，最后一个元素，中间元素，随机选择）</li>\n<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边</li>\n<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止</li>\n</ul>\n<h2 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h2><p>现在有一个数据集{85, 24, 63, 45, 17, 31, 96, 50}<br>第一步，选择中间的元素45作为”基准”。（基准值可以任意选择，但是选择中间的值比较容易理解。）<br><img src=\"https://user-images.githubusercontent.com/11263320/133765468-6b67f824-70fd-44df-a331-68bf238094ec.png\" alt=\"bg2011040403\"><br>第二步，按照顺序，将每个元素与”基准”进行比较，形成两个子集，一个”小于45”，另一个”大于等于45”。<br><img src=\"https://user-images.githubusercontent.com/11263320/133765497-6e77b23d-f7e1-4f23-8f07-2d5bdd0b1a38.png\" alt=\"bg2011040403\"><br>第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<br><img src=\"https://user-images.githubusercontent.com/11263320/133765525-19c59cc5-a190-4d8e-b3d9-0fe3a7890390.png\" alt=\"bg2011040403\"><br><img src=\"https://user-images.githubusercontent.com/11263320/133765548-4d39b943-ae3b-4228-9173-02a8486516c4.png\" alt=\"bg2011040403\"><br><img src=\"https://user-images.githubusercontent.com/11263320/133765572-cafc96a3-ba2a-44a3-b938-ef1a44e3e4c8.png\" alt=\"bg2011040403\"><br><img src=\"https://user-images.githubusercontent.com/11263320/133765594-bd931926-4731-4585-869c-ac7edf32ada6.png\" alt=\"bg2011040403\"></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">quick_sort(array,left,right)</span><br><span class=\"line\">if left &lt; right then</span><br><span class=\"line\">        partitionIndex &#x3D; partition(array,left,right)</span><br><span class=\"line\">        quick_sort(array,left,partitionIndex -1)</span><br><span class=\"line\">        quick_sort(array,partitionIndex +1,right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组划分\"><a href=\"#数组划分\" class=\"headerlink\" title=\"数组划分\"></a>数组划分</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">partition(array,left,right)</span><br><span class=\"line\">    pivot &#x3D; left; &#x2F;&#x2F; 设定基准值（pivot）</span><br><span class=\"line\">    index &#x3D; pivot + 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    for i&#x3D;index to right</span><br><span class=\"line\">        if array[i]&lt;array[pivot] then </span><br><span class=\"line\">            exchange array[i]&lt;-&gt;array[index]</span><br><span class=\"line\">            index++</span><br><span class=\"line\"></span><br><span class=\"line\">    exchange array[pivot]&lt;-&gt;array[index - 1]</span><br><span class=\"line\">    return index - 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"选取枢纽元问题\"><a href=\"#选取枢纽元问题\" class=\"headerlink\" title=\"选取枢纽元问题\"></a>选取枢纽元问题</h2><h3 id=\"糟糕的方法\"><a href=\"#糟糕的方法\" class=\"headerlink\" title=\"糟糕的方法\"></a>糟糕的方法</h3><p>通常的做法是选择数组中第一个元素作为枢纽元，如果输入是随机的，那么这是可以接受的。但是，如果输入序列是预排序的或者是反序的，那么依据这样的枢纽元进行划分则会出现相当糟糕的情况，因为可能所有的元素不是被划入<code>S1</code>，就是都被划入<code>S2</code>中。 </p>\n<h3 id=\"较好的方法\"><a href=\"#较好的方法\" class=\"headerlink\" title=\"较好的方法\"></a>较好的方法</h3><p>一个比较好的做法是随机选取枢纽元，一般来说，这种策略是比较妥当的。 </p>\n<h3 id=\"三数取取中值方法\"><a href=\"#三数取取中值方法\" class=\"headerlink\" title=\"三数取取中值方法\"></a>三数取取中值方法</h3><p>例如，输入序列为  8, 1, 4, 9, 6, 3, 5, 2, 7, 0 ，它的左边元素为8，右边元素为0，中间位置<code>|_left+right）/2_|</code>上的元素为6，于是枢纽元为6.显然，使用三数中值分割法消除了预排序输入的坏情形，并且减少了快速排序大约5%（此为前人实验所得数据，无法具体证明）的运行时间。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/29\">Camarón que se duerme se lo lleva la corriente.</a></p>\n","tags":["algorithm"]},{"title":"把lua文本文件“编译”成二进制的文本","url":"/post/505cc6be.html","content":"<p>当你发布<code>lua</code>时，你或许不想用户看到你的<code>lua</code>源码，更不想用户修改你的<code>lua</code>代码和系统内部的秘密，那就需要用别的方式来发布。</p>\n<a id=\"more\"></a>\n\n<p>最终的文本文件可以通过lua作者提供的标准发布版本中的程序来执行。这个程序称做<code>luac.exe</code>，把<code>lua</code>文本文件“编译”成二进制的文件。这样就可以让别人更难知道你的游戏是如何运行的，采用了什么技术。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>当写好一个<code>lua</code>文件后，可以通过一个典型的编译命令去“编译”这个文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">F:\\&gt;luac -o helloworld helloworld.lua</span><br></pre></td></tr></table></figure>\n<p>这一行代码会编译<code>helloworld.lua</code>脚本并在<code>helloworld</code>文件中生成二进制数据。<br><code>lua</code>解析器并不关心你传给它的是文本文件还是二进制文件，也不关心扩展名是什么。<br><img src=\"https://user-images.githubusercontent.com/11263320/120053671-1fecbf00-c05e-11eb-85b0-c9688b83d4e3.jpg\" alt=\"20131001191038156\"><br>用这个方法，就不用担心别人可以看到你的代码了。</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>当<code>require</code>一个模块<code>mod.sub</code>时，<code>require</code>会用原始的模块名“mod.sub”作为<code>key</code>来查询<code>table package.loaded</code>和<code>package.preload</code>，其中，模块名中的点在搜索中没有任何意义。<br>当搜索一个定义子模块的文件时，<code>require</code>会将点转换为另一个字符，通常就是系统的目录分隔符。转换之后<code>require</code>就像搜索其他名称一样来搜索这个名称。<br>所以最好的方法是在编译完<code>lua</code>脚本后，也把二进制文件改成<code>.lua</code>后缀。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/65\">El que ríe ultimo no ríe mejor, simplemente es por que no entendió el chiste. </a></p>\n","tags":["lua"]},{"title":"数据包收发流程","url":"/post/45d71738.html","content":"<p>这里研究下数据包收发的流程。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"数据包接收流程\"><a href=\"#数据包接收流程\" class=\"headerlink\" title=\"数据包接收流程\"></a>数据包接收流程</h2><p>在Linux内核中，一个网络数据包从网卡接收到用户空间需要经过链路层、传输层和socket的处理，最终到达用户空间。<br><img src=\"https://user-images.githubusercontent.com/11263320/116520929-f0834f00-a905-11eb-9a46-770ea2825161.png\" alt=\"20160413204525768\"><br>以DM9000网卡为例，当网卡收到数据包以后，调用中断处理函数 dm9000_interrupt()，该函数检查中断处理类型，如果是接收数据包中断，则调用 dm9000_rx()函数接收数据包到内核空间。</p>\n<p>dm9000_rx()函数收到数据包完成后，内核会继续调用 netif_rx()函数，函数的作用是把网卡接收到数据提交给协议栈处理。</p>\n<p>协议栈使用 net_rx_action()函数处理接收数据包队列，该函数处理数据包后如果是 IP数据包则提交给ip_recv()函数处理。ip_recv()函数主要是检查一个数据包IP头的合法性，检查通过后交给 ip_local_deliver()和 ip_local_deliver_finish()函数处理，之所以分开处理是因为内核中有防火墙相关的代码需要动态加载到此处。</p>\n<p>IP头处理完毕后，以UDP数据包为例将交由 udp_recv()函数处理，与 ip_recv()函数类亿，该函数检查 UDP头的合法性，然后交给 udp_queue_recv()函数处理，最后提交给 sock_queue_recv()函数处理。</p>\n<p>数据包进入 socket部分的第一个函数是 skb_recv_datagram()，该函数从内核的 socket队列取出数据包，交给 socket部分的 udp_recvmsg()函数，该函数负责处理UDP的数据，sock_recvmsg()处理提交给 sock_read()函数。</p>\n<p>sock_read()函数读取接收到的数据缓冲，把数据返回给 sys_read()系统调用。sys_read()函数调用最终把数据复制到用户空间，供用户使得。</p>\n<h2 id=\"数据包发送流程\"><a href=\"#数据包发送流程\" class=\"headerlink\" title=\"数据包发送流程\"></a>数据包发送流程</h2><p>以UDP数据包发送流程为例，在DM9000网卡上如何发送一个数据包。<br><img src=\"https://user-images.githubusercontent.com/11263320/116521198-3c35f880-a906-11eb-980f-42d878a22d3c.png\" alt=\"20160413204525768\"><br>当用户空间的应用程序通过 socket函数 sento()发送一个UDP数据后，会调用内核空间的 sock_writev()函数，然后通过 sock_sendmsg()函数处理。sock_sendmsg()函数调用 inet_sendmsg()函数处理，inet_sendmsg()函数会把要发送的数据交给传输层的 udp_sendmsg()函数处理。</p>\n<p>udp_sendmsg()函数在数据前加入UDP头，然后把数据交给 ip_build_xmit()函数处理，该函数根据 socket提供的目的 IP和端口信息构造IP头，然后调用 output_maybe_reroute()函数处理。out_maybe_reroute()函数检查数据包是否需要经过路由，最后交给 ip_output()函数写入到发送队列，写入完成后由 ip_finish_output()函数处理后续工作。</p>\n<p>链路层的 dev_queue_xmit()函数处理发送队列，调用 DM9000网卡的发送数据包函数 dm9000_xmit()发送数据包，发送完毕后，调用 dm9000_xmit_done函数处理发送结果。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>Linux内核网络分层结构 详见：<a href=\"https://zhuanlan.zhihu.com/p/367055157\">https://zhuanlan.zhihu.com/p/367055157</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/124\">Los dos estamos muy enamorados: yo de él y él de otra. </a></p>\n","tags":["linux kernel"]},{"title":"文章版面美化","url":"/post/b1bd8617.html","content":"<p>之前写博客受制于编辑器的限制，版面经常脏、乱、差。自从用了<code>markdown</code>后，看见清新的版面，写文章的动力增加不了少。以下是一些版面美化的方法。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>一段话作一个概括。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"特出的语句\"><a href=\"#特出的语句\" class=\"headerlink\" title=\"特出的语句\"></a>特出的语句</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;note warning&quot;&gt;&lt;p&gt;这里是警告。&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;note info&quot;&gt;&lt;p&gt;这里是提示&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<div class=\"note warning\"><p>这里是警告。</p></div>\n<div class=\"note info\"><p>这里是提示</p></div>\n\n<h2 id=\"字符高亮处理\"><a href=\"#字符高亮处理\" class=\"headerlink\" title=\"字符高亮处理\"></a>字符高亮处理</h2><p>背景加深<code>root\\server\\websocket</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#96;root\\server\\websocket&#96;</span><br></pre></td></tr></table></figure>\n<h2 id=\"列举\"><a href=\"#列举\" class=\"headerlink\" title=\"列举\"></a>列举</h2><p>最好能用 <code>&gt; </code></p>\n<blockquote>\n<ul>\n<li>整理知识</li>\n<li>发布日记</li>\n<li>撰写发布技术文稿</li>\n<li>撰写发布学术论文</li>\n</ul>\n</blockquote>\n<h2 id=\"注意标点符号\"><a href=\"#注意标点符号\" class=\"headerlink\" title=\"注意标点符号\"></a>注意标点符号</h2><p>不要太懒而不加句号。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>参考<a href=\"https://www.zybuluo.com/mdeditor\">mdeditor</a></p>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/137\">El español es divertido y fácil de aprender.</a></p>\n","tags":["blog"]},{"title":"日志分析工具","url":"/post/fce0b72c.html","content":"<p>这里记录下日志分析的工具。</p>\n<a id=\"more\"></a>\n\n<p>grep查找, sed 编辑, awk 根据内容分析并处理.</p>\n<ul>\n<li>grep(关键字: 截取)<br>文本搜集工具, 结合正则表达式非常强大</li>\n<li>awk(关键字:分析&amp;处理)<br>一行一行的分析处理</li>\n<li>sed(关键字: 编辑)<br>以行为单位的文本编辑工具 sed可以直接修改档案<br>sed 是一种新型的，非交互式的编辑器。它能执行与编辑器 vi 和 ex 相同的编辑任务。sed 编辑器没有提供交互式使用方式，使用者只能在命令行输入编辑命令、指定文件名，然后在屏幕上查看输出。 sed 编辑器没有破坏性，它不会修改文件，除非使用 shell 重定向来保存输出结果。默认情况下，所有的输出行都被打印到屏幕上。</li>\n<li>sort命令<br>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。’</li>\n</ul>\n<h2 id=\"根据日志查看一个服务的qps\"><a href=\"#根据日志查看一个服务的qps\" class=\"headerlink\" title=\"根据日志查看一个服务的qps\"></a>根据日志查看一个服务的qps</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tail -f XXX.log</span><br></pre></td></tr></table></figure>\n<p>命令：tail -f XXX.log | grep recommend.components.KeywordService | cut -d’ ‘ -f2 | cut -d’:’ -f3 | uniq -c<br>说明：取增量 | 一个请求取一行 | 把时间截取出来 | 把秒数截取出来 | 去重取计数</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/27\">La inteligencia me persigue, pero yo soy más rápido.</a></p>\n","tags":["linux"]},{"title":"查看linux的情况","url":"/post/fbc79433.html","content":"<p>在系统维护的过程中，随时可能有需要查看系统的情况，这里记录下查看系统情况的操作。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"查看进程内存占用情况\"><a href=\"#查看进程内存占用情况\" class=\"headerlink\" title=\"查看进程内存占用情况\"></a>查看进程内存占用情况</h2><p>(1)top<br>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。<br>以直接使用<code>top</code>命令后，查看<code>%MEM</code>（内存）的内容。可以选择按进程查看或者按用户查看，如想查看<code>oracle</code>用户的进程内存使用情况的话可以使用如下的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> top -u oracle</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"与ps的不同\"><a href=\"#与ps的不同\" class=\"headerlink\" title=\"与ps的不同\"></a>与ps的不同</h3><p><code>ps</code>看到的是命令执行瞬间的进程信息，而<code>top</code>可以持续的监视。<code>ps</code>只是查看进程，而<code>top</code>还可以监视系统性能，如平均负载，<code>cpu</code>和内存的消耗。</p>\n<h2 id=\"查看存储空间\"><a href=\"#查看存储空间\" class=\"headerlink\" title=\"查看存储空间\"></a>查看存储空间</h2><p>先看看根目录下面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -sh /* </span><br></pre></td></tr></table></figure>\n<p>下面这条命令就是显示所有隐藏文件和非隐藏文件的大小并根据占用空间排序的语句</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -sh .[!.]* * | sort -hr  </span><br></pre></td></tr></table></figure>\n<h2 id=\"查看系统信息\"><a href=\"#查看系统信息\" class=\"headerlink\" title=\"查看系统信息\"></a>查看系统信息</h2><p>查看发行版信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">lsb_release -a</span><br></pre></td></tr></table></figure>\n<p>查看内核信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">uname -a</span><br></pre></td></tr></table></figure>\n<h2 id=\"打印某个程序的线程栈\"><a href=\"#打印某个程序的线程栈\" class=\"headerlink\" title=\"打印某个程序的线程栈\"></a>打印某个程序的线程栈</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pstack $pid</span><br></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/36\">No hay peor sordo que el que no quiere oír.</a></p>\n","tags":["linux"]},{"title":"泛型编程与STL","url":"/post/21810799.html","content":"<p>这里记录下泛型编程与STL。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"泛型编程\"><a href=\"#泛型编程\" class=\"headerlink\" title=\"泛型编程\"></a>泛型编程</h2><p>定义抽象的concepts，并根据抽象的concepts来撰写算法与数据结构，是泛型编程的本质。</p>\n<h3 id=\"运用STL时的几个最重要的观念\"><a href=\"#运用STL时的几个最重要的观念\" class=\"headerlink\" title=\"运用STL时的几个最重要的观念\"></a>运用STL时的几个最重要的观念</h3><ol>\n<li>所谓使用STL，就是去扩充它。</li>\n<li>STL的算法和容器是独立分离的。</li>\n<li>无须继承。</li>\n<li>抽象化并不意味效率低。</li>\n</ol>\n<p>STL所实现的，是依据泛型思维架设起来的一个概念结构。这个以抽象概念为主体而非以实际类为主体的结构，形成了一个严谨的接口标准。在此接口下，任何组件都有最大的独立性，并以所谓迭代器胶合起来，或以所谓配接器互相配接，或以所谓仿函数动态选择某种策略。</p>\n<h3 id=\"六大组件交互关系\"><a href=\"#六大组件交互关系\" class=\"headerlink\" title=\"六大组件交互关系\"></a>六大组件交互关系</h3><p>Container通过Allocator取得数据储存空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同的策略变化，Adapter可以修饰或套接Functor。</p>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>Iterator可说是STL最重要的一个创新发明，它使”将算法与其相关数据结构的关系切割分离“一事变得可能。</p>\n<p>何为Concept？<br>如果Concept既非class，也非function或template，那么它是什么？有三种方式可以了解Concepts，这些方式一开始似乎大不相同，但是最后证明都是相通的。这三种方式有助于了解泛型算法的一些重要观点。</p>\n<p>第一，Concept可以想象是一组型别条件。如果说型别Ｔ是Concept Ｃ的一个model，则Ｔ必 须满足Ｃ的所有条件。描述某个型别所必须具备的性质几乎是最容易具体指明Concept的方式了。<br>第二，Concept可以想成是型别的集合。举例来说，Concept input iterator可涵盖char<em>、int</em>、node* 等型别。如果型别Ｔ是Concept C 的model，意思便是说Ｔ隶属于Ｃ所代表的那个型别集合。由于集合中的所有型别都满足那一系列条件，其实是以不同的角度看待同一件事情。<br>第三，Concept可以想象成是一组合法程序。依次定义，那么像input iterator这样的Concept，其重要性在于find以及其他许多算法都会用到它。这个Concept自身包含iterator及那些算法共有的性质。这种定义似乎比前两者更加抽象，但是却很重要，因为就某种意义来说，这是三中方法中最实用的。这也是新的概念的发掘方法。是的，我们并非藉由写下一组需求条件来发掘和描述新 的概念，而是藉由定义特别的算法并研究模板参数如何运行于这些算法身上的过程来完成。我们研究find，过程中导出了 input iterator。本书其他各种概念同样是肇因与算法。 </p>\n<p>Iterator是指针的概括物，它们是”用来指向其他对象“的一种对象。<br>Iterator对于泛型编程之所以重要，原因是它是算法与数据结构之间的接口。<br>1、Input Iterator ：只允许作为输入，也就是只读（Read Only）<br>2、Output Iterator ：只允许作为输出，也就是只写（Write Only）<br>3、Forward Iterator ：允许读写，但只能做前向移动<br>4、Bidirectional Iterator ：允许读写，可以做双向移动<br>5、Random Access Iterator ：允许读写，可以任意移动，可作（P+N和P-N）、（P[n]）、（P1-P2）、（P1 &lt; P2）</p>\n<h2 id=\"Function-objects\"><a href=\"#Function-objects\" class=\"headerlink\" title=\"Function objects\"></a>Function objects</h2><p>Function objects是非常一般化的概念，它们可以将任何种类的行为参数化。几乎任何算法都能以“将其行为的某一部分抽象化为function object”的方式来加以一般化。</p>\n<h2 id=\"Containers\"><a href=\"#Containers\" class=\"headerlink\" title=\"Containers\"></a>Containers</h2><p>STL预定义的所有container classes都是一种Forward Container，其中大多数甚至是Bidirectional Container。有一些像block之类的container classes，则属于Random Access Container。</p>\n<h2 id=\"Allocators\"><a href=\"#Allocators\" class=\"headerlink\" title=\"Allocators\"></a>Allocators</h2><p>很多containers以动态方式分配内存（但非全部如此，例如block就不是）。配置器，它代表一种特定内存模型，并提供一种抽象概念，以便将对内存的申请最终转变为对内存的直接调用。<br>STL提供了很多泛型容器，如vector，list和map。程序员在使用这些容器时只需关心何时往容器内塞对象，而不用关心如何管理内存，需要用多少内存，这些STL容器极大地方便了C++程序的编写。</p>\n<h2 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h2><p>各种常用算法，如sort,search,copy,erase。从实现的角度讲，STL算法是一种function template。</p>\n<h2 id=\"Adapters\"><a href=\"#Adapters\" class=\"headerlink\" title=\"Adapters\"></a>Adapters</h2><p>一种用来修饰容器或仿函数或迭代器接口的东西。<br>改变functor接口者，称为function adapter;<br>改变contrainer接口者，称为contrainer adapter;<br>改变iterator接口者，称为iterator adapter。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/92\">Los estudios son la luz del mundo…. deja los estudios y ahorra energía.</a></p>\n","tags":["cpp"]},{"title":"游戏中的Lua","url":"/post/c5fcde43.html","content":"<p><code>lua</code>作为一种脚本语言，可以快速地开发游戏的原型。提高游戏的开发效率。最熟悉不过的就是作为魔兽世界、博德之门、愤怒的小鸟等游戏的脚本语言。</p>\n<a id=\"more\"></a>\n\n<p>但是，具体来说，<code>lua</code>在游戏中可以做什么呢？<br>在游戏中，<code>lua</code>可以用来完成下面这些工作：</p>\n<blockquote>\n<p>● 编辑游戏的用户界面<br>● 定义、存储和管理基础游戏数据<br>● 管理实时游戏事件<br>● 创建和维护开发者友好的游戏存储和载入系统<br>● 编写游戏游戏的人工智能系统<br>● 创建功能原型，可以之后用高性能语言移植</p>\n</blockquote>\n<h2 id=\"编辑游戏界面\"><a href=\"#编辑游戏界面\" class=\"headerlink\" title=\"编辑游戏界面\"></a>编辑游戏界面</h2><p>进行界面布局、管理用户输入并且输出游戏数据。提高了界面设计的灵活性，为程序员节省不少时间。</p>\n<h2 id=\"管理游戏数据\"><a href=\"#管理游戏数据\" class=\"headerlink\" title=\"管理游戏数据\"></a>管理游戏数据</h2><p><code>Lua</code>可以让游戏存储系统更为简单，可以令<code>Lua</code>更方便地和数据库交互。方便按照需要修改、增加和缩减游戏数据。<code>Lua</code>本身并没有可以直接访问外部数据库的能力，但可以用<code>C/C++</code>开发访问数据库的组件，然后再利用<code>LuaGlue</code>函数整合该组件来达到目的。</p>\n<h2 id=\"处理游戏事件\"><a href=\"#处理游戏事件\" class=\"headerlink\" title=\"处理游戏事件\"></a>处理游戏事件</h2><p>其实就是利用<code>lua</code>与<code>C/C++</code>交互，在<code>C/C++</code>开发的事件系统中，用<code>Lua</code>来接收和处理这些事件。</p>\n<h2 id=\"保存和读取游戏状态\"><a href=\"#保存和读取游戏状态\" class=\"headerlink\" title=\"保存和读取游戏状态\"></a>保存和读取游戏状态</h2><p>利用<code>Lua</code>标准的输入/输出函数，编写一个函数来保存游戏数据到可执行的<code>Lua</code>脚本中是很好的方法。而且还可以利用脚本编译函数来为游戏数据加密。</p>\n<h2 id=\"游戏中的人工智能\"><a href=\"#游戏中的人工智能\" class=\"headerlink\" title=\"游戏中的人工智能\"></a>游戏中的人工智能</h2><p>这里说的人工智能不是那些对性能要求很好的算法。像路径寻找这些数据运算量很大的工作，计算机需要反复测试可能的路径来寻找最短或者最直接的路径，就需要用到<code>C/C++</code>这类底层语言来实现。但一些依赖有限的数据集合和参数的人工智能就更适合用<code>Lua</code>来编写了。</p>\n<h2 id=\"快速构建原型\"><a href=\"#快速构建原型\" class=\"headerlink\" title=\"快速构建原型\"></a>快速构建原型</h2><p><code>Lua</code>是构建可移植的核心游戏功能原型的不错工具。在游戏开发中，可以先用<code>Lua</code>构建出算法的结构，如果碰到有高性能需求的函数就可以用底层语言来实现。</p>\n<h2 id=\"动态加载调试\"><a href=\"#动态加载调试\" class=\"headerlink\" title=\"动态加载调试\"></a>动态加载调试</h2><p>这也是脚本的一个普遍功能，只需要应用重新加载脚本，就可以完成修改，调试的时候不用再等系统“慢慢编译了”。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>Lua</code>的优点是可以快速地编写简单的游戏模型，并快速验证和迭代想法。在游戏开发领域，<code>Lua</code>和<code>C/C++</code>是一个功能十分强大的组合，使游戏开发更加随心所欲。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/62\">La lengua no tiene hueso, pero corta lo más grueso. </a></p>\n","tags":["lua"]},{"title":"用插件将issues内容转换成博客的内容","url":"/post/7533a366.html","content":"<p>之前已经用<a href=\"https://github.com/losophy/losophy.github.io/issues/6\">Hexo+GitHub Pages博客搭建</a>。</p>\n<p><code>Hexo</code>默认文章存放于<code>source</code>分支，没有评论系统，不过都可以通过插件进行扩展。本文介绍如何将<code>hexo</code>的文章与评论存放于<code>Github Issue</code>中（<code>issue</code>内容为博客内容，<code>issue</code>评论为博客评论）。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"使用github-issue存放文章\"><a href=\"#使用github-issue存放文章\" class=\"headerlink\" title=\"使用github issue存放文章\"></a>使用github issue存放文章</h2><p>这种方案主要优点是，可以专心写博客系统，不用关注<code>Hexo</code>本身内容。还可以直接使用<code>GitHub</code>的图床（已墙），使用GitHub图床非常简单，把图片文件拖到编辑框就行了。</p>\n<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-migrator-github-issue --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"导入文章\"><a href=\"#导入文章\" class=\"headerlink\" title=\"导入文章\"></a>导入文章</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo migrate github-issue 你的Github用户名/你存放hexo的仓库名</span><br></pre></td></tr></table></figure>\n<p>然后生成部署即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用github-issue存放评论\"><a href=\"#使用github-issue存放评论\" class=\"headerlink\" title=\"使用github issue存放评论\"></a>使用github issue存放评论</h2><p>首先在<code>GitHub</code>上注册新应用，链接：<a href=\"https://github.com/settings/applications/new\">https://github.com/settings/applications/new</a> 。<br><img src=\"https://user-images.githubusercontent.com/11263320/117932622-27f4f100-b333-11eb-9e6f-27257ce39dc0.png\" alt=\"p22o24 md\"><br>参数说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Application name： # 应用名称，随意losophy.github.io</span><br><span class=\"line\">Homepage URL： # 网站URL，如https:&#x2F;&#x2F;losophy.github.io</span><br><span class=\"line\">Application description # 描述，随意</span><br><span class=\"line\">Authorization callback URL：# 网站URL，https:&#x2F;&#x2F;losophy.github.io</span><br></pre></td></tr></table></figure>\n<p>点击注册后，页面跳转如下，其中<code>Client ID</code>和<code>Client Secret</code>在后面的配置中需要用到，到时复制粘贴即可：<br><img src=\"https://user-images.githubusercontent.com/11263320/117932970-a356a280-b333-11eb-8da1-b0d0cc4c0bdd.png\" alt=\"p22o24 md\"><br>最新一版的<code>NexT</code>主题已经集成<code>gitalk</code>评论系统。<br>在主题配置文件<code>next/_config.yml</code>中更改如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Gitalk</span><br><span class=\"line\"># For more information: https:&#x2F;&#x2F;gitalk.github.io, https:&#x2F;&#x2F;github.com&#x2F;gitalk&#x2F;gitalk</span><br><span class=\"line\">gitalk:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  github_id: losophy # GitHub repo owner</span><br><span class=\"line\">  repo: comments # Repository name to store issues</span><br><span class=\"line\">  client_id: ******************** # GitHub Application Client ID</span><br><span class=\"line\">  client_secret: ********************* # GitHub Application Client Secret</span><br><span class=\"line\">  admin_user: losophy # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class=\"line\">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class=\"line\">  # Gitalk&#39;s display language depends on user&#39;s browser or system environment</span><br><span class=\"line\">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class=\"line\">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class=\"line\">  language: zh-CN</span><br></pre></td></tr></table></figure>\n<p><code>enable</code>打开<code>gitalk</code>，<code>github_id</code>是<code>github</code>帐号，<code>repo</code>填评论填充的仓库（因为本仓库<code>issues</code>用作转化博客内容，所以我另外起了一个仓库专门存评论），<code>client_id</code>填上图的<code>Client ID</code>，<code>client_secret</code>填上图的<code>Client Secret</code>，<code>admin_user</code>填<code>github</code>帐号。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/8\">Recuerda siempre que tu propia resolución de triunfar es más importante que cualquier otra cosa.</a></p>\n","tags":["blog"]},{"title":"线程锁","url":"/post/71bad47a.html","content":"<p>这里介绍下线程锁的各类。常见的有：互斥锁、自旋锁、读写锁和条件变量。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"自旋锁（spinlock）\"><a href=\"#自旋锁（spinlock）\" class=\"headerlink\" title=\"自旋锁（spinlock）\"></a>自旋锁（spinlock）</h2><p><strong>一条线程加锁锁住临界区，另一条线程尝试访问该临界区的时候，会发生阻塞，但是不会进入休眠状态，并且不断轮询该锁，直至原来锁住临界区的线程解锁。</strong><br>具体说明：假设一台机器上有两个核心<code>core0</code>和<code>core1</code>，现在有线程<code>A、B、C</code>，此时<code>core0</code>运行线程<code>A</code>，<code>core1</code>运行线程<code>B</code>，此时线程<code>B</code>调用<code>spin lock</code>锁住临界区，当线程<code>A</code>尝试访问该临界区时，因为<code>B</code>已经加锁，此时线程<code>A</code>会阻塞，并且不断轮询该锁，不会交出<code>core0</code>的使用权，当线程<code>B</code>释放锁时，<code>A</code>开始执行临界区逻辑。</p>\n<h3 id=\"skynet中自实现的自旋锁\"><a href=\"#skynet中自实现的自旋锁\" class=\"headerlink\" title=\"skynet中自实现的自旋锁\"></a>skynet中自实现的自旋锁</h3><p><a href=\"https://gist.github.com/losophy/3958fefacaf6e3bb45373f107149f782\">spinlock.h</a></p>\n<h2 id=\"互斥锁（mutex-lock）\"><a href=\"#互斥锁（mutex-lock）\" class=\"headerlink\" title=\"互斥锁（mutex lock）\"></a>互斥锁（mutex lock）</h2><p><strong>一条线程加锁锁住临界区，另一条线程尝试访问改临界区的时候，会发生阻塞，并进入休眠状态。临界区是锁<code>lock</code>和<code>unlock</code>之间的代码片段，一般是多条线程能够共同访问的部分。</strong><br>具体说明：假设一台机器上的<code>cpu</code>有两个核心<code>core0</code>和<code>core1</code>，现在有线程<code>A、B、C</code>，此时<code>core0</code>运行线程<code>A</code>，<code>core1</code>运行线程<code>B</code>，此时线程<code>B</code>使用<code>Mutex</code>锁，锁住一个临界区，当线程<code>A</code>试图访问该临界区时，因为线程<code>B</code>已经将其锁住，因此线程<code>A</code>被挂起，进入休眠状态，此时<code>core0</code>进行上下文切换，将线程<code>A</code>放入休眠队列中，然后<code>core0</code>运行线程<code>C</code>，当线程<code>B</code>完成临界区的流程并执行解锁之后，线程<code>A</code>又会被唤醒，<code>core0</code>重新运行线程<code>A</code>。</p>\n<h3 id=\"自旋锁和互斥锁的选择\"><a href=\"#自旋锁和互斥锁的选择\" class=\"headerlink\" title=\"自旋锁和互斥锁的选择\"></a>自旋锁和互斥锁的选择</h3><p>对自旋锁和互斥锁的选择是要根据得到锁的耗时来的，若果当得到锁后，需要执行大量的操作，一般选用互斥锁，若得到锁后，进行很少量的操作，一般选择自旋锁，因为执行的操作短，那么忙等的开销总体还是小于内核态和用户态切换带来的开销的。</p>\n<h2 id=\"条件变量（condition-variables）\"><a href=\"#条件变量（condition-variables）\" class=\"headerlink\" title=\"条件变量（condition variables）\"></a>条件变量（condition variables）</h2><p>假设<code>A,B,C</code>三条线程，其中<code>B,C</code>线程加了<code>condwait</code>锁并投入睡眠，而<code>A</code>线程则在某个条件触发时，会通过<code>signal</code>通知<code>B,C</code>线程，从而唤醒<code>B</code>和<code>C</code>线程。</p>\n<h3 id=\"互斥锁为什么还要和条件变量配合使用\"><a href=\"#互斥锁为什么还要和条件变量配合使用\" class=\"headerlink\" title=\"互斥锁为什么还要和条件变量配合使用\"></a>互斥锁为什么还要和条件变量配合使用</h3><p>mutex体现的是一种竞争，我离开了，通知你进来。<br>cond体现的是一种协作，我准备好了，通知你开始吧。<br>互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。</p>\n<h2 id=\"读写锁（readers–writer-lock）\"><a href=\"#读写锁（readers–writer-lock）\" class=\"headerlink\" title=\"读写锁（readers–writer lock）\"></a>读写锁（readers–writer lock）</h2><p>某线程加读取锁时，允许其他线程以读模式进入，此时如果有一个线程尝试以写模式访问临界区时，该线程会被阻塞，而其后尝试以读方式访问该临界区的线程也会被阻塞<br>读写锁适合在读远大于写的情形中使用</p>\n<h3 id=\"skynet中自实现的读写锁\"><a href=\"#skynet中自实现的读写锁\" class=\"headerlink\" title=\"skynet中自实现的读写锁\"></a>skynet中自实现的读写锁</h3><p><a href=\"https://gist.github.com/losophy/32dbde601728b2a595c4e7dd814d63d2\">rwlock.h</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/139\">El que tiene tejados de vidrio, no tire piedras a los de su vecino.</a></p>\n","tags":["linux"]},{"title":"网络游戏服务器开发注意事项","url":"/post/71a672e8.html","content":"<p>这里记录下网络游戏服务器开发中，要注意的事项。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"逻辑问题\"><a href=\"#逻辑问题\" class=\"headerlink\" title=\"逻辑问题\"></a>逻辑问题</h2><p>==判断限制太死了，少用点<br>使用while true时，可能造成死循环，应该添加保险措施，必现因为逻辑问题导致的死循环</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> weaponType ~= sword <span class=\"keyword\">do</span></span><br><span class=\"line\">    check = check + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">1000</span> &lt; check <span class=\"keyword\">then</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>递归调用也有可能会出现堆栈溢出，也需要加上保险措施<br>禁止广泛采用param arg等表示某一类参数，统一加上对应的模块或功能特性声明，比如：CreateRole(roleParam)</p>\n<h2 id=\"热更\"><a href=\"#热更\" class=\"headerlink\" title=\"热更\"></a>热更</h2><p>local不能热更，用local时，要考虑会不会有热更的情况</p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>协议字段要小，省宽带<br>协议接口目录统一，方便热更新</p>\n<h2 id=\"检查验收\"><a href=\"#检查验收\" class=\"headerlink\" title=\"检查验收\"></a>检查验收</h2><p>查看传入参数判空，长命名，默认值，参数检测，snsaerro中断会发生的问题<br>用户登录时，不要有中断发生<br>用户登录时，所有下推合成一个包发送</p>\n<p>所有的物品接口是遵循这个规律的（物品先扣再发）：<br>1.检测<br>2.扣钱、资源<br>3.发物品,修改数据</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h3><p>odm不要设计成第一层就用map，后续加字段会很困难</p>\n<h3 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h3><p>数据库用cache，定时存入<br>因为mysql写入的数据都是冷数据（只增，部分读），所以处理比较简单<br>（核查记录，邮件）这些业务交给网页部门，服务器拿网页接口</p>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>配置文件转换时，不要出现值为2.0这种错误</p>\n<h3 id=\"编写validate-lua\"><a href=\"#编写validate-lua\" class=\"headerlink\" title=\"编写validate.lua\"></a>编写validate.lua</h3><p>每新增配置表，策划有可能会配置错误的项目都需要添加检测。确保跑validate时，不会因配置错误，而出现程序出错。</p>\n<h2 id=\"国际化\"><a href=\"#国际化\" class=\"headerlink\" title=\"国际化\"></a>国际化</h2><h3 id=\"时间戳\"><a href=\"#时间戳\" class=\"headerlink\" title=\"时间戳\"></a>时间戳</h3><p>因为不同语言的版本会共用一套代码，不同时区发时间会有问题(linux时区)，同步会有问题，改用发时间戳</p>\n<h3 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h3><p>代码中不要写死中文，使用配置表映射编码。</p>\n<h2 id=\"计量\"><a href=\"#计量\" class=\"headerlink\" title=\"计量\"></a>计量</h2><p>尽是用‱，少用%</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/102\">A falta de pan, tortillas.Lack of bread, tortillas. </a></p>\n","tags":["design"]},{"title":"虚拟文件系统","url":"/post/ab453ce.html","content":"<p>它是允许和操作系统使用不同的文件系统实现的接口。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"分层结构\"><a href=\"#分层结构\" class=\"headerlink\" title=\"分层结构\"></a>分层结构</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/107371276-124b1200-6b1f-11eb-9cb4-41adcfc6297a.png\" alt=\"屏幕快照 2021-02-09 下午9 37 21\"></p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>对所有不同文件系统的抽象。</p>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><blockquote>\n<ul>\n<li>提供相同的文件和文件系统接口</li>\n<li>管理所有文件和文件系统关联的数据结构</li>\n<li>高效查询例程，遍历文件系统</li>\n<li>与特定文件系统模块的交互</li>\n</ul>\n</blockquote>\n<h2 id=\"文件系统基本数据结构\"><a href=\"#文件系统基本数据结构\" class=\"headerlink\" title=\"文件系统基本数据结构\"></a>文件系统基本数据结构</h2><h3 id=\"文件卷控制块（Unix-superblock）\"><a href=\"#文件卷控制块（Unix-superblock）\" class=\"headerlink\" title=\"文件卷控制块（Unix: superblock）\"></a>文件卷控制块（Unix: superblock）</h3><blockquote>\n<ul>\n<li>每个文件系统一个</li>\n<li>文件系统详细信息</li>\n<li>块、块大小、空余块、计数/ 指针等</li>\n</ul>\n</blockquote>\n<h3 id=\"文件控制块（Unix-vnode或者inode）\"><a href=\"#文件控制块（Unix-vnode或者inode）\" class=\"headerlink\" title=\"文件控制块（Unix: vnode或者inode）\"></a>文件控制块（Unix: vnode或者inode）</h3><blockquote>\n<ul>\n<li>每个文件一个</li>\n<li>文件详细信息</li>\n<li>访问权限、拥有者、大小、数据块位置等</li>\n</ul>\n</blockquote>\n<h3 id=\"目录项（Linux-dentry）\"><a href=\"#目录项（Linux-dentry）\" class=\"headerlink\" title=\"目录项（Linux: dentry）\"></a>目录项（Linux: dentry）</h3><blockquote>\n<ul>\n<li>每个目录项一个（目录和文件）</li>\n<li>将目录项数据结构及树型布局编码成树型数据结构</li>\n<li>指向文件控制块、父目录、子目录等</li>\n</ul>\n</blockquote>\n<h2 id=\"文件系统的组织视图\"><a href=\"#文件系统的组织视图\" class=\"headerlink\" title=\"文件系统的组织视图\"></a>文件系统的组织视图</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/107373169-2f80e000-6b21-11eb-91ea-5e68e24bac7e.png\" alt=\"屏幕快照 2021-02-09 下午9 52 38\"></p>\n<h2 id=\"文件系统的存储\"><a href=\"#文件系统的存储\" class=\"headerlink\" title=\"文件系统的存储\"></a>文件系统的存储</h2><p>持久存储在外存中，存储设备的数据块中。<br>当需要时加载进内存：</p>\n<blockquote>\n<ul>\n<li>卷控制模块：当文件系统挂载时进入内存</li>\n<li>文件控制块：当文件被访问时进入内存</li>\n<li>目录节点：在遍历一个文件路径时进入内存</li>\n</ul>\n</blockquote>\n<h3 id=\"文件系统的存储视图\"><a href=\"#文件系统的存储视图\" class=\"headerlink\" title=\"文件系统的存储视图\"></a>文件系统的存储视图</h3><p><img src=\"https://user-images.githubusercontent.com/11263320/107374773-ea5dad80-6b22-11eb-9710-f59ed5a38305.png\" alt=\"屏幕快照 2021-02-09 下午10 04 13\"></p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p>21.4 虚拟文件系统 详见：<a href=\"https://www.youtube.com/watch?v=q5oejwc-azM\">https://www.youtube.com/watch?v=q5oejwc-azM</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/18\">Dame pan y dime tonto.Give me bread and call me a fool.</a></p>\n","tags":["linux kernel"]},{"title":"计算机接收数据的过程","url":"/post/51f04a0c.html","content":"<p>这里记录下计算机接收数据的过程。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"从硬件的角度看计算机接收网络数据\"><a href=\"#从硬件的角度看计算机接收网络数据\" class=\"headerlink\" title=\"从硬件的角度看计算机接收网络数据\"></a>从硬件的角度看计算机接收网络数据</h2><p>下图是一个典型的计算机结构图，计算机由CPU、存储器（内存）、网络接口等部件组成。<br><img src=\"https://user-images.githubusercontent.com/11263320/116509560-1e609780-a8f6-11eb-882b-543b7e234e62.png\" alt=\"20190506110916170\"><br>展示了网卡接收数据的过程：<br>1.网卡收到网线传来的数据<br>2.硬件电路的传输（这个过程涉及到DMA传输、IO通路选择等硬件有关的知识）<br>3.写入到内存中的某个地址上<br><img src=\"https://user-images.githubusercontent.com/11263320/116510009-d4c47c80-a8f6-11eb-80b3-82986a308f68.jpg\" alt=\"v2-6827b63c9fb42823dcd1913ea5433b15_720w\"><br>通过硬件传输，网卡接收的数据存放到内存中。操作系统就可以去读取它们。</p>\n<h2 id=\"CPU如何知道接收了数据\"><a href=\"#CPU如何知道接收了数据\" class=\"headerlink\" title=\"CPU如何知道接收了数据\"></a>CPU如何知道接收了数据</h2><p>要理解这个问题，要先了解一个概念——中断。<br>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供CPU运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。<br>一般而言，由硬件产生的信号需要cpu立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu理应中断掉正在执行的程序，去做出响应；当cpu完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。<br><img src=\"https://user-images.githubusercontent.com/11263320/116510411-71871a00-a8f7-11eb-889f-cc6fdf8ccf65.png\" alt=\"v2-89a9490f1d5c316167ff4761184239f7_720w\"><br>以键盘为例，当用户按下键盘某个按键时，键盘会给cpu的中断引脚发出一个高电平。cpu能够捕获这个信号，然后执行键盘中断程序。下图展示了各种硬件通过中断与cpu交互。<br><img src=\"https://user-images.githubusercontent.com/11263320/116510698-e6f2ea80-a8f7-11eb-9fc5-189e9548a6f7.jpg\" alt=\"v2-c756381c0f63f9104f9102d280759d22_720w\"><br>现在可以回答本节提出的问题了：当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过cpu执行网卡中断程序（网络设备驱动程序+内核网络设备处理程序）去处理数据。详见<a href=\"https://github.com/losophy/losophy.github.io/issues/124\">数据包收发流程</a>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>如果这篇文章说不清epoll的本质，那就过来掐死我吧！详见：<a href=\"https://zhuanlan.zhihu.com/p/63179839\">https://zhuanlan.zhihu.com/p/63179839</a></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/123\">Me revienta que hablen cuando interrumpo.</a></p>\n","tags":["linux kernel"]},{"title":"调试nodejs程序","url":"/post/f006d367.html","content":"<p>写程序时免不了遇到<code>bug</code>，而当<code>bug</code>发生以后，除了抓耳挠腮之外，一个常用的技术是单步调试。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"命令行调试\"><a href=\"#命令行调试\" class=\"headerlink\" title=\"命令行调试\"></a>命令行调试</h2><p><code>Node.js</code>支持命令行下的单步调试。下面是一个简单的程序：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&#x27;world&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hello &#x27;</span> + x + a);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">c(b);</span><br></pre></td></tr></table></figure>\n<p>在命令行下执行<code>node debug debug.js</code>，将会启动调试工具：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt; debugger listening on port 5858</span><br><span class=\"line\">connecting... ok</span><br><span class=\"line\">break in &#x2F;home&#x2F;byvoid&#x2F;debug.js:1</span><br><span class=\"line\">1 var a &#x3D; 1;</span><br><span class=\"line\">2 var b &#x3D; &#39;world&#39;;</span><br><span class=\"line\">3 var c &#x3D; function(x) &#123;</span><br><span class=\"line\">debug&gt;</span><br></pre></td></tr></table></figure>\n<p>这样就打开了一个<code>Node.js</code>的调试终端，我们可以用一些基本的命令进行单步跟踪调试。<br><img src=\"https://user-images.githubusercontent.com/11263320/117808221-31c51880-b28f-11eb-8a12-c90b9389d1fb.JPG\" alt=\"捕1获\"></p>\n<h2 id=\"在VS-Code中调试\"><a href=\"#在VS-Code中调试\" class=\"headerlink\" title=\"在VS Code中调试\"></a>在VS Code中调试</h2><p>用<code>VS Code</code>打开程序根目录，按<code>F5</code>调试，选择<code>chrome</code>，打开<code>launch.json</code>。<br>修改<code>launch.json</code>文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class=\"line\">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class=\"line\">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class=\"line\">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">    &quot;configurations&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;type&quot;: &quot;node&quot;,</span><br><span class=\"line\">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">            &quot;name&quot;: &quot;node&quot;,</span><br><span class=\"line\">            &quot;console&quot;:&quot;integratedTerminal&quot;,</span><br><span class=\"line\">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;node_modules&#x2F;hexo&#x2F;node_modules&#x2F;hexo-cli&#x2F;bin&#x2F;hexo&quot;,</span><br><span class=\"line\">            &quot;args&quot;: [</span><br><span class=\"line\">                &quot;s&quot;,</span><br><span class=\"line\">                &quot;--debug&quot;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置<code>console</code>为<code>integratedTerminal</code>，调试时的输出就会打印到<code>VS code</code>控制台中。不配置该项时默认为<code>internalConsole</code>，并不会将控制台输出打印到<code>VS Code</code>控制台中，在调试过程中看不到任何输出。<br>配置<code>program</code>为需要启动的应用，这里图为<code>hexo</code>，这个<code>Hexo</code>是通过<code>npm</code>安装的，需要配置相对于<code>Hexo</code>目录的相对路径。<br>配置<code>args</code>为传递的参数，也就是运行程序指令时输入的各个选项。这里是用<code>Hexo</code>的指令，选择”g”,”s”或者”d”，都是可以的。<br><img src=\"https://user-images.githubusercontent.com/11263320/117828780-b9695200-b2a4-11eb-9e57-e74b73d0fb86.JPG\" alt=\"捕获\"></p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/136\"> La amistad borra la lejanía.</a></p>\n","tags":["nodejs"]},{"title":"软件设计那些事","url":"/post/51b53ddf.html","content":"<p>这里记录下软件设计的那些事。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"软件生命周期-Systems-Development-Life-Cycle\"><a href=\"#软件生命周期-Systems-Development-Life-Cycle\" class=\"headerlink\" title=\"软件生命周期(Systems Development Life Cycle )\"></a>软件生命周期(Systems Development Life Cycle )</h2><p>需求分析-&gt;设计-&gt;编码-&gt;测试-&gt;发布-&gt;维护</p>\n<h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>这阶段是软件开发的最初阶段，也是最重要的阶段。明确的需求，可以在之后的开发中，少走弯路。<br>这个阶段也要和需求方共同讨论，有时候也需要开会，集中各参与者的意见。</p>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><p>这阶段要对整个软件系统进行设计，确定要用什么技术，什么方法，怎样的设计模式。</p>\n<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>将软件设计的结果转换成计算机可运行的程序代码。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>对软件进行测试，黑白盒测试。</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>测试没有问题后，就可以上线发布。是一些新功能，或者是一些bug补丁。</p>\n<h3 id=\"维护\"><a href=\"#维护\" class=\"headerlink\" title=\"维护\"></a>维护</h3><p>软件维护是软件生命周期中持续时间最长的阶段。软件的维护包括纠错性维护和改进性维护两个方面。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/14\">Querer es poder.</a></p>\n","tags":["design"]},{"title":"进程间通信ipc、线程间通信","url":"/post/3c2943c4.html","content":"<p>进程间通信<code>(IPC,Inter-Process Communication)</code>指至少两个进程或线程间传送数据或信号的一些技术或方法。</p>\n<a id=\"more\"></a>\n\n<p>进程是计算机系统分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。（但是采用了某种形式的内核开销，降低了性能）。</p>\n<h2 id=\"常用的进程间通信\"><a href=\"#常用的进程间通信\" class=\"headerlink\" title=\"常用的进程间通信\"></a>常用的进程间通信</h2><h3 id=\"管道（包括无名管道和命名管道）\"><a href=\"#管道（包括无名管道和命名管道）\" class=\"headerlink\" title=\"管道（包括无名管道和命名管道）\"></a>管道（包括无名管道和命名管道）</h3><p>管道是一种通信机制，通常用于进程间的通信（也可通过<code>socket</code>进行网络通信），它表现出来的形式将前面每一个进程的输出<code>（stdout）</code>直接作为下一个进程的输入<code>（stdin）</code>。<br>无名管道，是<code>UNIX</code>系统<code>IPC</code>最古老的形式。基于管道文件操作。<br>管道通信特点是：速度慢，容量有限，只有父子进程能通讯（<code>FIFO</code>：任何进程间都能通讯，但速度慢）。</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>是消息的链接表，存放在内核中。特点是容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</p>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>与已经介绍过的<code>IPC</code>结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<br>特点是不能传递复杂消息，只能用来同步。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>指两个或多个进程共享一个给定的存储区。是最快的一种<code>IPC</code>，因为进程是直接对内存进行存取。信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。<br>特点是能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</p>\n<h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p><code>socket</code>一般指套接字。所谓套接字<code>(Socket)</code>，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。<br>特点是<code>I/O</code>复用提供一种能力，这种能力使得当一个<code>I/O</code>条件满足时，进程能够及时得到这个信息。适合（远程过程调用、集群）。</p>\n<h2 id=\"几种线程间的通信机制\"><a href=\"#几种线程间的通信机制\" class=\"headerlink\" title=\"几种线程间的通信机制\"></a>几种线程间的通信机制</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>同一进程下的线程共享全局变量、静态变量等数据。线程之间的通信更方便。</p>\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h3><blockquote>\n<ul>\n<li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li>\n<li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li>\n<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</li>\n</ul>\n</blockquote>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/24\">A los tontos no les dura el dinero.</a></p>\n","tags":["linux kernel"]},{"title":"进程，线程，协程","url":"/post/efd5c410.html","content":"<p>多进程多线程已经是老生常谈了，本文主要介绍进程、线程和协程三者之间的区别。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>进程是资源（<code>CPU</code>、内存等）分配的基本单位，它是程序执行时的一个实例。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是程序执行时的最小单位，它是进程的一个执行流，是<code>CPU</code>调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈、局部变量和指令指针。</p>\n<h3 id=\"线程和进程的区别和优劣\"><a href=\"#线程和进程的区别和优劣\" class=\"headerlink\" title=\"线程和进程的区别和优劣\"></a>线程和进程的区别和优劣</h3><blockquote>\n<ul>\n<li>进程是资源分配的最小单位，线程是程序执行的最小单位</li>\n<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此<code>CPU</code>切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多</li>\n<li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式<code>(IPC)</code>进行。不过如何处理好同步与互斥是编写多线程程序的难点</li>\n<li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间</li>\n</ul>\n</blockquote>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>从概念上讲线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作地运行。就是说，<strong>一个具有多个协同程序的程序在任意时刻只能运行一个协同程序</strong>，并且正在运行的协同程序只会在其显式地要求挂起<code>(suspend)</code>时，它的执行才会暂停。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/34\">Desgracia compartida, menos sentida.</a></p>\n","tags":["linux"]},{"title":"连接Github与本地","url":"/post/e5f6b383.html","content":"<p>Using the SSH protocol, you can connect and authenticate to remote servers and services. With SSH keys, you can connect to GitHub without supplying your username and personal access token at each visit.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"配置用户名和邮箱\"><a href=\"#配置用户名和邮箱\" class=\"headerlink\" title=\"配置用户名和邮箱\"></a>配置用户名和邮箱</h2><p>首先输入下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;你的github用户名&quot;</span><br><span class=\"line\">git config --global user.email &quot;你的github注册邮箱&quot;</span><br></pre></td></tr></table></figure>\n<p>用户名和邮箱根据你注册<code>github</code>的信息自行修改。</p>\n<h2 id=\"上传SSH-key\"><a href=\"#上传SSH-key\" class=\"headerlink\" title=\"上传SSH key\"></a>上传SSH key</h2><p>生成密钥<code>SSH key</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;你的注册邮箱&quot;</span><br></pre></td></tr></table></figure>\n<p>打开<code>github</code>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便。<br><code>cmd</code>中cat ~/.ssh/id_rsa.pub<br>将输出的内容复制到框中，点击确定保存。<br>输入<code>ssh -T git@github.com</code>，出现你的用户名，那就成功了。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/1\">El mejor tiempo para plantar un árbol fue hace veinte años. El segundo mejor tiempo es AHORA.</a></p>\n","tags":["git"]},{"title":"TCP","url":"/post/24cb124c.html","content":"<p>在 TCP 通讯中主要有<strong>连接的建立</strong>、<strong>数据的传输</strong>、<strong>连接的关闭</strong>三个过程！每个过程完成不同的工作，而且序列号和确认号在每个过程中的变化都是不同的。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"TCP-建立连接\"><a href=\"#TCP-建立连接\" class=\"headerlink\" title=\"TCP 建立连接\"></a>TCP 建立连接</h2><p>TCP 建立连接，也就是我们常说的三次握手，它需要三步完成。在 TCP 的三次握手中，发送第一个 SYN 的一端执行的是主动打开。而接收这个 SYN 并发回下一个 SYN 的另一端执行的是被动打开。</p>\n<div class=\"note info\"><p>SYN：同步序列编号（Synchronize Sequence Numbers）。SYN用于建立TCP/IP时的握手连接，由客户端想服务端发送SYN，服务端向客户端发送SYN+ACK响应报文,客户端向服务端发送一个ACK响应报文，然后建立一个完整的连接,即三次握手。</p></div>\n\n<p>这里以客户端向服务器发起连接来说明。<br>1.客户端向服务器发送一个同步数据包请求建立连接，该数据包中，初始序列号（ISN）是客户端随机产生的一个值，确认号是 0；</p>\n<div class=\"note info\"><p>初始化序号（Initial Sequence Number），每次建立连接前重新初始化一个序列号，为了通信双方能够根据序号将不属于本连接的报文段丢弃。</p></div>\n<div class=\"note info\"><p>确认号（acknowledgement number）,指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</p></div>\n\n<p>2.服务器收到这个同步请求数据包后，会对客户端进行一个同步确认。这个数据包中，序列号（ISN）是服务器随机产生的一个值，确认号是客户端的初始序列号+1</p>\n<p>3.客户端收到这个同步确认数据包后，再对服务器进行一个确认。该数据包中，序列号是上一个同步请求数据包中的确认号值，确认号是服务器的初始序列号+1。</p>\n<p>初始序列号（ISN）随时间而变化的，而且不同的操作系统也会有不同的实现方式，所以每个连接的初始序列号是不同的。 TCP 连接两端会在建立连接时，交互一些信息，如窗口大小、 MSS 等，以便为接着的数据传输做准备。<br><img src=\"https://user-images.githubusercontent.com/11263320/119770861-5f48cd80-beef-11eb-8ccc-61b1595eeb07.JPG\" alt=\"TCPConnect\"></p>\n<h3 id=\"窗口字段\"><a href=\"#窗口字段\" class=\"headerlink\" title=\"窗口字段\"></a>窗口字段</h3><p>用于接收端通知发送端：接收端当前能够接收的字节数（即当前允许发送端发送的字节数）。接收端通告的窗口大小变成0，发送端会发一个1字节的段（就是下一字节的数据，没新的数据段发送的时候发一个ack）（TCP零窗口探测），强制接收端重新宣告下一个期望的字节和窗口大小。如果接收方回复窗口大小仍然为零，则发送方的探测定时器加倍。没有收到ACK时，发送探测包的最大次数之后连接超时。</p>\n<h2 id=\"TCP-传输数据\"><a href=\"#TCP-传输数据\" class=\"headerlink\" title=\"TCP 传输数据\"></a>TCP 传输数据</h2><p>在 TCP 建立连接后，就可以开始传输数据了。 TCP 工作在全双工模式，它可以同时进行双向数据传输。这里为了简化，我们只谈服务器向客户端发送数据的情况，而客户端向服务器发送数据的原理和它是类似的，这里便不重复说明。<br>服务器向客户端发送一个数据包后，客户端收到这个数据包后，会向服务器发送一个确认数据包<br>1.发送数据：服务器向客户端发送一个带有数据的数据包，该数据包中的序列号和确认号与建立连接第三步的数据包中的序列号和确认号相同；<br>2.确认收到：客户端收到该数据包，向服务器发送一个确认数据包，该数据包中，序列号是为上一个数据包中的确认号值，而确认号为服务器发送的上一个数据包中的序列号+所该数据包中所带数据的大小。<br>数据分段中的序列号可以保证所有传输的数据按照正常的次序进行重组，而且通过确认保证数据传输的完整性<br><img src=\"https://user-images.githubusercontent.com/11263320/119771680-a71c2480-bef0-11eb-96eb-436715435192.jpg\" alt=\"115A462I-0\"></p>\n<h2 id=\"TCP-关闭连接\"><a href=\"#TCP-关闭连接\" class=\"headerlink\" title=\"TCP 关闭连接\"></a>TCP 关闭连接</h2><p>前面我们提到，建立一个连接需要 3 个步骤，但是关闭一个连接需要经过 4 个步骤。因为TCP 连接是全双工的工作模式，所以每个方向上需要单独关闭。在 TCP 关闭连接时，首先关闭的一方（即发送第一个终止数据包的）将执行主动关闭，而另一方（收到这个终止数据包的）再执行被动关闭。<br>关闭连接的 4 个步骤如下：<br>1.服务器完成它的数据发送任务后，会主动向客户端发送一个终止数据包，以关闭在这个方向上的 TCP 连接。该数据包中，序列号为客户端发送的上一个数据包中的确认号值，而确认号为服务器发送的上一个数据包中的序列号+该数据包所带的数据的大小；<br>2.客户端收到服务器发送的终止数据包后，将对服务器发送确认信息，以关闭该方向上的 TCP 连接。这时的数据包中，序列号为第 1 步中的确认号值，而确认号为第 1 步的数据包中的序列号+1<br>3.同理，客户端完成它的数据发送任务后，就也会向服务器发送一个终止数据包，以关闭在这个方向上的 TCP 连接，该数据包中，序列号为服务器发送的上一个数据包中的确认号值，而确认号为客户端发送的上一个数据包中的序列号+该数据包所带数据的大小；<br>4.服务器收到客户端发送的终止数据包后，将对客户端发送确认信息，以关闭该方向上的 TCP 连接。这时在数据包中，序列号为第 3 步中的确认号值，而确认号为第 3 步数据包中的序列号+1；<br><img src=\"https://user-images.githubusercontent.com/11263320/119774108-41ca3280-bef4-11eb-9679-99cf0584ab87.png\" alt=\"281600391879667\"></p>\n<div class=\"note warning\"><p>因为 FIN 和 SYN 一样，也要占一个序号。理论上服务器在 TCP 连接关闭时发送的终止数据包中，只有终止位是置 1，然后客户端进行确认。但是在实际的 TCP 实现中，在终止数据包中，确认位和终止位是同时置为 1 的，确认位置为 1 表示对最后一次传输的数据进行确认，终止位置为 1 表示关闭该方向的 TCP 连接</p></div>\n\n<h3 id=\"为什么需要TIME-WAIT？\"><a href=\"#为什么需要TIME-WAIT？\" class=\"headerlink\" title=\"为什么需要TIME_WAIT？\"></a>为什么需要TIME_WAIT？</h3><p>TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。<br>描述过程：<br>Client调用close()函数，给Server发送FIN，请求关闭连接；Server收到FIN之后给Client返回确认ACK，同时关闭读通道（不清楚就去看一下shutdown和close的差别），也就是说现在不能再从这个连接上读取东西，现在read返回0。此时Server的TCP状态转化为CLOSE_WAIT状态。<br>Client收到对自己的FIN确认后，关闭 写通道，不再向连接中写入任何数据。<br>接下来Server调用close()来关闭连接，给Client发送FIN，Client收到后给Server回复ACK确认，同时Client关闭读通道，进入TIME_WAIT状态。<br>Server接收到Client对自己的FIN的确认ACK，关闭写通道，TCP连接转化为CLOSED，也就是关闭连接。<br>Client在TIME_WAIT状态下要等待最大数据段生存期的两倍，然后才进入CLOSED状态，TCP协议关闭连接过程彻底结束。</p>\n<p>以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。<br>从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。</p>\n<p>原因有二：<br>一、保证TCP协议的全双工连接能够可靠关闭<br>二、保证这次连接的重复数据段从网络中消失</p>\n<p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>\n<p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2>","tags":["linux kernel"]},{"title":"docker一些操作","url":"/post/aac66c62.html","content":"<p>用了<code>Docker</code>我们就可以更加专注地开发业务代码了，不用因安装环境而浪费时间。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"利用docker运行各软件\"><a href=\"#利用docker运行各软件\" class=\"headerlink\" title=\"利用docker运行各软件\"></a>利用docker运行各软件</h2><p>使用<code>docker</code>运行各软件，然后暴露其端口。这里做，就不用担心不同版本的问题了。也让主机更干净。</p>\n<h3 id=\"docker-run-mongo\"><a href=\"#docker-run-mongo\" class=\"headerlink\" title=\"docker run mongo\"></a>docker run mongo</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 27017:27017 --name mongo -d mongo:4.4.6</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-run-redis\"><a href=\"#docker-run-redis\" class=\"headerlink\" title=\"docker run redis\"></a>docker run redis</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 6379:6379 --name redis -d redis:6.2.3</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地开发的程序\"><a href=\"#本地开发的程序\" class=\"headerlink\" title=\"本地开发的程序\"></a>本地开发的程序</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it -p 3000:3000 --name bbs --link redis-server:redis --link mongo bbs /bin/bash</span><br></pre></td></tr></table></figure>\n<h2 id=\"进入容器内部\"><a href=\"#进入容器内部\" class=\"headerlink\" title=\"进入容器内部\"></a>进入容器内部</h2><p>如果想在启动容器的时候，就进入容器内部，可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run -it  容器名 镜像名 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>\n<p>-i：以交互模式运行容器，通常与 -t 同时使用；<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>\n<h2 id=\"利用docker-save保存镜像\"><a href=\"#利用docker-save保存镜像\" class=\"headerlink\" title=\"利用docker save保存镜像\"></a>利用docker save保存镜像</h2><p>docker commit新镜像之后删除旧镜像，并不能成功，镜像存在依赖。<br>我们可以用以下方法删除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker save -o nginx.tar nginx2:latest</span><br><span class=\"line\">docker rmi fff815b9c91f b175e7467d66</span><br><span class=\"line\">docker load -i .&#x2F;nginx.tar</span><br></pre></td></tr></table></figure>\n<p>保存的tar文件也可以移动到其它电脑。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/141\">Aprender no es otra cosa que acordarse.</a></p>\n","tags":["docker"]},{"title":"skynet集群","url":"/post/1ddabdda.html","content":"<p>skynet 支持两种集群模式。master/slave和cluster。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"为什么要cluster\"><a href=\"#为什么要cluster\" class=\"headerlink\" title=\"为什么要cluster\"></a>为什么要cluster</h2><p>除非你的业务本来就是偏重 IO 的，也就是你根本不打算利用单台硬件的多核心优势来增强计算力，抹平本机和网络的差异是没有意义的。无论硬件怎样发展，你都不可能看到主板上的总线带宽和 TCP 网络的带宽工作在同一数量级的那一天，因为这是物理基本规律决定的。<br>当你的业务需要高计算力，把 actor 放在一台机器上才可以正常的发挥 CPU 能力去合作；如果你的系统又需要分布式扩展，那么一定是有很多组独立无关的业务可以平行处理。这两类工作必须由构架系统的人自己想清楚，规划好怎么部署这些 actor ，而不可能随手把 actor 扔在分布式系统中，随便挑台硬件运行就够了。<br>恰巧网络游戏服务就是这种业务类型。多组服务器、多个游戏场景之间交互很弱，但其中的个体又需要很强的计算力。这就是 skynet 切合的应用场景。</p>\n<h2 id=\"同一进程下的服务通讯和跨网络的通讯到底有什么不同\"><a href=\"#同一进程下的服务通讯和跨网络的通讯到底有什么不同\" class=\"headerlink\" title=\"同一进程下的服务通讯和跨网络的通讯到底有什么不同\"></a>同一进程下的服务通讯和跨网络的通讯到底有什么不同</h2><p>1.进程内的内存是共享的，skynet 是用 lua 沙盒来隔离服务状态，但是可以通过 C 库来绕过沙盒直接沟通。如果一个服务生产了大量数据，想传给您一个服务消费，在同一进程下，是不必经过序列化过程，而只需要通过消息传递内存地址指针即可。这个优化存在 O(1) 和 O(n) 的性能差别，不可以无视。</p>\n<p>2.同一进程内的服务从底层角度来说，是同生共死的。Lua 的沙盒可以确保业务错误能够被正确捕获，而非常规代码不可控的错误，比如断电、网络中断，不会破坏掉系统的一部分而另一部分正常工作。所以，如果两个 actor 你确定在同一进程内，那么你可以像写常规程序那样有一个共识：如果我这个 actor 可以正常工作，那么对端协作的另一个 actor 也一样在正常工作。就等同于，我这个函数在运行，我当然可以放心的调用进程内的另一个函数，你不会担心调用函数不存在，也不会担心它永远不返回或是收不到你的调用。这也是为什么我们不必为同一进程内的服务间 RPC 设计超时的机制。不用考虑对方不相应你的情况，可以极大的简化编写程序的人的心智负担。比如，常规程序中，就没有（非 IO 处理的）程序库的 API 会在调用接口上提供一个超时参数。</p>\n<p>3.同一进程内所有服务间的通讯公平共享了同一内存总线的带宽。这个带宽很大，和 CPU 的处理速度是匹配的。可以基本不考虑正常业务下的服务过载问题。也就是说，大部分情况下，一个服务能生产数据的速度不太会超过另一个服务能消费数据的速度。这种情况会造成消费数据的服务过载，是我们使用 skynet 框架这几年来 bug 出现最多的类型。而跨越网络时，不仅会因为生产速度和消费速度不匹配造成过载，更会因为传递数据的带宽和生产速度不匹配而过载。如果让开发者时刻去考虑，这些数据是投递到本地、那些数据是投递到网络，那么已经违背了抹平本地和网络差异这点设计初衷。</p>\n<h2 id=\"master-slave-模式（局域网）\"><a href=\"#master-slave-模式（局域网）\" class=\"headerlink\" title=\"master/slave 模式（局域网）\"></a>master/slave 模式（局域网）</h2><p><strong>当单台机器的处理能力达到极限后，可以考虑通过内置的 master/slave 机制来扩展。</strong> master与每个slave相连，每个slave又两两互连。master同时会充当一个中心节点的作用，用来协调各个slave的工作。</p>\n<p>每个 skynet 进程都是一个 slave 节点。但其中一个 slave 节点可以通过配置 standalone 来多启动一个 cmaster 服务，用来协调 slave 组网。<strong>对于每个 slave 节点，都内置一个 harbor 服务用于和其它 slave 节点通讯</strong>。在 master/slave 模式中，节点内的消息通讯和节点间的通讯是透明的。skynet 核心会根据目的地址的 harbor id 来决定是直接投递消息，还是把消息转发给 harbor 服务。<br><img src=\"https://user-images.githubusercontent.com/11263320/130348405-e26204ec-2846-4e28-9846-23929a5f5974.png\" alt=\"network\"></p>\n<p>这种模式的缺点也非常明显：它被设计为对单台物理机计算能力不足情况下的补充。所以忽略了系统一部分故障的处理机制，而把整个网络视为一体。即，整个网络中任意一个节点都必须正常工作，节点间的联系也不可断开。这就好比你一台物理机上如果插了多块 CPU ，任意一个损坏都会导致整台机器不能正常工作一样。所以，不要把这个模式用于跨机房的组网。所有 slave 节点都应该在同一局域网内（最好在同一交换机下）。不应该把系统设计成可以任意上线或下线 slave 的模式。slave 的组网机制也限制了这一点。如果一个 slave 意外退出网络，这个 harbor id 就被废弃，不可再使用。这样是为了防止网络中其它服务还持有这个断开的 slave 上的服务地址；而一个新的进程以相同的 harbor id 接入时，是无法保证旧地址和新地址不重复的。</p>\n<p>master/slave最大的缺点在于不能很好的处理某个节点异常断开的情况。底层的 harbor 假设机器间是可靠连接，不会断开。而一旦内部网络不健康，很可能会导致整个系统无法正常工作。<strong>它的设计目的并不是为了提供弹性扩展的分布式方案，而是为了突破单机性能上限的问题。</strong></p>\n<h2 id=\"cluster-模式\"><a href=\"#cluster-模式\" class=\"headerlink\" title=\"cluster 模式\"></a>cluster 模式</h2><p>skynet 提供了更具弹性的集群方案。它可以和 master/slave 共存。也就是说，你可以部署多组 master/slave 网络，然后再用 cluster 将它们联系起来。</p>\n<p>它的工作原理是这样的：<br><strong>在每个 skynet 节点（单个进程）内，启动一个叫 clusterd 的服务。所有需要跨进程的消息投递都先把消息投递到这个服务上，再由它来转发到网络。</strong></p>\n<p>Cluster 是去中心化的，所以需要在每台机器上都放置一份配置文件（通常是相同的）。通过调用 cluster.reload 可以让本进程重新加载配置。如果你修改了每个节点名字对应的地址，那么 reload 之后的请求都会发到新的地址。而之前没有收到回应的请求还是会在老地址上等待。如果你老的地址已经无效（通常是主动关闭了进程）那么请求方会收到一个错误。</p>\n<p>这种做法要求明确本地服务的调用和远程调用的区别。虽然远程调用的性能可能略低，但由于不像底层 harbor 那样把本地、远程服务的区别透明化，反倒不容易出问题。且 tcp 连接使用了更健壮的 socketchannel ，一旦连接断开，发起 rpc 的一方会收到异常，也可以重试（自动重连）。</p>\n<hr>\n<p><a href=\"https://github.com/losophy/losophy.github.io/issues/77\">Toda cuestion tiene dos puntos de vista: El equivocado y el nuestro. </a></p>\n","tags":["skynet"]},{"title":"冒泡排序","url":"/post/14e6f1eb.html","content":"<p>冒泡排序作为最简单的算法之一，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作就是重复地比较元素，直到元素们都落座了正确的位置，序列排序就算完成。<br>简而言之，将每次相邻两个关键字进行比较（0与1,1与2依次比较大小），小数上浮，大数下沉，每趟排序找出最大的数换到最右边。<br>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，“blue、blue~”<br><img src=\"https://user-images.githubusercontent.com/11263320/133589954-b5d713e5-ce0a-400f-8098-7880b1542ed8.gif\" alt=\"c84bc96ad1ae5c83768f55cc0afc90af5503\"></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span> <span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[], <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> outer, inner;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (outer=<span class=\"number\">0</span>; outer&lt;len<span class=\"number\">-1</span>; outer++) <span class=\"comment\">/* 外循环为排序趟数，len个数进行len-1趟 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (inner=<span class=\"number\">0</span>; inner&lt;len<span class=\"number\">-1</span>-outer; inner++) &#123; <span class=\"comment\">/* 内循环为每趟比较的次数，第i趟比较len-i次 */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">array</span>[inner] &gt; <span class=\"built_in\">array</span>[inner+<span class=\"number\">1</span>]) &#123; <span class=\"comment\">/* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */</span></span><br><span class=\"line\">                temp = <span class=\"built_in\">array</span>[inner];</span><br><span class=\"line\">                <span class=\"built_in\">array</span>[inner] = <span class=\"built_in\">array</span>[inner+<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"built_in\">array</span>[inner+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["algorithm"]},{"title":"分布式事务","url":"/post/cdcc4eae.html","content":"<h2 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h2><p>原子性<br>要么全部执行成功，要么全部执行失败。</p>\n<p>一致性<br>执行前后，数据始终处于一致的状态。</p>\n<p>隔离性<br>两个事务之间互不干扰，事务a完成前，事务b不会读取事务a操作时的变化。</p>\n<p>持久性<br>事务的操作会被持久化到数据库，并且不会被回滚。</p>\n<h2 id=\"事务的类型\"><a href=\"#事务的类型\" class=\"headerlink\" title=\"事务的类型\"></a>事务的类型</h2><p>扁平事务，带有保存点的扁平事务，链式事务，嵌套事务，</p>\n<h2 id=\"并发事务带来的问题\"><a href=\"#并发事务带来的问题\" class=\"headerlink\" title=\"并发事务带来的问题\"></a>并发事务带来的问题</h2><p>更新丢失（脏写），后者覆盖前者</p>\n<p>脏读，一个事务读取了另一个事务未提交的数据</p>\n<p>不可重复读，一个事务读取了某些数据，在一段时间后，这个事务再次读取之前读过的数据，此时数据被更改或删除了</p>\n<p>幻读，一个事务按照相同的查询条件重新读取之前读过的数据，此时发现其他事务插入了满足当前事务查询条件的新数据。这是针对数据的插入。</p>\n<p>##mysql中锁的分类<br>按性能：悲观锁、乐观锁（乐观锁是通过版本对比来实现的）<br>按操作类型：读锁，写锁（这两都是悲观锁）<br>读锁又称为共享锁或S锁（shared Lock）<br>写锁又锁为排他锁或L锁（Exclusive Lock）<br>按数据粒度：表锁，行锁，页面锁<br>按更细粒度：间隙锁、临键锁</p>\n<h2 id=\"死锁的必要条件（4个都满足，才会发生死锁）\"><a href=\"#死锁的必要条件（4个都满足，才会发生死锁）\" class=\"headerlink\" title=\"死锁的必要条件（4个都满足，才会发生死锁）\"></a>死锁的必要条件（4个都满足，才会发生死锁）</h2><p>1互拆条件<br>2不可剥夺条件<br>3请求与保持条件<br>4循环等待条件</p>\n<h2 id=\"处理死锁的方法\"><a href=\"#处理死锁的方法\" class=\"headerlink\" title=\"处理死锁的方法\"></a>处理死锁的方法</h2><p>1预防死锁，破坏造成死锁的4个必要条件中的一个或多个，以防止死锁的发生。<br>2避免死锁，在资源分配中，使用策略防止系统进入不安全状态，从而避免死锁的发生。<br>3检测死锁<br>4解除死锁<br>在实际工作中，，通常采用有序资源分配法和银行家算法来避免死锁。<br>在mysql中，通常通过以下几种方式来避免死锁<br>1尽量让数据表中的数据检索都通过索引来完成，避免无效索引导致锁升级为表锁<br>2合理设计索引，尽量缩小锁的范围<br>3尽量减少查询条件的范围，尽量避免间隙锁或缩小间隙锁的范围<br>4尽量控制事务的大小，减少一次事务锁定的资源数量，缩短锁定资源的时间<br>5如果一条sql语句涉及事务加锁操作，则尽量将其放在整个事务的最后执行<br>6尽可能使用低级别的事务隔离机制</p>\n<h2 id=\"mysql事务的实现原理\"><a href=\"#mysql事务的实现原理\" class=\"headerlink\" title=\"mysql事务的实现原理\"></a>mysql事务的实现原理</h2><p>mysql中事务的隔离性是由锁和MVCC机制实现的，原子性和持久性是由redo log实现的，一致性是由undo log实现的。<br>redo log是重做日志，提供前滚操作(binlog中有数据,commit)，undo log是回滚日志，提供回滚操作。<br>redo log与binlog的区别<br>1binlog是mysql本身就拥有，而redolog是innodb特有的。<br>2两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句。而innodb存储引擎层面的redolog日志是物理日志，保存了数据库中的值。<br>3两种日志记录写入磁盘的时间点不同，二进制日志只在事务提交完成后进行一次写入。而InnoDB 存储引擎的重做日志在事务进行中不断地被写入（不断地写入redo log buffer，不断地刷新）<br>4binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redo log是循环使用。<br>5binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。<br><img src=\"https://user-images.githubusercontent.com/11263320/187072247-3c03ce72-c882-4865-a702-f4f0ce595a69.JPG\" alt=\"IMG_1421\"></p>\n<h2 id=\"xa\"><a href=\"#xa\" class=\"headerlink\" title=\"xa\"></a>xa</h2><p>xa事务是一种基于两阶段提交和分布式事务。prepare，commit。</p>\n<h2 id=\"数据一致性问题\"><a href=\"#数据一致性问题\" class=\"headerlink\" title=\"数据一致性问题\"></a>数据一致性问题</h2><p>1.数据多副本场景<br>2.调用超时场景<br>3.缓存与数据库不一致场景<br>4.多个缓存节点数据不一致场景</p>\n<h2 id=\"分布式事务的理论知识\"><a href=\"#分布式事务的理论知识\" class=\"headerlink\" title=\"分布式事务的理论知识\"></a>分布式事务的理论知识</h2>","tags":["mysql"]},{"title":"图","url":"/post/ee040603.html","content":"<p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/141945849-091c4e00-9f62-4d03-9045-4d14c58af414.gif\" alt=\"0_12849822668MW5\"><br>在上面两个图结构中，一个是有向图，即每条边都有方向，另一个是无向图，即每条边都没有方向。<br>在有向图中，通常将边称作弧，含箭头的一端称为弧头，另一端称为弧尾，记作&lt;vi,vj&gt;，它表示从顶点vi到顶点vj有一条边。</p>\n<h2 id=\"稀疏图与稠密图\"><a href=\"#稀疏图与稠密图\" class=\"headerlink\" title=\"稀疏图与稠密图\"></a>稀疏图与稠密图</h2><p>有很少条边或弧（如e&lt;nlogn，n是图的顶点数，e是弧数）的图称为稀疏图（sparse graph），反之成为稠密图（dense graph）。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>要表示一个图G＝（V，E）,有两种标准的方法，即邻接表和邻接矩阵。</p>\n<h3 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h3><p>邻接矩阵（Adjacency Matrix)存储方式是用两个数组来表示图。一个一维的数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。<br>我们来看一个实例，下图就是一个无向图<br><img src=\"https://user-images.githubusercontent.com/11263320/141948214-881286bb-6699-487a-95ab-cc02a83cb8b1.jpg\" alt=\"Dingtalk_20211116162342\"><br>有向网图<br><img src=\"https://user-images.githubusercontent.com/11263320/141948633-ff97c954-9f74-4446-8aed-11efb2d976eb.jpg\" alt=\"Dingtalk_20211116162342\"></p>\n<h3 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h3><p>邻接表作为图的一种存储方式，在存储稀疏图上相对于邻接矩阵有相当大的空间节省。如一个稀疏图的顶点个个数为n，边数为e。用邻接矩阵存储需要n^2空间，而真正进行存储的只有2e个空间， 剩下的n^2-2e都浪费了。但是对于邻接表来讲，存储空间只需要n+2e个，相对于邻接矩阵减少了很多。邻接表虽然在空间上有很大的优势，但是对于一个有向图，如果需要查找每个顶点的入度就需要遍历整个邻接表，在效率上很低下的。因此才有了逆邻接表的诞生。<br>邻接表：反映的是顶点出度的情况。<br>逆邻接表：反映的是顶点的入度情况。</p>\n<p>下面举一个例子：<br><img src=\"https://user-images.githubusercontent.com/11263320/141949452-aed2f38e-b52f-497c-be81-eb3453ee6e6a.png\" alt=\"20191122211916187\"><br>邻接表：<br><img src=\"https://user-images.githubusercontent.com/11263320/141950896-edd84f87-faf3-4672-b092-74f3b7039970.png\" alt=\"20191122211916187\"></p>\n<p>逆邻接表：<br><img src=\"https://user-images.githubusercontent.com/11263320/141950647-7539e72e-989e-46f6-a0d3-295797f1b980.png\" alt=\"20191122211916187\"></p>\n","tags":["algorithm"]},{"title":"归并排序","url":"/post/1599bffe.html","content":"<p>归并排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>\n<img width=\"884\" alt=\"1024555-20161218163120151-452283750\" src=\"https://user-images.githubusercontent.com/11263320/133566405-144fc31a-bf27-4f18-a273-aa056e49ff01.png\">\n\n<p>可以看到这种结构很像一棵完全二叉树，分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p>\n<h2 id=\"合并相邻有序子序列\"><a href=\"#合并相邻有序子序列\" class=\"headerlink\" title=\"合并相邻有序子序列\"></a>合并相邻有序子序列</h2><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p>\n<img width=\"852\" alt=\"1024555-20161218194508761-468169540\" src=\"https://user-images.githubusercontent.com/11263320/133570378-80864055-7efb-41e6-9927-eba79bf3d734.png\">\n<img width=\"885\" alt=\"1024555-20161218194621308-588010220\" src=\"https://user-images.githubusercontent.com/11263320/133570460-62ad5937-9a76-4750-8ab0-5144a65792f6.png\">\n\n<p><strong>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。</strong></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> range,<span class=\"keyword\">int</span> mid)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> aux[range-start+<span class=\"number\">1</span>],i,j,k;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k=start;k&lt;=range;k++)</span><br><span class=\"line\">    aux[k-start]=a[k];</span><br><span class=\"line\">  </span><br><span class=\"line\">  i=start;</span><br><span class=\"line\">  j=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(k=start;k&lt;=range;k++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span>(i&gt;mid)</span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">  \t\ta[k]=aux[j-start];</span><br><span class=\"line\">  \t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j&gt;range)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[k]=aux[i-start];</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(aux[i-start]&gt;aux[j-start])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[k]=aux[j-start];</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ta[k]=aux[i-start];</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[],<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> range)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    range = range - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(start&gt;=range)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid=(start+range)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmerge_sort(<span class=\"built_in\">array</span>,start,mid);</span><br><span class=\"line\">\tmerge_sort(<span class=\"built_in\">array</span>,mid+<span class=\"number\">1</span>,range);</span><br><span class=\"line\">\tmerge(<span class=\"built_in\">array</span>,start,range,mid);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["algorithm"]},{"title":"桶排序","url":"/post/9fe164cc.html","content":"<h2 id=\"桶排序（Bucket-Sort）\"><a href=\"#桶排序（Bucket-Sort）\" class=\"headerlink\" title=\"桶排序（Bucket Sort）\"></a>桶排序（Bucket Sort）</h2><p>桶排序是<a href=\"https://github.com/losophy/losophy.github.io/issues/149\">计数排序</a>的升级版。顾名思义，会使用「桶」，核心思想就是 把要排序的的数据分到几个有序的桶里，每个桶里面的数据在单独进行排序，所有的桶内数据排序完成后，再按照桶的顺序依次取出，组成的序列就是有序的。</p>\n<p>为了桶排序的高效，我们需要做到以下两点：<br>1.在额外空间充足的情况下，尽量增加桶的数量。<br>2.使用的映射函数能够把输入的 n 个数据均匀的分配到 k 个桶中。</p>\n<p>同时，对于桶内元素的排序，选择哪一种排序算法对于性能的影响也至关重要。</p>\n<h2 id=\"如何把百万级别的订单根据金额排序\"><a href=\"#如何把百万级别的订单根据金额排序\" class=\"headerlink\" title=\"如何把百万级别的订单根据金额排序\"></a>如何把百万级别的订单根据金额排序</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/137052679-06293673-6b43-42d4-890b-3a06e9eeeac8.png\" alt=\"aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzk4Nzc4Mi03M2VjMzkwZTZjODU0MTNlLnBuZw\"></p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>比较适合用在<strong>外部排序</strong>中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大而内存有限，无法一次性全部加载到内存中。</p>\n<p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p>\n<p>订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。<br>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> len=<span class=\"keyword\">sizeof</span>(a)/<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b[<span class=\"number\">10</span>][len+<span class=\"number\">1</span>]=&#123;<span class=\"number\">0</span>&#125;;<span class=\"comment\">//将b全部置0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> digits=numOfDigits(a);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=digits;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        distributeElments(a,b,i);</span><br><span class=\"line\">        collectElments(a,b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i!=digits)</span><br><span class=\"line\">            zeroBucket(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">numOfDigits</span><span class=\"params\">(<span class=\"keyword\">int</span> a[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> largest=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)<span class=\"comment\">//获取最大值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i]&gt;largest)</span><br><span class=\"line\">            largest=a[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> digits=<span class=\"number\">0</span>;<span class=\"comment\">//digits为最大值的位数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(largest)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            digits++;</span><br><span class=\"line\">            largest/=<span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">distributeElments</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> b[<span class=\"number\">10</span>][len+<span class=\"number\">1</span>],<span class=\"keyword\">int</span> digits)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> divisor=<span class=\"number\">10</span>;<span class=\"comment\">//除数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;digits;i++)</span><br><span class=\"line\">        divisor*=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;len;j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> numOfDigist=(a[j]%divisor-a[j]%(divisor/<span class=\"number\">10</span>))/(divisor/<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">//numOfDigits为相应的(divisor/10)位的值,如当divisor=10时,求的是个位数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> num=++b[numOfDigist][<span class=\"number\">0</span>];<span class=\"comment\">//用b中第一列的元素来储存每行中元素的个数</span></span><br><span class=\"line\">        b[numOfDigist][num]=a[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">collectElments</span><span class=\"params\">(<span class=\"keyword\">int</span> a[],<span class=\"keyword\">int</span> b[<span class=\"number\">10</span>][len+<span class=\"number\">1</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)</span><br><span class=\"line\">        (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=b[i][<span class=\"number\">0</span>];j++)</span><br><span class=\"line\">            a[k++]=b[i][j];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zeroBucket</span><span class=\"params\">(<span class=\"keyword\">int</span> b[][len+<span class=\"number\">1</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;len+<span class=\"number\">1</span>;j++)</span><br><span class=\"line\">            b[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>快排、归并是经济实用型小轿车。而桶排序、计数排序、基数排序则是赛道上的跑车竞速。</p>\n","tags":["algorithm"]},{"title":"游戏ECS","url":"/post/127ad618.html","content":"<h2 id=\"多使用组合\"><a href=\"#多使用组合\" class=\"headerlink\" title=\"多使用组合\"></a>多使用组合</h2><p>如果一味地使用继承，那么当游戏世界里面的对象种类变多，功能变复杂以后，会导致整个继承树“头重脚轻”，严重破坏了良好的面向对象设计原则—我们设计的类层次结构应该是扁平结构的，而不是一个头很大的树。<br>那么，我们需要使用怎样的架构来处理游戏里面的对象呢？答案就是使用组合。</p>\n<h2 id=\"ECS\"><a href=\"#ECS\" class=\"headerlink\" title=\"ECS\"></a>ECS</h2><p>ECS由三个基本部分组成：实体、组件和系统。实体是与对象关联的唯一id，组件是表示实体信息的数据，系统在实体上运行逻辑，以利用或更改来自组件的数据。</p>\n<p>一个简单的例子：玩家，怪或者物体entity。技能component。逻辑集中在system里。</p>\n<p>e-c里gameobject是entity，只是个类似容器的抽象概念，entity里包含的component决定了对象是什么<br>component可以给不同的gameobject重用，通过组合多种component而不是继承来构造不同的对象。<br>e-c-s三者都有其意义，e-c是组合优于继承，主要用以改善oo的继承耦合过重以及多继承菱形问题。</p>\n<p><strong>冗余的OOP层次结构</strong><br><img src=\"https://user-images.githubusercontent.com/11263320/130573019-8157d310-f4ef-4d73-bd9b-ea03b05b72d1.jpg\" alt=\"v2-481d8c44ab799ea842b3e5b1e6bd0d27_720w\"></p>\n<p><strong>实体组件系统(ECS)</strong><br><img src=\"https://user-images.githubusercontent.com/11263320/130572511-d4191abc-d72e-450d-ad24-9b21964f5508.jpg\" alt=\"v2-5ba6b2aec06fc6eebbb5baeaf343a586_720w\"></p>\n","tags":["design"]},{"title":"线上出问题，我们应该如何快速解决","url":"/post/44bf3fa0.html","content":"<h2 id=\"查日志\"><a href=\"#查日志\" class=\"headerlink\" title=\"查日志\"></a>查日志</h2><p>找到日志的位置，<code>grep Exception backend.log</code> 一把梭。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/136902110-04669e00-d9ca-40a5-b30b-2cf72017290e.png\" alt=\"v2-bde8961612504ec5f9266194a01642fa_720w\"><br><img src=\"https://user-images.githubusercontent.com/11263320/136902668-317513e4-e663-4e41-8caa-8f23b35b20f7.jpg\" alt=\"v2-d0857c699d0751275db34b9a19f24dfb_720w\"></p>\n<p>如果一个Exception不够，再来一个ERROR，反正把你能想到的关键词都想干净。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/136902704-8da0f108-6035-4fda-807a-73b317126287.jpg\" alt=\"v2-a1877871cf01aa2d15f99bd3f84ae9db_720w\"></p>\n<p>千万不要跟我说你查不到日志，如果是日志没有打印，请打印出来，磨刀不误砍柴工。如果是你没有权限查看，麻烦你一定要先搞到权限。千万千万要避免“猜”问题。一群人在那儿讨论半天，你猜我猜，最终猜出来的概率是比较低的，除非你见过这个BUG。</p>\n<h2 id=\"看状态\"><a href=\"#看状态\" class=\"headerlink\" title=\"看状态\"></a>看状态</h2><p>top一把，看看应用CPU占用率是不是异常的高。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/136902909-3b6e94cf-67f6-4393-b17d-f88e81a1571f.jpg\" alt=\"v2-ae4034ccd5feba1e6aa91cb75df7841f_720w\"></p>\n<p>load average根据CPU核心数来判断，CPU占用看是否为100%或异常的高。</p>\n<h2 id=\"看线程是否卡住\"><a href=\"#看线程是否卡住\" class=\"headerlink\" title=\"看线程是否卡住\"></a>看线程是否卡住</h2><p>打印出所有线程栈之后，看看有没有你关心的线程卡住了，BLOCK或者wating之类的情况，然后看看他正在做什么调用</p>\n","tags":["design"]},{"title":"虚幻五从零开始做一个动作类游戏（纯蓝图）","url":"/post/19604296.html","content":"<p>今天，我们开始做一个动作类游戏。</p>\n<h1 id=\"美术资源\"><a href=\"#美术资源\" class=\"headerlink\" title=\"美术资源\"></a>美术资源</h1><p>我们先下载今天要用到的美术资源。</p>\n<p>链接：<a href=\"https://link.zhihu.com/?target=https://pan.baidu.com/s/1Vci83yoTRvViXIXElZ4k0g?pwd=tynm\">https://pan.baidu.com/s/1Vci83yoTRvViXIXElZ4k0g?pwd=tynm</a></p>\n<p>提取码：tynm<br><img src=\"https://github.com/user-attachments/assets/9f3ea942-dee5-45ac-8cd8-4b7fede16cdb\" alt=\"image\"></p>\n<p>新建项目。<br><img src=\"https://github.com/user-attachments/assets/d6873037-4bcb-42d8-92d1-44cfa6b5d559\" alt=\"image\"></p>\n<p>把美术资源拖进项目。<br><img src=\"https://github.com/user-attachments/assets/961328cc-6e2c-455a-a4f2-f29b7b4aa971\" alt=\"image\"></p>\n<h1 id=\"创建角色\"><a href=\"#创建角色\" class=\"headerlink\" title=\"创建角色\"></a>创建角色</h1><p>我们创建个文件夹，就叫Player。<br><img src=\"https://github.com/user-attachments/assets/1c2d9af5-6176-4cb5-8a4a-14b43b8a8dc8\" alt=\"image\"></p>\n<p>创建角色蓝图。<br><img src=\"https://github.com/user-attachments/assets/d5af8d95-bf28-4ce2-adc6-dff2d57191e3\" alt=\"image\"></p>\n<p>我们再创建一个玩家控制器。<br><img src=\"https://github.com/user-attachments/assets/9650c7b5-7af5-4c09-98e7-e41d4a690d07\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/498fe4ee-1312-4116-956f-95553fa6e649\" alt=\"image\"></p>\n<p>这时候我们再添加一个游戏模式。<br><img src=\"https://github.com/user-attachments/assets/fe081ca9-fb7b-44aa-8716-3fbb4bb468cf\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/ed3fa57c-65b1-4318-b465-a1e421fcc90e\" alt=\"image\"></p>\n<p>然后我们改下GameMode的类默认值细节的设置。<br><img src=\"https://github.com/user-attachments/assets/4c22a644-7b74-4d3f-b2fa-04f2bbdfce8c\" alt=\"image\"></p>\n<p>编译保存。然后改一下默认游戏模式。改成我们刚建的。<br><img src=\"https://github.com/user-attachments/assets/70374fb0-f05d-41bc-9f67-89210b2c5a79\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/240ffbb0-7ca2-4615-8882-8f98c4fefa0a\" alt=\"image\"></p>\n<p>返回资源浏览器。编辑PlayerChar。给它添加个模型。<br><img src=\"https://github.com/user-attachments/assets/7819ce98-fedb-4660-afcb-a6a940778f8a\" alt=\"image\"></p>\n<p>调整下位置，旋转。<br><img src=\"https://github.com/user-attachments/assets/f2c0de30-be41-49b2-9130-cc3d0f3e91a9\" alt=\"image\"></p>\n<p>选中胶囊体组件，把胶囊体半高改成92。<br><img src=\"https://github.com/user-attachments/assets/3addbd6d-15f3-453c-ba68-35fef9eb670f\" alt=\"image\"></p>\n<p>然后添加摄像机。<br><img src=\"https://github.com/user-attachments/assets/990a0745-a27e-4613-be5c-8f4dc3dbddfd\" alt=\"image\"></p>\n<p>然后调整下弹簧臂的位置。<br><img src=\"https://github.com/user-attachments/assets/57cc65ac-ddbb-4248-baa0-602f3e069cfc\" alt=\"image\"></p>\n<p>编译保存运行。<br><img src=\"https://github.com/user-attachments/assets/f18734cc-8349-412c-8c8f-5c3ed408dac9\" alt=\"image\"></p>\n<h1 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h1><p>编辑PlayerChar。添加自定义事件。<br><img src=\"https://github.com/user-attachments/assets/b59fa409-e0f5-49b7-98e1-d3e04e883a6d\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/9bedb5aa-e237-48b5-95c6-21d9c8255416\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/32b73dd0-9fb4-4d09-b4fe-a4e2c2a8e811\" alt=\"image\"></p>\n<p>增加ScaleValue变量编译。<br><img src=\"https://github.com/user-attachments/assets/a6d54df9-d35c-4d39-9fd4-30c49c5a1fbd\" alt=\"image\"></p>\n<p>保存编译。返回项目设置。<br><img src=\"https://github.com/user-attachments/assets/fd8bc74a-1f96-4034-a6e9-792287533b23\" alt=\"image\"></p>\n<p>添加轴映射。<br><img src=\"https://github.com/user-attachments/assets/659c1467-79db-44c2-9b5a-d85e113cfa19\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/d5c57cc8-9171-4101-a2f3-ba1427470334\" alt=\"image\"></p>\n<p>然后我们打开Controller。<br><img src=\"https://github.com/user-attachments/assets/0dfe567c-1678-4cc0-baf2-b166adb30421\" alt=\"image\"></p>\n<p>编辑。<br><img src=\"https://github.com/user-attachments/assets/9e4359b1-6bee-468a-b1b0-6e0fd0139cd1\" alt=\"image\"></p>\n<p>编译保存。现在角色可以向前向后移动了。左右也是。<br><img src=\"https://github.com/user-attachments/assets/18833bee-cedc-4712-9072-9709eacd8cbc\" alt=\"image\"></p>\n<p>然后再在项目设置里加一个轴。<br><img src=\"https://github.com/user-attachments/assets/61f3c2c3-bbce-457f-8a9e-6214bf84a248\" alt=\"image\"></p>\n<p>然后控制器也加上左右。<br><img src=\"https://github.com/user-attachments/assets/7bb5154f-b929-467b-8122-f330a75a36cb\" alt=\"image\"></p>\n<p>前后左右都没有问题。现在回到项目设置添加视角。<br><img src=\"https://github.com/user-attachments/assets/a85147a3-a8e8-4943-9b90-f0d93b6e467b\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/2a0f7354-4b24-40f0-920e-3bb9d57b52f5\" alt=\"image\"></p>\n<p>返回playerchar。<br><img src=\"https://github.com/user-attachments/assets/4a77a983-397e-4d0c-af27-9e0f00de4ced\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/8469ebf1-a2e3-400d-8fb3-064a2ba48490\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/757c49e9-2896-480e-8cfd-86c205b9cd5d\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/22fed050-8f64-4341-8f0a-9fece8b166bb\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0cda10b7-de25-4f86-86f9-70f2ab6e8ec8\" alt=\"image\"></p>\n<p>编译保存运行。ok行走没问题了。</p>\n<h1 id=\"移动动画\"><a href=\"#移动动画\" class=\"headerlink\" title=\"移动动画\"></a>移动动画</h1><p>现在要创建动画蓝图了。<br><img src=\"https://github.com/user-attachments/assets/9c108ce2-1620-4675-b577-a901a5bba0e2\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/da2874d8-3c10-4aca-b5c0-47e896e60a07\" alt=\"image\"></p>\n<p>打开动画蓝图编辑。保存。<br><img src=\"https://github.com/user-attachments/assets/78a8c831-b4ed-4c43-ae1c-0f4cb75ed5d2\" alt=\"image\"></p>\n<p>新建一个混合空间。<br><img src=\"https://github.com/user-attachments/assets/3f18904f-ccfb-4c88-9e2a-82582887cd66\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/24f8ae8b-6d94-4c8e-bdcc-eebd405eccaf\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/09678330-957c-4fac-a67b-cb276717d879\" alt=\"image\"></p>\n<p>点击编辑混合空间。在资产详情里修改水平坐标。<br><img src=\"https://github.com/user-attachments/assets/49f27cca-ae4f-4779-ac51-eeed6e108e66\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/695f9268-2677-4395-a3a3-f6db8825bb4b\" alt=\"image\"></p>\n<p>拖动idle_eqip_01到最左。<br><img src=\"https://github.com/user-attachments/assets/9bac41b2-6f55-4984-958e-09902e4495c9\" alt=\"image\"></p>\n<p>然后把walk_eqip_front拖到速度为1时的地方。<br><img src=\"https://github.com/user-attachments/assets/c895131d-eaff-450f-9bbd-8f98d55eafa8\" alt=\"image\"></p>\n<p>让速度到3时跑。<br><img src=\"https://github.com/user-attachments/assets/4a6c143d-1286-4c8f-ba07-5e5a127c7acd\" alt=\"image\"></p>\n<p>保存。等于走有三种状态。</p>\n<p>然后再打开动画蓝图。<br><img src=\"https://github.com/user-attachments/assets/82b9a962-2edd-42bc-b25a-ae19e56fd64c\" alt=\"image\"></p>\n<p>点开状态机。<br><img src=\"https://github.com/user-attachments/assets/497e6f62-da27-4d73-94d6-161fbef3cdb5\" alt=\"image\"></p>\n<p>添加状态。<br><img src=\"https://github.com/user-attachments/assets/595c897c-99b7-48f6-b575-f13580af9985\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/4b9f88ab-3474-4473-8c4a-21848da20438\" alt=\"image\"></p>\n<p>进去Idle/Run状态。<br><img src=\"https://github.com/user-attachments/assets/9df15e01-3a26-4b6a-bd21-2f68372b7b95\" alt=\"image\"></p>\n<p>把Speed提升为变量。<br><img src=\"https://github.com/user-attachments/assets/a8fb6fed-8c74-4b3f-bab8-cda464a90786\" alt=\"image\"></p>\n<p>然后点击事件图表。<br><img src=\"https://github.com/user-attachments/assets/d89e934d-6576-4343-b62e-db52fcb9b827\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/2636ac66-1141-4650-b151-0c311783c16e\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/5530c255-dade-4165-9d34-2f21629b7535\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/8272a871-1241-4206-89c1-575b4136eb8d\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/15ab7d19-e9b2-41d6-9752-3c37da690ebd\" alt=\"image\"></p>\n<p>保存，打开playerchat。点网格体。设置动画类。<br><img src=\"https://github.com/user-attachments/assets/ecc9e60d-a805-40d5-94bd-1c7c8fe3cc7e\" alt=\"image\"></p>\n<p>编译保存，运行。现在可以跑了。</p>\n<p>现在输入我们加一个慢走。<br><img src=\"https://github.com/user-attachments/assets/606a6040-7495-4aa3-90c8-15a1e5fe5a4c\" alt=\"image\"></p>\n<p>打开玩家PlayerCharController。编写走路。<br><img src=\"https://github.com/user-attachments/assets/9707cb49-0fdf-43c2-82e9-ac8564fcae68\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/e2423583-60b8-4b6a-ae0b-4be1fac4a316\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/9707cb49-0fdf-43c2-82e9-ac8564fcae68\" alt=\"image\"></p>\n<p>编译保存运行。现在可以慢慢地走了。</p>\n<p>武器<br>现在我们加一下武器。在playerChar中加一个骨骼网格体。<br><img src=\"https://github.com/user-attachments/assets/f308233a-ae8f-4be5-9f54-d1e73adfc4c7\" alt=\"image\"></p>\n<p>然后父项插槽选Sword_1。资产也选一下。<br><img src=\"https://github.com/user-attachments/assets/bba79a0f-a4b4-4eac-a61d-e804315aa164\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/d1609393-3d6b-4404-a714-539e859e2424\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/58c2fd63-5b91-4e91-91ea-9c1387899a95\" alt=\"image\"></p>\n<p>编译保存运行。<br><img src=\"https://github.com/user-attachments/assets/aa0d5f74-e2b6-4f7c-80d2-6226d6d4c7f9\" alt=\"image\"></p>\n<h1 id=\"连招系统\"><a href=\"#连招系统\" class=\"headerlink\" title=\"连招系统\"></a>连招系统</h1><h2 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h2><p>找到这个动作。<br><img src=\"https://github.com/user-attachments/assets/2a303454-31a0-4217-9664-5c928b8d7fcd\" alt=\"image\"></p>\n<p>然后创建动画蒙太奇。<br><img src=\"https://github.com/user-attachments/assets/f1783d12-3771-432c-b0e8-ac4bc783bc5d\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/66bdc622-3750-4dbb-902f-29125869b5d5\" alt=\"image\"></p>\n<p>然后绑定下按键。<br><img src=\"https://github.com/user-attachments/assets/f128a767-fcdb-4029-9c81-6923eceee408\" alt=\"image\"></p>\n<p>然后打开PlayerChat。添加自定义事件。<br><img src=\"https://github.com/user-attachments/assets/9011b90d-b094-45a0-a5d4-719238a6e19c\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0aaba138-281f-4954-9977-4e6f8aac4b26\" alt=\"image\"></p>\n<p>然后我们找到角色的控制器。加上攻击。<br><img src=\"https://github.com/user-attachments/assets/c0f1f8a2-0165-4c56-944b-34416f6fa3dc\" alt=\"image\"></p>\n<p>运行发现胶囊体没有跟角色移动。找到动画，启动根运动。<br><img src=\"https://github.com/user-attachments/assets/e891827d-9779-435a-a5ce-974e91060f1b\" alt=\"image\"></p>\n<p>现在胶囊体会跟角色移动了。角色会跟着攻击动画移动。打开PlayerChar。让角色每次攻击都能连续。不会因双次按下攻击按键而抽搐。增加一个变量，用来判断是否在攻击中。<br><img src=\"https://github.com/user-attachments/assets/4430713c-5956-4973-8309-b43f417f3e4b\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/8c45ac92-afef-4f1b-a5b0-9eb4e60f3157\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/fb43a9e1-b88f-41b1-8aa8-eed469c54658\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/3c117730-5ff8-4256-9a35-890a63343476\" alt=\"image\"></p>\n<p>完整蓝图。<br><img src=\"https://github.com/user-attachments/assets/6a945287-460a-4ae4-a3f7-7901bdedcb76\" alt=\"image\"></p>\n<p>现在连点不会抽搐了。</p>\n<h2 id=\"连招\"><a href=\"#连招\" class=\"headerlink\" title=\"连招\"></a>连招</h2><p>删掉攻击的逻辑，开始编写连招逻辑。<br><img src=\"https://github.com/user-attachments/assets/03f7a5ba-edfc-491c-935d-22f1a971e499\" alt=\"image\"></p>\n<p>增加变量。并使用数组。<br><img src=\"https://github.com/user-attachments/assets/71a85a88-b641-46e7-8f58-11a70ff90d9a\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/6fb787ca-1d1d-49c9-8085-f497fa4e0261\" alt=\"image\"></p>\n<p>这里要多少个连击动作，就加多少个数组就可以了。<br><img src=\"https://github.com/user-attachments/assets/64b73094-5859-40d0-ae4b-48002baca662\" alt=\"image\"></p>\n<p>接着，我们找到连击动作。<br><img src=\"https://github.com/user-attachments/assets/8767d43f-3fa0-4f71-acef-5d43f0e4d805\" alt=\"image\"></p>\n<p>创建动画蒙太奇。<br><img src=\"https://github.com/user-attachments/assets/0d180b97-dee1-49b5-b684-d3198c6ba9ce\" alt=\"image\"></p>\n<p>然后找到Combo_01动画。<br><img src=\"https://github.com/user-attachments/assets/2df260aa-176a-42ed-b2d6-a1329c967aad\" alt=\"image\"></p>\n<p>我们分解下连招动画。找到第一下下剑时的结束时间。调整结束时间。<br><img src=\"https://github.com/user-attachments/assets/0bf794a2-50ec-4a61-a535-06ee8d5c1ff8\" alt=\"image\"></p>\n<p>然后做连招第二下的动画。<br><img src=\"https://github.com/user-attachments/assets/23192d08-d4f7-41b5-810e-73d92b384d2a\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/56ae4681-15b6-4c68-9ae6-48a5d13141ff\" alt=\"image\"></p>\n<p>然后做连招第三下的动画。<br><img src=\"https://github.com/user-attachments/assets/789d51dc-9470-42a5-9cc9-f51b0a69b1d5\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/fc18c643-c836-41b8-b351-3fc720a47273\" alt=\"image\"></p>\n<p>然后做连招第四下的动画。<br><img src=\"https://github.com/user-attachments/assets/eca68f6f-100e-4e11-b0b9-3907bb8662ba\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/639e8cc0-459c-4bc9-abe7-cc7091474740\" alt=\"image\"></p>\n<p>所有分解的招式。<br><img src=\"https://github.com/user-attachments/assets/7d91685e-c92f-4c5a-9ea5-cacdb6ee5257\" alt=\"image\"></p>\n<p>然后返回PlayerChar。编辑连招逻辑。</p>\n<p>然后找到刚创建的数组变量。<br><img src=\"https://github.com/user-attachments/assets/7a5a2cf8-fa7b-47e5-866e-01a98fda8069\" alt=\"image\"></p>\n<p>把四个连招动作按顺序赋予数组。<br><img src=\"https://github.com/user-attachments/assets/6d486066-12b5-4c84-9a85-018395a6061b\" alt=\"image\"></p>\n<p>然后我们添加一个变量，用来计数攻击次数。<br><img src=\"https://github.com/user-attachments/assets/b35ab0fe-57ee-48c3-9c13-2b674b2d3bc8\" alt=\"image\"></p>\n<p>初始值设为-1。<br><img src=\"https://github.com/user-attachments/assets/703fae67-04fb-4baf-bca3-56a35975e6be\" alt=\"image\"></p>\n<p>然后编译下蓝图。<br><img src=\"https://github.com/user-attachments/assets/21bd3a37-4a71-45e4-8d25-42bb8a08a548\" alt=\"image\"></p>\n<p>攻击先判断是否在攻击。</p>\n<p>然后攻击次数加1。<br><img src=\"https://github.com/user-attachments/assets/de6a6441-fa2e-4f0c-bbef-5a61ca1217a0\" alt=\"image\"></p>\n<p>然后判断攻击次数是否大于招式动画的长度。<br><img src=\"https://github.com/user-attachments/assets/9d0e0f45-a6a4-4a9d-9917-2b28be11d220\" alt=\"image\"></p>\n<p>如果小于招式动画的长度就获取一下招式。<br><img src=\"https://github.com/user-attachments/assets/f0065873-ebab-46c2-81ae-55c00c19f52c\" alt=\"image\"></p>\n<p>如果大于招式动画的长度就把，Attack count归零。<br><img src=\"https://github.com/user-attachments/assets/c3686a87-c482-473f-9f0e-22338a0bbda4\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/076ecc2a-cce7-4f9d-8876-230e12aa9c40\" alt=\"image\"></p>\n<p>然后设置一下ComboReset。<br><img src=\"https://github.com/user-attachments/assets/5783687d-53bd-4fdb-9932-d03e673bdeb9\" alt=\"image\"></p>\n<p>接着找到动画Combo_01_1_Montage，然后在攻击后摇前，大概在8后，右键加一下动画通知。<br><img src=\"https://github.com/user-attachments/assets/8b407b60-3c42-4d55-bee3-535a930f45e6\" alt=\"image\"></p>\n<p>在动画结束时也加一下动画通知。<br><img src=\"https://github.com/user-attachments/assets/a5abf03e-192d-4e6e-9339-f72aad85bb6f\" alt=\"image\"></p>\n<p>动画234也一样。<br><img src=\"https://github.com/user-attachments/assets/758c0aed-3a29-4969-a14a-28cc1eacf2f6\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/36639cce-0f8f-4d17-9428-6b05ef9cbe54\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/b984c24a-f5d4-426f-acb6-2c3b7cb6a989\" alt=\"image\"></p>\n<p>加完通知后，接着我们使用下通知。 打开PlayerCharABP。<br><img src=\"https://github.com/user-attachments/assets/f6e8a2aa-ad39-42ac-8241-63cd4e9ec13d\" alt=\"image\"></p>\n<p>在ComoStart通知时去做Do Attack。<br><img src=\"https://github.com/user-attachments/assets/6860d775-e070-4285-a6b4-7ab358e25772\" alt=\"image\"></p>\n<p>然后再动画播放结束时，把所有的状态设置为初始值。<br><img src=\"https://github.com/user-attachments/assets/01fe304e-1bff-4f44-b76d-68a8e56ce51d\" alt=\"image\"></p>\n<p>然后在动画蒙太奇里设置下混出混入时间。让混出混入时间远小于本身动画的时间。<br><img src=\"https://github.com/user-attachments/assets/7935fae1-e01d-4d48-a225-b52d34aa99c6\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/51096613-4f8d-41b5-883d-1627b58bb1d5\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/ef63fa91-ac32-4bb1-975f-5ad2575fe2e1\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/8b058de4-beea-469c-bef8-ca9772e01634\" alt=\"image\"></p>\n<p>然后创建一个保存攻击的状态。<br><img src=\"https://github.com/user-attachments/assets/425339ea-65ce-4ecf-b7c6-b62b180ea268\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/c3599336-bdfc-4081-ae71-770b56a0b083\" alt=\"image\"></p>\n<p>SaveAttack开始时也要保存下。<br><img src=\"https://github.com/user-attachments/assets/cf210f25-c69c-4ec3-89a3-d7b35230e6c0\" alt=\"image\"></p>\n<p>然后把动画蓝图里的DoAttack改成AttackSave就可以连击出连招了。<br><img src=\"https://github.com/user-attachments/assets/c6f6dcb3-3dde-4245-8324-ce1009555231\" alt=\"image\"><br><a href=\"https://github.com/user-attachments/assets/801d8e67-cbcd-4e1b-846b-c73e4299567a\">https://github.com/user-attachments/assets/801d8e67-cbcd-4e1b-846b-c73e4299567a</a></p>\n<h1 id=\"更好的打击感\"><a href=\"#更好的打击感\" class=\"headerlink\" title=\"更好的打击感\"></a>更好的打击感</h1><p>上面已经把攻击连招讲完了，但是攻击的时候不能转向，他只能朝着一个方向走，手感不是很好。下面完善一下攻击。然后做出攻击时可转向，添加闪避以及伤害通知。</p>\n<h2 id=\"攻击时可转向\"><a href=\"#攻击时可转向\" class=\"headerlink\" title=\"攻击时可转向\"></a>攻击时可转向</h2><p>一个流畅的动作类游戏，他必须得是非常跟手的。随时都跟着你的操作。在你攻击的时候，他应该也能跟着转向。这样才是一个好的动作游戏的手感。</p>\n<p>打开playerchar。</p>\n<p>新建一个函数。<br><img src=\"https://github.com/user-attachments/assets/4a6288ed-d2ef-4b94-b848-dc99f679efe9\" alt=\"image\"></p>\n<p>用这个函数计算最后一次输入。就是要用这个函数获取最后一次键盘是按的哪个方向。这个函数不能单独使用，得配合其它函数使用。</p>\n<p>新建一个变量，用来保存我们的输入movement。<br><img src=\"https://github.com/user-attachments/assets/9036e3c0-024a-48d0-ac58-2da19c92dd5b\" alt=\"image\"></p>\n<p>还要新建一个变量，用来保存我们最后一次输入的角度。<br><img src=\"https://github.com/user-attachments/assets/0278751e-9b45-4d33-9d9c-40513c1aa0f1\" alt=\"image\"></p>\n<p>我们把角色移动拖进来。<br><img src=\"https://github.com/user-attachments/assets/c414784c-1131-49ae-aeec-55f8f4b0a8f7\" alt=\"image\"></p>\n<p>把角色最后输入的向量存到Movement Input。<br><img src=\"https://github.com/user-attachments/assets/9aa6bbf5-fe40-44bc-867c-24fd911f4180\" alt=\"image\"></p>\n<p>我们还需要加一个变量，用来检测砍一刀时，有没有输入向量。<br><img src=\"https://github.com/user-attachments/assets/0c4e68a4-ce7b-4df3-afd3-cc96a07067aa\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0436e4c8-567d-432c-95ec-136fa91a493a\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/d0b7f6b8-253b-46cf-be63-8e3f69160eb9\" alt=\"image\"></p>\n<p>输入角度也保存一下。<br><img src=\"https://github.com/user-attachments/assets/d747cb78-6bd2-460e-8083-237881fdcf03\" alt=\"image\"></p>\n<p>这样这个函数是算写完了。</p>\n<p>然后我们返回事件图表，让每帧都执行一下。<br><img src=\"https://github.com/user-attachments/assets/d1865a31-e973-48d1-8fa1-8ec585c90913\" alt=\"image\"></p>\n<p>然后我们再创建一个函数。用这个函数改变角度。就是要让攻击动画改变角度。<br><img src=\"https://github.com/user-attachments/assets/24a06105-22ab-413f-aa2d-fe28b930fccd\" alt=\"image\"></p>\n<p>添加两个输入。<br><img src=\"https://github.com/user-attachments/assets/ef48c198-51b1-4e3d-bb44-26f4c107c80b\" alt=\"image\"></p>\n<p>先判断下输入的两个值。<br><img src=\"https://github.com/user-attachments/assets/ed6be0bf-b182-46e8-a135-16681a299eef\" alt=\"image\"></p>\n<p>然后就可以对角度设置渐变推进。<br><img src=\"https://github.com/user-attachments/assets/99a6e54c-dcd2-4f0b-91bc-a52cbe144518\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/1ae3b1bd-d152-471c-b5fd-5c815766df3a\" alt=\"image\"></p>\n<p>也设置下没有速度的时候的情况。<br><img src=\"https://github.com/user-attachments/assets/b3ecf038-72f9-4f86-9c62-7fc3e6452e7c\" alt=\"image\"></p>\n<p>然后我们做下动画通知。新建一个文件夹。<br><img src=\"https://github.com/user-attachments/assets/380784a7-a35a-4bee-bffa-e7c7e8b96d1e\" alt=\"image\"></p>\n<p>创建一个AnimNotifyState蓝图。<br><img src=\"https://github.com/user-attachments/assets/2b20fed6-ae14-43a4-9e81-5f74eb2e392c\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0cf35830-994f-49bf-821b-d4f92865fc41\" alt=\"image\"></p>\n<p>打开编辑。新建变量。<br><img src=\"https://github.com/user-attachments/assets/0e138e0d-85b1-43cf-8d74-712b8a78bdfc\" alt=\"image\"></p>\n<p>然后重载一下函数。<br><img src=\"https://github.com/user-attachments/assets/a8e4adda-947b-4b31-aba9-9f78f62d364b\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0e206ea6-a179-4263-a96c-6980ec01fb40\" alt=\"image\"></p>\n<p>然后找个动画试试。找到攻击这个蒙太奇。<br><img src=\"https://github.com/user-attachments/assets/2d013e61-8bdd-44c0-ba2c-c41bd8d7d31a\" alt=\"image\"></p>\n<p>添加状态通知。<br><img src=\"https://github.com/user-attachments/assets/f7919d84-e851-47fe-8578-5e16c87b365c\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/978b2249-b88e-4307-9414-14525bc4bdd8\" alt=\"image\"></p>\n<p>表于在这段区间之间都可以转向。就是攻击前摇时可以选择方向。</p>\n<p>然后回到RotationByAnim，把InterpSpeed变量小眼睛点开。<br><img src=\"https://github.com/user-attachments/assets/79686d7d-ae73-4616-b648-e7ab24764c64\" alt=\"image\"></p>\n<p>编译。回到动作就可以看到这个变量了。<br><img src=\"https://github.com/user-attachments/assets/9532603e-b1fc-4ede-997d-1ee05c5bf306\" alt=\"image\"></p>\n<p>然后设置这个渐变速度为10。<br><img src=\"https://github.com/user-attachments/assets/0cd6ca7e-28ce-4b74-93f9-ef468274b83c\" alt=\"image\"></p>\n<p>然后把其它的动画也设置下。<br><img src=\"https://github.com/user-attachments/assets/641d6428-6686-4c5e-ae71-fa0c4faea7a7\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/39c525bd-01b1-4cda-851f-2cab0b4b81eb\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/8444bd70-4172-41cd-9fd9-f0779b0d798c\" alt=\"image\"></p>\n<p>然后接下来我们开始写这个动画通知的函数。<br><img src=\"https://github.com/user-attachments/assets/92524503-3377-410e-959d-5ecd782ffb61\" alt=\"image\"></p>\n<p>我们再重载下两个函数。<br><img src=\"https://github.com/user-attachments/assets/61e82b9f-faad-4ccc-a6f2-6e4d2a4e3f6c\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0ebde729-e6d0-40ab-b68c-a0e57a087ff0\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/a6a8c95c-79d0-404e-ac12-90196deb8fc3\" alt=\"image\"></p>\n<p>现在攻击时可以转向了。<br><a href=\"https://github.com/user-attachments/assets/f2124445-7383-46ad-b3cc-a05e40cee7fb\">https://github.com/user-attachments/assets/f2124445-7383-46ad-b3cc-a05e40cee7fb</a></p>\n<h1 id=\"伤害通知\"><a href=\"#伤害通知\" class=\"headerlink\" title=\"伤害通知\"></a>伤害通知</h1><p>直接在动画序列中加通知。<br><img src=\"https://github.com/user-attachments/assets/ace26a8e-1eaf-4ffb-8f12-d2f59313b651\" alt=\"image\"></p>\n<p>接着我们回到playerchar写伤害逻辑。<br><img src=\"https://github.com/user-attachments/assets/ae4bb258-13d2-41c1-9e34-6a4d47523e2a\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/baef7631-9a6d-4777-9c2a-593468c87832\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/b1cdbd5d-902e-432f-ab09-bd514143ef62\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/4d72a763-5781-4b6d-9167-7bf78dfb7ec4\" alt=\"image\"></p>\n<p>然后我们返回动画蓝图。<br><img src=\"https://github.com/user-attachments/assets/147c63c7-dea0-482c-a4b6-ceecb10b31b0\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/05271849-a737-4302-ad95-d2f71ba6a779\" alt=\"image\"></p>\n<p>运行可以看到攻击的范围。<br><a href=\"https://github.com/user-attachments/assets/d1f9993d-0546-469f-a9c4-45f4dbdc1316\">https://github.com/user-attachments/assets/d1f9993d-0546-469f-a9c4-45f4dbdc1316</a></p>\n<h1 id=\"闪避\"><a href=\"#闪避\" class=\"headerlink\" title=\"闪避\"></a>闪避</h1><p>我们先加一下按键。<br><img src=\"https://github.com/user-attachments/assets/decb48f6-03fd-47f4-8f2b-75b8f6d3c245\" alt=\"image\"></p>\n<p>然后我们找个动画。创建动画蒙太奇。<br><img src=\"https://github.com/user-attachments/assets/212daa59-c148-4326-a63e-3f2847290c54\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/959fe89f-ff6d-410d-837e-f99e0e038c18\" alt=\"image\"></p>\n<p>然后回到动画。把启动根运动勾上。<br><img src=\"https://github.com/user-attachments/assets/e1f84ff8-0f0a-43d6-83cc-b2706fea5811\" alt=\"image\"></p>\n<p>角色就能跟着胶囊体动了。</p>\n<p>然后我们写一下闪避的逻辑。<br><img src=\"https://github.com/user-attachments/assets/fdc1016a-882d-40a8-af6e-93146933addb\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/629b54bd-7aab-45ed-a342-749ebb3df4a5\" alt=\"image\"></p>\n<p>在控制里也加一下。<br><img src=\"https://github.com/user-attachments/assets/d8569f09-32d5-49ba-886e-05af77f61777\" alt=\"image\"></p>\n<p>编译保存运行。<br><a href=\"https://github.com/user-attachments/assets/6e411bef-0ddc-465b-b158-d4b264e40361\">https://github.com/user-attachments/assets/6e411bef-0ddc-465b-b158-d4b264e40361</a></p>\n<p>但反复按会鬼畜。这里改一下。<br><img src=\"https://github.com/user-attachments/assets/1a839d4c-618d-4cd1-adb7-205a198bac06\" alt=\"image\"></p>\n<p>然后在动画播放完后状态设置为不翻滚。<br><img src=\"https://github.com/user-attachments/assets/02483ca6-92e5-42f8-a3cc-ce7e866f1cfd\" alt=\"image\"></p>\n<p>编译保存运行。</p>\n<p>现在反复按不会鬼畜了。</p>\n<p>这里可以加速动画播放让翻滚快点。<br><img src=\"https://github.com/user-attachments/assets/a85ff490-3a3b-4a6f-98ef-405c7afd3c75\" alt=\"image\"></p>\n<h2 id=\"闪避时可转向\"><a href=\"#闪避时可转向\" class=\"headerlink\" title=\"闪避时可转向\"></a>闪避时可转向</h2><p><img src=\"https://github.com/user-attachments/assets/4b78300c-abd5-489b-8cbd-a5b22f27ec25\" alt=\"image\"><br>直接给这个通知拉满，只要在翻滚的过程就能改变方向。</p>\n<h2 id=\"修复攻击时闪避后不能再攻击的Bug\"><a href=\"#修复攻击时闪避后不能再攻击的Bug\" class=\"headerlink\" title=\"修复攻击时闪避后不能再攻击的Bug\"></a>修复攻击时闪避后不能再攻击的Bug</h2><p>因为攻击中闪避而没有走ComboReset。所以IsAttack永远为真。所以在闪避后再做一下ComboReset就可以了。<br><img src=\"https://github.com/user-attachments/assets/55919daa-5f86-4a61-874d-ddc6dde8144c\" alt=\"image\"></p>\n<h2 id=\"闪避时不能攻击\"><a href=\"#闪避时不能攻击\" class=\"headerlink\" title=\"闪避时不能攻击\"></a>闪避时不能攻击</h2><p>如果在闪避中，就不要给角色攻击了。<br><img src=\"https://github.com/user-attachments/assets/14805986-0c57-475e-8747-59ea86249464\" alt=\"image\"></p>\n<h1 id=\"创建敌人\"><a href=\"#创建敌人\" class=\"headerlink\" title=\"创建敌人\"></a>创建敌人</h1><p>按照惯例，先创建一个文件夹。<br><img src=\"https://github.com/user-attachments/assets/66545018-5140-430a-baf6-57e0eba58f0a\" alt=\"image\"></p>\n<h2 id=\"创建模型\"><a href=\"#创建模型\" class=\"headerlink\" title=\"创建模型\"></a>创建模型</h2><p>然后创建一个蓝图。<br><img src=\"https://github.com/user-attachments/assets/82b4ef15-613c-4ff8-bb95-86bfd201b9c1\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/043d70a2-8913-4cc2-946d-f8ccc1185e99\" alt=\"image\"></p>\n<p>然后打开它。给它加个模型。<br><img src=\"https://github.com/user-attachments/assets/8c805fcc-34b7-4ab2-9a0c-8f251beb302e\" alt=\"image\"></p>\n<p>调下参数。<br><img src=\"https://github.com/user-attachments/assets/05da5778-8ed3-479c-b022-e96243f94b1c\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/3bcf1d66-5a2b-480a-91ee-352c1d9c3932\" alt=\"image\"></p>\n<p>然后改一下这个模型的颜色。<br><img src=\"https://github.com/user-attachments/assets/b8bb0b83-c7bc-4501-ba03-6a46b923ec1b\" alt=\"image\"></p>\n<p>再原来的材质上复制多一份。<br><img src=\"https://github.com/user-attachments/assets/c98ae2e6-baa1-418c-b66c-eaf53a58de63\" alt=\"image\"></p>\n<p>双击新的材质，我们改下颜色。<br><img src=\"https://github.com/user-attachments/assets/0f32c809-c657-40db-8044-4529fdbf3de8\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/4aedcb06-83f7-41c9-a900-aab1ec0ad434\" alt=\"image\"></p>\n<p>点应用，保存。回来看，白色的材质球就做好了。<br><img src=\"https://github.com/user-attachments/assets/4fd7459b-3e23-40c6-82b6-449027807531\" alt=\"image\"></p>\n<p>然后回到AIChar，模型换个颜色。<br><img src=\"https://github.com/user-attachments/assets/26819ff3-d67c-4d9a-a417-328df0283880\" alt=\"image\"></p>\n<h2 id=\"敌人AI\"><a href=\"#敌人AI\" class=\"headerlink\" title=\"敌人AI\"></a>敌人AI</h2><p>然后我们创建一个AIController。<br><img src=\"https://github.com/user-attachments/assets/ca1ea923-691c-4406-8ae8-a2605a4c4afb\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/6142ce79-a7d7-47ad-bb52-853a968ffb97\" alt=\"image\"></p>\n<p>然后还要一个行为树。<br><img src=\"https://github.com/user-attachments/assets/8a2997c0-c965-4cf8-8def-c95980bde21e\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/cae9b9a6-05fb-4d6f-af34-f65307fe115a\" alt=\"image\"></p>\n<p>打开AICharController。在事件开始时运行行为树。<br><img src=\"https://github.com/user-attachments/assets/cbbe8f52-e13b-4f2d-a2d3-c03fb258aaa6\" alt=\"image\"></p>\n<p>然后在AIChar里关联上AICharController。<br><img src=\"https://github.com/user-attachments/assets/82b37ce7-943c-4c72-9228-586691b3aee8\" alt=\"image\"></p>\n<p>编译保存。然后我们打开行为树，新建一个黑板。<br><img src=\"https://github.com/user-attachments/assets/87f5f7f6-8aa1-41e8-bcc2-00e39c8a6f49\" alt=\"image\"></p>\n<p>给AI也创建下动画蓝图。<br><img src=\"https://github.com/user-attachments/assets/d4ae34fe-0497-4b96-8f4a-8f32be06de45\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/353c2213-71a3-4643-8ab8-81fe456faf4f\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/3726f82b-6edd-4505-b141-f4e93bdad4d6\" alt=\"image\"></p>\n<p>然后打开它。<br><img src=\"https://github.com/user-attachments/assets/67a68fc9-0068-4ec4-86b5-c3a583d7b1d9\" alt=\"image\"></p>\n<p>双击状态机添加状态。<br><img src=\"https://github.com/user-attachments/assets/362b54cd-10ab-4904-a7ce-efa55e78568c\" alt=\"image\"></p>\n<p>因为都是小白人，所以AI也可以用之前创建的混合空间。<br><img src=\"https://github.com/user-attachments/assets/36a6e05f-c548-4db8-8e2b-208a0a72dc85\" alt=\"image\"></p>\n<p>speed提升为变量。<br><img src=\"https://github.com/user-attachments/assets/ac0bb2cd-72a2-4ca0-80a3-43b84bee80ea\" alt=\"image\"></p>\n<p>编译保存。<br><img src=\"https://github.com/user-attachments/assets/d9d93f67-29ff-4f8c-befb-bbdfe581e070\" alt=\"image\"></p>\n<p>然后回到AIChar。使用刚才的动画蓝图。<br><img src=\"https://github.com/user-attachments/assets/ea8db878-043b-42eb-8936-330e2c5d048e\" alt=\"image\"></p>\n<p>然后给敌人加下武器。加下骨骼网格体。<br><img src=\"https://github.com/user-attachments/assets/76c6adae-251e-4d14-96be-b82e293b6a9e\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/1130ad52-7785-4931-9312-91fbf1c4cf1d\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/234fa00b-4cd9-4d80-8be5-d58ac0900013\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/6f318a91-327a-48b0-8a28-158336dab2a2\" alt=\"image\"></p>\n<p>然后加一下盾。<br><img src=\"https://github.com/user-attachments/assets/180eef07-6249-4739-ac7a-a4e2994a7511\" alt=\"image\"></p>\n<p>然后我们返回动画蓝图。<br><img src=\"https://github.com/user-attachments/assets/d50c8b23-e749-4657-9c2d-16bf50677047\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/6aee8920-6cdc-46be-93df-82858d1d17cc\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/13e49e0d-cb89-4202-b618-d391f84e0a0f\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/d88c102b-bebf-4c52-9cc0-e79d818ba4d1\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/2f6cb08f-9d80-410c-b528-b2576d347862\" alt=\"image\"></p>\n<p>我们动画蓝图算是写完了。AI也会根据它移动的速度来决定它动画是走是跑还是站立。这些都是和主角一样的。然后我们写下行为树。<br><img src=\"https://github.com/user-attachments/assets/4e7dc377-9747-4c00-917f-7d1023990d1b\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/1202b687-ea9a-4b89-ae81-bdb00773687b\" alt=\"image\"></p>\n<p>然后新建一个装饰器。<br><img src=\"https://github.com/user-attachments/assets/bfbc3bee-59d4-4abd-9823-94f0bb229410\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/7789d7df-4865-4efd-ba0c-4fc8be63b293\" alt=\"image\"></p>\n<p>用来检测有没有玩家。<br><img src=\"https://github.com/user-attachments/assets/7434c5be-fca0-45f4-83b9-ba3fd1df28c4\" alt=\"image\"></p>\n<p>然后取一下位置。<br><img src=\"https://github.com/user-attachments/assets/7740ec9f-dba1-4191-a9cb-0f5ca09d57de\" alt=\"image\"></p>\n<p>然后需要加一下球形检测。<br><img src=\"https://github.com/user-attachments/assets/beb4b409-3f79-405a-9237-f24fc95cd669\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/1154a98f-368a-47cb-bd3d-4b276a3a6291\" alt=\"image\"></p>\n<p>Object Types提升为变量。<br><img src=\"https://github.com/user-attachments/assets/08b38a85-4b63-4cfa-8836-991dcc527a00\" alt=\"image\"></p>\n<p>半径给1000。<br><img src=\"https://github.com/user-attachments/assets/6d87d7c8-5a04-4a62-8135-a7bf7107c398\" alt=\"image\"></p>\n<p>然后Draw Debug Type改成持久。<br><img src=\"https://github.com/user-attachments/assets/fbd8e918-a7ed-47c3-a5a8-6a3a98fd0d13\" alt=\"image\"></p>\n<p>最后连上。<br><img src=\"https://github.com/user-attachments/assets/93bd8211-11f5-4190-b6d0-8703e1fdb9a4\" alt=\"image\"></p>\n<p>输出会Out Hits打开。<br><img src=\"https://github.com/user-attachments/assets/e3d14855-7217-4f45-bff3-aa3720303b1e\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/2745b143-8870-4e6c-8e2a-25debb69af17\" alt=\"image\"></p>\n<p>然后把每个数组再break一下。<br><img src=\"https://github.com/user-attachments/assets/5ebc42d8-1a31-49a4-9c39-2b096357b57b\" alt=\"image\"></p>\n<p>如果这个球体检测到玩家，那就转化为玩家。检测不到就什么都不干。<br><img src=\"https://github.com/user-attachments/assets/09471e45-65d3-4a2d-bd82-5df1a67a9426\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/0a507935-2258-48cf-8946-4b99e14222df\" alt=\"image\"></p>\n<p>然后as player char给他设置黑板值。<br><img src=\"https://github.com/user-attachments/assets/ed1493fa-e09b-45a1-b52f-4c49256f4579\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/3cdcc036-34fd-49dc-9c5f-a3d2b017a6da\" alt=\"image\"></p>\n<p>然后把Key提升为变量。<br><img src=\"https://github.com/user-attachments/assets/89623cc9-dab7-4d09-899b-372d1d1c02ff\" alt=\"image\"></p>\n<p>把小眼睛点亮，这样你在行为树上才能看到这个变量。<br><img src=\"https://github.com/user-attachments/assets/c2244e2b-bbc2-4039-8cb1-ca8150336da6\" alt=\"image\"></p>\n<p>然后返回节点也连上。在循环结束之后返回为真。<br><img src=\"https://github.com/user-attachments/assets/a616f6ee-2b2e-4fb1-8247-c0424f4f884e\" alt=\"image\"></p>\n<p>编译保存。返回行为树。添加装饰器。<br><img src=\"https://github.com/user-attachments/assets/d019a563-e881-48e0-8515-aa4fc73077c2\" alt=\"image\"></p>\n<p>然后点击黑板，在黑板上新建一个值。<br><img src=\"https://github.com/user-attachments/assets/2e4f07d8-feea-4c40-9bc9-7454292e5e56\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/174988a1-a7ec-4921-87ee-9c1a5bdac27f\" alt=\"image\"></p>\n<p>改下基类。<br><img src=\"https://github.com/user-attachments/assets/86569bc7-4b95-4975-b031-67b58def24df\" alt=\"image\"></p>\n<p>保存。<br><img src=\"https://github.com/user-attachments/assets/98dddf20-b80e-4197-bf30-9eb4f7f0fd2a\" alt=\"image\"></p>\n<p>把顺序换成选择。<br><img src=\"https://github.com/user-attachments/assets/06b3aa9f-1276-4cfa-8635-f0ce44a48994\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/5a94f3f3-8e4f-44b7-8b02-1489184b7181\" alt=\"image\"></p>\n<p>然后再来个顺序。再加个装饰器。<br><img src=\"https://github.com/user-attachments/assets/7d931a30-fc9c-4880-9757-3c56ad88af0b\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/c1c0aac2-2ed4-458d-bce5-638629957965\" alt=\"image\"></p>\n<p>再来个顺序。<br><img src=\"https://github.com/user-attachments/assets/212147ac-2301-4c4c-a663-f32f3b5bc7d5\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/a9a367ba-a9e0-45fb-8b9b-f1d3a1280559\" alt=\"image\"></p>\n<p>设置未设置。用于没检测到玩家的操作。<br><img src=\"https://github.com/user-attachments/assets/d04af495-7b46-465e-9e8d-c27d9afd3767\" alt=\"image\"></p>\n<p>检测到玩家就走向玩家。<br><img src=\"https://github.com/user-attachments/assets/24347503-0e46-4a65-9a47-5b8096bf4683\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/13a5f6b8-c5c7-4155-9d3a-162d91ee3530\" alt=\"image\"></p>\n<p>保存。给场景添加一个导航网格体边界体积。<br><img src=\"https://github.com/user-attachments/assets/f24d1ce7-1c1b-4711-abc4-85ffe3e557b4\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/20ee04bc-be93-4bd7-88d3-4d172bb441cb\" alt=\"image\"></p>\n<p>调整导航网格体边界体积，让它覆盖整个场景。保存运行。现在可以看到敌人走过来了。<br><a href=\"https://github.com/user-attachments/assets/b852159c-7af5-4355-939e-5cbf04939564\">https://github.com/user-attachments/assets/b852159c-7af5-4355-939e-5cbf04939564</a></p>\n<h1 id=\"参数调整\"><a href=\"#参数调整\" class=\"headerlink\" title=\"参数调整\"></a>参数调整</h1><p>AI追到你后的等待时间可以自行调整。<br><img src=\"https://github.com/user-attachments/assets/fcba9118-7c70-4098-a1a0-c9179f369d63\" alt=\"image\"></p>\n<p>敌人的速度也可以调整下。<br><img src=\"https://github.com/user-attachments/assets/4d14a7f8-d3e6-478a-9b1e-c6a79ad2fd1a\" alt=\"image\"></p>\n<h1 id=\"添加巡逻\"><a href=\"#添加巡逻\" class=\"headerlink\" title=\"添加巡逻\"></a>添加巡逻</h1><p>新建一个服务。<br><img src=\"https://github.com/user-attachments/assets/6d9b22b3-3b70-4cf5-9200-1e7ecb759cb0\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/7826cc0b-20a0-4920-b223-106825196f2c\" alt=\"image\"></p>\n<p>打开，重载下接收Tick AI。<br><img src=\"https://github.com/user-attachments/assets/4f4815c6-b2a7-49cb-9b79-ed5e3a5fa077\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/9ca00b89-9d68-4390-8bf5-f9a63e575c86\" alt=\"image\"></p>\n<p>然后先取一下位置。<br><img src=\"https://github.com/user-attachments/assets/42bb346d-ba2d-450e-854d-9a549124d1d8\" alt=\"image\"></p>\n<p>然后得到一个随机可以到达的位置。<br><img src=\"https://github.com/user-attachments/assets/bf370ea4-3f26-46a2-8df8-6a62c7815796\" alt=\"image\"></p>\n<p>设置半径为500。<br><img src=\"https://github.com/user-attachments/assets/fe9e4284-c70c-4f8a-87a8-567d551f3ad4\" alt=\"image\"></p>\n<p>然后把得到的位置设置为黑板键。<br><img src=\"https://github.com/user-attachments/assets/a5bec732-a837-4875-b696-c7690adea388\" alt=\"image\"></p>\n<p>把Key提升为变量。改一名。<br><img src=\"https://github.com/user-attachments/assets/3c83a91c-bfcd-4f57-9dfd-bcfbce9e58cc\" alt=\"image\"></p>\n<p>小眼睛打开。<br><img src=\"https://github.com/user-attachments/assets/3ddae1e8-188e-4a9d-a10b-cb3c95f55896\" alt=\"image\"></p>\n<p>最后把线连上。<br><img src=\"https://github.com/user-attachments/assets/df24f285-4130-4843-8346-465866d29d16\" alt=\"image\"></p>\n<p>编译保存。</p>\n<p>返回行为树。添加服务。<br><img src=\"https://github.com/user-attachments/assets/8d0e7025-8d16-45fa-89cc-f698ee09f75e\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/34f276ee-746e-44f2-b1bb-faaff368a21b\" alt=\"image\"></p>\n<p>返回黑板。增加一个向量变量。<br><img src=\"https://github.com/user-attachments/assets/75355dc6-7c7a-4556-9ae4-f6ee6011255d\" alt=\"image\"></p>\n<p>返回行为树，把Target Location改为目的地。<br><img src=\"https://github.com/user-attachments/assets/e1f64468-1f56-497f-95e1-953fa33a155f\" alt=\"image\"></p>\n<p>移动到目的点。<br><img src=\"https://github.com/user-attachments/assets/f45fbc61-aeb5-464e-9ee0-51949851d8af\" alt=\"image\"></p>\n<p>保存。运行。现在AI能随机走动了。</p>\n<h1 id=\"攻击-1\"><a href=\"#攻击-1\" class=\"headerlink\" title=\"攻击\"></a>攻击</h1><p>然后在行为树新加一个任务，让敌人攻击。<br><img src=\"https://github.com/user-attachments/assets/21a18234-ea06-4923-8b43-cfdb11d9d685\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/32aeff91-334a-47fd-9657-045ff1fac6c6\" alt=\"image\"></p>\n<p>打开，重载下接收执行AI函数。<br><img src=\"https://github.com/user-attachments/assets/f2566b25-5b3b-45c0-9555-04b301db8aa2\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/447bc837-7608-4a9c-a161-53670f74a35c\" alt=\"image\"></p>\n<p>转化为AIChar，直接播放蒙大奇。<br><img src=\"https://github.com/user-attachments/assets/3c09d789-0314-4f1f-a616-e2e85595837d\" alt=\"image\"></p>\n<p>给AI找个攻击动画。<br><img src=\"https://github.com/user-attachments/assets/7fba2a81-e5be-41c4-ac82-9903aa212c43\" alt=\"image\"></p>\n<p>创建一个动画蒙太奇。<br><img src=\"https://github.com/user-attachments/assets/d881adea-72fe-40c1-8fc8-9245f2ec4686\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/13d49b0a-caa4-46f2-9417-68118e020362\" alt=\"image\"></p>\n<p>打开动画，启动下根运动。让他播放这个动画时有位移。<br><img src=\"https://github.com/user-attachments/assets/00d9ba67-0f8f-4b78-ad67-d4620ff36c08\" alt=\"image\"></p>\n<p>返回任务，指定动画资产为Attack_08_Montage。<br><img src=\"https://github.com/user-attachments/assets/14a4c53b-41a6-4458-9901-10583600a58c\" alt=\"image\"></p>\n<p>最后返回执行结果。<br><img src=\"https://github.com/user-attachments/assets/d94dcdd0-128d-4973-bc94-75238e223cdb\" alt=\"image\"></p>\n<p>然后返回行为树。添加攻击。<br><img src=\"https://github.com/user-attachments/assets/1cb244fe-5c72-489b-9a33-867eb291b57c\" alt=\"image\"></p>\n<p>编译保存运行。现在敌人会先过来再攻击，等待两秒再攻击。<br><a href=\"https://github.com/user-attachments/assets/7590acab-f16d-413a-9b09-176d8f08e8de\">https://github.com/user-attachments/assets/7590acab-f16d-413a-9b09-176d8f08e8de</a></p>\n<h1 id=\"添加伤害\"><a href=\"#添加伤害\" class=\"headerlink\" title=\"添加伤害\"></a>添加伤害</h1><h2 id=\"玩家打AI\"><a href=\"#玩家打AI\" class=\"headerlink\" title=\"玩家打AI\"></a>玩家打AI</h2><p>先给AI加点变量。<br><img src=\"https://github.com/user-attachments/assets/e18656d2-e52d-49fb-b01a-d2a8d6e55bef\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/2ecb1439-a4bf-4ec2-951f-d1a410049fb5\" alt=\"image\"></p>\n<p>接着回到主角这里，编辑攻击逻辑。<br><img src=\"https://github.com/user-attachments/assets/859f260f-2f1c-47b5-a299-48f757f2a715\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/9dda0063-e06d-4c78-af7b-0b8684947e64\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/e2229a81-18a5-417e-b9d7-d6f71da507b5\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/06839999-1235-4e38-9ffb-b1781f7b67fd\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/3c4dc47a-01de-4d1f-a25e-7e44d4861d18\" alt=\"image\"></p>\n<p>基础伤害给到10。<br><img src=\"https://github.com/user-attachments/assets/71ce7575-8069-4c08-89bb-87ddb81bfd65\" alt=\"image\"></p>\n<p>主角这边的攻击伤害算写完了。<br><img src=\"https://github.com/user-attachments/assets/a37e64ab-b14d-4b72-9056-50cf7f31df10\" alt=\"image\"></p>\n<p>返回AIChar，继续写敌人被打的逻辑。<br><img src=\"https://github.com/user-attachments/assets/70c83268-78c4-443d-b67b-fc5d36c53c69\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/aee29057-e22b-44cb-979b-cfc7e8c0b862\" alt=\"image\"></p>\n<p>保存编译运行。<br><img src=\"https://github.com/user-attachments/assets/9c1d00f4-2c3b-4ef1-9456-1831a88e5bb1\" alt=\"image\"></p>\n<p>打印了很多。需要关掉一些没必要的碰撞。<br><img src=\"https://github.com/user-attachments/assets/2df51470-4145-403a-84b3-d21b326e56a9\" alt=\"image\"></p>\n<p>主角这边也改一下。<br><img src=\"https://github.com/user-attachments/assets/4213bec2-c58a-4056-95fe-ef2f7dc77d01\" alt=\"image\"></p>\n<p>现在的攻击输出就正常了。<br><img src=\"https://github.com/user-attachments/assets/2b893408-ce33-4fe9-9d80-7ca626dcc997\" alt=\"image\"></p>\n<p>因为AI会档主角的摄像机，所以AI的胶囊机碰撞的自定义下。<br><img src=\"https://github.com/user-attachments/assets/3389da54-6eda-459b-9f2e-10a71e804525\" alt=\"image\"></p>\n<h2 id=\"死亡\"><a href=\"#死亡\" class=\"headerlink\" title=\"死亡\"></a>死亡</h2><p>先加个变量判断是否死亡。<br><img src=\"https://github.com/user-attachments/assets/fccb6abb-2bf4-4e7e-9842-3ab867a38a25\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/af07e16b-b6bd-4208-9f1c-883d2f292b96\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/2a9de655-0cc2-459d-94c6-1147112920c4\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/edde0898-0ae7-4273-b933-d6d9e2a0e38c\" alt=\"image\"></p>\n<h1 id=\"UI\"><a href=\"#UI\" class=\"headerlink\" title=\"UI\"></a>UI</h1><h2 id=\"敌人血条\"><a href=\"#敌人血条\" class=\"headerlink\" title=\"敌人血条\"></a>敌人血条</h2><p>新建UI文件夹。<br><img src=\"https://github.com/user-attachments/assets/1fa79399-80e6-4380-8f21-0f8178060568\" alt=\"image\"></p>\n<p>我们做一下血条。新建UI控件蓝图。<br><img src=\"https://github.com/user-attachments/assets/c2099d7a-4005-4955-bd2b-d4cfcb37ebd1\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/c3fd59f4-7d0c-49dd-85db-ffec77a567de\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/78f9adbc-eea5-4660-8ef3-e9e365a8c589\" alt=\"image\"></p>\n<p>然后打开它。新加画布。<br><img src=\"https://github.com/user-attachments/assets/e96e5f5e-a9c9-4308-be55-bebd2f57779b\" alt=\"image\"></p>\n<p>然后加个进度条。<br><img src=\"https://github.com/user-attachments/assets/125bf8e1-9a32-448d-8b47-2a0764340fc7\" alt=\"image\"></p>\n<p>锚点改成中间。<br><img src=\"https://github.com/user-attachments/assets/f2c53b34-4da2-408a-a456-688c00c93ead\" alt=\"image\"></p>\n<p>然后把位置设置回来。<br><img src=\"https://github.com/user-attachments/assets/2312d81c-218f-40d8-bbd5-fe6c48627d54\" alt=\"image\"></p>\n<p>对齐都改成0.5。<br><img src=\"https://github.com/user-attachments/assets/1f4c108a-04dd-48c5-96d6-398203fbf2eb\" alt=\"image\"></p>\n<p>尺寸y改成15。<br><img src=\"https://github.com/user-attachments/assets/a3edc8b1-0621-4e78-8d30-6984311355f3\" alt=\"image\"></p>\n<p>填充颜色改成红色。<br><img src=\"https://github.com/user-attachments/assets/da0c3187-48e9-4da6-bec5-c1d037e0a4ba\" alt=\"image\"></p>\n<p>然后创建绑定。<br><img src=\"https://github.com/user-attachments/assets/2f2c752a-8a2d-4b3c-bab7-696adb408e00\" alt=\"image\"><br><img src=\"https://github.com/user-attachments/assets/ad5e8fde-a1e7-47cf-ac0d-9ceb1b5bd1d6\" alt=\"image\"></p>\n<p>添加对象变量。<br><img src=\"https://github.com/user-attachments/assets/fbc5f798-e214-4ccb-907f-aa108af84477\" alt=\"image\"></p>\n<p>用现血量除以总血量得到血条的百分比。<br><img src=\"https://github.com/user-attachments/assets/7c73de96-f1dc-4e19-9644-fb7f94f73fa4\" alt=\"image\"></p>\n<p>编译保存。回到AIChar。</p>\n<p>添加控件组件。<br><img src=\"https://github.com/user-attachments/assets/3eccbaf8-e288-4ef3-88f7-12d8b5d02e1c\" alt=\"image\"></p>\n<p>改名为血条。</p>\n<p>控件类是AIHPBar。</p>\n<p>血条放到头顶上。</p>\n<p>给它空间设为屏幕。</p>\n<p>编译保存。回到事件图表。</p>\n<p>把HPBar拖进来。</p>\n<p>这样血条就加上了。</p>\n<p>玩家血条<br>接着我们做一下玩家的血条。</p>\n<p>新建个控件蓝图。</p>\n<p>编译保存。然后在PlayerChar里加点变量。</p>\n<p>然后回到PlayerHPBar创建绑定。</p>\n<p>然后我们回到PlayerChar。</p>\n<p>编译保存运行。</p>\n<p>让玩家受伤<br>直接在动画Attack08里新建一个通知。</p>\n<p>新建通知后，需要一个球形检测。</p>\n<p>基本和之前写的玩家攻击逻辑一样。</p>\n<p>然后返回PlayerChar。先加个变量。</p>\n<p>然后回到AIChar_ABP。</p>\n<p>保存编译，运行。现在敌人打玩家，玩家会扣血了。</p>\n<p>AI被打动画<br>找到这个被打动画。</p>\n<p>然后创建动画蒙太奇。</p>\n<p>打开AIChar。</p>\n<p>AI死亡动画<br>找到这个动画。</p>\n<p>创建动画蒙太奇。</p>\n<p>返回AIChar编写死亡动画逻辑。</p>\n<p>动画要设置根运动。</p>\n<p>在动画蒙太奇中不设置启动自动混出。敌人死亡倒地就结束了。</p>\n<p>然后找到AI攻击。</p>\n<p>让AI攻击前加个判断 ，判断是否正在播动画。</p>\n<p>接着回到AIChar。在死亡后删除胶囊体。</p>\n<p>编译保存运行。</p>\n<p>把AI的攻击动画换成原地的<br>现在AI攻击会向前，对于游戏来说，玩家不容易闪避。我们给AI换个原地攻击的动画。敌人呆一点比较好。选一个腿没有动的。</p>\n<p>然后创建蒙太奇。</p>\n<p>动作启动根运动。</p>\n<p>在AI攻击蓝图中改用这个动画。</p>\n<p>当然，也要加上动画通知。</p>\n<p>增加AI攻击前摇时间<br>打开攻击的动画蒙太奇，再拉一个动作。</p>\n<p>把第一段做成0.138。</p>\n<p>把前摇速率放慢。</p>\n<p>现在敌人的攻击前摇时间加长了，玩家容易闪避了。</p>\n<p>玩家被攻击动画<br>找到玩家被打动画。</p>\n<p>然后启用根运动。</p>\n<p>创建动画蒙太奇。</p>\n<p>然后回到PlayerChar。增加被攻击动画。</p>\n<p>每次受到伤害重置下玩家的攻击，防止玩家攻击时被攻击而不能再攻击。</p>\n<p>玩家被死亡动画</p>\n<p>把红框去掉<br><img src=\"https://github.com/user-attachments/assets/f531a06f-644a-44b7-8d66-71fac249c4a6\" alt=\"image\"></p>\n"},{"title":"计数排序","url":"/post/cb625b07.html","content":"<p>假如 H 省有 80 万考生，如何通过成绩快速排序得出排名呢？</p>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p><strong>计数排序是一种稳定的排序算法。</strong> 它的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。但是，计数排序也是很高冷！作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n<p>沿用上面的例子。考生的满分是 750 分，最小是 0 分，符合我们之前说的条件：数据范围小且是整数。我们可以划分为 751 个桶分别对应分数为 0 ~ 750 分数的考生。<br>接着开始遍历考生数据，每个考生按照分数则划分到对应数组下标，相同数组的下标则将该下标的数据值 + 1。其实就是每个数组下标位置对应的是数列数据出现的次数，最后直接遍历该数组，输出元素的下标就是对应的分数，下标对应的元素值是多少我们就输出几次。<br>桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 80 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/131610328-6297327d-4901-49e3-8e88-5de00e64711b.gif\" alt=\"计数排序\"></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countSort(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出数组A中的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : A) &#123;</span><br><span class=\"line\">        max = Math.max(max, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化计数数组count</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[max+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 对计数数组各元素赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : A) &#123;</span><br><span class=\"line\">        count[num]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建结果数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[A.length];</span><br><span class=\"line\">    <span class=\"comment\">// 创建结果数组的起始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历计数数组，将计数数组的索引填充到结果数组中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;count.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count[i]&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            result[index++] = i;</span><br><span class=\"line\">            count[i]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回结果数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们要输出的不仅仅是分数还有学生信息呢，比如说从小到大输出所有学生的姓名和分数，那么这个时候也只要做一点小小的变动。<br>我们用一个结构体去表示一个学生，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">students</span>&#123;</span> </span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">15</span>];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">    students *next;</span><br><span class=\"line\">&#125;student;</span><br></pre></td></tr></table></figure>\n<p>排序的过程中，我们依次遍历所有的学生分数，假设某个学生的分数为 i ,那么就在 score[i] 的后面插入该学生的节点。排完序后再按每个分数组打印链表中的学生姓名和分数。</p>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>需要排序的元素必须是整数，二是排序元素的取值要在一定范围内（例子是0-750。如果只排350-750分段，数组长度需要删减），并且比较集中。只有这两个条件都满足，才能最大程度发挥计数排序的优势。</p>\n<h2 id=\"计数排序与桶排序\"><a href=\"#计数排序与桶排序\" class=\"headerlink\" title=\"计数排序与桶排序\"></a>计数排序与桶排序</h2><p>其实计数排序是桶排序的一种特殊情况（桶不用再排序）。 桶排序的核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>\n","tags":["algorithm"]},{"title":"跳跃表","url":"/post/c5b5ce8a.html","content":"<p>这是发生在很多年以前的故事……<br>咱们需要做一个拍卖行系统，用来查阅和出售游戏中的道具。<br>拍卖行的商品总数量有几十万件，对应数据库商品表的几十万条记录。<br>如果是按照商品名称精确查询还好办，可以直接从数据库查出来，最多也就上百条记录。<br>如果是没有商品名称的全量查询怎么办？总不可能把数据库里的所有记录全查出来吧，而且还要支持不同字段的排序。<br>所以，只能提前在内存中存储有序的全量商品集合，每一种排序方式都保存成独立的集合，每次请求的时候按照请求的排序种类，返回对应的集合。<br>比如按价格字段排序的集合：<br>比如按等级字段排序的集合：</p>\n<p>拍卖行商品列表是线性的，最容易表达线性结构的自然是数组和链表。可是，无论是数组还是链表，在插入新商品的时候，都会存在性能问题。<br>按照商品等级排序的集合为例，如果使用数组，插入新商品的方式如下：<br><img src=\"https://user-images.githubusercontent.com/11263320/131290237-57b12c04-46af-44b0-83e6-61f93c211d65.JPG\" alt=\"捕获\"><br>如果要插入一个等级是3的商品，首先要知道这个商品应该插入的位置。使用二分查找可以最快定位，这一步时间复杂度是O（logN）。<br>插入过程中，原数组中所有大于3的商品都要右移，这一步时间复杂度是O（N）。所以总体时间复杂度是O（N）。</p>\n<p>如果使用链表，插入新商品的方式如下：<br><img src=\"https://user-images.githubusercontent.com/11263320/131290297-fd76c14e-bf17-47c1-be8b-549d5167e2fe.JPG\" alt=\"捕获\"><br>如果要插入一个等级是3的商品，首先要知道这个商品应该插入的位置。链表无法使用二分查找，只能和原链表中的节点逐一比较大小来确定位置。这一步的时间复杂度是O（N）。<br>插入的过程倒是很容易，直接改变节点指针的目标，时间复杂度O（1）。因此总体的时间复杂度也是O（N）。</p>\n<p>这对于拥有几十万商品的集合来说，这两种方法显然都太慢了。</p>\n<h2 id=\"什么是跳跃表\"><a href=\"#什么是跳跃表\" class=\"headerlink\" title=\"什么是跳跃表\"></a>什么是跳跃表</h2><p>这时候，可以用到<strong>跳跃表</strong>这种数据结构。<br>跳跃表是一种基于有序链表的扩展，简称跳表。<br>跳表利用类似索引的思想，提取出链表中的部分关键节点。比如给定一个长度是7的有序链表，节点值依次是<br>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8。那么我们可以取出所有值为奇数的节点作为关键节点。<br><img src=\"https://user-images.githubusercontent.com/11263320/131291889-32b55289-a6ee-40a4-ba7b-d86401c72b6f.JPG\" alt=\"捕获\"><br>此时如果要插入一个值是4的新节点，不再需要和原节点8，7，6，5，3逐一比较，只需要比较关键节点7，5，3.<br><img src=\"https://user-images.githubusercontent.com/11263320/131292038-90109f91-16f1-45a1-9748-27c5e72c0ec8.JPG\" alt=\"捕获\"><br>确定了新节点在关键节点中的位置（3和5之间），就可以回到原链表，迅速定位到对应的位置插入（同样是3和5之间）。<br><img src=\"https://user-images.githubusercontent.com/11263320/131292187-e8aa1cc2-58ed-4232-aa0f-370272a0120d.JPG\" alt=\"捕获\"><br>现在节点数目少，优化效果还不明显，如果链表中有1W甚至10W个节点，比较次数就整整减少了一半！<br>这样做法虽然增加了50%的额外的空间，但是性能提高了一倍。</p>\n<p>不过我们可以进一步思考。既然已经提取出了一层关键节点作为索引，那我们为何不能从索引中进一步提取，提出一层索引的索引？<br><img src=\"https://user-images.githubusercontent.com/11263320/131292531-2603383a-c87e-419c-9479-7ef2f1ddcb21.JPG\" alt=\"捕获\"><br>有了2级索引之后，新的节点可以先和2级索引比较，确定大体范围；然后再和1级索引比较；最后再回到原链表，找到并插入对应的位置。<br>当节点很多的时候，比较次数会减少到原来的四分之一。<br>当节点足够多的时候，不止能提出两层索引，还可以向更高层次提取，保证每一层是上一层节点数的一半。<br>至于提取的极限，则是同一层只有两个节点的时候，因为一个节点没有比较的意义。这样的多层链表结构，就是所谓的<strong>跳跃表</strong>。</p>\n<h2 id=\"跳跃表的插入\"><a href=\"#跳跃表的插入\" class=\"headerlink\" title=\"跳跃表的插入\"></a>跳跃表的插入</h2><p>当大量的新节点通过逐层比较，最终插入到原链表之后，上层的索引节点会渐渐变得不够用。这时候需要从新节点当中选取一部分提到上一层。跳跃表设计者采用了一种有趣的办法：抛硬币。也就是随机决定新节点是否提拔，每向上提拔一层的几率是50%。<br>我们仍然借用刚才的例子，假如值为9新节点插入原链表。<br><img src=\"https://user-images.githubusercontent.com/11263320/131293478-8c7f7b13-fe95-4043-a55d-a45100a7906b.JPG\" alt=\"捕获\"><br>因为跳跃表删除和添加的节点是不可预测的，所有很难用一种有效的算法来保证跳表的索引分部始终均匀。<br>随机抛硬币的方法虽然不能保证索引绝对均匀分布，却可以让大体趋于均匀。</p>\n<p>总结一下，跳跃表插入节点的流程有以下几步：<br>新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）</p>\n<p>把索引插入到原链表。O（1）<br>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）<br>总体上，跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）。</p>\n<h2 id=\"跳跃表的删除\"><a href=\"#跳跃表的删除\" class=\"headerlink\" title=\"跳跃表的删除\"></a>跳跃表的删除</h2><p>删除操作比较简单，只要在索引层找到要删除的节点，然后顺藤摸瓜，删除每一层的相同节点即可。<br>如果某一层索引在删除后只剩下一个节点，那么整个一层就可以干掉了。还用原来的例子，如果要删除的节点值是5：<br><img src=\"https://user-images.githubusercontent.com/11263320/131294128-9dc535c5-9db7-4277-9f04-f88beb6f2f20.JPG\" alt=\"捕获\"></p>\n<p>总结一下，跳跃表删除节点的步骤：<br>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O（logN）<br>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。O（logN）<br>总体上，跳跃表删除操作的时间复杂度是O（logN）。</p>\n<h2 id=\"跳跃表与二叉查找树的区别\"><a href=\"#跳跃表与二叉查找树的区别\" class=\"headerlink\" title=\"跳跃表与二叉查找树的区别\"></a>跳跃表与二叉查找树的区别</h2><p>跳跃表的优点是维持结构平衡的成本比较低，完全依靠随机。而二叉查找树在多次插入删除后，需要rebalance来重新调整结构平衡。</p>\n","tags":["algorithm"]}]