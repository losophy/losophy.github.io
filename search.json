[{"title":"Hexo+GitHub Pages博客搭建","url":"/2021/01/25/Hexo-GitHub-Pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><p>Hexo是一种使用Node.js编写的静态博客框架，快速、简洁、扩展丰富。</p>\n<h2 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h2><p>从官网下载Node.js，安装<br>安装结束后，添加阿里的国内镜像源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用GitHub-Pages\"><a href=\"#使用GitHub-Pages\" class=\"headerlink\" title=\"使用GitHub Pages\"></a>使用GitHub Pages</h2><p><a href=\"https://pages.github.com/\">GitHub Pages</a> 是一个GitHub提供的静态站点托管服务。<br>新建一个项目，项目名为（你的账号名.github.io）<br>建成项目后，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。<br>然后等一会儿，再回到GitHub Pages，点击那个链接，就可以看见自己的网页了</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件就存放在D:\\blog目录下。<br>cmd定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它即可。<br>安装完后输入hexo -v可以验证是否安装成功。</p>\n<p>如遇到，无法加载文件 .ps1，这是因为在此系统中禁止执行脚本的缘故。执行下列命令即可解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set-executionpolicy remotesigned</span><br><span class=\"line\">输入y</span><br></pre></td></tr></table></figure>\n<p>然后就可以初始化网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。<br>这样本地的网站配置也就弄好了，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>\n<p>就可以在本地看到博客了</p>\n<h2 id=\"写文章、发布文章\"><a href=\"#写文章、发布文章\" class=\"headerlink\" title=\"写文章、发布文章\"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。<br>然后输入hexo new post “article title”，新建一篇文章。<br>然后打开D:\\blog\\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章了。</p>\n<h2 id=\"删除文章\"><a href=\"#删除文章\" class=\"headerlink\" title=\"删除文章\"></a>删除文章</h2><p>直接在source/_post，删除所需删除的md文件<br>执行hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>然后再生成发布<br>hexo g<br>hexo d</p>\n<h2 id=\"绑定私人域名\"><a href=\"#绑定私人域名\" class=\"headerlink\" title=\"绑定私人域名\"></a>绑定私人域名</h2><p>ping你的github.io域名，得到一个IP<br>修改你的域名解析记录，添加一个A记录，用得到的IP<br><img src=\"https://user-images.githubusercontent.com/11263320/111414144-6d71b500-871a-11eb-824f-ef1c4c9fee70.JPG\" alt=\"捕获\"><br>在blog\\source生成文件CNAME，内容为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">你要用到的域名</span><br></pre></td></tr></table></figure>\n<p>注意域名不要加http://或https://<br>再生成发布下hexo就可以了</p>\n","tags":["blog"]},{"title":"Hexo替换主题","url":"/2021/04/09/Hexo%E6%9B%BF%E6%8D%A2%E4%B8%BB%E9%A2%98/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前在<a href=\"https://github.com/losophy/losophy.github.io/issues/6\">Hexo+GitHub Pages博客搭建</a>搭建了博客，这里将替换hexo的主题。这个<a href=\"https://hexo.io/themes/\">网站</a>有很多主题可以供我们去选择。我们这次安装主题也是上面这些主题中其中一个，它就是 NexT。</p>\n<h2 id=\"安装NexT主题\"><a href=\"#安装NexT主题\" class=\"headerlink\" title=\"安装NexT主题\"></a>安装NexT主题</h2><p>将主题克隆到themes目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> &lt;博客存放的目录&gt;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/114160164-36797280-9959-11eb-95be-9fe07290a533.JPG\" alt=\"gff\"></p>\n<h2 id=\"使用NexT主题\"><a href=\"#使用NexT主题\" class=\"headerlink\" title=\"使用NexT主题\"></a>使用NexT主题</h2><p>打开_config.yml文件，该文件为站点配置文件，存放位置如下图所示：<br><img src=\"https://user-images.githubusercontent.com/11263320/114160272-54df6e00-9959-11eb-907e-16f6e9a907f5.JPG\" alt=\"fgsdfgs\"><br>将主题修改为next<br><img src=\"https://user-images.githubusercontent.com/11263320/114160330-632d8a00-9959-11eb-80dd-fd3020941291.JPG\" alt=\"hgdfshdg\"></p>\n<h2 id=\"部署到服务器\"><a href=\"#部署到服务器\" class=\"headerlink\" title=\"部署到服务器\"></a>部署到服务器</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g -d</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/114160707-ccad9880-9959-11eb-98b5-9baa2c65bb07.JPG\" alt=\"捕获\"><br>这里可能会出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro&#x2F;post.swig‘ as post_template %&#125;“</span><br></pre></td></tr></table></figure>\n<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>","tags":["blog"]},{"title":"IO模型:select,poll,epoll","url":"/2021/02/12/IO%E6%A8%A1%E5%9E%8B-select-poll-epoll/","content":"<h2 id=\"鬼子进村\"><a href=\"#鬼子进村\" class=\"headerlink\" title=\"鬼子进村\"></a>鬼子进村</h2><p>处理大量的连接的读写，select 是够低效的。因为 kernel 每次都要对 select 传入的一组 socket 号做轮询，这叫鬼子进村策略。一遍遍的询问“鬼子进村了吗？”，“鬼子进村了吗？”… 大量的 cpu 时间都耗了进去。使用 kqueue 这些，变成了派一些个人去站岗，鬼子来了就可以拿到通知，效率自然高了许多。</p>\n<h2 id=\"缓存I-O\"><a href=\"#缓存I-O\" class=\"headerlink\" title=\"缓存I/O\"></a>缓存I/O</h2><p>缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n<h2 id=\"五种IO模型\"><a href=\"#五种IO模型\" class=\"headerlink\" title=\"五种IO模型\"></a>五种IO模型</h2><h3 id=\"阻塞式I-O模型\"><a href=\"#阻塞式I-O模型\" class=\"headerlink\" title=\"阻塞式I/O模型\"></a>阻塞式I/O模型</h3><p>默认情况下，所有套接字都是阻塞的。recvfrom等待数据准备好，从内核向进程复制数据。</p>\n<h3 id=\"非阻塞式I-O\"><a href=\"#非阻塞式I-O\" class=\"headerlink\" title=\"非阻塞式I/O\"></a>非阻塞式I/O</h3><p>进程把一个套接字设置成非阻塞是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误，recvfrom总是立即返回。</p>\n<h3 id=\"I-O多路复用\"><a href=\"#I-O多路复用\" class=\"headerlink\" title=\"I/O多路复用\"></a>I/O多路复用</h3><p>虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。其本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。select、poll 和 epoll 都是 Linux API 提供的 IO 复用方式。</p>\n<h3 id=\"信号驱动式I-O\"><a href=\"#信号驱动式I-O\" class=\"headerlink\" title=\"信号驱动式I/O\"></a>信号驱动式I/O</h3><p>用的很少，就不做讲解了。</p>\n<h3 id=\"异步I-O\"><a href=\"#异步I-O\" class=\"headerlink\" title=\"异步I/O\"></a>异步I/O</h3><p>这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我。recvfrom函数(经socket接收数据)。</p>\n<h2 id=\"再看POSIX对同步、异步这两个术语的定义\"><a href=\"#再看POSIX对同步、异步这两个术语的定义\" class=\"headerlink\" title=\"再看POSIX对同步、异步这两个术语的定义\"></a>再看POSIX对同步、异步这两个术语的定义</h2><ul>\n<li>同步I/O操作：导致请求进程阻塞，直到I/O操作完成；</li>\n<li>异步I/O操作：不导致请求进程阻塞。</li>\n</ul>\n<h2 id=\"各IO运行机制\"><a href=\"#各IO运行机制\" class=\"headerlink\" title=\"各IO运行机制\"></a>各IO运行机制</h2><h3 id=\"select运行机制\"><a href=\"#select运行机制\" class=\"headerlink\" title=\"select运行机制\"></a>select运行机制</h3><p>select()的机制中提供一种fd_set的数据结构，实际上是一个long类型的数组，每一个数组元素都能与一打开的文件句柄（不管是Socket句柄,还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一Socket或文件可读。</p>\n<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<h3 id=\"poll运行机制\"><a href=\"#poll运行机制\" class=\"headerlink\" title=\"poll运行机制\"></a>poll运行机制</h3><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。</p>\n<h3 id=\"epoll运行机制\"><a href=\"#epoll运行机制\" class=\"headerlink\" title=\"epoll运行机制\"></a>epoll运行机制</h3><p>epoll在Linux2.6内核正式提出，是基于事件驱动的I/O方式，相对于select来说，epoll没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。<br>epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。<br>epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>\n<ul>\n<li>水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件</li>\n<li>边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。<br><a href=\"https://github.com/losophy/losophy.github.io/issues/7\">LT和ET</a>原本应该是用于脉冲信号的，可能用它来解释更加形象。Level和Edge指的就是触发点，Level为只要处于水平，那么就一直触发，而Edge则为上升沿和下降沿的时候触发。比如：0-&gt;1 就是Edge，1-&gt;1 就是Level。</li>\n</ul>\n<p>ET模式很大程度上减少了epoll事件的触发次数，因此效率比LT模式下高。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一张图总结一下select,poll,epoll的区别：<br><img src=\"https://user-images.githubusercontent.com/11263320/107748824-9d611d80-6d54-11eb-8873-f5c79ac617b8.png\" alt=\"屏幕快照 2021-02-12 下午4 55 45\"><br>epoll是Linux目前大规模网络并发程序开发的首选模型。在绝大多数情况下性能远超select和poll。目前流行的高性能web服务器Nginx正式依赖于epoll提供的高效网络套接字轮询服务。但是，在并发连接不高的情况下，多线程+阻塞I/O方式可能性能更好。</p>\n<p>既然select，poll，epoll都是I/O多路复用的具体的实现，之所以现在同时存在，其实他们也是不同历史时期的产物</p>\n<ul>\n<li>select出现是1984年在BSD里面实现的</li>\n<li>14年之后也就是1997年才实现了poll，其实拖那么久也不是效率问题， 而是那个时代的硬件实在太弱，一台服务器处理1千多个链接简直就是神一样的存在了，select很长段时间已经满足需求</li>\n<li>2002, 大神 Davide Libenzi 实现了epoll</li>\n</ul>\n","tags":["linux"]},{"title":"IO设计模式：Actor、Reactor、Proactor","url":"/2021/02/13/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AActor%E3%80%81Reactor%E3%80%81Proactor/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前有提过<a href=\"https://github.com/losophy/losophy.github.io/issues/19\">IO模型</a>，而这些介绍下，用这些IO模型发展出来的IO设计模式</p>\n<h2 id=\"先介绍两种高性能服务器模式Reactor、Proactor\"><a href=\"#先介绍两种高性能服务器模式Reactor、Proactor\" class=\"headerlink\" title=\"先介绍两种高性能服务器模式Reactor、Proactor\"></a>先介绍两种高性能服务器模式Reactor、Proactor</h2><h3 id=\"Reactor模型\"><a href=\"#Reactor模型\" class=\"headerlink\" title=\"Reactor模型\"></a>Reactor模型</h3><p>1 向事件分发器注册事件回调<br>2 事件发生<br>4 事件分发器调用之前注册的函数<br>4 在回调函数中读取数据，对数据进行后续处理<br>Reactor模型实例：libevent，Redis、ACE</p>\n<h3 id=\"Proactor模型\"><a href=\"#Proactor模型\" class=\"headerlink\" title=\"Proactor模型\"></a>Proactor模型</h3><p>1 向事件分发器注册事件回调<br>2 事件发生<br>3 操作系统读取数据，并放入应用缓冲区，然后通知事件分发器<br>4 事件分发器调用之前注册的函数<br>5 在回调函数中对数据进行后续处理<br>Preactor模型实例：ASIO</p>\n<h3 id=\"reactor和proactor的主要区别\"><a href=\"#reactor和proactor的主要区别\" class=\"headerlink\" title=\"reactor和proactor的主要区别\"></a>reactor和proactor的主要区别</h3><h4 id=\"主动和被动\"><a href=\"#主动和被动\" class=\"headerlink\" title=\"主动和被动\"></a>主动和被动</h4><p>以主动写为例：<br>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；<br>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</p>\n<p>可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；<br>Proactor直接调用异步读写操作，调用完后立刻返回；</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；<br>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>Reactor实现相对简单，对于耗时短的处理场景处理高效；<br>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；<br>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；<br>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，<br>Proactor性能更高，能够处理耗时长的并发场景；</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；<br>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；</p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；<br>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</p>\n<h2 id=\"再说Actor模型\"><a href=\"#再说Actor模型\" class=\"headerlink\" title=\"再说Actor模型\"></a>再说Actor模型</h2><p>Actor模型被称为高并发事务的终极解决方案，<br>实体之通过消息通讯，各自处理自己的数据，能够实现这并行。<br>actor模型实例：skynet，Erlang </p>\n<p>Actor模型是一个概念模型，用于处理并发计算。它定义了一系列系统组件应该如何动作和交互的通用规则，最著名的使用这套规则的编程语言是Erlang。<br>一个Actor指的是一个最基本的计算单元。它能接收一个消息并且基于其执行计算。<br>这个理念很像面向对象语言，一个对象接收一条消息（方法调用），然后根据接收的消息做事（调用了哪个方法）。</p>\n<p>Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。</p>\n<h3 id=\"思路方向\"><a href=\"#思路方向\" class=\"headerlink\" title=\"思路方向\"></a>思路方向</h3><p>其实无论是使用数据库锁 还是多线程，这里有一个共同思路，就是将数据喂给线程，就如同计算机是一套加工流水线，数据作为原材料投入这个流水线的开始，流水线出来后就是成品，这套模式的前提是数据是被动的，自身不复杂，没有自身业务逻辑要求。适合大数据处理或互联网网站应用等等。</p>\n<p>但是如果数据自身要求有严格的一致性，也就是事务机制，数据就不能被动被加工，要让数据自己有行为能力保护实现自己的一致性，就像孩子小的时候可以任由爸妈怎么照顾关心都可以，但是如果孩子长大有自己的思想和要求，他就可能不喜欢被爸妈照顾，他要求自己通过行动实现自己的要求。</p>\n<p>数据也是如此。<br>只有我们改变思路，让数据自己有行为维护自己的一致性，才能真正安全实现真正的事务。<br>我们可以看到<br>Actor模型=数据+行为+消息。<br>Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。</p>\n","tags":["linux"]},{"title":"LT 和 ET","url":"/2021/01/25/LT-%E5%92%8C-ET/","content":"<h2 id=\"使用os提供的api如epoll编写并发应用程序\"><a href=\"#使用os提供的api如epoll编写并发应用程序\" class=\"headerlink\" title=\"使用os提供的api如epoll编写并发应用程序\"></a>使用os提供的api如epoll编写并发应用程序</h2><ul>\n<li>  <a href=\"https://github.com/yedf/handy/blob/master/raw-examples/epoll.cc\">epoll.cc</a>，演示了epoll的通常用法，使用epoll的LT模式</li>\n<li>  <a href=\"https://github.com/yedf/handy/blob/master/raw-examples/epoll-et.cc\">epoll-et.cc</a>，演示了epoll的ET模式，与LT模式非常像，区别主要体现在不需要手动开关EPOLLOUT事件</li>\n</ul>\n<h2 id=\"LT-和-ET本质的区别是\"><a href=\"#LT-和-ET本质的区别是\" class=\"headerlink\" title=\"LT 和 ET本质的区别是\"></a>LT 和 ET本质的区别是</h2><p>LT模式状态时，主线程正在epoll_wait等待事件时，请求到了，epoll_wait返回后没有去处理请求(recv)，那么下次epoll_wait时此请求还是会返回（立刻返回了）；而ET模式状态下，这次没处理，下次epoll_wait时将不返回（所以我们应该每次一定要处理），可见很大程度降低了epoll的触发次数（记住这句话先）。</p>\n","tags":["linux"]},{"title":"NexT主题美化","url":"/2021/04/22/NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/","content":"<h2 id=\"隐藏网页底部powered-By-Hexo-强力驱动\"><a href=\"#隐藏网页底部powered-By-Hexo-强力驱动\" class=\"headerlink\" title=\"隐藏网页底部powered By Hexo / 强力驱动\"></a>隐藏网页底部powered By Hexo / 强力驱动</h2><p>打开themes/next/layout/_partials/footer.swig,使用注释隐藏之间的代码即可，或者直接删除。位置如图：<br><img src=\"https://user-images.githubusercontent.com/11263320/115642209-1b413680-a34d-11eb-846e-e1d0bfa4ba4c.JPG\" alt=\"捕获\"></p>\n<h2 id=\"侧边栏显示当前浏览进度\"><a href=\"#侧边栏显示当前浏览进度\" class=\"headerlink\" title=\"侧边栏显示当前浏览进度\"></a>侧边栏显示当前浏览进度</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115645384-da4c2080-a352-11eb-8614-7c0ac37bab8c.JPG\" alt=\"捕获\"><br>打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true<br>如果想把 top 按钮放在侧边栏,打开 themes/next/_config.yml ,搜索关键字 b2t ,把 false 改为 true</p>\n<h2 id=\"右上角添加github入口\"><a href=\"#右上角添加github入口\" class=\"headerlink\" title=\"右上角添加github入口\"></a>右上角添加github入口</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115648404-f2726e80-a357-11eb-8778-d89058048806.JPG\" alt=\"捕获\"><br>1.首先到GitHub Corners或者GitHub Ribbons选择自己喜欢的图标，然后copy相应的代码<br>2.然后将刚才复制的代码粘贴到themes/next/layout/_layout.swig文件中</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;headband&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下面一行<br>3.把代码中的href后面的值替换成你要跳转的地址，比如你的GitHub主页</p>\n<h2 id=\"选择-Scheme\"><a href=\"#选择-Scheme\" class=\"headerlink\" title=\"选择 Scheme\"></a>选择 Scheme</h2><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。<br>编辑主题配置文件(themes\\next_config.yml)，确定喜爱的scheme</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">scheme: Pisces</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置菜单\"><a href=\"#设置菜单\" class=\"headerlink\" title=\"设置菜单\"></a>设置菜单</h2><h3 id=\"设定菜单内容\"><a href=\"#设定菜单内容\" class=\"headerlink\" title=\"设定菜单内容\"></a>设定菜单内容</h3><p>编辑主题配置文件(themes\\next_config.yml)，设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: &#x2F;|| home</span><br><span class=\"line\">  about: &#x2F;about&#x2F;|| user</span><br><span class=\"line\">  #tags: &#x2F;tags&#x2F;|| tags</span><br><span class=\"line\">  #categories: &#x2F;categories&#x2F;|| th</span><br><span class=\"line\">  #archives: &#x2F;archives&#x2F;|| archive</span><br><span class=\"line\">  #schedule: &#x2F;schedule&#x2F;|| calendar</span><br><span class=\"line\">  #sitemap: &#x2F;sitemap.xml|| sitemap</span><br><span class=\"line\">  #commonweal: &#x2F;404&#x2F;|| heartbeat</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理菜单的点击跳转\"><a href=\"#处理菜单的点击跳转\" class=\"headerlink\" title=\"处理菜单的点击跳转\"></a>处理菜单的点击跳转</h3><p>按照上面的方式设置的菜单之后，点击标签，或者关于我都会出现错误页面，那这是怎么回事呢？<br>在默认情况，source 目录只有 _posts 一个文件夹的，并没有生成对应的 tags,about 等文件夹，所以就会出现错误 页面。<br>生成下菜单文件夹的可以了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure>\n<p>将 source/tags/index.md 的内容修改为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">date: 2021-11-10 12:36:26</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>同样，about页面也按上面的方法生成下<br><img src=\"https://user-images.githubusercontent.com/11263320/114270259-f0e2a580-9a3d-11eb-9317-bbab438285a2.JPG\" alt=\"捕获\"><br>再重新部署一下项目，就不会出现错误页面问题了</p>\n<h2 id=\"添加搜索功能\"><a href=\"#添加搜索功能\" class=\"headerlink\" title=\"添加搜索功能\"></a>添加搜索功能</h2><p>在博客根目录安装搜索插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-search --安装插件，用于生成博客索引数据</span><br></pre></td></tr></table></figure>\n<p>修改博客配置文件（根目录/_config.yml），添加以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json #之前就是这里出了问题导致图标错误，错误的教程是 search.xml</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 1000</span><br></pre></td></tr></table></figure>\n<p>修改主题的根目录配置文件(themes\\next_config.yml)，把enable的false改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # if auto, trigger search by changing input</span><br><span class=\"line\">  # if manual, trigger search by pressing enter key or search button</span><br><span class=\"line\">  trigger: auto</span><br><span class=\"line\">  # show top n results per article, show all results by setting to -1</span><br><span class=\"line\">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>\n<p>重新生成下页面，就可以看到搜索框了<br><img src=\"https://user-images.githubusercontent.com/11263320/115741541-6fd2c900-a3c2-11eb-9982-8ec9693aadbd.JPG\" alt=\"捕获\"></p>\n<h2 id=\"修改文章底部带-号的标签\"><a href=\"#修改文章底部带-号的标签\" class=\"headerlink\" title=\"修改文章底部带#号的标签\"></a>修改文章底部带#号的标签</h2><p>将 # 换成标签图标。<br>[NexT 7.1.0 Released]修改方法为：<br>打开模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”，进行如下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class&#x3D;&quot;post-tags&quot;&gt;</span><br><span class=\"line\">          &#123;% for tag in post.tags %&#125;</span><br><span class=\"line\">            &lt;a href&#x3D;&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel&#x3D;&quot;tag&quot;&gt;&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt; &#123;&#123; tag.name &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class=\"line\">          &#123;% endfor %&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文章目录默认展开\"><a href=\"#文章目录默认展开\" class=\"headerlink\" title=\"文章目录默认展开\"></a>文章目录默认展开</h2><p>文章目录样式文件custom.styl文件位于themes/next/source/css/_custom，打开后添加内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;文章目录默认展开</span><br><span class=\"line\">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure>","tags":["blog"]},{"title":"NexT问题改进","url":"/2021/04/22/NexT%E9%97%AE%E9%A2%98%E6%94%B9%E8%BF%9B/","content":"<h2 id=\"主题分页的翻页箭头显示异常\"><a href=\"#主题分页的翻页箭头显示异常\" class=\"headerlink\" title=\"主题分页的翻页箭头显示异常\"></a>主题分页的翻页箭头显示异常</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115652669-45502400-a360-11eb-837c-cef626156a95.JPG\" alt=\"捕获\"><br>修改代码的位置: themes\\next\\layout_partials\\pagination.swig<br>修改为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% <span class=\"keyword\">if</span> page.prev or page.next %&#125;</span><br><span class=\"line\">  &lt;nav <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;pagination&quot;</span>&gt;</span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        prev_text: <span class=\"string\">&#x27;&lt;&#x27;</span>,</span><br><span class=\"line\">        next_text: <span class=\"string\">&#x27;&gt;&#x27;</span>,</span><br><span class=\"line\">        mid_size: <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &lt;/nav&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中文目录不跳转\"><a href=\"#中文目录不跳转\" class=\"headerlink\" title=\"中文目录不跳转\"></a>中文目录不跳转</h2><p>文章左侧的中文目录一直不能跳转也不能展开<br>浏览器按F12，点击目录链接会在控制台报错：Cannot read property ‘top’ of undefined。<br>打开控制台，查看目录的的超链接标签，会看到 href 是一串乱码。<br>实际上直接点击这个超链接是可以跳转的，但是点目录却不行。这是因为标题 id 是中文，但是目录的连接是中文乱码，代码里头的 JQuery 选择器拿着乱码是没法找到对应 id 的标题的。<br>顺着控制台错误提示找到 themes\\next\\source\\js\\src\\post-details.js，找到第 75 行为目录绑定点击事件的方法，会看到：<br><img src=\"https://user-images.githubusercontent.com/11263320/115653689-30749000-a362-11eb-872c-8552058812b2.JPG\" alt=\"捕获\"><br>targetSelector就是对应标题的 id，我们在他被塞到选择器之前重新编码一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对获取到的url进行重编码</span></span><br><span class=\"line\">targetSelector = <span class=\"built_in\">decodeURI</span>(<span class=\"built_in\">this</span>.getAttribute(<span class=\"string\">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>\n<p>然后 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g </span><br><span class=\"line\">hexo s </span><br></pre></td></tr></table></figure>\n<p>重新跑一下，发现目录就正常了。</p>\n","tags":["blog"]},{"title":"STL源码分析：Adapters","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AAdapters/","content":"<p>配接器在STL组件的灵活组合运用功能上，扮演着轴承、转换器的角色。Adaper这个概念，事实上是一种设计模式。在《设计模式》中adapter定义如下：将一个class的接口转换为另一个class的接口，使原本因接口不兼容而不能合作的classes，可以一起运作。</p>\n<h2 id=\"adapter模式\"><a href=\"#adapter模式\" class=\"headerlink\" title=\"adapter模式\"></a>adapter模式</h2><p>如果你有一个存在的系统需要插入一个新的类库,但是新的类库并不能匹配你写的系统，这时候我们就需要写一个适配器了,用这个适配器来适配新类库的接口。</p>\n<p>adapter取自生活中的配接器<br><img src=\"https://user-images.githubusercontent.com/11263320/111445192-200b3d00-8746-11eb-9fc2-f2eb3b84b33a.jpg\" alt=\"242dd42a2834349bcff8dd6ecbea15ce37d3be5b\"><br>在软件中也就是<br><img src=\"https://user-images.githubusercontent.com/11263320/111445271-3618fd80-8746-11eb-9055-ab836b4a01a6.jpg\" alt=\"902397dda144ad34bc5d346cd2a20cf430ad857f\"></p>\n<p>实现Adapter的方式主要有两种：组合(composition)和继承(inheritance)。<br>stl主要是用组合这种方式<br>container adapters内藏了一个container member一样，reverse iterator底层内藏了iterator member，而functions 的底层内藏了一个functions， 每个配接器的底层都有封装了一个对象，既然是这个对象的主人，就有资格调用该对象，并在参数和返回值上动手脚。</p>\n<h2 id=\"stl配接器分类\"><a href=\"#stl配接器分类\" class=\"headerlink\" title=\"stl配接器分类\"></a>stl配接器分类</h2><p>function adapter（通过它们之间的绑定，组合，修饰能力，几乎可以无限制地创造出各种可能的表达式。如使用bind2nd）<br>container adapter（如queue和stack，这两者底层容器都是deque，修饰deque的接口而成就出另一种容器风貌）<br>iterator adapter（所谓对迭代器的修饰，只是一种观念上的改变（赋值操作变成插入操作、前进变成后退、绑定到特殊装置上）。如insert iterators，reverse iterators，iostream iterators）</p>\n","tags":["cpp"]},{"title":"STL源码分析：Algorithms","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AAlgorithms/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>广义而言，我们所写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都用来解决或大或小的逻辑问题或数学问题。<br>STL算法包括排序、查找、排列组合算法，以及用于数据移动、复制、删除、比较、组合、运算等等。</p>\n<h2 id=\"质变与非质变\"><a href=\"#质变与非质变\" class=\"headerlink\" title=\"质变与非质变\"></a>质变与非质变</h2><p>如果以运算过程中会更改区间内的元素内容区分算法，可以分为质变算法与非质变算法。</p>\n<ul>\n<li>质变算法包括：拷贝、互换、替换、填写、删除、排列组合、分割、随机重排、排序等等。</li>\n<li>非质变算法包括：查找、匹配、计数、巡访、比较、寻找极值等等。</li>\n</ul>\n<h2 id=\"算法泛化\"><a href=\"#算法泛化\" class=\"headerlink\" title=\"算法泛化\"></a>算法泛化</h2><p>所有泛型算法的前两个参数都是一对迭代器，通常称为first和last，用以标示算法的操作区间。STL习惯采用前闭后开区间，写成[first,last)，表示区间涵盖first至last（不含last）之间的所有元素。当first==last时，上述所表现的便是一个空区间。</p>\n<p>只要把操作对象的型别加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化，整个算法也就在一个抽象层面上工作了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Iterator</span>,<span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\">Iterator <span class=\"title\">find</span><span class=\"params\">(Iterator begin, Iterator end, <span class=\"keyword\">const</span> T&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(begin != end &amp;&amp; *begin != value)</span><br><span class=\"line\">        ++begin;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> begin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["cpp"]},{"title":"STL源码分析：Allocator","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AAllocator/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Allocator译为空间配置器而不是内存配置器，是因为空间也可以是磁盘或其它辅助介质。</p>\n<h2 id=\"设计哲学\"><a href=\"#设计哲学\" class=\"headerlink\" title=\"设计哲学\"></a>设计哲学</h2><ul>\n<li>向system heap要求空间</li>\n<li>考虑多线程状态</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区块”可能造成的内存碎片问题</li>\n</ul>\n<p>考虚到小型区块所可能造成的内存破碎问题，SGI设计了双层级配置器，第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略：当配置区块超过128bytes时，视之为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用复杂的内存池整理方式，而不再求助于第一级配置器。</p>\n<h2 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h2><p>内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升。</p>\n<h2 id=\"内存基本处理工具\"><a href=\"#内存基本处理工具\" class=\"headerlink\" title=\"内存基本处理工具\"></a>内存基本处理工具</h2><p>STL定义有五个全局函数，作用于未初始化空间上。这样的功能对于容器的实现很有帮助。<br>分别是用于构造的construct()和用于析构的destroy()，另三个函数是uninitialized_copy()，uninitialized_fill()，uninitialized_fill_n()，分别对应该于高层次函数copy()，fill()，fill_n()。</p>\n","tags":["cpp"]},{"title":"STL源码分析：Containers","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AContainers/","content":"<h2 id=\"容器分类\"><a href=\"#容器分类\" class=\"headerlink\" title=\"容器分类\"></a>容器分类</h2><p>STL容器分两种：序列式容器，关联式容器。<br><img src=\"https://user-images.githubusercontent.com/11263320/111740539-e5c5ab00-88bf-11eb-9df6-00311a3ee53b.jpg\" alt=\"未标题-1副本\"><br>上图以内缩方式来表达基层与衍生层的关系。<br>heap内含一个vector，priority-queue内含一个heap、stack和queue都含一个deque，set/map/multiset/multimap都内含一个RB-tree，hash_x都内含一个hastable。</p>\n<h2 id=\"序列式容器\"><a href=\"#序列式容器\" class=\"headerlink\" title=\"序列式容器\"></a>序列式容器</h2><p>所谓序列式容器，其中的元素都可序(ordered)，但未必有序(sorted)。C++语言本身提供了一个序列式容器array。STL另外再提供 上列呈现的序列式容器。</p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p>vector的数据安排以及操作方式与array非常相似。两者唯一差别在于空间的运用的灵活性上。array是静态空间，设定要先定义空间。vector是动态空间，它的内部机制会自行扩充空间以容纳新元素。vector人运用对于内存的合理利用与运用的灵活性有很大的帮助。<br>vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。这里具体要看空间配置的策略。</p>\n<h4 id=\"vector的数据结构\"><a href=\"#vector的数据结构\" class=\"headerlink\" title=\"vector的数据结构\"></a>vector的数据结构</h4><p>线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的观念。<br>它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。<br><img src=\"https://user-images.githubusercontent.com/11263320/111742634-79e54180-88c3-11eb-82f0-394f0666b691.JPG\" alt=\"捕获\"></p>\n<h4 id=\"vector的迭代器\"><a href=\"#vector的迭代器\" class=\"headerlink\" title=\"vector的迭代器\"></a>vector的迭代器</h4><p>因为普通指针就可以满足vector的所有必要条件，而vector支持随机存取，所以vector提供的是Random Access Iterators。</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>list的好处是每次插入或删除一个元素，就配置或释放一个元素空间。list对于空间的运用有绝对的精准，一点也不浪费。而且对于任何位置的元素插入或无素移除，list永远是常数时间。<br>list和vector的选择最多视所元素的多寡、元素的构造复杂度、元素存取行为的特性而定。</p>\n<h4 id=\"list的数据结构\"><a href=\"#list的数据结构\" class=\"headerlink\" title=\"list的数据结构\"></a>list的数据结构</h4><p>从list的节点结构看，STL中的list是个双向链表。</p>\n<h4 id=\"list的迭代器\"><a href=\"#list的迭代器\" class=\"headerlink\" title=\"list的迭代器\"></a>list的迭代器</h4><p>所其操作上看，其迭代器是Bidirectional Itertors。</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。<br>deque没有容量观念。不像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”。<br>deque的数据结构：array无法成长，vector虽可成长，却只能向尾端成长，而且是个假象。deque采用一块空间作缓冲区，利用这个空间成长。<br><img src=\"https://user-images.githubusercontent.com/11263320/111743229-553d9980-88c4-11eb-8302-75aa7b6dc28e.JPG\" alt=\"捕获\"></p>\n<h4 id=\"deque的迭代器\"><a href=\"#deque的迭代器\" class=\"headerlink\" title=\"deque的迭代器\"></a>deque的迭代器</h4><p>和vector相似，是Random Access Iterators。</p>\n<h3 id=\"stack与queue\"><a href=\"#stack与queue\" class=\"headerlink\" title=\"stack与queue\"></a>stack与queue</h3><p>这两种都没有迭代器，数据结构是用deque实现的（其实用list也可以）。</p>\n<p>为什么选择deque作为stack、queue的底层默认容器？<br>stack是后进先出的特殊线性数据结构，只要具有push_back()和pop_back()操作的线性结构，都可以作为stack的底层容器，比如vector和list都可以；queue是先进先出的特殊线性数据结构，只要具有push_back和pop_front()操作的线性结构，都可以作为queue的底层容器，比如list<br>但是STL中对stack和queue选择deque作为其底层容器，主要是因为：<br>（1）stack和queue不需要遍历（stack和queue没有迭代器），只需要在固定的一端或者两端进行操作<br>（2）在stack中元素增长时，deque比vector的效率高<br>（3）在queue中的元素增长时，deque不仅效率高，而且内存使用率也高</p>\n<h3 id=\"heap\"><a href=\"#heap\" class=\"headerlink\" title=\"heap\"></a>heap</h3><p>heap不归属于stl容器组件，它是priority queue的助手。priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）的元素开始取。binary max heap正是具有这样的特性，适合作为priority queue的底层机制。</p>\n<h4 id=\"heap底部容器\"><a href=\"#heap底部容器\" class=\"headerlink\" title=\"heap底部容器\"></a>heap底部容器</h4><p>以vector表现的完全二叉树。实现算法为最大堆。</p>\n<p>priority_queue<br>priority_queue是一个拥有权值观念的queue。<br>priority_queue没有迭代器。</p>\n<h3 id=\"slist\"><a href=\"#slist\" class=\"headerlink\" title=\"slist\"></a>slist</h3><p>这是个单向链表，所以迭代器变为Forward Iterator。</p>\n<h2 id=\"关联式容器\"><a href=\"#关联式容器\" class=\"headerlink\" title=\"关联式容器\"></a>关联式容器</h2><p>标准的STL关联式容器分为set（集合）和map（映射表）两大类，以及这两大类的衍生体mutiset（多键集合）和multimap（多键映射表）。由于RB-tree自动排序的效果很不错，所以这些容器的底层机制均以RB-tree（红黑树）完成。RB-tree也是一个独立容器，但并不开放给外界使用。<br>此外，STL还提供了一个关联式容器：hash_table（散列表），以及以此为底层机制而完成的hash_set（散列集合）、hash_map（散列映射表）、hash_multiset（散列多键集合）、hash_multimap（散列多键映射表）。</p>\n<p>所谓关联式容器，观念上类似关联式数据库（key-value）。当元素被插入到关联式容器中时，容器内部结构（可能是RB-tree，也可能是hash-table）便依照其键值大小，以某种特定规则将这个元素放置于适当位置。<br>关联式容器没有所谓头尾（只有最大元素与最小元素）。<br>一般而言，关联式容器的内部结构是一个balanced binary tree，以便获得良好的搜寻效率。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>set的特性是所有元素都会根据元素的键值自动被排序。set元素的键值就是实值，实值就是健值。set不允许两个元素有相同的键值。</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>map的特性是，所有元素都会根据元素的键值自动被排序。map的所有元素都是pair。</p>\n<h3 id=\"multiset与multimap\"><a href=\"#multiset与multimap\" class=\"headerlink\" title=\"multiset与multimap\"></a>multiset与multimap</h3><p>特性以及用法和各自兄弟(set，map)完全相同，唯一的差别在于它们允许键值重复。</p>\n<h3 id=\"hashtable\"><a href=\"#hashtable\" class=\"headerlink\" title=\"hashtable\"></a>hashtable</h3><p>二叉搜索树表现的构造在一个假设上：输入数据有足够的随机性。而hash_table（散列表）的数据结构的操作表现是以统计为基础，不需仰赖输入元素的随机性。<br>hash_set、hash_map、hash_multiset、hash_multimap<br>都是以hash_table为底层机制。但其实元素不能自动排序。</p>\n<h2 id=\"Hash与RB树的区别\"><a href=\"#Hash与RB树的区别\" class=\"headerlink\" title=\"Hash与RB树的区别\"></a>Hash与RB树的区别</h2><p>权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性，有序性。<br>总体来说，hash查找速度会比RB树快，而且查找速度基本和数据量大小无关，属于常数级别;而RB树的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。</p>\n<p>红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。<br>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。<br>红黑树是有序的，Hash是无序的，根据需求来选择。</p>\n<p>拿红黑树实现的Map和Hash实现的HashMap相比：<br>如果只需要判断Map中某个值是否存在之类的操作，当然是Hash实现的要更加高效。<br>如果是需要将两个Map求并集交集差集等大量比较操作，就是红黑树实现的Map更加高效。</p>\n","tags":["cpp"]},{"title":"STL源码分析：Functors","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AFunctors/","content":"<p>仿函数其实上就是一个“行为类似函数”的对象。仿函数可以让STL算法有更灵活的演出。<br>c++11中已经引入lamda表达式，相当于将这部分内容加入了语法。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>为实现仿函数，其类别定义中必须自定义（或说改写、重载）function call运算子（operator()）。拥有这样的运算子后，我们就可以在仿函数的对象后而加上一对小括号，以此调用仿函数所定义 的operator()。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>STL仿函数的分类，若以操作数的个数划分，可分为一元和二元仿函数，若以功能划分，可以为算术运算、关系运算、逻辑运算三在类。</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>在我们写代码时有时会发现有些功能实现的代码，会不断的在不同的成员函数中用到，但是又不好将这些代码独立出来成为一个类的一个成员函数。但是又很想复用这些代码。写一个公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。这时就可以用仿函数了，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。这样就免去了对一些公共变量的全局化的维护了。又可以使那些代码独立出来，以便下次复用。而且这些仿函数，还可以用关联，聚合，依赖的类之间的关系，与用到他们的类组合在一起，这样有利于资源的管理（这点可能是它相对于函数最显著的优点了）。</p>\n<p>有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针，依据函数生成对象，甚至是让函数之间有继承关系，对函数进行运算和操作的效果。</p>\n","tags":["cpp"]},{"title":"STL源码分析：Iterators","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AIterators/","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>提供一种方法，使之能够依序巡访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p>\n<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><p>迭代器是一种行为类似指针人对象。而指针的各种行为中最常见也最重要的便是内容提领(*)和成员访问(-&gt;)，迭代器最重要的编程工作就是对这两个操作进行重载工作。</p>\n<h2 id=\"Traits编程技法（STL源代码门钥）\"><a href=\"#Traits编程技法（STL源代码门钥）\" class=\"headerlink\" title=\"Traits编程技法（STL源代码门钥）\"></a>Traits编程技法（STL源代码门钥）</h2><p>Traits就像一台“特性萃取机”，榨取各个迭代器的特性（相应型别）<br><img src=\"https://user-images.githubusercontent.com/11263320/109153358-c8f9f400-77a7-11eb-9fc2-f553290702c7.png\" alt=\"20180320140804433\"><br>迭代器相应有以上↑这五种型别。如果你希望你所开发的容器能与stl兼容，一定要为你的容器迭代器定义这五种相应型别。<br>value type：迭代器所指对象的型别。<br>difference type：两个迭代器之间的距离。<br>reference type：引用<br>pointer type：指针<br>iterator_category：这里就是移动特性与施行操作了。</p>\n<h2 id=\"按iterator-category区分迭代器的五类\"><a href=\"#按iterator-category区分迭代器的五类\" class=\"headerlink\" title=\"按iterator_category区分迭代器的五类\"></a>按iterator_category区分迭代器的五类</h2><p>Input Iterator<br>Output Iterator<br>Forward Iterator<br>Bidirectional Iterator<br>Random Access Iterator</p>\n<p>为了符合规范，任何迭代器都应该提供五个内嵌相应型别，以利于traits萃取。STL提供了一个iterators class，继承它，就可以保证符合stl所需之规范。</p>\n","tags":["cpp"]},{"title":"STL源码分析：泛型编程与STL","url":"/2021/02/25/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8ESTL/","content":"<h2 id=\"泛型编程\"><a href=\"#泛型编程\" class=\"headerlink\" title=\"泛型编程\"></a>泛型编程</h2><p>定义抽象的concepts，并根据抽象的concepts来撰写算法与数据结构，是泛型编程的本质。</p>\n<h3 id=\"运用STL时的几个最重要的观念\"><a href=\"#运用STL时的几个最重要的观念\" class=\"headerlink\" title=\"运用STL时的几个最重要的观念\"></a>运用STL时的几个最重要的观念</h3><ol>\n<li>所谓使用STL，就是去扩充它。</li>\n<li>STL的算法和容器是独立分离的。</li>\n<li>无须继承。</li>\n<li>抽象化并不意味效率低。</li>\n</ol>\n<p>STL所实现的，是依据泛型思维架设起来的一个概念结构。这个以抽象概念为主体而非以实际类为主体的结构，形成了一个严谨的接口标准。在此接口下，任何组件都有最大的独立性，并以所谓迭代器胶合起来，或以所谓配接器互相配接，或以所谓仿函数动态选择某种策略。</p>\n<h3 id=\"六大组件交互关系\"><a href=\"#六大组件交互关系\" class=\"headerlink\" title=\"六大组件交互关系\"></a>六大组件交互关系</h3><p>Container通过Allocator取得数据储存空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同的策略变化，Adapter可以修饰或套接Functor。</p>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>Iterator可说是STL最重要的一个创新发明，它使”将算法与其相关数据结构的关系切割分离“一事变得可能。</p>\n<p>何为Concept？<br>如果Concept既非class，也非function或template，那么它是什么？有三种方式可以了解Concepts，这些方式一开始似乎大不相同，但是最后证明都是相通的。这三种方式有助于了解泛型算法的一些重要观点。</p>\n<p>第一，Concept可以想象是一组型别条件。如果说型别Ｔ是Concept Ｃ的一个model，则Ｔ必 须满足Ｃ的所有条件。描述某个型别所必须具备的性质几乎是最容易具体指明Concept的方式了。<br>第二，Concept可以想成是型别的集合。举例来说，Concept input iterator可涵盖char<em>、int</em>、node* 等型别。如果型别Ｔ是Concept C 的model，意思便是说Ｔ隶属于Ｃ所代表的那个型别集合。由于集合中的所有型别都满足那一系列条件，其实是以不同的角度看待同一件事情。<br>第三，Concept可以想象成是一组合法程序。依次定义，那么像input iterator这样的Concept，其重要性在于find以及其他许多算法都会用到它。这个Concept自身包含iterator及那些算法共有的性质。这种定义似乎比前两者更加抽象，但是却很重要，因为就某种意义来说，这是三中方法中最实用的。这也是新的概念的发掘方法。是的，我们并非藉由写下一组需求条件来发掘和描述新 的概念，而是藉由定义特别的算法并研究模板参数如何运行于这些算法身上的过程来完成。我们研究find，过程中导出了 input iterator。本书其他各种概念同样是肇因与算法。 </p>\n<p>Iterator是指针的概括物，它们是”用来指向其他对象“的一种对象。<br>Iterator对于泛型编程之所以重要，原因是它是算法与数据结构之间的接口。<br>1、Input Iterator ：只允许作为输入，也就是只读（Read Only）<br>2、Output Iterator ：只允许作为输出，也就是只写（Write Only）<br>3、Forward Iterator ：允许读写，但只能做前向移动<br>4、Bidirectional Iterator ：允许读写，可以做双向移动<br>5、Random Access Iterator ：允许读写，可以任意移动，可作（P+N和P-N）、（P[n]）、（P1-P2）、（P1 &lt; P2）</p>\n<h2 id=\"Function-objects\"><a href=\"#Function-objects\" class=\"headerlink\" title=\"Function objects\"></a>Function objects</h2><p>Function objects是非常一般化的概念，它们可以将任何种类的行为参数化。几乎任何算法都能以“将其行为的某一部分抽象化为function object”的方式来加以一般化。</p>\n<h2 id=\"Containers\"><a href=\"#Containers\" class=\"headerlink\" title=\"Containers\"></a>Containers</h2><p>STL预定义的所有container classes都是一种Forward Container，其中大多数甚至是Bidirectional Container。有一些像block之类的container classes，则属于Random Access Container。</p>\n<h2 id=\"Allocators\"><a href=\"#Allocators\" class=\"headerlink\" title=\"Allocators\"></a>Allocators</h2><p>很多containers以动态方式分配内存（但非全部如此，例如block就不是）。配置器，它代表一种特定内存模型，并提供一种抽象概念，以便将对内存的申请最终转变为对内存的直接调用。<br>STL提供了很多泛型容器，如vector，list和map。程序员在使用这些容器时只需关心何时往容器内塞对象，而不用关心如何管理内存，需要用多少内存，这些STL容器极大地方便了C++程序的编写。</p>\n<h2 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h2><p>各种常用算法，如sort,search,copy,erase。从实现的角度讲，STL算法是一种function template。</p>\n<h2 id=\"Adapters\"><a href=\"#Adapters\" class=\"headerlink\" title=\"Adapters\"></a>Adapters</h2><p>一种用来修饰容器或仿函数或迭代器接口的东西。<br>改变functor接口者，称为function adapter;<br>改变contrainer接口者，称为contrainer adapter;<br>改变iterator接口者，称为iterator adapter。</p>\n","tags":["cpp"]},{"title":"c++对象模型研究1：关于对象","url":"/2021/02/25/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B61%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/","content":"<h2 id=\"对象模型\"><a href=\"#对象模型\" class=\"headerlink\" title=\"对象模型\"></a>对象模型</h2><p>和c不同，c是将数据和处理数据的函数分开的（数据流过程决定函数编写，过程式的）；而c++把数据和处理数据的方法关联在了一起（对象发起动作，操纵数据）。那么像class一样将数据和方法包含在一起，甚至再用上模板是否会增加布局成本呢？</p>\n<p>C++对象模式<br>在C++中，有两种类成员数据：static和非static，以及三种类成员函数：static、非static和virtual。</p>\n<p>在C++对象模型中，非static成员数据被配置于每一个类对象之内，static成员数据则被放在所有类对象之外。static和非static成员函数也被放在所有的类对象之外。</p>\n<p>C++在布局以及存取时间上主要的额外负担是由virtual引起，包括<br>1.虚函数机制（执行时绑定）<br>2.虚基类。还有一些多重继承下的额外负担。</p>\n<p>virtual函数则以两个步骤支持之：<br>1.每一个类产生出一堆指向virtual函数的指针，放在表格之中。这个表格被称为virtual表。<br>2.第一个类对象被添加了一个指针，指向相关的virtual表。这个指针的设定和重置都由每一个类的构造函数，析构函数和拷贝赋值运算符自动完成。另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time Type Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</p>\n<p>和c相比，c++的布局成本主要来自于virtual，virtual使得class object需要先找虚表，再由虚表找所在地，增加了耗费。而像nonstatic data menber，跟c中struct完全一样，所以这些并不会增加c++的布局成本（相对于c而言）。</p>\n<p>对于C++中的单继承<br>C++实际模型是：对于一般继承是扩充已有存在的虚函数表；对于虚继承添加一个虚函数表指针。</p>\n<p>对于C++中的多继承<br>1）每一个基类都有自己的虚函数表，基类各有虚表<br>2）子类的虚函数被放到第一个基类的虚函数表中，子类与第一个父类共用一张虚表<br>3）内存布局中，基类的排列顺序就是基类的声明顺序<br>4）重写：每一个基类的虚表中的fun都被重写成子类的fun，这样做就是为了解决不同的基类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>\n<p>对于C++中的多继承中的虚继承<br>虚继承的子类，有单独的虚函数表，另外也单独保存一份父类的虚函数表。</p>\n<h2 id=\"如何访问成员\"><a href=\"#如何访问成员\" class=\"headerlink\" title=\"如何访问成员\"></a>如何访问成员</h2><p>数据成员如何访问（直接取址）？<br>跟实际对象模型相关联，根据对象起始地址+偏移量取得。</p>\n<p>函数成员如何访问（间接取址）？<br>跟实际对象模型相关联，普通函数（nonstatic、static）根据编译、链接的结果直接获取函数地址；如果是虚函数根据对象模型，取出对于虚函数地址，然后在虚函数表中查找函数地址。</p>\n<p>多态如何实现?<br>多态（Polymorphisn）在C++中是通过虚函数实现的。如果类中有虚函数，编译器就会自动生成一个虚函数表，对象中包含一个指向虚函数表的指针。能够实现多态的关键在于：虚函数是允许被派生类重写的，在虚函数表中，派生类函数对覆盖（override）基类函数。除此之外，还必须通过指针或引用调用方法才行，将派生类对象赋给基类对象。</p>\n<p>为什么析构函数设为虚函数是必要的？<br>带有多态性质的基类应该声明一个虚析构函数。如果一个类带有任何虚函数，它就应该拥有一个虚析构函数。 </p>\n<p>如果析构函数不定义为虚函数，那么派生类就不会重写基类的析构函数，在有多态行为的时候，派生类的析构函数不会被调用到（有内存泄漏的风险！）。<br>一个类的设计目的不是作为基类使用，或不是为了具备多态性，就不该声明虚析构函数。</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>本质上一个引用通常是以一个指针来实现，而且是const指针。</p>\n","tags":["cpp"]},{"title":"c++对象模型研究2：构造函数","url":"/2021/02/25/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B62%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","content":"<p>关键词explicit之所以被导入这个语言，就是为了提供给程序员一种方法，使他们能够制止“单一参数的构造函数”被当做一个转换运算符。</p>\n<h2 id=\"默认构造函数的构建操作\"><a href=\"#默认构造函数的构建操作\" class=\"headerlink\" title=\"默认构造函数的构建操作\"></a>默认构造函数的构建操作</h2><p>以下四种情况类会被生成“有用的”默认构造函数<br>a.一个带有默认构造函数的成员对象类<br>  合成的默认构造函数是以inline的方式完成的，如果函数太复杂则会做成非inline的static实体</p>\n<p>b.带有默认构造函数的基类<br>  和上述情况相似，子类没有构造函数，编译器会默认合成一个调用基类默认（无参）构造函数的子类默认构造函数</p>\n<p>c.带有一个虚函数的class<br>  以下两种情况需要合成出默认构造函数<br>1）类声明（或继承）一个虚函数<br>2）类派生自一个继承串链，其中有一个或多个虚基类</p>\n<p>d.带有一个虚基类的类（菱形继承）</p>\n<p>关于默认构造函数的合成两点是需要注意的：<br>1）不是任何没有定义构造函数的类都会被合成出一个默认构造函数<br>2）编译器合成出来的默认构造函数不会对类内每一个成员数据都设定默认值</p>\n<h2 id=\"拷贝构造函数的构建操作\"><a href=\"#拷贝构造函数的构建操作\" class=\"headerlink\" title=\"拷贝构造函数的构建操作\"></a>拷贝构造函数的构建操作</h2><p>有三种情况，会以一个对象的内容作为另一个类对象的初值<br>1.对一个对象做明确的初始化操作<br>2.当对象被当作参数交给某个函数时<br>3.当函数传回一个类对象时</p>\n<p>一个类对象可以从两种方式复制得到，一种是拷贝构造，另一种是拷贝赋值操作（=）。</p>\n<p>关于复制<br>其实复制涉及到C++内部模型的两个概念，即Default Memberwise Initialization 和bitwise copy semantics。<br>Default Memberwise Initialization： 这是C 模型的内部一种实现方案,其原理就是对于同一类的两个对象直接的赋值进行的暗箱操作。说白了，就是将一个对象的内存空间中的数据，原封不动的拷贝出另一份来填满另一个对象的内存。<br>如果该类内含其他类的对象作为自己的成员变量的话，那赋值操作并不会对该对象变量进行赋值，而是递归的对其内部数据成员赋值（原理还是有关对象内存布局）。如果类中有个指针成员变量，而其指向堆中的一片区域，然而在赋值过程中，根据memberwise的概念，只是将指针的值进行了赋值，这样一来，这两个对象中的指针变量自然都是指向同一片内存区域了，即所谓的浅拷贝。所以这时就需要程序员自己来实现拷贝构造函数来完成那片堆内存的拷贝赋值操作，即所谓的深拷贝。</p>\n<p>不要bitwise copy semantic<br>什么时候一个类不展现出bitwise copy semantic呢？<br>1）当类内含有一个成员类对象，而这个成员类对象内有一个拷贝构造函数时（不论是class设计者明确声明，或者被编译器合成 ）。<br>2）当类继承自 一个基类，而基类有拷贝构造函数时（不论是类设计者明确声明，或者被编译器合成 ）。<br>3）当一个类声明了一个或多个virtual 函数时。<br>4）当类派生自一个继承串链，其中一个或者多个virtual基类。<br>在前两种情况中，编译器必须将成员或基类的“ 构造函数的调用操作” 安插到被合成的构造函数中。（就像构造函数中的操作那样）。<br>第三种情况，如果编译器对于每一个新产生的类对象的虚表不能成功而正确地设好其初值，将导致可怕的后果。因此，当编译器导入一个虚表到类之中时，该类就不再展现bitwise copy semantic了。如果没有 bitwise copy semantics的作用的话，很容易想到，编译器会用到默认复制来对两个对象的vptr进行复制，因为两个类对象的vp都指向同一个vptr，所以会导致可怕的后果。</p>\n<p>这里我都被bitwise 和Memberwise 搞昏了。反正就是以上四种情况，复制不是单纯的直接复制。编译器会开辟新内存。</p>\n<h2 id=\"构造函数使用\"><a href=\"#构造函数使用\" class=\"headerlink\" title=\"构造函数使用\"></a>构造函数使用</h2><p>在使用者层面做优化<br>一般来说是这么写的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tX xx;</span><br><span class=\"line\">\txx.X::X(p1,p2);<span class=\"comment\">//default constructor? OR member fuction?</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xx；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//编译器内部的伪码：</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> bar(X&amp; _result, <span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tX xx;</span><br><span class=\"line\">\txx.X::X(p1,p2);<span class=\"comment\">//default constructor? OR member fuction?</span></span><br><span class=\"line\">\t_result.X::XX(xx);<span class=\"comment\">//copy constructor</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;  <span class=\"comment\">//什么也不返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这么写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">bar</span><span class=\"params\">(<span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> X(p1,p2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//编译器内部的伪码：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bar</span><span class=\"params\">(X&amp; _result, <span class=\"keyword\">const</span> X&amp; p1, <span class=\"keyword\">const</span> X&amp; p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t_result.X::X(p1,p2);<span class=\"comment\">//default constructor? OR member fuction?</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;<span class=\"comment\">//什么也不返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比较而言，少了个copy constructor。换句话说，少用局部变量，能直接计算返回的，就直接计算返回，这样可以少产生一个拷贝构造函数。</p>\n<p>在编译器层面做优化<br>在使用者层面做优化的例子，原先是使用者注意少用局部变量，能直接计算返回的，就直接计算返回，这样可以少产生一个拷贝构造函数。现在这件事情编译器代你做了，换句话说，即使我们仍用了xx做局部变量，保存计算结果，return xx，编译器也会自动把xx用_result替换掉，替你精简掉一个copy constructor。<br>然后呢，lippman把这种行为叫做“NRV优化”， NRV优化的本质是优化掉拷贝构造函数，当然去掉它的前提是作为使用者的我们用了xx做局部变量、return xx；如果我们没有这么做，而是直接return X(p1,p2) 那么这种行为也就不会发生了。</p>\n<p>要不要构造函数？<br>其实就是bitwise和Memberwise的问题了。如果类对象的成员数据以数值来储存。bitwise copy既不会导致memory leak，也不会产生address aliasing，因此它既快速又安全。如果类需要大量的memberwise初始化操作，例如以传值的方式传回对象，那么就需要explicit了。<br>当然，你也可以手动memcpy，但使用前提是：在class不含任何编译器产生的内部members。例如virtual相关内容。</p>\n<h2 id=\"成员们的初始化队列\"><a href=\"#成员们的初始化队列\" class=\"headerlink\" title=\"成员们的初始化队列\"></a>成员们的初始化队列</h2><p>当你写下一个构造函数的时候，你有机会设定类成员的初值。要不是经由成员初始化列表，就是在构造函数本身之内。除了四种情况，你的任何选择其实都差不多。</p>\n<p>必须使用初始化列表的情况<br>1）当初始化一个引用成员时<br>2）当初始化一个常量成员时<br>3）当调用一个基类的构造函数，而它拥有一组参数时<br>4）当调用一个类成员的构造函数，而它拥有一组参数时</p>\n<p>第一第二是因为：const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化，因此初始化const对象或引用的唯一机会是构造函数函数体之前的初始化列表中。<br>第三第四是因为：主要是性能问题，如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数。对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。</p>\n<p>所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表。<br>还有，对于初始化列表有些地方需要注意：list中的生成次序是由类中成员的声明次序决定的，而不是initialization list的排列次序决定的。</p>\n<p>全局对象的内存保证会在程序激活的时候被清为0。局部对象配置于程序的堆栈中，动态对象配置于自由空间中，都不一定会被清为0，它们的内容将是内存上次被使用后的遗迹。</p>\n","tags":["cpp"]},{"title":"c++对象模型研究3：数据","url":"/2021/02/25/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B63%EF%BC%9A%E6%95%B0%E6%8D%AE/","content":"<p>开始前先看看</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Z</span>:</span><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> X &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> Y,<span class=\"keyword\">public</span> Z &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述X，Y，Z，A中没有任何一个class内含明显的数据，其间只表示了继承关系。<br>按照书上的例子</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sizeof</span> X = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Y = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Z = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> A = <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n<p>译注是</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sizeof</span> X = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Y = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> Z = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span> A = <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>先看X，事实上并不是空的，编译器会安插进去一个char。使得这个class的对象在内存中配置独一无二的地址。</p>\n<p>至于Y和Z受到三个因素的影响：<br>1.语言本身所造成的额外负担。其实就是之前一直说的virtual问题。<br>2.编译器对于特殊情况所提供的优化处理。有些编译器会对这个1bytes作出不同的处理（例如省略）。<br>3.Alignment的限制，我的理解是字节对齐，在大部分机器上，群聚的结构体大小会受到alignment的限制，使它们能够更有效率地在内存中被存取。</p>\n<p>ps:一个虚基类对象只会在派生类中存在一份实体，不管它在class继承体系中出现了多少次。</p>\n<p>C++对象模型尽量以空间优化和存取速度优化的考虑来表现非static成员数据，并且保持和C语言struct数据配置的兼容性。它把数据直接存放在每一个类对象之中。对于继承而来的非static成员数据（不管是virtual还是非virtual基类）也是如此。而类的static成员数据是存放在全局中，只有一份实例（甚至即使该class没有任何对象实体，其static成员数据也已存在），但是一个template类的static成员数据的行为稍有不同。</p>\n<p>每一个类对象必须有足够的大小以容纳它所有的非static成员数据，它可能比你想象的还大，原因是：<br>1.由编译器自动加上的额外成员数据，用以支持某些语言特性（主要是各种virtual特性）。<br>2.因为alignment的需要。</p>\n<h2 id=\"成员数据的绑定\"><a href=\"#成员数据的绑定\" class=\"headerlink\" title=\"成员数据的绑定\"></a>成员数据的绑定</h2><p>先说说extern：<br>extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.。例如变量在xxx.cpp里面定义过了，现在在本头文件中，以extern int a; 的形式声明，那么include”本头文件”的cpp，都可以使用该变量。extern与（const&amp;static）不同，（const和static只在本模块中起作用） extern可以在其他模块中起作用。</p>\n<p>如果成员函数没参数，或者不闲的蛋疼把两个类型定义成同个关键字typedef。那么typedef或者成员数据放前放后都一样；如果出现了以上状况，那么必须把内联typedef 放在成员函数的参数之前。这个主要注意的是内联typedef声明需要放在类的起始处，而其他成员函数里面的数据，可以放在类里面的任何地方。</p>\n<h2 id=\"成员数据的布局\"><a href=\"#成员数据的布局\" class=\"headerlink\" title=\"成员数据的布局\"></a>成员数据的布局</h2><p>非static成员数据在类对象中的排列顺序将和其被声明的顺序一样，任何中间介入的static成员数据都不会被放进对象布局之中。</p>\n<p>c++ standard要求，同一个access section（访问级别）中，成员的排列只需要符合“较晚出现的成员在对象中有较高的地址”即可，并不一定要连续排列。原因之一是边界调整，原因之二是插入的关于virtual的东西，如vptr。<br>c++ standard也允许将多个access sections中的成员数据自由排列，不必在乎声明次序(是指access sections之间的自由排列)，但当前各家编译器都是把一个以上的access section连起来，依照声明次序，称为一个连续区块。另外access sections的多寡不会招来额外的负担。</p>\n<h2 id=\"成员数据的存取\"><a href=\"#成员数据的存取\" class=\"headerlink\" title=\"成员数据的存取\"></a>成员数据的存取</h2><p>static成员数据：在内存中只有一份实体，所以用什么方式，无论是指针也好，对象也罢；本子类的也好，从祖祖父继承来的也罢，都一样其存取路径还是一样的直接。</p>\n<p>非static成员数据：直接存放在每个对象中，所以只能由对象来对他们进行存取操作。对象分为explicit class object（自己定义的）和implicit class object（由this指针表达这个implicit class object）（成员函数中访问成员数据时用的）。</p>\n<p>从object origin存取”和“从pointer pt存取”的区别：<br>如果是关于virtual，这里就涉及多态的概念。如果用pt，那么我们不能说pt必然指向哪个class type（因此我们也就不知道编译时期这个成员真正的offset）所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能解决。但如果用“.”那么class type就确定无疑了，也就没那么多的事儿了。</p>\n<h2 id=\"继承与成员数据\"><a href=\"#继承与成员数据\" class=\"headerlink\" title=\"继承与成员数据\"></a>继承与成员数据</h2><p>单一继承不含virtual函数<br>其数据布局是这样的，子类对象总是把从父类对象弄成一个子对象，然后把这个子对象放在自己的成员数据之前。因此，子类通过对象或者通过对象指针访问父类成员不会存在间接性，父类成员在编译期就可以确定其offset值（父类成员在父类中的offset值和在子类中的offset值是一样的，因为子类对象把整个父类对象给扒拉下来直接按头上了）。因为父类对象在子类对象的首部，这样当父类指针被子类赋值时，父类指针仍然指向子类对象的父类部分（子对象）起始地址。<br>当然这样的存放方式也是有缺点的（指的是没有虚函数，没有多态的情况）。</p>\n<p>加上多态<br>加上多态即虚函数后，首先是virtual table 和vptr 会创建出来，当然这个创建过程会影响到constructor、copy constructor（为vptr设初值）、destructor（结束后删除vptr）。<br>至于vptr放在哪里要看具体的编译器，vptr放在尾端，可以兼容c的struct object；vptr放在前端可以避免“从class object起始点开始量起的offset在执行期必须备妥，甚至于class vptr之间的offset也必须备妥”。</p>\n<p>多重继承<br>单一继承提供了一种“自然多态”形式，换句话说单一继承可以把子对象一个一个的叠加在derived object上面，based object和derived object 都是从相同地址开始的。所以derived object转based object比较方便（只要改变对象size就行了）。</p>\n<p>虚拟继承<br>如果一个class 内含一个或多个virtual based class subobjects，那它将会被分成两个部分：不变的部分和共享的部分。不变的部分不论后继如何衍化，总是拥有固定的offset（从object头算起），所以这部分数据可以被直接存取。共享部分表现出来的就是virtual base class（虚基类） subobject（因为虚基类被多个class继承，也会被多个子object 更改，为了保证虚基类的 object 的统一性，就需要单独把虚基类的 object 给拎出来了），这一部分其位置会因为派生对象操作而发生变化，所以只能被间接存取（引入一个新的指针，指向共享的内容）。<br>当然只是单纯的引入指针指向共享的virtual base class subobject的话会存在两个缺点：1是随着虚基类的增加，指针的个数也会增加；2是虚基类之间如果也存在虚继承的话，间接存取的层数也会增加（子对象-&gt;父虚基类对象-&gt;祖父虚基类对象···）。<br>对于第一个问题，有两种解决方案：1是设一个指针指向一张虚基类表，虚基类表中存放虚基类对象访问地址；2是在虚基类表中存放每一个虚基类的offset，而不是地址。</p>\n<h2 id=\"对象成员的访问效率\"><a href=\"#对象成员的访问效率\" class=\"headerlink\" title=\"对象成员的访问效率\"></a>对象成员的访问效率</h2><p>指向数据成员的指针，是一个有点神秘又颇有用处的语言特性，特别是如果你需要详细调查类成员的底层布局的话。这样的调查可以用于决定vptr是放在class的起始处或者尾端。另外一个用途是可以用来决定类中的access sections的次序。</p>\n<p>指向成员数据的指针的效率问题<br>具体要看编译器怎样优化了</p>\n","tags":["cpp"]},{"title":"c++对象模型研究5：构造、解构、拷贝","url":"/2021/02/25/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B65%EF%BC%9A%E6%9E%84%E9%80%A0%E3%80%81%E8%A7%A3%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D/","content":"<p>纯虚函数<br>虚函数是为了重载和多态的需要，子类中可以重写或不重写该函数；纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像Java中的interface。</p>\n<p>纯虚函数引入原因：<br>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。纯虚函数就是基类只定义了函数体，没有实现过程，定义方法如： virtual void Eat() = 0; 不要在cpp中定义；纯虚函数相当于接口，不能直接实例化，需要派生类来实现函数定义；</p>\n<p>纯虚函数不能调用的两处地方<br>1.在基类的构造函数中调用纯虚函数。<br>2.在基类的析构函数中调用纯虚函数。</p>\n<p>一些原则<br>纯虚函数的存在：一般来说不要把虚析构函数写成纯虚析构函数。<br>虚函数的存在：一般而言，把所有成员函数都声明成虚函数，然后再靠编译器优化操作吧非必要的virtual invocation去除，并不是好的设计观念。<br>虚函数中的const：因为不确定子类会不会更改数据，所以虚函数最好不要声明成const了。</p>\n<h2 id=\"无继承情况下的对象构造\"><a href=\"#无继承情况下的对象构造\" class=\"headerlink\" title=\"无继承情况下的对象构造\"></a>无继承情况下的对象构造</h2><p>三种对象的产生方式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Point global;<span class=\"comment\">//全局内存配置，生命周期等同整个程序的生命周期 </span></span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">foobar</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tPoint local;<span class=\"comment\">//局部内存配置，生命周期在&#123;&#125;之间\t</span></span><br><span class=\"line\">\tPoint *heap=<span class=\"keyword\">new</span> Point;<span class=\"comment\">//堆内存配置，生命周期在new和delete之间，但在此处指针*heap的生命周期在&#123;&#125;之间 </span></span><br><span class=\"line\">\t*heap=local;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> heap;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> local;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>程序表现出<br>1.global内存配置<br>在C中，global被视为一个”临时性的定义”，因为它没有明确的初始化操作，一个”临时性的定义”可以在程序中发生多次.那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序data segment中一个”特别保留给为初始化的global objects使用”的空间。<br>C++并不支持”临时性的定义”，这是因为 class 构造行为的隐含应用的缘故.global在C++中被视为完全定义。C++中所有全局对象都被当作”初始化过的数据”来对待。<br>2.local内存配置<br>3.heap内存配置</p>\n<p>无继承情况下的对象构造。plain old data约等于bitwise copy semantic，他们的构造函数是trivial，要不就是根本没有被构造，要不就是构造了也没有被调用。复制构造函数、析构函数也都是类似的情况。</p>\n<h2 id=\"继承体系下的对象构造\"><a href=\"#继承体系下的对象构造\" class=\"headerlink\" title=\"继承体系下的对象构造\"></a>继承体系下的对象构造</h2><p>A.继承情况下对象的构造过程<br>a. 调用所有的虚基类构造函数，从左到右，由最深到最浅（虚基类在对象模型中是以独特的方式（固定部分与共享部分）支持的，不涉及到在对象模型中的偏移量的问题）<br>b. 调用所有的上一层的基类构造函数，以基类的声明顺序为顺序（这是因为一般基类的子对象都会被放在对象的开始，并且按基类声明的次序放置）<br>c. 如果类对象有虚函数表指针，设定其初值，指向适当的虚函数表<br>d. 如果有一个成员对象并没有出现在成员初始化列表中，且它有一个默认构造函数，那么该默认构造函数必须被调用<br>e. 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数本身，并以成员声明的顺序为顺序。<br>f. 程序员自己的代码（在此步以上的操作均为编译器安插的）</p>\n<p>B.继承情况下对象构造过程中如何压制虚基类的构造函数的重复调用<br>“virtual base class constructors的调用”有着明确的定义：只有一个完整的classobject被定义出来时，它才会被调用；如果object只是某个完整的object的subject，它就不会被调用。</p>\n<p>class PVertex 的object中，在保存 PVertex 自己的数据之前，上面有很多个父类的subobject，那么虚基类Point的构造函数不会被其他的subobject所调用，它的构造函数只有当整个object被定义出来时，也即PVertex数据定义出来时才会被调用，也就是只会被PVertex所调用。而在PVertex之前的subobject 对虚基类构造函数的调用操作将会被抑制。另外，如果没有最下层的PVertex，那么就是被Vertex3d调用。综上所述，这样才能保证共享虚基类对象的一致性。</p>\n<h2 id=\"对象复制\"><a href=\"#对象复制\" class=\"headerlink\" title=\"对象复制\"></a>对象复制</h2><p>关于重载赋值操作符和复制拷贝构造函数的区别</p>\n<p>拷贝构造函数是用一个已存在的对象去构造一个不存在的对象（拷贝构造函数毕竟还是构造函数嘛），也就是初始化一个对象。<br>而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过（即已经过构造函数的初始化了）的对象进行赋值。</p>\n<p>当设计一个类，并以一个类对象指定给另一个对象时，我们有三种选择：<br>a.什么都不做，实施默认行为<br>b.提供一个explicit copy assignment operator<br>c.拒绝拷贝，拒绝拷贝方式：<br>1.将copy assignment operator私有化<br>2.不提供函数定义，导致在链接失败</p>\n<p>对象赋值（拷贝）函数是为了打开named value return（NVR）<br>对象赋值操作copy assignment operator的合成条件和构造函数类似<br>当不要Bitwise Copy Semantics时，类就需要合成一个对象赋值操作：<br>1.当类内含一个成员对象，而成员对象声明有一个copy constructor operator时<br>2.当类继承一个基类对象而后者存在有一个copy constructor operator时<br>3.当类声明了一个或多个virtual functions时，<br>4.当类派生自一个继承串链，其中有一个或多个virtual base classes时。此时无论基类有没有copy operator。</p>\n<h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><p>如果类没有定义析构函数，那么只有类存在成员对象且该成员对象含有析构函数的情况下，编译器才会自动合出一个析构函数来。默认情况下编译器并不会合成一个析构函数，即使是它拥有一个virtual function。<br>析构函数的扩展方式与构造函数相同，但顺序相反。</p>\n","tags":["cpp"]},{"title":"c++对象模型研究6：执行期","url":"/2021/02/25/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B66%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%9C%9F/","content":"<p>C++的一件困难事情：不太容易从程序代码看出表达式的复杂度。<br>执行期语意学，即在程序执行时，编译器产生而外的指令调用，确保对象的构造，内存的释放，以及类型转换与临时对象的生成的安全进行。</p>\n<h2 id=\"对象的构造和析构\"><a href=\"#对象的构造和析构\" class=\"headerlink\" title=\"对象的构造和析构\"></a>对象的构造和析构</h2><p>一般而言，我们会把对象尽可能放置在使用它的那个程序区段附近，这样做可以节省不必要的对象产生操作和摧毁操作（主要是析构）。不建议把所有的对象放在函数或某个区段的起始处。</p>\n<p>全局对象<br>对于全局变量，C++会保证在调用全局变量之前，将全局变量构造出来。<br>而所有的全局变量都被放置在程序的数据段中（data segment），并且为没有显示指定值的变量初始化为0。<br>同时对于全局的类对象，在编译时期被放置于data segment中并且内容也为0.只有在程序启动时其对应的constructor才会实施。因此object需要静态初始化。<br>静态初始化的munch策略：<br>1.为每个需要静态初始化的文件产生一个_sti()函数，内含必要的constructor调用操作和inline expansions。<br>2.为每一个需要静态的内存释放操作的文件，产生一个_std()函数。<br>3.提供一个_main()函数调用所有的_sti()函数，一个_exit()函数调用所有的_std()函数</p>\n<p>局部静态对象<br>局部静态对象的构造函数只能被施行一次，析构函数也只有一次。<br>所以对于局部静态对象，一个很简单的思路就是导入一个临时性对象，当第一次传入时，设置为true，之后则不再进行处理。<br>条件式析构也是所有编译器所必须的，而局部静态对象需以构造的相反的顺序被析构。</p>\n<p>对象数组<br>对于以下数组定义，我们一般使用vec_new()函数来构造数组(这是在cfront中的方式), 对于VS等，则提供一个用来处理没有”virtual base class”的class，另一个用来处理”内含virtual base class”的class。后一个函数通常称为 vec_vnew()。<br>函数的原型一般如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\">vec_new( </span><br><span class=\"line\">    <span class=\"keyword\">void</span> *<span class=\"built_in\">array</span>,                       <span class=\"comment\">// 数组的起始地址</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> elem_size,                  <span class=\"comment\">//每一个class object大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> elem_count,                    <span class=\"comment\">//数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*constructor)(<span class=\"keyword\">void</span> *)        <span class=\"comment\">//类的constructor函数指针</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destructor)(<span class=\"keyword\">void</span> *, <span class=\"keyword\">char</span>)   <span class=\"comment\">//类的destructor函数指针</span></span><br></pre></td></tr></table></figure>\n<p>所以对上述的Point对象的初始化，对应的vec_new()的实例化如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">vec_new( &amp;knots, <span class=\"keyword\">sizeof</span>(Point), <span class=\"number\">10</span>, &amp;Point::Point, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>同理，对于对象的删除，也有类似的vec_delete()来进行操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *</span><br><span class=\"line\">vec_new( </span><br><span class=\"line\">    <span class=\"keyword\">void</span> *<span class=\"built_in\">array</span>,                       <span class=\"comment\">// 数组的起始地址</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> elem_size,                  <span class=\"comment\">//每一个class object大小</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> elem_count,                    <span class=\"comment\">//数组中的元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*destructor)(<span class=\"keyword\">void</span> *, <span class=\"keyword\">char</span>)   <span class=\"comment\">//类的destructor函数指针</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"new和delete运算符\"><a href=\"#new和delete运算符\" class=\"headerlink\" title=\"new和delete运算符\"></a>new和delete运算符</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pi = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>其实是通过两个步骤完成的，第一步通过适当的new运算符函数实例，配置所需的内存，然后将配置来的内存设定初值。</p>\n<p>使用pi，和使用pi所指的对象，其差别在于哪一个生命已经结束了。因为即使对象不合法，但是指针所指的对象也是合法的。<br>new其实是通过标准的c malloc完成的，每一次对new的调用必须传回一个独一无二的指针，指向默认1byte的内存地址。</p>\n<p>针对数组的new语意<br>如果类对象数组没定义constructor和destructor，则不会调用vec_new。<br>对于delete[] p_array, 只有中括号出现时，编译器才会寻找数组的维度，否则他只会假设单独的一个object要被删除。<br>那么如何记录数组的元素个数呢？一个明显的方法是为vec_new()所传回的每一个内存区域块设置一个额外的word，然后把元素个数包藏在那个word之中。而包藏的数值通常称为cookie。<br>在原始编译器中，有两个主要函数用来存取cookie</p>\n<p>注意，避免一个base class指针指向一个derived class object所组成的数组。</p>\n<p>如果一定要这样做，默认情况下只会交给施行vec_delete()函数的”被删除之指针类型的destructor“，也就是Point destructor。<br>所以，需要程序员如下显著的进行释放内存。</p>\n<p>placement Operator new语意</p>\n<h2 id=\"临时性对象\"><a href=\"#临时性对象\" class=\"headerlink\" title=\"临时性对象\"></a>临时性对象</h2><p>临时性对象的摧毁，应该是对完整表达式求值过程中最后一个步骤。该完整表达式造成临时对象的产生。<br>凡持有表达式执行结果的临时对象，应该保留到object的初始化操作完成为止。<br>如果一个临时对象被绑定于一个reference，对象将残留，直到初始化之reference生命结束，或直到临时对象的什么范畴结束。</p>\n","tags":["cpp"]},{"title":"c++对象模型研究7：站在对象模型的顶端","url":"/2021/02/25/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B67%EF%BC%9A%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A1%B6%E7%AB%AF/","content":"<h2 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h2><p>在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：模板对源代码重用，而不是通过继承和组合重用对象代码。当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。</p>\n<p>未使用的template member function不应该被实例化。<br>对于template的错误检查，只有在实例化操作时才会进行类型类型检查，而所有的语汇（lexing）错误和解析（parsing）错误都会在处理template声明的过程中被表示出来。也就是用到了语法分析器。<br>在目前的编译器中，面对一个template声明，在它被一组实际参数实例化之前，只能施以有限的错误检查。</p>\n<p>template中的名称决议法，分为 scope of the template definition 和 scope of the template instantiation.<br>template之中，对于一个nonmember的决议结果，是根据这个name的使用是否与“用以实例化该template的参数类型”有关而决定。如果互不相关，则使用“scope of the template declaration”来决定name，否则以“scope of the template instantiation”来决定name。<br>函数的决议结果，只和函数的原型有关，和函数的返回值没有关系。</p>\n<p>对于member function的实例化行为，编译器设计者需要考虑以下3种问题：<br>1.编译器如何找打函数的定义？ –&gt; 答案是产生template program text file, 有点类似header<br>2.编译器如何能够只实例化程序中用到的member function？ –&gt; 解法方法之一，是忽略此项要求，只要class的object被实例化，就全部产生出来；另一个解决方法是模拟链接操作，检测看看哪个函数真正需要，然后只为他们产生实例<br>3.编译器如何组织member definition在多个 .o文件中被实例化？  –&gt;方法是产生多个实例，但只在链接器中保存一个。</p>\n<p>对于member function，每个member function的地址都被放在active classes的virtual table中。<br>如果virtual table被产生出来，每个virtual function 都必须被实例化。</p>\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>欲支持exception handling，编译器的主要工作是找到catch子句，以处理被抛出来的exception。</p>\n<h2 id=\"执行期类型识别\"><a href=\"#执行期类型识别\" class=\"headerlink\" title=\"执行期类型识别\"></a>执行期类型识别</h2><p>dynamic_cast运算符可以在执行期决定真正的类型。<br>如果downcast是安全的，也就是说base type pointer指向一个derived class object。这个运算符会传回被适当转换过的指针。<br>如果downcast是不安全的，这个运算符会传回0。<br>dynamic_cast的成本是编译时会产生一个类型描述器。<br>执行期对一个class指针施以dynamic_cast运算符，会返回true或false，true指的是返回真正的地址，false表示没有指向任何对象。</p>\n<p>dynamic_cast运算符也适用于reference。<br>若将一个reference设为0，会引起一个临时对象被产生出来，该临时对象的初值为0，这个reference然后被设定成该临时对象的别名。<br>如果真正参考到derived class，downcast会继续执行程序，反之，会跑出一个bad_cast exception操作。</p>\n<p>typeid运算符<br>typeid运算符传回一个const reference。类型为type_info.<br>RTT1只适合于多态类，但是typeid同时也适用于内建类型。 如typeid(double) 会传回一个 const type_info&amp;。这个时候type_info object是静态取得，而非执行期取得。</p>\n<h2 id=\"效率、弹性\"><a href=\"#效率、弹性\" class=\"headerlink\" title=\"效率、弹性\"></a>效率、弹性</h2><p>传统的C++对象模型提供有效率的执行期支持。这份效率，再加上与C之间的兼容性，造成了C++的广泛被接受度。然而，在某些领域方面，像是动态共享函数库、共享内存、以及分布式对象方面，这个对象模型的弹性还是不够。</p>\n","tags":["cpp"]},{"title":"cmake","url":"/2021/02/22/cmake/","content":"<p>CMake是一个比make更高级的编译配置工具，它可以根据不同平台、不同的编译器，生成相应的Makefile或者vcproj项目。通过编写CMakeLists.txt，可以控制生成的Makefile，从而控制编译过程。CMake自动生成的Makefile不仅可以通过make命令构建项目生成目标文件，还支持安装（make install）、测试安装的程序是否能正确执行（make test，或者ctest）、生成当前平台的安装包（make package）、生成源码包（make package_source）、产生Dashboard显示数据并上传等高级功能，只要在CMakeLists.txt中简单配置，就可以完成很多复杂的功能，包括写测试用例。如果有嵌套目录，子目录下可以有自己的CMakeLists.txt。</p>\n<h3 id=\"外部编译\"><a href=\"#外部编译\" class=\"headerlink\" title=\"外部编译\"></a>外部编译</h3><p>外部编译，一个最大的好处是，对于原有的工程没<br>有任何影响，所有动作全部发生在编译目录。通过这一点，也足以说服我们全部采用外部编<br>译方式构建工程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#确定cmake最低版本需求</span><br><span class=\"line\">cmake_minimum_required(VERSION 3.0.0)</span><br><span class=\"line\"></span><br><span class=\"line\">#打印</span><br><span class=\"line\">MESSAGE(STATUS &quot;This is install dir &quot; $&#123;CMAKE_INSTALL_PREFIX&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">#确定工程名</span><br><span class=\"line\">#(这一行会引入两个变量XXX_BINARY_DIR (二进制文件保存路径)和 #XXX_SOURCE_DIR(源代码保存路径))</span><br><span class=\"line\">project(XXX)</span><br><span class=\"line\"></span><br><span class=\"line\">#添加需要的库</span><br><span class=\"line\">set(CMAKE_PREFIX_PATH $&#123;CMAKE_PREFIX_PATH&#125; &quot;&#x2F;usr&#x2F;local&#x2F;share&#x2F;OpenCV&quot;)</span><br><span class=\"line\">find_package(OpenCV 3.2.0 REQUIRED)</span><br><span class=\"line\"></span><br><span class=\"line\">#添加需要的头文件</span><br><span class=\"line\">include_directories(include)</span><br><span class=\"line\">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class=\"line\">include_directories(&#x2F;usr&#x2F;local&#x2F;cuda-8.0&#x2F;include&#x2F;)</span><br><span class=\"line\"></span><br><span class=\"line\">#确定编译语言</span><br><span class=\"line\">#add_definitions(-std&#x3D;c++11)</span><br><span class=\"line\">set(CMAKE_CXX_STANDARD 11)</span><br><span class=\"line\"></span><br><span class=\"line\">#设定变量</span><br><span class=\"line\">ADD_DEFINITIONS( -DGPU -DCUDNN )</span><br><span class=\"line\"></span><br><span class=\"line\">#添加源代码</span><br><span class=\"line\">aux_source_directory($&#123;CMAKE_CURRENT_LIST_DIR&#125;&#x2F;src src)</span><br><span class=\"line\"></span><br><span class=\"line\">#编译动态库并链接库文件</span><br><span class=\"line\">link_directories($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class=\"line\">add_library(plate_recognition SHARED $&#123;SRC&#125;)</span><br><span class=\"line\">target_link_libraries(plate_recognition $&#123;OpenCV_LIBS&#125;)</span><br><span class=\"line\">target_link_libraries(plate_recognition -llianghao  -lpthread -lm -lstdc++)</span><br><span class=\"line\"></span><br><span class=\"line\">#生成可执行文件</span><br><span class=\"line\">link_directories($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class=\"line\">add_executable(Test $&#123;SRC&#125;)</span><br><span class=\"line\">target_link_libraries(Test $&#123;OpenCV_LIBS&#125;)</span><br><span class=\"line\">target_link_libraries(Test -llianghao  -lpthread -lm -lstdc++)</span><br><span class=\"line\"></span><br><span class=\"line\">#make install</span><br><span class=\"line\">SET(CMAKE_INSTALL_PREFIX $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">INSTALL(TARGETS myengine</span><br><span class=\"line\">    DESTINATION ..&#x2F;assets&#x2F;bin&#x2F;</span><br><span class=\"line\">   )</span><br></pre></td></tr></table></figure>\n<h3 id=\"项目删除\"><a href=\"#项目删除\" class=\"headerlink\" title=\"项目删除\"></a>项目删除</h3><p>CMake 默认不提供 uninstall 这个 target，想要的话，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xargs rm &lt; install_manifest.txt</span><br></pre></td></tr></table></figure>\n<p>对于不修改配置的项目足够了，manifest.txt 是CMake 生成的安装文件列表。</p>\n","tags":["linux"]},{"title":"epoll实现","url":"/2021/02/15/epoll%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</p>\n<h2 id=\"epoll实现\"><a href=\"#epoll实现\" class=\"headerlink\" title=\"epoll实现\"></a>epoll实现</h2><p>epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。<br>把原先的select/poll调用分成了3个部分：<br>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)<br>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字<br>3）调用epoll_wait收集发生的事件的连接</p>\n<p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>\n<p>下面来看看Linux内核具体的epoll机制实现思路。<br>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventpoll</span>&#123;</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"comment\">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span>  <span class=\"title\">rbr</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">rdlist</span>;</span></span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>\n<p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p>\n<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epitem</span>&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span>  <span class=\"title\">rbn</span>;</span><span class=\"comment\">//红黑树节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>    <span class=\"title\">rdllink</span>;</span><span class=\"comment\">//双向链表节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_filefd</span>  <span class=\"title\">ffd</span>;</span>  <span class=\"comment\">//事件句柄信息</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventpoll</span> *<span class=\"title\">ep</span>;</span>    <span class=\"comment\">//指向其所属的eventpoll对象</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">event</span>;</span> <span class=\"comment\">//期待发生的事件类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>\n<p>从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。<br>OK，讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。<br>一句话描述就是：三步曲。<br>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。<br>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。<br>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。</p>\n<h2 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h2><p>使用起来很清晰，首先要调用epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。<br>epoll_ctl可以操作上面建立的epoll，例如，将刚建立的socket加入到epoll中让其监控，或者把 epoll正在监控的某个socket句柄移出epoll，不再监控它等等。<br>epoll_wait在调用时，在给定的timeout时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程。</p>\n<p>epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</p>\n<p>几乎所有的epoll程序都使用下面的框架：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>( ; ; )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        nfds = epoll_wait(epfd,events,<span class=\"number\">20</span>,<span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;nfds;++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(events[i].data.fd==listenfd) <span class=\"comment\">//有新的连接</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class=\"comment\">//accept这个连接</span></span><br><span class=\"line\">                ev.data.fd=connfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class=\"comment\">//将新的fd添加到epoll的监听队列中</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( events[i].events&amp;EPOLLIN ) <span class=\"comment\">//接收到数据，读socket</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                n = read(sockfd, line, MAXLINE)) &lt; <span class=\"number\">0</span>    <span class=\"comment\">//读</span></span><br><span class=\"line\">                ev.data.ptr = md;     <span class=\"comment\">//md为自定义类型，添加数据</span></span><br><span class=\"line\">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class=\"comment\">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(events[i].events&amp;EPOLLOUT) <span class=\"comment\">//有数据待发送，写socket</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class=\"comment\">//取数据</span></span><br><span class=\"line\">                sockfd = md-&gt;fd;</span><br><span class=\"line\">                send( sockfd, md-&gt;ptr, <span class=\"built_in\">strlen</span>((<span class=\"keyword\">char</span>*)md-&gt;ptr), <span class=\"number\">0</span> );        <span class=\"comment\">//发送数据</span></span><br><span class=\"line\">                ev.data.fd=sockfd;</span><br><span class=\"line\">                ev.events=EPOLLIN|EPOLLET;</span><br><span class=\"line\">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class=\"comment\">//修改标识符，等待下一个循环时接收数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//其他的处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>","tags":["linux"]},{"title":"gdb调试","url":"/2021/02/28/gdb%E8%B0%83%E8%AF%95/","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmd:gdb</span><br><span class=\"line\">gdb$ file yourpram</span><br><span class=\"line\"></span><br><span class=\"line\">* 保存历史命令</span><br><span class=\"line\">echo &#39;set history save on&#39; &gt;&gt; ~&#x2F;.gdbinit &amp;&amp; chmod 600 ~&#x2F;.gdbinit</span><br><span class=\"line\">gdb$ show history</span><br><span class=\"line\"></span><br><span class=\"line\">* 设置参数</span><br><span class=\"line\">gdb$ set args(e.g. set args 10 20 30 40 50)</span><br><span class=\"line\">gdb$ show args</span><br><span class=\"line\"></span><br><span class=\"line\">* 执行程序至 main() 主函数的起始位置，即在 main() 函数的第一行语句处停止执行（该行代码尚未执行）。</span><br><span class=\"line\">gdb$ start</span><br><span class=\"line\"></span><br><span class=\"line\">* 加断点</span><br><span class=\"line\">gdb$ b gdb_test.c:3 </span><br><span class=\"line\">gdb$ info b</span><br><span class=\"line\"> </span><br><span class=\"line\"> * 打印参数</span><br><span class=\"line\">gdb$ p i</span><br><span class=\"line\">gdb$ p&#x2F;x i</span><br><span class=\"line\"></span><br><span class=\"line\">* run 指令会执行程序至第一个断点处，没有指令就一直执行程序</span><br><span class=\"line\">gdb$ run</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>UI interface(TUI mode)<br>ctrl+X+A</li>\n</ul>\n","tags":["gdb"]},{"title":"git项目相关问题","url":"/2021/01/26/git%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","content":"<h2 id=\"提交不停弹出登陆弹窗的问题\"><a href=\"#提交不停弹出登陆弹窗的问题\" class=\"headerlink\" title=\"提交不停弹出登陆弹窗的问题\"></a>提交不停弹出登陆弹窗的问题</h2><p>无论是用git push 还是tortoisegit push，都会不停弹出登录窗口<br>结果不论如何填写用户名和密码，都说logon failed。</p>\n<p>google了一下，发现原来有个git credentials manager这个软件，这是安装git的时候勾选安装的，这个弹窗就是这个软件弹出来的。</p>\n<p>根据提示，执行了“git credential-manager uninstall”。不再弹出登录窗口了，提交直接push就行了。</p>\n<h2 id=\"git项目如何过滤没有后缀的二进制文件\"><a href=\"#git项目如何过滤没有后缀的二进制文件\" class=\"headerlink\" title=\"git项目如何过滤没有后缀的二进制文件\"></a>git项目如何过滤没有后缀的二进制文件</h2><p>一般是输出到固定目录，比如dest然后统一忽略。要不然就赋予他们一个相同的pattern 然后忽略。</p>\n<p>原本扩展名对liunx的影响不大，只是今年来linux也才慢慢的用扩展名标识文件类型。<br>window文件你也可以不写扩展名。<br>不一定非要二进制文件才没有扩展名。<br>git没有通过判断文件内容来忽略的接口，除非自己写。</p>\n<h2 id=\"git仓库太大的处理方法\"><a href=\"#git仓库太大的处理方法\" class=\"headerlink\" title=\"git仓库太大的处理方法\"></a>git仓库太大的处理方法</h2><h3 id=\"只下载最后一次的提交\"><a href=\"#只下载最后一次的提交\" class=\"headerlink\" title=\"只下载最后一次的提交\"></a>只下载最后一次的提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;Wuchenwcf&#x2F;MyCode.git --depth&#x3D;&#x3D;1</span><br></pre></td></tr></table></figure>\n<h3 id=\"git仓库压缩瘦身\"><a href=\"#git仓库压缩瘦身\" class=\"headerlink\" title=\"git仓库压缩瘦身\"></a>git仓库压缩瘦身</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看历史大文件</span><br><span class=\"line\">git rev-list --objects --all | grep &quot;$(git verify-pack -v .git&#x2F;objects&#x2F;pack&#x2F;*.idx | sort -k 3 -n | tail -5 | awk &#39;&#123;print$1&#125;&#39;)&quot;</span><br><span class=\"line\"># 从历史中删除 target&#x2F; 这个文件夹</span><br><span class=\"line\">git filter-branch --force --index-filter &#39;git rm -r  --cached --ignore-unmatch target&#x2F;&#39; --prune-empty --tag-name-filter cat -- --all</span><br><span class=\"line\"># 执行仓库压缩</span><br><span class=\"line\">git gc --prune&#x3D;now</span><br><span class=\"line\"># 推送到远程仓库</span><br><span class=\"line\">git push origin --force --all</span><br></pre></td></tr></table></figure>","tags":["git"]},{"title":"linux下的一些操作","url":"/2021/01/24/linux%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/","content":"<h2 id=\"wc查看单个或多个文件的行数或总行数\"><a href=\"#wc查看单个或多个文件的行数或总行数\" class=\"headerlink\" title=\"wc查看单个或多个文件的行数或总行数\"></a>wc查看单个或多个文件的行数或总行数</h2><p>wc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。</p>\n<h3 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h3><p>-c或–bytes或——chars：只显示Bytes数；<br>-l或——lines：只显示列数；<br>-w或——words：只显示字数。</p>\n<h3 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h3><p>查看cpp文件和h文件行数<br>find ./ -name “<em>.cpp” -o -name “</em>.h” |xargs cat|wc -l</p>\n<h2 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h2><p>如果你想在当前目录下 查找”hello,world!”字符串,可以这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">grep -rn &quot;hello,world!&quot; *</span><br></pre></td></tr></table></figure>\n<h2 id=\"在linux下找文件\"><a href=\"#在linux下找文件\" class=\"headerlink\" title=\"在linux下找文件\"></a>在linux下找文件</h2><p>在linux下，主要用到的文件查找有find，whereis，locate。</p>\n<p>通常 find 不是很常用的。因为速度慢之外， 也很操硬盘！通常我们都是先使用 whereis 或者是 locate来检查，如果真的找不到了，才以 fin来搜寻。 为什么呢？因为 whereis 不 locate 是利用数据库来搜寻数据，所以相当的快速，而且并没有实际的搜寻硬盘， 比较省时间！</p>\n<p>whereis命令会在指定的目录中查找符合条件的文件，文件应的属性应属于原始代码，二进制文件，或是帮助文件.</p>\n<p>locate命令用于查找符合条件的文件，它会去保存文件与目录名称的数据库内，查找符合条件的文件或目录。<br>locate的使用更简单，直接在后面输入『档案的部分名称』后，就能够得到结果。（locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新）</p>\n<p>最后是find。<br>Find是一个非常有效的工具，它可以遍历当前目录甚至于整个文件系统来查找某些文件或目录。<br>查找文件名包含I的文件<br>find -name “I*.cpp”</p>\n<p>在Linux下查找包含某个单词的所有文件<br>grep hello /files -r -n<br>这样 grep 会输出类似于<br>filenames:hello<br>类似的信息，不光能知道文件名还能知道什么内容。<br>-r 是包含子目录，-n 是显示文件名<br>你可以 grep –help 看看帮助。还有很多参数可用。</p>\n<h2 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h2><p>只需要把make输出中的错误（及警告）信息输出到文件中ing，可以用：<br>make xxx 2&gt; build_output.txt</p>\n<p>只需要把make输出中的正常（非错误，非警告）的信息输出到文件中，可以用：<br>make xxx 1&gt; build_output.txt</p>\n<p>所有的信息都输出到同一个文件中：<br>make xxx &gt; build_output_all.txt 2&gt;&amp;1<br>其中的2&gt;&amp;1表示错误信息输出到&amp;1中，而&amp;1，指的是前面的那个文件：build_output_all.txt 。<br>注意：上面所有的1,2等数字，后面紧跟着大于号’&gt;’ ，中间不能有空格</p>\n<h2 id=\"根据进程名称Kill多个进程\"><a href=\"#根据进程名称Kill多个进程\" class=\"headerlink\" title=\"根据进程名称Kill多个进程\"></a>根据进程名称Kill多个进程</h2><p>经常需要Kill多个进程，这些进程包含共同的关键字，可以用一条命令Kill掉它们。<br>ps aux | grep “common” |grep -v grep| cut -c 9-15 | xargs kill -9</p>\n<p>管道符“|”用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。下面说说用管道符联接起来的几个命令：<br>“ps aux” 查看所有进程的命令。这时检索出的进程将作为下一条命令grep “common”的输入。<br>“grep “common” 选出所有含有关键字”common”的进程。<br>“cut -c 9-15” 截取输入行的第9个字符到第15个字符，而这正好是进程号PID。<br>grep -v grep除去“grep”<br>wc -l 统计行号<br>“xargs kill –9” 中的xargs命令是用来把前面命令的输出结果（PID）作为”kill –9”命令的参数，并执行该命令。”kill –9” 会强行杀掉指定进程<br>ps -ef | grep skynet</p>\n<h2 id=\"在linux下对比文件\"><a href=\"#在linux下对比文件\" class=\"headerlink\" title=\"在linux下对比文件\"></a>在linux下对比文件</h2><p>diff是用来比较两个文本文件的差异的工具程序。是代码版本管理的基石之一。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> diff &lt;变动前的文件&gt; &lt;变动后的文件&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用split-来分割大文件\"><a href=\"#使用split-来分割大文件\" class=\"headerlink\" title=\"使用split 来分割大文件\"></a>使用split 来分割大文件</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">split  -b  20m  gkdb.db   gkdb_pack_</span><br></pre></td></tr></table></figure>\n<p>split 是命今。<br>-B  20M  是指将每个分卷文件最大20M 。<br>gkdb.db   需要分割的文件。<br>gkdb_pack_  是指分割后的文件开头， 分割后后的文件名一般为   gkdb_pack_aa、gkdb_pack_ab、gkdb_pack_ac依次类推。</p>\n","tags":["linux"]},{"title":"linux下的一些网络调试命令","url":"/2021/02/22/linux%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/","content":"<h2 id=\"测试到达目的主机的网络是否连接-但ping无法检查系统端口是否开放\"><a href=\"#测试到达目的主机的网络是否连接-但ping无法检查系统端口是否开放\" class=\"headerlink\" title=\"测试到达目的主机的网络是否连接,但ping无法检查系统端口是否开放\"></a>测试到达目的主机的网络是否连接,但ping无法检查系统端口是否开放</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping www.google.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"检查某个端口是否开放\"><a href=\"#检查某个端口是否开放\" class=\"headerlink\" title=\"检查某个端口是否开放\"></a>检查某个端口是否开放</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">telnet ip_addr:port</span><br></pre></td></tr></table></figure>\n<h2 id=\"检测发出数据包的主机到目标主机之间所经过的网关数量\"><a href=\"#检测发出数据包的主机到目标主机之间所经过的网关数量\" class=\"headerlink\" title=\"检测发出数据包的主机到目标主机之间所经过的网关数量\"></a>检测发出数据包的主机到目标主机之间所经过的网关数量</h2><p>traceroute 的原理是试图以最小的TTL发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。<br>程序利用增加存活时间（TTL）值来实现其功能。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并传送一个ICMP TTL数据包给原数据包的发出者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">traceroute www.google.com</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断连接是否健康\"><a href=\"#判断连接是否健康\" class=\"headerlink\" title=\"判断连接是否健康\"></a>判断连接是否健康</h2><h3 id=\"查看服务器端口有没有客户端来连接\"><a href=\"#查看服务器端口有没有客户端来连接\" class=\"headerlink\" title=\"查看服务器端口有没有客户端来连接\"></a>查看服务器端口有没有客户端来连接</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -anp | grep xxxx</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看到进程id之后，使用netstat命令查看其占用的端口\"><a href=\"#查看到进程id之后，使用netstat命令查看其占用的端口\" class=\"headerlink\" title=\"查看到进程id之后，使用netstat命令查看其占用的端口\"></a>查看到进程id之后，使用netstat命令查看其占用的端口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">netstat -nap | grep pid</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看tcp连接数及状态\"><a href=\"#查看tcp连接数及状态\" class=\"headerlink\" title=\"查看tcp连接数及状态\"></a>查看tcp连接数及状态</h3><p>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LAST_ACK 5  </span><br><span class=\"line\">SYN_RECV 30  </span><br><span class=\"line\">ESTABLISHED 15  </span><br><span class=\"line\">FIN_WAIT1 51  </span><br><span class=\"line\">FIN_WAIT2 5  </span><br><span class=\"line\">TIME_WAIT 10  </span><br></pre></td></tr></table></figure>\n<p>状态：描述<br>CLOSED：无连接是活动的或正在进行<br>LISTEN：服务器在等待进入呼叫<br>SYN_RECV：一个连接请求已经到达，等待确认<br>SYN_SENT：应用已经开始，打开一个连接<br>ESTABLISHED：正常数据传输状态<br>FIN_WAIT1：应用说它已经完成<br>FIN_WAIT2：另一边已同意释放<br>ITMED_WAIT：等待所有分组死掉<br>CLOSING：两边同时尝试关闭<br>TIME_WAIT表示处理完毕，等待超时结束的请求数。<br>LAST_ACK：等待所有分组死掉</p>\n","tags":["linux"]},{"title":"linux信号","url":"/2021/02/14/linux%E4%BF%A1%E5%8F%B7/","content":"<h2 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h2><p>ctrl+c</p>\n<h2 id=\"信号本质\"><a href=\"#信号本质\" class=\"headerlink\" title=\"信号本质\"></a>信号本质</h2><p>软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。<br>和单片机上编写的中断相似。</p>\n<h2 id=\"信号的种类\"><a href=\"#信号的种类\" class=\"headerlink\" title=\"信号的种类\"></a>信号的种类</h2><p>可以从两个不同的分类角度对信号进行分类：<br>可靠性方面：可靠信号与不可靠信号；<br>与时间的关系上：实时信号与非实时信号。</p>\n<h2 id=\"信号处理流程\"><a href=\"#信号处理流程\" class=\"headerlink\" title=\"信号处理流程\"></a>信号处理流程</h2><p>对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个阶段：<br>信号诞生<br>信号在进程中注册<br>信号的执行和注销</p>\n<h2 id=\"信号的发送\"><a href=\"#信号的发送\" class=\"headerlink\" title=\"信号的发送\"></a>信号的发送</h2><p>发送信号的主要函数有：kill()、raise()、 sigqueue()、alarm()、setitimer()以及abort()。</p>\n<h2 id=\"系统如何将一个信号通知到进程？\"><a href=\"#系统如何将一个信号通知到进程？\" class=\"headerlink\" title=\"系统如何将一个信号通知到进程？\"></a>系统如何将一个信号通知到进程？</h2><p>内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。<br>进程检查信号的时机是：进程即将从内核态返回用户态时。如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则唤醒。<br>进程有一个链表的数据结果，维护一个未决信号的链表。<br>信号在进程中注册，其实就是把该信号加入到这个未决信号链表当中。<br>可靠信号不管链表中是否已经有这个信号了，还是会加进去。不可靠信号，如果链表中已经有这个信号了，就会忽略。<br>进程处理信号的时机就是从内核态即将返回用户态度的时候。<br>执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。<br>被屏蔽的信号，取消屏蔽后还会被检查。</p>\n","tags":["linux"]},{"title":"linux调试core，解决段错误","url":"/2021/02/28/linux%E8%B0%83%E8%AF%95core%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AE%B5%E9%94%99%E8%AF%AF/","content":"<h2 id=\"core文件在什么位置创建？\"><a href=\"#core文件在什么位置创建？\" class=\"headerlink\" title=\"core文件在什么位置创建？\"></a>core文件在什么位置创建？</h2><p>在进程当前工作目录的下创建。通常与程序在相同的路径下。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。有好多程序崩溃了，我们却找不到core文件放在什么位置。和chdir函数就有关系。当然程序崩溃了不一定都产生core文件。</p>\n<h2 id=\"什么时候不产生core文件？\"><a href=\"#什么时候不产生core文件？\" class=\"headerlink\" title=\"什么时候不产生core文件？\"></a>什么时候不产生core文件？</h2><p>在下列条件下不产生core文件：<br>( a )进程是设置-用户-ID，而且当前用户并非程序文件的所有者；<br>( b )进程是设置-组-ID，而且当前用户并非该程序文件的组所有者；<br>( c )用户没有写当前工作目录的许可权；<br>( d )文件太大。core文件的许可权(假定该文件在此之前并不存在)通常是用户读/写，组读和其他读。</p>\n<h2 id=\"如何产生core文件？\"><a href=\"#如何产生core文件？\" class=\"headerlink\" title=\"如何产生core文件？\"></a>如何产生core文件？</h2><p>系统中默认的是禁止产生core文件的<br>ulimit用于shell启动进程所占用的资源.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ulimit -c    0 </span><br></pre></td></tr></table></figure>\n<p>允许产生core文件，并且限制大小为1000 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ulimit -c 1000 </span><br></pre></td></tr></table></figure>\n<p>不限制大小</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ulimit -c unlimited</span><br></pre></td></tr></table></figure>\n<p>这时，再执行程序。当程序段错误时，就会产生core。如果还是无法产生core文件，注意看一下，程序是否有当前目录权限。</p>\n<h2 id=\"利用gdb定位到出错的具体位置\"><a href=\"#利用gdb定位到出错的具体位置\" class=\"headerlink\" title=\"利用gdb定位到出错的具体位置\"></a>利用gdb定位到出错的具体位置</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# gdb ./xxx core</span><br></pre></td></tr></table></figure>","tags":["gdb"]},{"title":"lua Table","url":"/2021/03/22/lua-Table/","content":"<p>table实现了关联数组，即可以同时用数字和字符串索引的数组。<br>table是一种强大的语言构造。因为table的泛型特点，简化了使用lua编写程序所用的数据结构和算法。</p>\n<h2 id=\"哈希与数组\"><a href=\"#哈希与数组\" class=\"headerlink\" title=\"哈希与数组\"></a>哈希与数组</h2><p>直到Lua 4.0为止，table都是作为纯哈希表实现的，所有的键值对都是显式存储的。在Lua 5.0版本引入了table的混合表示：每个table包含了一个哈希部分和一个数组部分，两个部分都可以是空的。Lua检测一个table是不是作为一个数组来使用，并自动将数字索引的值移动到数组部分，而非原本的存储在哈希部分。这种分裂只在底层实现层次进行；访问table域是透明的，即使是对虚拟机来说。table会自动根据内容使用两个部分。<br>这个混合机制有两个优点。第一，访问整型key的操作会变得更快了，因为不再需要哈希。第二，更重要的是，数组部分只占原来哈希部分的一半大小，因为哈希部分需要同时存储key和value，而数组部分的key已经隐含在下标了。结果是，如果一个table是作为数组使用的，它的表现就像数组一样，只要它的整型key是密集分布的。而且，哈希部分没有内存或者时间的代价，因为作为数组使用时，哈希部分不存在。反过来说，如果table是作为记录使用而非数组，那么数组部分就是空的。这些节省下来的内存是重要的。</p>\n<h2 id=\"Lua核心突出角色\"><a href=\"#Lua核心突出角色\" class=\"headerlink\" title=\"Lua核心突出角色\"></a>Lua核心突出角色</h2><p>从Lua 4.0开始，全局变量就存储在普通的Lua table里，称为全局table。Lua 5.0用元表和元方法取代了tag和tag方法（Lua 3.0引入的）。元表是普通的Lua table，元方法是作为元表的域存储的。Lua 5.0也引入了环境table，可以附加到Lua函数上；它们就是Lua函数索引的全局环境。Lua 5.1将环境变量table扩展到C函数、userdata和协程，取代了全局的环境变量。这些改动简化了Lua的实现、Lua和C程序员所用的API，因为全局变量和元方法可以在Lua里操控，不再需要特殊函数了。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>先看看表的数据类型定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Table</span> &#123;</span></span><br><span class=\"line\">  CommonHeader;</span><br><span class=\"line\">  lu_byte flags;  <span class=\"comment\">/* 1&lt;&lt;p means tagmethod(p) is not present */</span> </span><br><span class=\"line\">  lu_byte lsizenode;  <span class=\"comment\">/* log2 of size of `node&#x27; array */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Table</span> *<span class=\"title\">metatable</span>;</span><span class=\"comment\">//存放该表的元表</span></span><br><span class=\"line\">  TValue *<span class=\"built_in\">array</span>;  <span class=\"comment\">//指向数组部分的指针</span></span><br><span class=\"line\">  Node *node;  <span class=\"comment\">//指向该表的散列桶数组起始位置的指针 </span></span><br><span class=\"line\">  Node *lastfree;  <span class=\"comment\">//指向该表散列桶数组的最后位置的指针</span></span><br><span class=\"line\">  GCObject *gclist; <span class=\"comment\">//GC相关的链表</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sizearray;  <span class=\"comment\">//数组部分的大小</span></span><br><span class=\"line\">&#125; Table;</span><br></pre></td></tr></table></figure>\n<p>lu_byte_flags：这是一个byte类型的数据，用于表示这个表中提供了哪些元方法。最开始这个flags是空的，也就是0，当查找一次之后，如果该表中存在某个元方法，那么将该元方法对应的flag bit置为1，这样下一次查找时只需要比较这个bit就行了。每个元方法对应的bit定义在ltm. h文件中。<br>lu_byte_lsizenode：该表中以2为底的散列表大小的对数值。同时由此可知，散列表部分的大小一定是2的幕，即如果散列桶数组要扩展的话，也是以每次在原大小基础上乘以2的形式扩展。</p>\n<p>从Node类型来看，它包含两个成员，一个是key，另一个是value（TValue）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TKey</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    TValuefields;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> *<span class=\"title\">next</span>;</span>  <span class=\"comment\">/* for chaining */</span></span><br><span class=\"line\">  &#125; nk;</span><br><span class=\"line\">  TValue tvk;</span><br><span class=\"line\">&#125; TKey;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">  TValue i_val;</span><br><span class=\"line\">  TKey i_key;</span><br><span class=\"line\">&#125; Node;</span><br></pre></td></tr></table></figure>\n<h2 id=\"表查找\"><a href=\"#表查找\" class=\"headerlink\" title=\"表查找\"></a>表查找</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** search function for integers</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> TValue *<span class=\"title\">luaH_getnum</span> <span class=\"params\">(Table *t, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cast(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, key<span class=\"number\">-1</span>) &lt; cast(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, t-&gt;sizearray))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;t-&gt;<span class=\"built_in\">array</span>[key<span class=\"number\">-1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    lua_Number nk = cast_num(key);</span><br><span class=\"line\">    Node *n = hashnum(t, nk);</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;  <span class=\"comment\">/* check whether `key&#x27; is somewhere in the chain */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ttisnumber(gkey(n)) &amp;&amp; luai_numeq(nvalue(gkey(n)), nk))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gval(n);  <span class=\"comment\">/* that&#x27;s it */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> n = gnext(n);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> luaO_nilobject;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如采输入的Key是一个正坐数，并且它的位＞0 &amp;&amp; ＜= 数组且大小，尝试在数组部分查找。<br>如果不是，尝试在散列表部分查找，计算出该Key的散列值，根据此散列值访问Node数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该Key为止。<br>可以看到，即使是一个正整数的key，其存储部分也不见得会一定落在数组部分，这完全取决于它的大小是再落在了当前数组可容纳的空间范围内。也解释了ipairs遍历断裂的问题。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> t = &#123;&#125;</span><br><span class=\"line\">t[<span class=\"number\">1</span>] = <span class=\"number\">0</span> <span class=\"comment\">-- 1作为数组部分存储下来</span></span><br><span class=\"line\">t[<span class=\"number\">100</span>] = <span class=\"number\">0</span> <span class=\"comment\">--100存储到散列表部分中</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"新增元素\"><a href=\"#新增元素\" class=\"headerlink\" title=\"新增元素\"></a>新增元素</h2><p>当找不到对应的key时，最终都会调用内部的 newkey函数分配一个新的key来返回</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** inserts a new key into a hash table; first, check whether key&#x27;s main </span></span><br><span class=\"line\"><span class=\"comment\">** position is free. If not, check whether colliding node is in its main </span></span><br><span class=\"line\"><span class=\"comment\">** position or not: if it is not, move colliding node to an empty place and </span></span><br><span class=\"line\"><span class=\"comment\">** put new key in its main position; otherwise (colliding node is in its main </span></span><br><span class=\"line\"><span class=\"comment\">** position), new key goes to an empty position. </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TValue *<span class=\"title\">newkey</span> <span class=\"params\">(lua_State *L, Table *t, <span class=\"keyword\">const</span> TValue *key)</span> </span>&#123;</span><br><span class=\"line\">  Node *mp = mainposition(t, key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!ttisnil(gval(mp)) || mp == dummynode) &#123;</span><br><span class=\"line\">    Node *othern;</span><br><span class=\"line\">    Node *n = getfreepos(t);  <span class=\"comment\">/* get a free place */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"literal\">NULL</span>) &#123;  <span class=\"comment\">/* cannot find a free place? */</span></span><br><span class=\"line\">      rehash(L, t, key);  <span class=\"comment\">/* grow table */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> luaH_set(L, t, key);  <span class=\"comment\">/* re-insert key into grown table */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lua_assert(n != dummynode);</span><br><span class=\"line\">    othern = mainposition(t, key2tval(mp));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (othern != mp) &#123;  <span class=\"comment\">/* is colliding node out of its main position? */</span></span><br><span class=\"line\">      <span class=\"comment\">/* yes; move colliding node into free position */</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (gnext(othern) != mp) othern = gnext(othern);  <span class=\"comment\">/* find previous */</span></span><br><span class=\"line\">      gnext(othern) = n;  <span class=\"comment\">/* redo the chain with `n&#x27; in place of `mp&#x27; */</span></span><br><span class=\"line\">      *n = *mp;  <span class=\"comment\">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class=\"line\">      gnext(mp) = <span class=\"literal\">NULL</span>;  <span class=\"comment\">/* now `mp&#x27; is free */</span></span><br><span class=\"line\">      setnilvalue(gval(mp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* colliding node is in its own main position */</span></span><br><span class=\"line\">      <span class=\"comment\">/* new node will go into free position */</span></span><br><span class=\"line\">      gnext(n) = gnext(mp);  <span class=\"comment\">/* chain new position */</span></span><br><span class=\"line\">      gnext(mp) = n;</span><br><span class=\"line\">      mp = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  gkey(mp)-&gt;value = key-&gt;value; gkey(mp)-&gt;tt = key-&gt;tt;</span><br><span class=\"line\">  luaC_barriert(L, t, key);</span><br><span class=\"line\">  lua_assert(ttisnil(gval(mp)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gval(mp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>散列表部分的数据组织是，首先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织<br>上述代码主要操作：</p>\n<ul>\n<li>根据key来查找其所在散列桶的mainposition，如果返回的结果中，该Node的值为nil，那么直接将key赋值并且返回Node的TValue指针就可以了。</li>\n<li>再则说明该mainposition上已经有其他数据了，需要重新分配空间给这个新的 key ，然后将这个新的Node串联到对应的散列桶上 。<br>可见，整个过程都是在散列桶部分进行的，理由是即使key是一个数字，也已经在调用 newkey函数之前进行了查找，结果却没有找到，所以这个key都会进入散列桶部分来查找。</li>\n</ul>\n<h3 id=\"rehash\"><a href=\"#rehash\" class=\"headerlink\" title=\"rehash\"></a>rehash</h3><p>以上操作涉及重新对表空间进行分配的情况。入口函数是rehash，顾名思义，这个两数的作用就是为了做重新散列操作。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span> <span class=\"params\">(lua_State *L, Table *t, <span class=\"keyword\">const</span> TValue *ek)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nasize, na;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nums[MAXBITS+<span class=\"number\">1</span>];  <span class=\"comment\">/* nums[i] = number of keys between 2^(i-1) and 2^i */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> totaluse;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;=MAXBITS; i++) nums[i] = <span class=\"number\">0</span>;  <span class=\"comment\">/* reset counts */</span></span><br><span class=\"line\">  nasize = numusearray(t, nums);  <span class=\"comment\">/* count keys in array part */</span></span><br><span class=\"line\">  totaluse = nasize;  <span class=\"comment\">/* all those keys are integer keys */</span></span><br><span class=\"line\">  totaluse += numusehash(t, nums, &amp;nasize);  <span class=\"comment\">/* count keys in hash part */</span></span><br><span class=\"line\">  <span class=\"comment\">/* count extra key */</span></span><br><span class=\"line\">  nasize += countint(ek, nums);</span><br><span class=\"line\">  totaluse++;</span><br><span class=\"line\">  <span class=\"comment\">/* compute new size for array part */</span></span><br><span class=\"line\">  na = computesizes(nums, &amp;nasize);</span><br><span class=\"line\">  <span class=\"comment\">/* resize the table to new computed sizes */</span></span><br><span class=\"line\">  resize(L, t, nasize, totaluse - na);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码主要操作：</p>\n<ul>\n<li>分配一个位图nums，将其中的所有位置0。这个位图的意义在于：nums数组中第 i个元素存放的是key在2{i- l）和i之间的元素数量。</li>\n<li>遍历Lua表中的数组部分，计算其中的元素数量，更新对应的nums数组中的元素数量( numusearray函数）。</li>\n<li>遍历 lua表中的散列桶部分，因为其中也可能存放了正整数，需要根据这里的正整数数量更新对应的nums数组元素数量（numusehash函数）</li>\n<li>此时nums数组已经有了当前这个Table中所有正整数的分配统计，逐个遍历nums数组，获得其范围区间内所包含的整数数量大于50%的最大索引，作为重新散列之后的数组大小，超过这个范围的正整数，就分配到散列桶部分了（ computesizes函数）</li>\n<li>根据上面计算得到的调整后的数组和散列桶大小调整表（ resize 函数）。</li>\n</ul>\n<p>在重新散列的过程中，除了增大Lua表的大小以容纳新的数据之外，还希望能借此机会对原有的数组和散列桶部分进行调整，让两部分都尽可能发挥其存储的最高容纳效率。那么，这里的标准是什么呢？希望在调整过后，数组在每一个2次方位置容纳的元素数量都超过该范围的50%。 能达到这个目标的话，就认为这个数组范围发挥了最大的效率。</p>\n<p>当数字键值的统计跑完之后，得到了这个数组每个元素的数据，也就是得到了落在每个范围内的数据数量。接着会计算怎样才能最大限度地使用这部分空间 。这个算法由函数computesizes实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">computesizes</span> <span class=\"params\">(<span class=\"keyword\">int</span> nums[], <span class=\"keyword\">int</span> *narray)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> twotoi;  <span class=\"comment\">/* 2^i */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;  <span class=\"comment\">/* number of elements smaller than 2^i */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> na = <span class=\"number\">0</span>;  <span class=\"comment\">/* number of elements to go to array part */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;  <span class=\"comment\">/* optimal size for array part */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, twotoi = <span class=\"number\">1</span>; twotoi/<span class=\"number\">2</span> &lt; *narray; i++, twotoi *= <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      a += nums[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a &gt; twotoi/<span class=\"number\">2</span>) &#123;  <span class=\"comment\">/* more than half elements present? */</span></span><br><span class=\"line\">        n = twotoi;  <span class=\"comment\">/* optimal size (till now) */</span></span><br><span class=\"line\">        na = a;  <span class=\"comment\">/* all elements smaller than n will go to array part */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == *narray) <span class=\"keyword\">break</span>;  <span class=\"comment\">/* all elements already counted */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  *narray = n;</span><br><span class=\"line\">  lua_assert(*narray/<span class=\"number\">2</span> &lt;= na &amp;&amp; na &lt;= *narray);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> na;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>在一般算法库的设计中，针对容器类的迭代，会提供一个迭代器的数据，这个数据主要用于维护当前迭代到容器的哪部分数据了，下次再根据这个位置查找下一部分数据。表迭代不是这样设计的，很大的原因是为了兼容数组部分和散列桶部分的访问 。 迭代操作传入的不是一个迭代器，而是key。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaH_next</span> <span class=\"params\">(lua_State *L, Table *t, StkId key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = findindex(L, t, key);  <span class=\"comment\">/* find original element */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i++; i &lt; t-&gt;sizearray; i++) &#123;  <span class=\"comment\">/* try first array part */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ttisnil(&amp;t-&gt;<span class=\"built_in\">array</span>[i])) &#123;  <span class=\"comment\">/* a non-nil value? */</span></span><br><span class=\"line\">      setnvalue(key, cast_num(i+<span class=\"number\">1</span>));</span><br><span class=\"line\">      setobj2s(L, key+<span class=\"number\">1</span>, &amp;t-&gt;<span class=\"built_in\">array</span>[i]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i -= t-&gt;sizearray; i &lt; sizenode(t); i++) &#123;  <span class=\"comment\">/* then hash part */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ttisnil(gval(gnode(t, i)))) &#123;  <span class=\"comment\">/* a non-nil value? */</span></span><br><span class=\"line\">      setobj2s(L, key, key2tval(gnode(t, i)));</span><br><span class=\"line\">      setobj2s(L, key+<span class=\"number\">1</span>, gval(gnode(t, i)));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">/* no more elements */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不管是在数组部分还是散列桶部分查找数据，查找成功都会返回该key的下一个数据。<br>这个函数一开始就进入findindex中进行查询，并区分数组和散列桶部分。findindex函数的返回结果是一个整数索引，如果这个索引在表的sizearray之内，则说明落入到数组部分，否则就落入到散列桶部分。在luaH_next函数中使用这个返回值时，看起来是两个循环，实际上已经根据这个值的范围进行了区分，不会同一个key走入两个循环中。而在返回散列桶部分时，这个索引值为”sizearray＋对应散列柏索引的值”。</p>\n<h2 id=\"取长度操作\"><a href=\"#取长度操作\" class=\"headerlink\" title=\"取长度操作\"></a>取长度操作</h2><p>在Lua中，可以使用#符号对表进行取长度操作。对Lua中的表进行取长度操作时，如果没有提供该表的元方法_len，那么该操作只针对该表的序列（ sequence ）部分进行。 “序列”指的是表的一个子集{1 … n}，其中 n是一个正整数，并且里面每个键对应的数据都不为nil。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Try to find a boundary in table `t&#x27;. A `boundary&#x27; is an integer index</span></span><br><span class=\"line\"><span class=\"comment\">** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaH_getn</span> <span class=\"params\">(Table *t)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> j = t-&gt;sizearray;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; ttisnil(&amp;t-&gt;<span class=\"built_in\">array</span>[j - <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* there is a boundary in the array part: (binary) search for it */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j - i &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> m = (i+j)/<span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ttisnil(&amp;t-&gt;<span class=\"built_in\">array</span>[m - <span class=\"number\">1</span>])) j = m;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> i = m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* else must find a boundary in hash part */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t-&gt;node == dummynode)  <span class=\"comment\">/* hash part is empty? */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j;  <span class=\"comment\">/* that is easy... */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> unbound_search(t, j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果表中混合了这两种风格的数据，那么优先取数组部分的长度。如果表存在数组部分，在数组部分二分查找返回位置。如果前面的数组部分查不到满足条件的数据，进入散列表部分查找。<br>所以，尽量不要将一个表混用数组和散列桶部分，即一个表最好只存放一类数据。Lua的实现上确实提供了两者统一表示的遍历，但是这不意味着使用者就应该混用这两种方式。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>《Lua设计与实现》</p>\n","tags":["lua"]},{"title":"lua_state","url":"/2021/02/23/lua-state/","content":"<p>Lua除了是一门扩展的言语外，还是一门“胶水语言”。最著名的就是作为游戏的脚本开发。</p>\n<p>这里主要说lua怎样与c交互。<br>Lua和c语言通信的主要方法是一个无所不在的虚拟栈。几乎所有的API调用都会操作这个栈上的值。所有的数据交换，无论是Lua到C语言或C语言到Lua都通过这个栈来完成。栈可以解决Lua和C语言之间存在的两大差异，第一种差异是Lua使用垃圾收集，而C语言要求显式地释放内存；第二种是Lua使用动态类型，而C语言使用静态类型。</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[<span class=\"number\">256</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> error;</span><br><span class=\"line\">    lua_State *L = luaL_newstate();<span class=\"comment\">//创建一个新的环境</span></span><br><span class=\"line\">    luaL_openlibs(L);<span class=\"comment\">//打开标准库</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fgets(buff,<span class=\"keyword\">sizeof</span>(buff),<span class=\"built_in\">stdin</span>)!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        error = luaL_loadbuffer(L,buff,<span class=\"built_in\">strlen</span>(buff),<span class=\"string\">&quot;line&quot;</span>) || lua_pcall(L,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">&quot;%s&quot;</span>,lua_tostring(L,<span class=\"number\">-1</span>));</span><br><span class=\"line\">            lua_pop(L,<span class=\"number\">1</span>);<span class=\"comment\">//从栈中弹出错误消息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lua_close(L);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>luaL_newstate用c运行库的内存分配函数。<br>lua_newstate可自定义内存分配函数。</p>\n<p>头文件lua.h定义了lua提供的基础函数，包括创建lua环境、调用lua函数（如lua_pcall）、读写lua环境中全局变量，以及注册供lua调用的新函数等。Lua.h中定义所有内容都有一个lua_前缀。<br>头文件lauxlib.h定义了辅助库（auxiliary library,auxlib）提供的函数。它的所有定义都以luaL_开头（如luaL_loadbuffer）。辅助库是一个使用lua.h中API编写出的一个较高的抽象层。Lua的所有标准库编写都用到了辅助库。</p>\n<p>注意：Lua脚本的编译执行是相互独立的，在不同的线程上执行。通过luaL_newstate()函数可以申请一个虚拟机，返回指针类型lua_State。今后其他所有Lua Api函数的调用都需要此指针作为第一参数，用来指定某个虚拟机。所以lua_State代表一个lua虚拟机对像，luaL_newstate()分配一个虚拟机。lua类库管理着所有的虚拟机。销毁指定虚拟机的所有对像（如果有垃圾回收相关的无方法则会调用该方法）并收回所有由该虚拟机动态分配产生的内存，在有些平台下我们不需要调用此函数，因为当主程序退出时，资源会被自然的释放掉，但是但一个长时间运行的程序，比如后台运行的web服务器，需要立即回收虚拟机资源以避免内存过高占用。</p>\n<h2 id=\"Lua虚拟机相关的数据结构与栈\"><a href=\"#Lua虚拟机相关的数据结构与栈\" class=\"headerlink\" title=\"Lua虚拟机相关的数据结构与栈\"></a>Lua虚拟机相关的数据结构与栈</h2><p>下列代码分析，均源自lua5.1。</p>\n<p>解释器要做的就是模拟计算机的执行，这主要分为以下两大块。<br>CPU：用于指令的执行。<br>内存：用于数据的存储。<br>指令执行的部分在<a href=\"https://github.com/losophy/losophy.github.io/issues/113\">lua虚拟机</a>（lua虚拟机工作流程）大体介绍过，即解释器分析Lua文件之后生成 Proto结构体，最后到luaV_execute函数中依次取出指令来执行。<br>而“内存”部分，在Lua解释器中就存放在Lua战中。 Lua中也是把栈的某一个位置称为寄存器（非真CPU中的寄存器）。<br>每个Lua虚拟机对应一个lua_State结构体，它使用TValue数组来模拟栈，其中包括几个与找相关的成员<br>stack ：栈数组的起始位置。<br>base ： 当前函数栈的基地址 。<br>top ： 当前栈的下一个可用位置 。<br>这些成员的初始化操作在stack_init函数中完成</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">stack_init</span> <span class=\"params\">(lua_State *L1, lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* initialize CallInfo array */</span></span><br><span class=\"line\">  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);</span><br><span class=\"line\">  L1-&gt;ci = L1-&gt;base_ci;</span><br><span class=\"line\">  L1-&gt;size_ci = BASIC_CI_SIZE;</span><br><span class=\"line\">  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - <span class=\"number\">1</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看看lua_State</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** `per thread&#x27; state</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_State</span> &#123;</span></span><br><span class=\"line\">  CommonHeader;</span><br><span class=\"line\">  lu_byte status;</span><br><span class=\"line\">  StkId top;  <span class=\"comment\">/* first free slot in the stack */</span></span><br><span class=\"line\">  StkId base;  <span class=\"comment\">/* base of current function */</span></span><br><span class=\"line\">  global_State *l_G;</span><br><span class=\"line\">  CallInfo *ci;  <span class=\"comment\">/* call info for current function */</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>lua_State里面存放的是一个Lua虚拟机的全局状态，当执行到一个两数时，需要有对应的数据结构来表示函数相关的信息。这个数据结构就是CallInfo，这个结构体中同样有top、base这两个与战相关的成员。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** informations about a call</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CallInfo</span> &#123;</span></span><br><span class=\"line\">  StkId base;  <span class=\"comment\">/* base for this function */</span></span><br><span class=\"line\">  StkId func;  <span class=\"comment\">/* function index in the stack */</span></span><br><span class=\"line\">  StkId\ttop;  <span class=\"comment\">/* top for this function */</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Instruction *savedpc;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> nresults;  <span class=\"comment\">/* expected number of results from this function */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> tailcalls;  <span class=\"comment\">/* number of tail calls lost under this entry */</span></span><br><span class=\"line\">&#125; CallInfo;</span><br></pre></td></tr></table></figure>\n<p>无论函数怎么执行，有多少函数，最终它们引用到的栈都是当前Lua虚拟机的栈。 这好比一个操作系统中的进程无论有多少，最终引用的内存实际上都还是由操作系统内核来管理的。<br>在lua_Stat巴中，有一个base_ci的CallInfo数组，存储的就是CallInfo的信息。而另一个ci成员，指向的就是当前函数的CallInfo指针。<br>在调用函数之前，一般会调用luaD_precall函数，它主要完成如下几个操作 。<br>(1 ）保存当前虚拟机执行的指令savedpc到当前CallInfo的savedpc中。此处保存下来是为了后面调用完毕之后恢复执行。<br>(2）分别计算出待调用函数的base、top值，这些值的计算依赖于函数的参数数量。<br>(3）从lua_State的base_ci数组中分配一个新的CallInfo指针，存储前面两步计算出来的信息，切换到这个函数中准备调用。<br>可以看到，lua_State结构体中的top、base指针是与函数执行相关的变量，在函数执行前后都会有所变化。</p>\n<p>需要注意的是，前后调用的函数中Lua栈的大小是有限的，同时CallInfo数组的大小也是有限的。 栈的使用和函数的嵌套层次都不能过多，以防这些资源、用尽了。 这就好比操作系统内核不可能无限制新建进程，也不可能无限制分配内存，资源总是有限的 。</p>\n","tags":["lua"]},{"title":"lua与C/C++程序的整合","url":"/2021/02/23/lua%E4%B8%8EC-C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B4%E5%90%88/","content":"<p>lua与C/C++交互，主要靠lua API和向lua注册好的函数。如下图</p>\n<p>注：LuaGlue就是让Lua脚本中可调用的C++函数的接口。即那些注册的函数。<br>这里起关键作用的要数lua_State的结构，这就得讲一下Lua环境和Lua Stack。</p>\n<h2 id=\"Lua环境\"><a href=\"#Lua环境\" class=\"headerlink\" title=\"Lua环境\"></a>Lua环境</h2><p>Lua环境由所有可操作的数据构成，如编译好的函数、变量以及其他运行时内存。这些数据保存在一个称做lua_State的结构中。所有Lua应用程序都要求至少有一个lua_State，如果需要还可以有多个（如需要为两个不同的系统保存不同的数据时）。</p>\n<h2 id=\"Lua-Stack\"><a href=\"#Lua-Stack\" class=\"headerlink\" title=\"Lua Stack\"></a>Lua Stack</h2><p>对于我们来说，Lua环境是用来发送和接收数据的地方，它利用栈（Lua Stack）来达到该目的。所有的数据交换，无论是Lua到C/C++语言或C/C++语言到Lua都通过这个栈来完成。Lua栈不同于系统栈，它只能通过Lua的API函数访问。</p>\n<h2 id=\"注册到Lua中的函数\"><a href=\"#注册到Lua中的函数\" class=\"headerlink\" title=\"注册到Lua中的函数\"></a>注册到Lua中的函数</h2><p>所有注册到Lua中的函数都具有相同的原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*lua_Function)</span><span class=\"params\">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这个函数仅有一个参数，即Lua的状态。它返回一个整数，表示其压入栈中的返回值数量。因此函数无须在压入结果前清空栈。在它返回后，Lua会自动删除栈中结果之下的内容。</p>\n<p>在Lua使用这个函数前，必须注册这个函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lua_pushcfunction</span> <span class=\"params\">(lua_State *L, lua_CFunction f)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>将一个 C 函数压入堆栈。 这个函数接收一个 C 函数指针，并将一个类型为 function 的 Lua 值 压入堆栈。当这个栈顶的值被调用时，将触发对应的 C 函数。<br>这种方法需要重新编译Lua的执行程序，才能在Lua程序中使用这个新函数。但用下面的方法会更好，直接将C函数链接到lua。</p>\n<h2 id=\"Lua调用C函数\"><a href=\"#Lua调用C函数\" class=\"headerlink\" title=\"Lua调用C函数\"></a>Lua调用C函数</h2><p>Lua调用C函数时，并不依赖于函数名、包的位置或可见性规则，而只依赖于注册时传入的函数地址。当用C函数扩展Lua时，最好将代码设计为一个C模块。因为现在只注册一个函数，但说之后可能会需要更多的函数。辅助库为这项工作提供了一个函数luaL_register，这个函数接收一些C函数及其名称，并将这些函数注册到一个与模块同名的table中。例如，假设创建一个模块，其中包含了这个luaglue函数。首先，必须定义这个模块函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">luaglue</span><span class=\"params\">(lua_state *L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，声明一个数组，其中包含模块中所有函数及名称。这个数组元素的类型为luaL_Reg结构，该结构有两个字段，一个字符串和一个函数指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">luaL_Reg</span> <span class=\"title\">mylib</span>[] =</span> &#123;</span><br><span class=\"line\">&#123;<span class=\"string\">&quot;dir&quot;</span>,l_dir&#125;,</span><br><span class=\"line\">&#123;<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>&#125;<span class=\"comment\">//结尾</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后，声明一个主函数，其中用到了luaL_register:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaopen_mylib</span><span class=\"params\">(lua_State *L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     luaL_register(L,<span class=\"string\">&quot;mylib&quot;</span>,mylib);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中luaL_register原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaL_register</span> <span class=\"params\">(lua_State *L,<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *libname,<span class=\"keyword\">const</span> luaL_Reg *l)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>luaL_register根据给定的名称（“mylib”）创建（或复用）一个table，并用数组mylib中的信息填充这个table。在luaL_Register返回时，会将这个table留在栈中。最后，luaopen_mylib函数返回1，表示将这个table返回给Lua。<br>ps：打开一个库，当libname为null时，该函数注册所有在luaL_Reg上的函数，不为null时，该函数会创建一个table，根据libname注册不与libname关联的函数。<br>当写完c模块后，必须将其链接到解释器。如果Lua解释器支持动态链接的话，那么最简便的方法是使用动态链接机制。在这种情况中，必须将c代码编译成动态链接库，并将这个库放入C路径（LUA_CPATH）中。然后，便可以用require从Lua中加载这个模块：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span> <span class=\"string\">&quot;mylib&quot;</span></span><br></pre></td></tr></table></figure>\n<p>这名调用会将动态库mylib链接到Lua，并会寻找luaopen_mylib函数，将其注册为一个Lua函数，然后调用它以打开模块。<br>如果解释器不支持动态链接，那么就必须用新的模块来重新编译Lua。此外，还需要以某种方式来告诉解释器，它应在打开一个新状态的同时打开这个模块。最简单的做法是，将luaopen_mylib加到luaL_openlibs会打开的标准库列表中，这个列表在文件linit.c中。</p>\n<p>从C++程序员的观点来看，Lua像一个“黑盒子”，为一些服务处理命令和调用。Lua通常作为最上层接口直接和程序使用者和游戏玩家打交道，在核心程序处理之前接受并响应输入。</p>\n<h2 id=\"lua-tinker\"><a href=\"#lua-tinker\" class=\"headerlink\" title=\"lua_tinker\"></a>lua_tinker</h2><p>如果嫌麻烦，不想手动写这些代码的话，我推荐lua_tinker。也就只有两个文件，lua_tinker.h，lua_tinker.cpp。<br>环境配置，首先你需要搭建一个可以用lua的开发环境，这里网上有很多，我就不多说了。然后再将lua_tinker的lua_tinker.h和lua_tinker.cpp添加到你的工程中就可以了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">lua_tinker::def(L, <span class=\"string\">&quot;cpp_func&quot;</span>, cpp_func); <span class=\"comment\">//在L栈中注册C++函数</span></span><br><span class=\"line\">lua_tinker::dofile(L, <span class=\"string\">&quot;sample1.lua&quot;</span>); <span class=\"comment\">//加载lua文件</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> result = lua_tinker::call&lt;<span class=\"keyword\">int</span>&gt;(L, <span class=\"string\">&quot;lua_func&quot;</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">//调用lua中的function lua_func</span></span><br><span class=\"line\"></span><br><span class=\"line\">lua_tinker::class_add(L,<span class=\"string\">&quot;classA&quot;</span>);<span class=\"comment\">//在lua中注册类</span></span><br><span class=\"line\">lua_tinker::class_con(L,lua_tinker::constructor&lt;classA&gt;);<span class=\"comment\">//在lua中注册构造函数</span></span><br><span class=\"line\">lua_tinker::class_mem(L,<span class=\"string\">&quot;memName&quot;</span>,&amp;classA::memName);</span><br></pre></td></tr></table></figure>\n<p>用lua_tinker::call是要注意，参数不支持智能指针</p>\n","tags":["lua"]},{"title":"lua与配置文件","url":"/2021/02/23/lua%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","content":"<p>lua的一项重要用途就是作为一种配置语言（configuration language）。<br>目前，我们常用的配置文件格式有XML和ini,  XML层次分明，但其缺点就是写起来太繁杂，对一些关键字如&lt;&gt;之类的处理比较特殊。而ini呢，配置不够灵活，只有简单的段-<br>键-值模式，对于一些多层结构的配置，或者一些列表类型的配置，就显得力不从心了，往往需要编码人员自己分割字符串。<br>Lua脚本非常简洁清晰，是非常适合做配置文件的，无论是映射表型配置，还是列表型配置，还是简单的键值配置，lua都可以完全胜任。而且lua格式清新简洁，一看就懂。</p>\n<p>下面的代码主要是读变量和table。<br>mycon.lua</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--my config </span></span><br><span class=\"line\"></span><br><span class=\"line\">width = <span class=\"number\">300</span></span><br><span class=\"line\">height = <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\">luat_Test1=&#123;a=<span class=\"number\">123</span>, b=<span class=\"number\">456</span>, c=<span class=\"number\">789</span>&#125;</span><br><span class=\"line\">luat_Test2=&#123;<span class=\"number\">123</span>, <span class=\"number\">456</span>, <span class=\"number\">789</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>这里说个题外话，Lua不会根据一个范围的值来创建表，而是根据设定的单个值来创建表内容，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">textTable &#x3D; &#123;&#125;</span><br><span class=\"line\">textTable[2000] &#x3D; &quot;hello 2000!&quot;</span><br></pre></td></tr></table></figure>\n<p>这里虽然会生成许多未使用的Key，但不必担心这个方法会牺牲任何表的存储空间。<br>main.cpp</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;  </span></span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//如不用extern会出现连接错误，编译成了C++文件  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span>   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;lua.h&quot;</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;lauxlib.h&quot;</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;lualib.h&quot;</span>  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> comment(lib, <span class=\"meta-string\">&quot;lua5.1.lib&quot;</span>)  </span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ReadVariable</span> <span class=\"params\">(lua_State *L,<span class=\"keyword\">int</span> *width,<span class=\"keyword\">int</span> *height)</span></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L,<span class=\"string\">&quot;width&quot;</span>);   <span class=\"comment\">//获得Lua中变量的值，将其放入栈中  </span></span><br><span class=\"line\">    lua_getglobal(L,<span class=\"string\">&quot;height&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!lua_isnumber(L,<span class=\"number\">-2</span>))     <span class=\"comment\">//栈顶为-1，然后依次减少  </span></span><br><span class=\"line\">        luaL_error(L,<span class=\"string\">&quot;`width&#x27; should be a number\\n&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!lua_isnumber(L,<span class=\"number\">-1</span>))  </span><br><span class=\"line\">        luaL_error(L,<span class=\"string\">&quot;`height&#x27; should be a number\\n&quot;</span>);  </span><br><span class=\"line\">    *width = (<span class=\"keyword\">int</span>)lua_tonumber(L,<span class=\"number\">-2</span>);    <span class=\"comment\">//将栈顶元素转化为数字  </span></span><br><span class=\"line\">    *height = (<span class=\"keyword\">int</span>)lua_tonumber(L,<span class=\"number\">-1</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;width is %d ,height is %d\\n\\n&quot;</span>,*width,*height);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ReadTableFromItem</span><span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableName, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableItem)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L, lpszTableName);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    lua_pushstring(L, lpszTableItem);<span class=\"comment\">//首先把元素的名字压入栈顶  </span></span><br><span class=\"line\">    lua_gettable(L, <span class=\"number\">-2</span>);<span class=\"comment\">//值会放在栈顶，同时刚才压入的元素名字被弹出  </span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s.%s=%d\\n&quot;</span>, lpszTableName, lpszTableItem, (<span class=\"keyword\">int</span>)lua_tonumber(L, <span class=\"number\">-1</span>));  </span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ReadTableFromIndex</span><span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableName, <span class=\"keyword\">int</span> index)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L, lpszTableName);  </span><br><span class=\"line\">    lua_rawgeti(L, <span class=\"number\">-1</span>, index);<span class=\"comment\">//获得第一个元素  </span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s[%d]=%d\\n&quot;</span>, lpszTableName, index, (<span class=\"keyword\">int</span>)lua_tonumber(L, <span class=\"number\">-1</span>));  </span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">2</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">EnumTableItem</span><span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lpszTableName)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    lua_getglobal(L, lpszTableName);  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> it = lua_gettop(L);  </span><br><span class=\"line\">    lua_pushnil(L);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Enum %s:&quot;</span>, lpszTableName);  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lua_next(L, it))<span class=\"comment\">//用lua_next可以遍历这个数组  </span></span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;  %d&quot;</span>, (<span class=\"keyword\">int</span>)lua_tonumber(L, <span class=\"number\">-1</span>));  </span><br><span class=\"line\">        lua_pop(L, <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n\\n&quot;</span>);  </span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;param error!\\n&quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> *filename = argv[<span class=\"number\">1</span>];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    lua_State *L = lua_open();  </span><br><span class=\"line\">    luaL_openlibs(L);  <span class=\"comment\">//新版本库添加的方法  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(luaL_loadfile(L,filename) || lua_pcall(L,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>))&#123;  </span><br><span class=\"line\">        luaL_error(L,<span class=\"string\">&quot;loadfile error! %s \\n&quot;</span>,lua_tostring(L,<span class=\"number\">-1</span>));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> w=<span class=\"number\">1</span>,h=<span class=\"number\">2</span>;  </span><br><span class=\"line\">    ReadVariable(L,&amp;w,&amp;h);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ReadTableFromItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>, <span class=\"string\">&quot;a&quot;</span>);  <span class=\"comment\">// 等价与lua代码：print(luat_Test1.a)  </span></span><br><span class=\"line\">    ReadTableFromItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>, <span class=\"string\">&quot;b&quot;</span>);  </span><br><span class=\"line\">    ReadTableFromItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>, <span class=\"string\">&quot;c&quot;</span>);  </span><br><span class=\"line\">    EnumTableItem(L, <span class=\"string\">&quot;luat_Test1&quot;</span>);    <span class=\"comment\">// 枚举Table  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ReadTableFromIndex(L, <span class=\"string\">&quot;luat_Test2&quot;</span>, <span class=\"number\">1</span>);  <span class=\"comment\">// 等价与lua代码：print(luat_Test1[1])  </span></span><br><span class=\"line\">    ReadTableFromIndex(L, <span class=\"string\">&quot;luat_Test2&quot;</span>, <span class=\"number\">2</span>);  </span><br><span class=\"line\">    ReadTableFromIndex(L, <span class=\"string\">&quot;luat_Test2&quot;</span>, <span class=\"number\">3</span>);  </span><br><span class=\"line\">    EnumTableItem(L, <span class=\"string\">&quot;luat_Test2&quot;</span>);  </span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于配置文件安全的问题，一般会将这些lua文件进行加密。</p>\n<h2 id=\"excel转lua\"><a href=\"#excel转lua\" class=\"headerlink\" title=\"excel转lua\"></a>excel转lua</h2><p>配置文件多数以excel转lua的方式配置，网上也有很多相关工具。例如用xlrd</p>\n<h3 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h3><p>用[]表示数组，如</p>\n<ul>\n<li>[123456,123457]表示两个物品</li>\n<li>[1,1001001,1]表示物品的类型、code、数量</li>\n<li>如果要配置多种数据，可以使用json<h3 id=\"多key配置\"><a href=\"#多key配置\" class=\"headerlink\" title=\"多key配置\"></a>多key配置</h3>这个要写个配置文件，明确是用哪些字段作key<h3 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h3>可以按这个格式<blockquote>\n<p>2019-1-1 1:00:00</p>\n</blockquote>\n</li>\n</ul>\n<p>再根据需求转时间戳</p>\n","tags":["lua"]},{"title":"lua使用优化","url":"/2021/03/01/lua%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/","content":"<h2 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a>堆栈溢出</h2><p>我们在运行lua的时候，有可能遇到这样一种报错 “stack overflow”，先看看下面一段代码</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func_r</span><span class=\"params\">(a)</span></span></span><br><span class=\"line\">    a = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a &gt; <span class=\"number\">100000</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        func_r(a)</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"> </span><br><span class=\"line\">x = <span class=\"number\">1</span></span><br><span class=\"line\">func_r(x)</span><br></pre></td></tr></table></figure>\n<p>语法上的确没有任何问题，但在执行的时候就会出现 stack overflow 的报错。是什么原因导致堆栈溢出呢？这个就要追究到Lua源码：Lua虚拟机会对堆栈进行一系列的检查（函数：luaL_checkstack），错误类型就有：<br>“too many arguments”，<br>“assume array is smaller than 2^40 “，<br>“string slice too long”，<br>“too many captures”，<br>“too many arguments to script”，<br>“too many nested functions”<br>例如，上面的代码就属于递归嵌套次数太多，默认限制20000。</p>\n<h2 id=\"不支持边遍历表边删除表中字段\"><a href=\"#不支持边遍历表边删除表中字段\" class=\"headerlink\" title=\"不支持边遍历表边删除表中字段\"></a>不支持边遍历表边删除表中字段</h2><p>当在遍历表的时候为不存在的字段赋值时，next的遍历顺序是未知的，然而，你可以在遍历时修改已有的字段，或者，你可以删除已经存在的字段。</p>\n<h2 id=\"使用局部变量local\"><a href=\"#使用局部变量local\" class=\"headerlink\" title=\"使用局部变量local\"></a>使用局部变量local</h2><p>这是最基础也是最有用的策略，虽然使用全局变量并不能完全避免，但还是应该尽量避免，取而代之使用局部变量即local。这里的局部变量也包括函数function，因为在Lua里函数也是一个变量。局部变量的存取会更快，而且在生命周期之外就会释放掉。</p>\n<h2 id=\"尾调用消除\"><a href=\"#尾调用消除\" class=\"headerlink\" title=\"尾调用消除\"></a>尾调用消除</h2><p>Lua中的函数调用有两种，一种是标准的函数调用，它会需要生成新的一层调用栈，执行函数流程，然后弹出调用栈返回。另一种叫做尾调用，它是对标准函数调用的优化。尾调用不生成新的调用栈，而不复用当前的。在大多数函数式编程语言中，都需要对尾调用做特别优化。因为函数式语言特别依赖函数的层层调用，甚至用尾调用的方式来做循环。传统方式每次函数调用都需要生成新的栈帧，容易造成栈溢出。 尾调用可以看作C中的goto。</p>\n<p>当一个函数调用是另一个函数的最后一个动作时，该调用才算是一条“尾调用”。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> g(x) <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">--不是尾调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x)</span></span> g(x) <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>也就是说，当f调用完g之后就再无其他事情可做了。因此在这种情况中，程序就不需要返回那个“尾调用”所在的函数了。所以在“尾调用”之后，程序也不需要保存任何关于该函数的栈信息了。当g返回时，执行控制权可以直接返回到调用f的那个点上。使得在进行“尾调用”时不耗费任何栈空间。将这种实现称为支持“尾调用消除”。</p>\n<h2 id=\"传参时，少用…\"><a href=\"#传参时，少用…\" class=\"headerlink\" title=\"传参时，少用…\"></a>传参时，少用…</h2><p>…用于可变参数。如果在传参数过多时，为了方便使用…，会降低代码可读性（寻找参数）。</p>\n<h2 id=\"少用字符串连接操作符\"><a href=\"#少用字符串连接操作符\" class=\"headerlink\" title=\"少用字符串连接操作符\"></a>少用字符串连接操作符</h2><p>从lua字符串的<a href=\"https://github.com/losophy/losophy.github.io/issues/112\">实现</a>可知，运用字符串连接操作符每一次都会生成一个新的字符串。可使用table来模拟字符串缓冲区，避免了大量使用连接操作符。table.concat()。</p>\n<h2 id=\"table使用预填充技术\"><a href=\"#table使用预填充技术\" class=\"headerlink\" title=\"table使用预填充技术\"></a>table使用预填充技术</h2><p>Lua解释器背着我们会对表进行重新散列的动作， <a href=\"https://github.com/losophy/losophy.github.io/issues/110\">lua Table</a>新增元素有详细解释。一个整数的key在同一个表中不同的阶段可能被分配到数组或者散列桶部分。<br>而这个操作的代价是挺大的。<br>如下面的代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=l,<span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    a[i] = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>最开始，Lua创建了一个空表a。在第一次迭代中，a[1]为 true触发了一次重新散列操作，Lua将数组部分的长度设置为2^0 ，即 1，散列表部分仍为空。在第二次迭代中，a[2]为true再次触发了重新散列操作，将数组部分长度设为 2^1，即2。最后一次迭代又触发了一次重新散列操作，将数组部分长度设为2^2 ，即4。<br>只有三个元素的表会执行三次重新散列操作，然而有 100万个元素的表仅仅只会执行20次重新散列操作而已，因为2”20 = 1048576 &gt; 1000000。 但是，如果创建了非常多的长度很小的表（比如坐标点： point = {x=0, y=0｝），这可能会造成巨大的影响。所以，当需要创建非常多的小表时，应预先填充好表的大小，减少解释器被动地进行重新散列操作的过程。<br>如果你有很多很小的表需要创建，就可以预先填充以避免重新散列操作。比如：｛true, true,true}，Lua知道这个表有3个元素，所以直接创建了3个元素的数组。 类似地，｛ X=l, y=2, z＝3，}，Lua会在其散列表部分中创建长度为3的数组。<br>所以，上述代码使用了预填充技术为：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a = &#123;<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=l,<span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    a[i] = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"限制require到别的模块\"><a href=\"#限制require到别的模块\" class=\"headerlink\" title=\"限制require到别的模块\"></a>限制require到别的模块</h2><p>手工编写服务表，防止Require到别的服务的lua模块<br>REQUIRE_CHECK_LIST = {<br>    [“A”] = true,<br>    [“B”] = true,<br>}</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> realrequire = <span class=\"built_in\">require</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"built_in\">loaded</span> = <span class=\"built_in\">package</span>.<span class=\"built_in\">loaded</span></span><br><span class=\"line\"><span class=\"built_in\">require</span> = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">( moduleName )</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">local</span> loadedModule = <span class=\"built_in\">loaded</span>[moduleName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> loadedModule ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> loadedModule</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">local</span> header = moduleName:<span class=\"built_in\">match</span>(<span class=\"string\">&quot;([^%.]*)%..*&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>  REQUIRE_CHECK_LIST[header] <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">print</span>(try to <span class=\"built_in\">require</span> others service)</span><br><span class=\"line\">\t\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> realrequire(moduleName)</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>","tags":["lua"]},{"title":"lua元表和元方法","url":"/2021/03/19/lua%E5%85%83%E8%A1%A8%E5%92%8C%E5%85%83%E6%96%B9%E6%B3%95/","content":"<h2 id=\"元表的由来\"><a href=\"#元表的由来\" class=\"headerlink\" title=\"元表的由来\"></a>元表的由来</h2><p>Lua2.1灵活语义问世，极大的增加了Lua的表达能力，从此，灵活语义就变成了Lua的标志。</p>\n<p>灵活语义的一个目标是允许table作为对象和类的基础。为了实现这个目标，需要实现table的继承。另一个目标是将userdata变成应用数据的天然代理，可以作为函数参数而不只是一个句柄。userdata希望能够索引，就好像他们只是一个table，可供调用他们身上的方法。所以fallback机制的实现，让Lua把未定义行为交给程序员处理，而不是直接在语言本身实现这些特性。</p>\n<p>Lua2.1提供了fallback机制，支持以下行为：table索引，算术操作符，字符串拼接，顺序比较，函数调用。当这些操作应用到“错误”的类型上，对应的fallback就会被调用到，允许程序员决定Lua如何处理。table索引fallback允许userdata和其它值类型表现的跟表一样。定义当Key不在table时的fallback，从而实现多种形式的继承（通过委托）。为了完善面向对象编程，添加了两个语法糖：function a:foo(…)就好比function a.foo(self,…)一样，以及a:foo(…)作为a.foo(a, …)的语法糖。</p>\n<p>Lua2.1里引入的fallback机制，可以很好的支持灵活扩展的语义，但这个机制是全局的：每个事件只有一个钩子。这让共享或重用代码变的很艰难，因为同一事件的fallback在模块里只能定义一次，不能共存。Lua 3.0解决了fallback冲突问题。fallback替换为tag方法：钩子是以(event, tag)的形式挂在字典里的。Tags是在Lua2.1引入的整数标签，可以附在userdata上。最初的动机是希望同类的C对象，在Lua里都有相同的tag(不过，Lua没有强迫要对Tag提供解释)。Lua3.0里对所有值类型提供了tag支持，以支持对应的tag方法。</p>\n<p>标记方法机制工作的很好，一直存续到Lua 5.0为止。在Lua 5.0实现了元表和元方法来取代标记和标记方法。元表只是普通的Lua table，所以可以用Lua直接操作，不需要特殊函数。就像标记一样，元表可以用来表示userdata和table的用户定义类型：所有“同类”对象应该共享同一个元表。不像标记，元表和他们的内容会在所有引用消失后自动被回收掉。（相反，标记和标记方法会等到程序结束才会被回收。）元表的引入同时简化了实现：标记方法需要在Lua核心代码里添加特殊的私有表示方法，元表主要就是标准的table机制。<br>下面的代码展示了Lua 5.0里，继承是如何实现的。index元方法取代了index标记，元表里则是用__index域来表示。代码通过将b的元表里的__index域指向a，实现了b继承a。（一般情况下，index元方法都是函数，但允许它设为table，以直接支持简单的委托继承。）</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a=Window&#123;x=<span class=\"number\">100</span>, y=<span class=\"number\">200</span>, color=<span class=\"string\">&quot;red&quot;</span>&#125;</span><br><span class=\"line\">b=Window&#123;x=<span class=\"number\">300</span>, y=<span class=\"number\">400</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">setmetatable</span>(b, &#123;<span class=\"built_in\">__index</span> = a&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b.color) —&gt;red</span><br></pre></td></tr></table></figure>\n<h2 id=\"元方法\"><a href=\"#元方法\" class=\"headerlink\" title=\"元方法\"></a>元方法</h2><p>在Lua中有一个元表，也就是上面说的metatable，我们可以通过元表来修改一个值得行为，使其在面对一个非预定义的操作时执行一个指定的操作。比如，现在有两个table类型的变量a和b，我们可以通过metatable定义如何计算表达式a+b<br>我们是使用getmetatable来获取一个table或userdata类型变量的元表，当创建新的table变量时，使用getmetatable去获得元表，将返回nil；同理，我们也可以使用setmetatable去设置一个table或userdata类型变量的元表<br>在table中，我可以重新定义的元方法有以下几个</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">__add</span>(a, b) <span class=\"comment\">--加法</span></span><br><span class=\"line\"><span class=\"built_in\">__sub</span>(a, b) <span class=\"comment\">--减法</span></span><br><span class=\"line\"><span class=\"built_in\">__mul</span>(a, b) <span class=\"comment\">--乘法</span></span><br><span class=\"line\"><span class=\"built_in\">__div</span>(a, b) <span class=\"comment\">--除法</span></span><br><span class=\"line\"><span class=\"built_in\">__mod</span>(a, b) <span class=\"comment\">--取模</span></span><br><span class=\"line\"><span class=\"built_in\">__pow</span>(a, b) <span class=\"comment\">--乘幂</span></span><br><span class=\"line\"><span class=\"built_in\">__unm</span>(a) <span class=\"comment\">--相反数</span></span><br><span class=\"line\"><span class=\"built_in\">__concat</span>(a, b) <span class=\"comment\">--连接</span></span><br><span class=\"line\"><span class=\"built_in\">__len</span>(a) <span class=\"comment\">--长度</span></span><br><span class=\"line\"><span class=\"built_in\">__eq</span>(a, b) <span class=\"comment\">--相等</span></span><br><span class=\"line\"><span class=\"built_in\">__lt</span>(a, b) <span class=\"comment\">--小于</span></span><br><span class=\"line\"><span class=\"built_in\">__le</span>(a, b) <span class=\"comment\">--小于等于</span></span><br><span class=\"line\"><span class=\"built_in\">__index</span>(a, b) <span class=\"comment\">--索引查询</span></span><br><span class=\"line\"><span class=\"built_in\">__newindex</span>(a, b, c) <span class=\"comment\">--索引更新（PS：不懂的话，后面会有讲）</span></span><br><span class=\"line\"><span class=\"built_in\">__call</span>(a, ...) <span class=\"comment\">--执行方法调用</span></span><br><span class=\"line\"><span class=\"built_in\">__tostring</span>(a) <span class=\"comment\">--字符串输出</span></span><br><span class=\"line\"><span class=\"built_in\">__metatable</span> <span class=\"comment\">--保护元表</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>《The evolution of Lua》</p>\n","tags":["lua"]},{"title":"lua函数与闭包","url":"/2021/02/23/lua%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/","content":"<p>在lua中，函数是一种第一类值，它们具有特定的词法域。<br>lua当中函数是一个值，他可以存在变量中（无论全局变量还是局部变量）或table中，可以作为函数参数，可以作为返回值。</p>\n<h2 id=\"upvalue\"><a href=\"#upvalue\" class=\"headerlink\" title=\"upvalue\"></a>upvalue</h2><p>词法域：当一个函数内嵌套另一个函数的时候，内函数可以访问外部函数的局部变量。这也意味着lua完全可以包含“λ演算（Lambda Calculus）”。<br>这个特性在以下场景特别有用：匿名函数作为高阶函数的参数，用于table遍历和模式匹配。</p>\n<p>在lua中，函数可以看作一个“值”，由一些表达式创建的。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(x)</span></span> <span class=\"keyword\">return</span> <span class=\"number\">2</span>*x <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>举个例子：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">network = &#123;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;grauna&quot;</span>, IP = <span class=\"string\">&quot;210.26.30.34&quot;</span>&#125;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;arraial&quot;</span>, IP = <span class=\"string\">&quot;210.26.30.23&quot;</span>&#125;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;lua&quot;</span>, IP = <span class=\"string\">&quot;210.26.23.12&quot;</span>&#125;</span><br><span class=\"line\">    &#123;name = <span class=\"string\">&quot;derain&quot;</span>, IP = <span class=\"string\">&quot;210.26.23.20&quot;</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">sort</span>(network, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(a,b)</span></span> <span class=\"keyword\">return</span>(a.name&gt;b.name) <span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<p>这种用法叫匿名函数，在语句中显示出了极好的便捷性。</p>\n<h2 id=\"闭包-closure\"><a href=\"#闭包-closure\" class=\"headerlink\" title=\"闭包(closure)\"></a>闭包(closure)</h2><p>如果说C++式的面向对象编程是把一组函数绑定到特定数据类型上的话，那么闭包可以说是把一组数据绑定到特定函数上。<br>闭包通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数（就是工厂）产生的一个实例函数<br>闭包组成：外部函数+外部函数创建的upvalue+内部函数（闭包函数）</p>\n<p>Lua中只有闭包，函数是闭包一种特殊情况。</p>\n<h2 id=\"…\"><a href=\"#…\" class=\"headerlink\" title=\"…\"></a>…</h2><p>当一个变参函数被调用，对应…的参数将会收集到一个叫arg的table里。这种方式虽然很简单便捷，但是要把这些参数传给另一个函数，就需要解包这个table。因为程序员经常将参数传递给另一个函数，Lua 5.1允许…用于参数列表和赋值表达式的右值。这避免了没必要的创建arg table。</p>\n","tags":["lua"]},{"title":"lua协程","url":"/2021/02/23/lua%E5%8D%8F%E7%A8%8B/","content":"<p>协同程序与线程差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时又与其他协同程序共享全局变量和其他大部分东西。<br>一个具有多个协同程序的程序在任意时刻只能运行一个协同程序。</p>\n<p>lua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。</p>\n<p>一个协同程序可以处于4种不同的状态：挂起、运行、死亡和正常。<br>程序初创建：挂起<br>程序运行：运行<br>程序结束：死亡<br>程序被其实程序唤醒：正常</p>\n<p>co_create 传一个函数参数，用来创建协程。返回一个“thread”对象</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">co = <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">create</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(a,b)</span></span></span><br><span class=\"line\">        <span class=\"built_in\">coroutine</span>.<span class=\"built_in\">yield</span>(a+b,a-b)</span><br><span class=\"line\">        <span class=\"keyword\">end</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">coroutine</span>.<span class=\"built_in\">resume</span>(co,<span class=\"number\">20</span>,<span class=\"number\">10</span>))</span><br></pre></td></tr></table></figure>\n<p>与协同程序之间的对称性区别相比，协同程序与generator（Python所提供的）之间的区别很大。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>协程实现的两个关键点在于：</p>\n<ul>\n<li>协程状态的保存</li>\n<li>不同协程之间的数据通信机制 </li>\n</ul>\n<p>在Lua1-t码中，使用的是lua State结构体来表示协程，这与Lua虚拟机用的是同一个数据结构 。 这一点可以从创建协程的函数lua newthread中看出来，唯一有区别的是， Lua协程的类型是LUA TTHREAD 。 换言之，在Lua源码的处理中， Lua协程与Lua虚拟机的表现形式并没有太大差异，也许这样做是为了实现方便。 前面提到过，一个协程有自己私有的环境，不会因为协程的切换而发生改变 。</p>\n<p>接下来，我们来看看如何在不同协程之间通信，或者说Lua协程间数据的交换。 前面提到过resume和 yield 函数的参数就是用来做协程数据交换的，现在来看看里面的实现 。 奥秘就在函数lua_xmove 中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API <span class=\"keyword\">void</span> <span class=\"title\">lua_xmove</span> <span class=\"params\">(lua_State *from, lua_State *to, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (from == to) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  lua_lock(to);</span><br><span class=\"line\">  api_checknelems(from, n);</span><br><span class=\"line\">  api_check(from, G(from) == G(to));</span><br><span class=\"line\">  api_check(from, to-&gt;ci-&gt;top - to-&gt;top &gt;= n);</span><br><span class=\"line\">  from-&gt;top -= n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    setobj2s(to, to-&gt;top++, from-&gt;top + i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_unlock(to);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码做的事情就是，从from协程中移动n个数据到 to协程中 。 当然在移动之前，数据要在from协程的战顶上准备好。<br>创建协程在函数luaB cocreate中进行．</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">luaB_cocreate</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  lua_State *NL = lua_newthread(L);</span><br><span class=\"line\">  luaL_argcheck(L, lua_isfunction(L, <span class=\"number\">1</span>) &amp;&amp; !lua_iscfunction(L, <span class=\"number\">1</span>), <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Lua function expected&quot;</span>);</span><br><span class=\"line\">  lua_pushvalue(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* move function to top */</span></span><br><span class=\"line\">  lua_xmove(L, NL, <span class=\"number\">1</span>);  <span class=\"comment\">/* move function from L to NL */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>明白了前面的内容，理解创建协程的过程就不难了，这里主要做了以下几件事情。</p>\n<ul>\n<li>调用lua newthread创建lua State结构体。</li>\n<li>检查当前楼顶的元素是不是一个函数对象，因为需要一个函数作为协程开始运行时的主函数。 这个主函数必须是Lua函数， C函数将会报错。</li>\n<li>将协程主函数压人当前 lua State 的楼中，然后调用 lua xmove 将该函数从当前的lua State移动到新创建的协程的 lua State战中 。</li>\n</ul>\n<p>了解了Lua协程实现相关的数据结构，接下来看看最核心的两个操作resume和yield是如何实现的 。<br>resume操作在函数 luaB_coresume 中实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">luaB_coresume</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  lua_State *co = lua_tothread(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">  luaL_argcheck(L, co, <span class=\"number\">1</span>, <span class=\"string\">&quot;coroutine expected&quot;</span>);</span><br><span class=\"line\">  r = auxresume(L, co, lua_gettop(L) - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    lua_pushboolean(L, <span class=\"number\">0</span>);</span><br><span class=\"line\">    lua_insert(L, <span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;  <span class=\"comment\">/* return false + error message */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    lua_pushboolean(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">    lua_insert(L, -(r + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span>;  <span class=\"comment\">/* return true + `resume&#x27; returns */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里主要做几件事情：</p>\n<ul>\n<li>检查当前枝顶元素是不是协程指针。</li>\n<li>调用辅助函数auxresume进行实际的resume操作。</li>\n<li>根据auxresume的返回值来做不同的处理。 当返回值小于0时，说明 resume操作出错，并且此时出错信息在樵顶，因此压入false以及出错消息；否则， auxresume的返回值表示执行resume操作时返回的参数数量，这种情况下压人true以及这些返回参数。<br>auxresume 函数的实现如下：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">auxresume</span> <span class=\"params\">(lua_State *L, lua_State *co, <span class=\"keyword\">int</span> narg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_checkstack(co, narg))</span><br><span class=\"line\">    luaL_error(L, <span class=\"string\">&quot;too many arguments to resume&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lua_status(co) == <span class=\"number\">0</span> &amp;&amp; lua_gettop(co) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    lua_pushliteral(L, <span class=\"string\">&quot;cannot resume dead coroutine&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  <span class=\"comment\">/* error flag */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_xmove(L, co, narg);</span><br><span class=\"line\">  status = lua_resume(co, narg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status == <span class=\"number\">0</span> || status == LUA_YIELD) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nres = lua_gettop(co);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lua_checkstack(L, nres))</span><br><span class=\"line\">      luaL_error(L, <span class=\"string\">&quot;too many results to resume&quot;</span>);</span><br><span class=\"line\">    lua_xmove(co, L, nres);  <span class=\"comment\">/* move yielded values */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nres;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    lua_xmove(co, L, <span class=\"number\">1</span>);  <span class=\"comment\">/* move error message */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;  <span class=\"comment\">/* error flag */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n它主要做如下操作 。</li>\n<li>检查数据的合法性 。</li>\n<li>将参数通过lua xmove函数传递到待启动的协程中，调用 lua resume函数执行协程代码 。</li>\n<li>当 lua_resume函数返回时，说明该协程已经执行完毕，通过lua_xmove函数将yield传入的参数传递回启动该协程的协程。<br>auxresume函数会调用 lua resume 函数，在 lua resume 函数中进行一些检查，比如当前的状态是否合理，调用层次是否过多，最终使用 luaD_rawrunprotected 函数来保护调用 resume 函数 。resume 函数的代码如下所示：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">resume</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">void</span> *ud)</span> </span>&#123;</span><br><span class=\"line\">  StkId firstArg = cast(StkId, ud);</span><br><span class=\"line\">  CallInfo *ci = L-&gt;ci;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;status == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">/* start coroutine? */</span></span><br><span class=\"line\">    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (luaD_precall(L, firstArg - <span class=\"number\">1</span>, LUA_MULTRET) != PCRLUA)</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* resuming from previous yield */</span></span><br><span class=\"line\">    lua_assert(L-&gt;status == LUA_YIELD);</span><br><span class=\"line\">    L-&gt;status = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!f_isLua(ci)) &#123;  <span class=\"comment\">/* `common&#x27; yield? */</span></span><br><span class=\"line\">      <span class=\"comment\">/* finish interrupted execution of `OP_CALL&#x27; */</span></span><br><span class=\"line\">      lua_assert(GET_OPCODE(*((ci<span class=\"number\">-1</span>)-&gt;savedpc - <span class=\"number\">1</span>)) == OP_CALL ||</span><br><span class=\"line\">                 GET_OPCODE(*((ci<span class=\"number\">-1</span>)-&gt;savedpc - <span class=\"number\">1</span>)) == OP_TAILCALL);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (luaD_poscall(L, firstArg))  <span class=\"comment\">/* complete it... */</span></span><br><span class=\"line\">        L-&gt;top = L-&gt;ci-&gt;top;  <span class=\"comment\">/* and correct top if not multiple results */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"comment\">/* yielded inside a hook: just continue its execution */</span></span><br><span class=\"line\">      L-&gt;base = L-&gt;ci-&gt;base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这个函数做了以下的事情</li>\n<li>如果当前协程的状态是0 ，那么说明它是第一次执行 resume操作，此时调用 luaD_precall做函数调用前的准备工作。 如果luaD_precall函数的返回值不是PCRLUA ，说明是在C函数中进行resume操作的，此时并不需要后面的 luaV execute函数，就直接返回了 。</li>\n<li>否则就从之前的 YIELD状态中继续执行，首先将协程的状态置为0 ，其次判断此时口的类型，如果不是Lua函数，说明之前是被中断的函数调用，此时调用luaD_poscall函数继续完成未完的函数操作；否则只需要调整 base指针指向之前的ci的base指针即可 。</li>\n<li>以上的几种情况最终都会调用 luaV_execute 函数来进入 Lua虚拟机中执行 。 这里可以看到，由于使用了同样的结构lua State来表示Lua虚拟机和Lua协程，在表达Lua虚拟机的执行和协程的执行上，两者都是统一使用 luaV execute函数，方便了实现。</li>\n</ul>\n<p>yield操作在函数lua_yield 中进行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API <span class=\"keyword\">int</span> <span class=\"title\">lua_yield</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> nresults)</span> </span>&#123;</span><br><span class=\"line\">  luai_userstateyield(L, nresults);</span><br><span class=\"line\">  lua_lock(L);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;nCcalls &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    luaG_runerror(L, <span class=\"string\">&quot;attempt to yield across metamethod/C-call boundary&quot;</span>);</span><br><span class=\"line\">  L-&gt;base = L-&gt;top - nresults;  <span class=\"comment\">/* protect stack slots below */</span></span><br><span class=\"line\">  L-&gt;status = LUA_YIELD;</span><br><span class=\"line\">  lua_unlock(L);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数做的事情相比起来就简单多了，就是将协程执行状态至为YIELD ，这样可以终止luaV_execute函数的循环。<br><img src=\"https://user-images.githubusercontent.com/11263320/113825795-fdec6400-97b3-11eb-8f8f-40a19ca2088f.JPG\" alt=\"捕获\"></p>\n","tags":["lua"]},{"title":"lua字符串","url":"/2021/03/22/lua%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<p>c语言没有自带字符串类型，这导致有非常多的用c写的软件都自己实现一个处理字符串的类型。<br>一般来说，要表示一个字符串，核心就是以下两个数据：</p>\n<ul>\n<li>字符串长度 </li>\n<li>指向存放字符串内存数据的指针</li>\n</ul>\n<p>Lua 自己的字符串类型的实现也没有绕过这两个核心内容</p>\n<h2 id=\"内化的字符串\"><a href=\"#内化的字符串\" class=\"headerlink\" title=\"内化的字符串\"></a>内化的字符串</h2><ul>\n<li>在Lua虚拟机中存在一个全局的数据区，用来存放当前系统中的所有字符串 </li>\n<li>同一个字符串数据，在Lua虚拟机中只可能有一份副本，一个字符串一旦创建，将是不可变更的 </li>\n<li>变量存放的仅是字符串的引用，而不是其实际内容</li>\n</ul>\n<p>Lua在字符串实现上使用内化这种方案（hash）的优点在于，进行字符串数据的比较和查找操作时，性能会提升不少，因为这两个操作的核心都是字符串的比较。传统的字符串比较算法是根据字符串长度逐位来进行对比，这个时间复杂度与字符串长度线性相关；而内化之后，在已知字符串散列值的情况下，只需要一次整数的比较即可。这个实现还有另一大好处，那就是空间优化，多份<br>相同的字符串在整个系统中只存在一份副本。Lua是一个在设计之初就把性能、资源占用等放在重要位置的语言，这里再一次得到了体现。<br>当然，这个实现并不是完全没有缺陷的。以前面描述的创建字符串的过程来说，在创建一个新的字符串时，首先会检查系统中是否有相同的数据，只有不存在的情况下才创建，这与直接创建字符串相比，多了一次查找过程。 </p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** String headers for string table</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TString</span> &#123;</span></span><br><span class=\"line\">  L_Umaxalign dummy;  <span class=\"comment\">/* ensures maximum alignment for strings */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    CommonHeader;</span><br><span class=\"line\">    lu_byte reserved;<span class=\"comment\">//是否是Lua虚拟机中的保留字符串，1不会在GC阶段被回收</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">//字符串的散列值</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len;<span class=\"comment\">//字符串长度 </span></span><br><span class=\"line\">  &#125; tsv;</span><br><span class=\"line\">&#125; TString;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这是一个联合体，其目的是为了让TString数据类型按照 L_Umaxalign类型来对齐</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.</span></span><br><span class=\"line\"><span class=\"comment\">** CHANGE it if your system requires alignments larger than double. (For</span></span><br><span class=\"line\"><span class=\"comment\">** instance, if your system supports long doubles and they must be</span></span><br><span class=\"line\"><span class=\"comment\">** aligned in 16-byte boundaries, then you should add long double in the</span></span><br><span class=\"line\"><span class=\"comment\">** union.) Probably you do not need to change this.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUAI_USER_ALIGNMENT_T\tunion &#123; double u; void *s; long l; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>在C语言中， struct/union这样的复合数据类型是按照这个类型中最大对齐革·的数据来对齐的，所以这里就是按照double类型的对齐量来对齐的。 之所以要进行对齐操作，是为了在CPU读取数据时性能更高 。</p>\n<p>Lua会把系统中的所有字符串存在一个全局的地方，这个全局变量就是global_state的 strt成员</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_State</span> &#123;</span></span><br><span class=\"line\">  stringtable strt;  <span class=\"comment\">/* hash table for strings */</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; global_State;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stringtable</span> &#123;</span></span><br><span class=\"line\">  GCObject **hash;<span class=\"comment\">//这是一个散列数组，专门用于存放字符串</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; stringtable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">GCObject</span> &#123;</span></span><br><span class=\"line\">  GCheader gch;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TString</span> <span class=\"title\">ts</span>;</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当新创建一个字符串TString时，首先根据散列算法算出散列值，这就是strt数组的索引值。如果这里已经有元素，则使用链表串接起来。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">TString *<span class=\"title\">luaS_newlstr</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str, <span class=\"keyword\">size_t</span> l)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (l1=l; l1&gt;=step; l1-=step)  <span class=\"comment\">/* compute hash */</span></span><br><span class=\"line\">    h = h ^ ((h&lt;&lt;<span class=\"number\">5</span>)+(h&gt;&gt;<span class=\"number\">2</span>)+cast(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>, str[l1<span class=\"number\">-1</span>]));</span><br><span class=\"line\">  ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ts-&gt;tsv.len == l &amp;&amp; (<span class=\"built_in\">memcmp</span>(str, getstr(ts), l) == <span class=\"number\">0</span>)) &#123;<span class=\"comment\">//found</span></span><br><span class=\"line\">      <span class=\"comment\">/* string may be dead */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isdead(G(L), o)) changewhite(o);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newlstr(L, str, l, h);  <span class=\"comment\">/* not found */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TString *<span class=\"title\">newlstr</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str, <span class=\"keyword\">size_t</span> l,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ts = cast(TString *, luaM_malloc(L, (l+<span class=\"number\">1</span>)*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>)+<span class=\"keyword\">sizeof</span>(TString)));</span><br><span class=\"line\">  ts-&gt;tsv.len = l;</span><br><span class=\"line\">  ts-&gt;tsv.hash = h;</span><br><span class=\"line\">  ts-&gt;tsv.marked = luaC_white(G(L));</span><br><span class=\"line\">  ts-&gt;tsv.tt = LUA_TSTRING;</span><br><span class=\"line\">  ts-&gt;tsv.reserved = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(ts+<span class=\"number\">1</span>, str, l*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>));</span><br><span class=\"line\">  ((<span class=\"keyword\">char</span> *)(ts+<span class=\"number\">1</span>))[l] = <span class=\"string\">&#x27;\\0&#x27;</span>;  <span class=\"comment\">/* ending 0 */</span></span><br><span class=\"line\">  tb = &amp;G(L)-&gt;strt;</span><br><span class=\"line\">  h = lmod(h, tb-&gt;size);</span><br><span class=\"line\">  ts-&gt;tsv.next = tb-&gt;hash[h];  <span class=\"comment\">/* chain new entry */</span></span><br><span class=\"line\">  tb-&gt;hash[h] = obj2gco(ts);</span><br><span class=\"line\">  tb-&gt;nuse++;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/111952507-3afff780-8b20-11eb-8aa4-400918ef6e1d.JPG\" alt=\"捕获\"></p>\n<h2 id=\"resize\"><a href=\"#resize\" class=\"headerlink\" title=\"resize\"></a>resize</h2><p>当数据量非常大时，分配到每个桶上的数据也会非常多，这样一次查找也退化成了一次线性的查找过程。Lua中也考虑了这种情况，所以有一个重新散列（ rehash ）的过程，这就是当字符串数据非常多时，会重新分配桶的数量，降低每个桶上分配到的数据数量，这个过程在函数luaS_resize中。</p>\n<p>有两处关于luaS_resize函数的调用</p>\n<ul>\n<li>lgc.c的checkSizes函数：这里会进行检查，如果此时桶的数量太大，比如是实际存放的字符串数量的4倍，那么会将散列桶数组减少为原来的一半。</li>\n<li>lstring.c的newlstr函数：如果此时字符串的数量大于桶数组的数量，且桶数组的数量小于MAX_INT/2，那么就进行翻倍的扩容。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>《Lua设计与实现》</p>\n","tags":["lua"]},{"title":"lua数据类型","url":"/2021/03/20/lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"<h2 id=\"八种基本数据类型\"><a href=\"#八种基本数据类型\" class=\"headerlink\" title=\"八种基本数据类型\"></a>八种基本数据类型</h2><p>Lua的类型系统是相对稳定的。很长时间里，Lua只有6个基本类型：nil，number，string，table，function和userdata（实际上，直到Lua 3.0为止，之前的C函数和Lua函数有不同的内部类型，但是这个差异对于调用者是透明的）。唯一真正的改变来自于Lua 5.0，这个版本引入了两个新类型：thread和boolean。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** basic types</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TNONE\t(-1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TNIL\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TBOOLEAN\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TLIGHTUSERDATA\t2        <span class=\"comment\">//void *</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TNUMBER\t3                        <span class=\"comment\">//lua3后采用double精度表示数字整型</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TSTRING\t4                        <span class=\"comment\">//TString</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TTABLE\t5                        <span class=\"comment\">//Table</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TFUNCTION\t6                <span class=\"comment\">//CClosure、LClosure</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TUSERDATA\t7                <span class=\"comment\">//void *</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_TTHREAD\t8                        <span class=\"comment\">//协程</span></span></span><br></pre></td></tr></table></figure>\n<p>变量第一次赋值之前，值为nil。</p>\n<h2 id=\"第一类值\"><a href=\"#第一类值\" class=\"headerlink\" title=\"第一类值\"></a>第一类值</h2><p>lua中所有值都是第一类值，他们可以存在变量中（无论全局变量还是局部变量）或table中，可以作为函数参数，可以作为返回值。</p>\n<h2 id=\"Lua通用数据结构的实现\"><a href=\"#Lua通用数据结构的实现\" class=\"headerlink\" title=\"Lua通用数据结构的实现\"></a>Lua通用数据结构的实现</h2><h3 id=\"C语言中实现通用数据结构的一般做法\"><a href=\"#C语言中实现通用数据结构的一般做法\" class=\"headerlink\" title=\"C语言中实现通用数据结构的一般做法\"></a>C语言中实现通用数据结构的一般做法</h3><p>如果要使用一个通用的数据结构来表示不同的数据类型，一般的做法是</p>\n<ul>\n<li>需要一个字段来存储数据的类型</li>\n<li>需要存储不同的数据类型的数据 </li>\n</ul>\n<p>这里有这两种<a href=\"https://stackoverflow.com/questions/61200681/what-are-the-pros-and-cons-of-these-twoa-common-data-structure-to-represent-dif\">实现方法</a></p>\n<ol>\n<li>定义一个公共的数据结构作为基础类型，里面存储的都是表达这个数据的基础信息，其他具体的类型是从这里派生出来的 。 这就是一般的面向对象的思路。</li>\n<li> 使用联舍（ union ）来将所有数据包进来</li>\n</ol>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>上面两种做法各有利弊 。 在Lua代码中，一般采用两种做法相结合的方式<br>Lua需要进行GC操作的数据类型都会有一个CommonHeader宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>\n<p>任何需要进行垃圾回收处理的Lua数据类型，必然以 CommonHeader作为该结构体定义的最开始部分。如果熟悉C++类的实现原理，可以将CommoHeader这个成员理解为一个基类的所有成员，而其他需要回收处理的数据类型均从这个基类继承下来，所以它们的结构体定义的开始部分就是这个成员。</p>\n<p>还有一个名为GCheader的结构体，其中的成员只有Common Header</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Common header in struct form</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GCheader</span> &#123;</span></span><br><span class=\"line\">    CommonHeader;</span><br><span class=\"line\">&#125; GCheader;</span><br></pre></td></tr></table></figure>\n<p>于是，在Lua中就使用了GCObject联合体将所有需要进行垃圾回收的数据类型囊括了进来</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Union of all collectable objects</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">GCObject</span> &#123;</span></span><br><span class=\"line\">  GCheader gch;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">TString</span> <span class=\"title\">ts</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Udata</span> <span class=\"title\">u</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Closure</span> <span class=\"title\">cl</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Table</span> <span class=\"title\">h</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proto</span> <span class=\"title\">p</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">UpVal</span> <span class=\"title\">uv</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_State</span> <span class=\"title\">th</span>;</span>  <span class=\"comment\">/* thread */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>GCObject这个联合体，将所有需要进行垃圾回收的数据类型全部囊括其中，这样定位和查找不同类型的数据时就方便多了。</p>\n<p>还有几种数据类型是不需要进行垃圾回收的，Lua中将GCObject和它们一起放在了联合体Value中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Union of all Lua values</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">  GCObject *gc;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *p;<span class=\"comment\">//LUA_TLIGHTUSERDATA</span></span><br><span class=\"line\">  lua_Number n;<span class=\"comment\">//LUA_TNUMBER</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;<span class=\"comment\">//LUA_TBOOLEAN</span></span><br><span class=\"line\">&#125; Value;</span><br></pre></td></tr></table></figure>\n<p>到了这一步 ，差不多可以表示Lua中所有的数据类型了。但是还欠缺一点东西，那就是这些数据到底是什么类型的。于是Lua代码中又有了TValue，它用于将Value和类型结合在一起。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Tagged Values</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TValuefields\tValue value; int tt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_TValue</span> &#123;</span></span><br><span class=\"line\">  TValuefields;</span><br><span class=\"line\">&#125; TValue;</span><br></pre></td></tr></table></figure>\n<p>前面提到过， Lua同时采用了两种方式来做到数据统一。根据前面的分析，这表现在以下两个方面。</p>\n<ul>\n<li>具体类型中有CommonHeader 用来存放所有数据类型都通用的字段</li>\n<li>TValue作为统一表示所有数据的数据结构，内部使用了联合体Value将所有数据都包起来</li>\n</ul>\n<p>在具体的代码中，TValue用于统一地表示数据，而一旦知道了具体的类型，就需要使用具体的类型了。因此，代码中有不少涉及TValue与具体类型之间转换的代码，其主要逻辑都是将TValue中的tt、value与具体类型的数据进行转换。<br>如将 lua Number转换为TValue的宏 setnvalue：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> setnvalue(obj,x) \\</span></span><br><span class=\"line\">  &#123; TValue *i_o=(obj); i_o-&gt;value.n=(x); i_o-&gt;tt=LUA_TNUMBER; &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>《Lua设计与实现》</p>\n","tags":["lua"]},{"title":"lua指令相关","url":"/2021/03/24/lua%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3/","content":"<h2 id=\"指令的生成\"><a href=\"#指令的生成\" class=\"headerlink\" title=\"指令的生成\"></a>指令的生成</h2><p>指令的生成，不管生成的是哪一种格式的指令，其最终的入口函数都是luaK_code函数</p>\n<p>下面分析指令是如何生成的。<br>前面提到过，词法、语法阶段的分析中，最后结果就是输出一个Proto结构体，因此这个结构体才是关键。<br>首先，需要看分析阶段要用到的数据结构FuncState。 这个结构体用于在语法分析时保存解析函数之后相关的信息，根据其中的prev指针成员来串联起来。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* state needed to generate code for a given function */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FuncState</span> &#123;</span></span><br><span class=\"line\">  Proto *f;  <span class=\"comment\">/* current function header */</span></span><br><span class=\"line\">  Table *h;  <span class=\"comment\">/* table to find (and reuse) elements in `k&#x27; */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FuncState</span> *<span class=\"title\">prev</span>;</span>  <span class=\"comment\">/* enclosing function */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LexState</span> *<span class=\"title\">ls</span>;</span>  <span class=\"comment\">/* lexical state */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">lua_State</span> *<span class=\"title\">L</span>;</span>  <span class=\"comment\">/* copy of the Lua state */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BlockCnt</span> *<span class=\"title\">bl</span>;</span>  <span class=\"comment\">/* chain of current blocks */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> pc;  <span class=\"comment\">/* next position to code (equivalent to `ncode&#x27;) */</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; FuncState;</span><br></pre></td></tr></table></figure>\n<p>比如，下面的代码中：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 最外层 FuncState fs1</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span><span class=\"params\">()</span></span> <span class=\"comment\">--函数a的 FuncState fsa</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span><span class=\"params\">()</span></span> <span class=\"comment\">--函数b的 FuncState fsb</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>其实涉及3个FuncState指针， 一层一层嵌套包围，其中也fs1是fsa的父指针， fsa又是fsb的父指针<br><img src=\"https://user-images.githubusercontent.com/11263320/112278942-50128d00-8cbe-11eb-9451-5b321afab2e5.JPG\" alt=\"捕获\"></p>\n<p>而在FuncState结构体中，有一个成员Proto *f，它用来保存这个FuncState解析指令之后生成的指令，其中除了自己的，还包括内部嵌套的子函数。各个层次的Proto数据是逐层包含的，因此最外层的全局 FuncState结构体中的<br>Proto数组一定有这个全局结构中所有Proto 的信息，也就是解析完毕之后的指令信息。</p>\n<p>有了前面的分析，就很好理解luaY_parser这个函数了，它是分析阶段的唯一入口函数，这个函数的返回值就是Proto指针，而FuneState等数据结构仅是用于分析过程中的临时数据结构，它们最终都是为了解析代码生成指令到 Proto结构体服务的。</p>\n<h2 id=\"指令格式\"><a href=\"#指令格式\" class=\"headerlink\" title=\"指令格式\"></a>指令格式</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/112280977-86510c00-8cc0-11eb-8039-eb3ff697b84d.JPG\" alt=\"捕获\"><br>首先看到的是，Lua的指令是 32位的，这里由低位到高位进行解释 。 首先解析最低6位的OpCode，称为操作数，紧跟着就是A , B, C参数。<br>不同操作数的指令格式不同，含义也不同。由于操作数是6位的，所以Lua最多支持2^6-1=63个指令。Lua代码中，将每个操作数及其对应的指令格式都在Iopcodes.h中的opcode枚举类型中定义。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** grep &quot;ORDER OP&quot; if you change these enums</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\"><span class=\"comment\">/*----------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">name\t\targs\tdescription</span></span><br><span class=\"line\"><span class=\"comment\">------------------------------------------------------------------------*/</span></span><br><span class=\"line\">OP_MOVE,<span class=\"comment\">/*\tA B\tR(A) := R(B)\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADK,<span class=\"comment\">/*\tA Bx\tR(A) := Kst(Bx)\t\t\t\t\t*/</span></span><br><span class=\"line\">OP_LOADBOOL,<span class=\"comment\">/*\tA B C\tR(A) := (Bool)B; if (C) pc++\t\t\t*/</span></span><br><span class=\"line\">OP_LOADNIL,<span class=\"comment\">/*\tA B\tR(A) := ... := R(B) := nil\t\t\t*/</span></span><br><span class=\"line\">OP_GETUPVAL,<span class=\"comment\">/*\tA B\tR(A) := UpValue[B]\t\t\t\t*/</span></span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; OpCode;</span><br></pre></td></tr></table></figure>\n<p>在这些格式中，有不同的取值方式。有不同格式参数的含义。<br><img src=\"https://user-images.githubusercontent.com/11263320/112282047-b0ef9480-8cc1-11eb-8731-e7222d4bc6fc.JPG\" alt=\"捕获\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** size and position of opcode arguments.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE_C\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE_B\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE_Bx\t\t(SIZE_C + SIZE_B)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE_A\t\t8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE_OP\t\t6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POS_OP\t\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POS_A\t\t(POS_OP + SIZE_OP)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POS_C\t\t(POS_A + SIZE_A)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POS_B\t\t(POS_C + SIZE_C)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> POS_Bx\t\tPOS_C</span></span><br></pre></td></tr></table></figure>\n<p>有了这些，指令的参数获取、设置相关的宏就很好理解了，其核心就是根据前面格式中定义的大小对相关参数进行读、写操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GET_OPCODE(i)\t(cast(OpCode, ((i)&gt;&gt;POS_OP) &amp; MASK1(SIZE_OP,0)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SET_OPCODE(i,o)\t((i) = (((i)&amp;MASK0(SIZE_OP,POS_OP)) | \\</span></span><br><span class=\"line\">\t\t((cast(Instruction, o)&lt;&lt;POS_OP)&amp;MASK1(SIZE_OP,POS_OP))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GETARG_A(i)\t(cast(int, ((i)&gt;&gt;POS_A) &amp; MASK1(SIZE_A,0)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SETARG_A(i,u)\t((i) = (((i)&amp;MASK0(SIZE_A,POS_A)) | \\</span></span><br><span class=\"line\">\t\t((cast(Instruction, u)&lt;&lt;POS_A)&amp;MASK1(SIZE_A,POS_A))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GETARG_B(i)\t(cast(int, ((i)&gt;&gt;POS_B) &amp; MASK1(SIZE_B,0)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SETARG_B(i,b)\t((i) = (((i)&amp;MASK0(SIZE_B,POS_B)) | \\</span></span><br><span class=\"line\">\t\t((cast(Instruction, b)&lt;&lt;POS_B)&amp;MASK1(SIZE_B,POS_B))))</span><br></pre></td></tr></table></figure>\n<p>可是仅有注释里面写明的每个OpCode的格式还不够，因为这起不到程序上的约束和说明作用，于是使用数组来定义所有OpCode的一些说明信息</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> opmode(t,a,b,c,m) (((t)&lt;&lt;7) | ((a)&lt;&lt;6) | ((b)&lt;&lt;4) | ((c)&lt;&lt;2) | (m))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> lu_byte luaP_opmodes[NUM_OPCODES] = &#123;</span><br><span class=\"line\"><span class=\"comment\">/*       T  A    B       C     mode\t\t   opcode\t*/</span></span><br><span class=\"line\">  opmode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, OpArgR, OpArgN, iABC) \t\t<span class=\"comment\">/* OP_MOVE */</span></span><br><span class=\"line\"> ,opmode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, OpArgK, OpArgN, iABx)\t\t<span class=\"comment\">/* OP_LOADK */</span></span><br><span class=\"line\"> ,opmode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, OpArgU, OpArgU, iABC)\t\t<span class=\"comment\">/* OP_LOADBOOL */</span></span><br><span class=\"line\"> ,opmode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, OpArgR, OpArgN, iABC)\t\t<span class=\"comment\">/* OP_LOADNIL */</span></span><br><span class=\"line\"> ,opmode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, OpArgU, OpArgN, iABC)\t\t<span class=\"comment\">/* OP_GETUPVAL */</span></span><br></pre></td></tr></table></figure>\n<p>这里用一个宏opmode封装了每个OpCode的具体格式</p>\n<blockquote>\n<p>T： 表示这是不是一条逻辑测试相关的指令，这种指令可能会将pc指针自增1。<br>A： 表示这个指令会不会赋值给R(A)。<br>B/C:  B、E参数的格式。<br>mode：这个OpCode的格式。</p>\n</blockquote>\n<p>B、C参数的含义<br><img src=\"https://user-images.githubusercontent.com/11263320/112283272-efd21a00-8cc2-11eb-9e70-81d04f58279c.JPG\" alt=\"捕获\"><br>OpArgN表示这个参数没有使用，但是这里的意思并不是真的没有使用，只是没有作为R()或者以RK()宏的参数使用 。</p>\n<p>Lua共有3种指令格式： iABC、 iABx和iAsBx<br>Lua代码中提供了根据指令中的值得到相应数据的几个宏：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RA(i)\t(base+GETARG_A(i))</span></span><br><span class=\"line\"><span class=\"comment\">/* to be used after possible stack reallocation */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RKB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\</span></span><br><span class=\"line\">\tISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RKC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\</span></span><br><span class=\"line\">\tISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KBx(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))</span></span><br></pre></td></tr></table></figure>\n<p>RA、RB、RC不必多做解释，前面讲解Lua指令执行时已经说过，其含义就是以参数为偏移量在函数棋中取数据。<br>RKB, RKC的意思有两层，第一层是这个指令格式只可能作用在OpCode的B、C参数上，不会作用在参数A上；第二层意思是这个数据除了从函数枝中获取之外，还有可能从常量数组（也就是K数组）中获取，关键在于宏ISK的判断</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIZE B</span></span><br></pre></td></tr></table></figure>\n<p>结合起来看，这个宏的含义就很简单了：判断这个数据的第八位是不是1，如果是，则认为应该从K数组中获取数据，否则就是从函数战寄存器中获取数据。<br>宏KBx也是自解释的，它不会从函数战中取数据了，直接从K数组（即常量数组）中获取数据。<br>这可以看到，从寄存器中取指令也就是在前面以 R开头的宏中，实际代码中会使用一个base再加上对应的地址，如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RA(i)\t(base+GETARG_A(i))</span></span><br></pre></td></tr></table></figure>\n<p>取其他参数的宏，如RB和RC等，也和这里的宏RA一样，都是基于base来获取的。 不难相象，base值保存的是函数椅基址</p>\n<h2 id=\"指令的执行\"><a href=\"#指令的执行\" class=\"headerlink\" title=\"指令的执行\"></a>指令的执行</h2><p>指令执行的入口函数是luaV_execute<br>这里的问题在于，第一步“准备执行环境”具体都做了些什么。不妨回忆一下，前面提到过虚拟机主要扮演的是CPU和内存的角色，CPU用来执行指令， 内存负责数据的存取读写。因此，虚拟机在执行指令之前的准备工作也差不多： 将内部的pc指针指向待执行的代码位置，准备好栈指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaV_execute</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> nexeccalls)</span> </span>&#123;</span><br><span class=\"line\">  LClosure *cl;</span><br><span class=\"line\">  StkId base;</span><br><span class=\"line\">  TValue *k;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Instruction *pc;</span><br><span class=\"line\"> reentry:  <span class=\"comment\">/* entry point */</span></span><br><span class=\"line\">  lua_assert(isLua(L-&gt;ci));</span><br><span class=\"line\">  pc = L-&gt;savedpc;</span><br><span class=\"line\">  cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;</span><br><span class=\"line\">  base = L-&gt;base;</span><br><span class=\"line\">  k = cl-&gt;p-&gt;k;</span><br><span class=\"line\">  <span class=\"comment\">/* main loop of interpreter */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>从代码里可以看到，在循环执行指令之前，主要做了几个变量的赋值</p>\n<ul>\n<li>pc：用于保存当前指令的执行位置。</li>\n<li>cl：当前所在的函数环境（前面提到过，一个即使没有任何函数的Lua文件也对应一个函数环境）。</li>\n<li>base：当前函数环境的战base地址。</li>\n<li>k：当前函数环境的常量数组。<br>总结来说，上面这几个变量就是这两方面的内容：指令和栈。<br>先来看指令，pc从当前Lua虚拟机的savedpc得来，这在前面的luaD_precall中可以看到：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">L-&gt;savedpc = p-&gt;code;  <span class=\"comment\">/* starting point */</span></span><br></pre></td></tr></table></figure>\n可以看到，savedpc在调用之前首先赋值为Proto的code成员，而这个成员就是前面提到的解析完指令之后指令存储的位置。因此，每一次执行Lua虚拟机指令之前，pc都会指向当前函数环境的指令。</li>\n</ul>\n<p>栈地址的设置同样也在前面的luaD_precall函数中提到过了，它是函数械的基地址。 由此回到上一节最后提出来的疑问，下面这些宏中 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RA(i)\t(base+GETARG_A(i))</span></span><br><span class=\"line\"><span class=\"comment\">/* to be used after possible stack reallocation */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RKB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\</span></span><br><span class=\"line\">\tISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RKC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\</span></span><br><span class=\"line\">\tISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KBx(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))</span></span><br></pre></td></tr></table></figure>\n<p>其中 base参数就是当前函数环境的 base地址。 以 base地址为基础位置，以指令参数作为偏移量，拿到的数据肯定就是当前函数棋中的数据<br>所以，以 R开头的宏都是根据具体的参数（ A 、 B 、 C ）到当前函数战中获取数据的手段 </p>\n<p>到了这里，我们看到了虚拟机执行的全貌，下面简单小结一下 :</p>\n<ul>\n<li>分析阶段最后的结果就是 Proto结构体 。 在这个结构体中， code成员用于存储指令， f数组用于保存里面嵌套的函数的 Proto结构体。</li>\n<li>每个环境（再次强调，即使没有任何函数的代码也有对应的环境）都有自己对应的栈，base指向这个栈的基地址， top指向这个栈的栈顶地址 。 取函数校内的数据，都是以base基地址为基础地址的操作 。</li>\n<li>在虚拟机开始执行指令之前，需要把对应的指令和械地址切换到所要执行的函数的对应数据上</li>\n</ul>\n","tags":["lua"]},{"title":"lua考古","url":"/2021/03/02/lua%E8%80%83%E5%8F%A4/","content":"<h2 id=\"Lua版本的年表\"><a href=\"#Lua版本的年表\" class=\"headerlink\" title=\"Lua版本的年表\"></a>Lua版本的年表</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/111862027-7c13d280-898d-11eb-9cab-ab361a8372b6.png\" alt=\"timeline\"></p>\n<p>Lua的<a href=\"https://www.lua.org/versions.html\">发行版</a>编号为x.y.z，其中x.y是版本，而z是发行版。<br>同一版本的不同发行版对应于错误修复。同一版本的不同发行版具有相同的参考手册，相同的虚拟机.<br><a href=\"https://www.lua.org/doc/hopl.pdf\">不同的版本</a>实际上是不同的。API可能略有不同。虚拟机在新版本中也很有可能会有所不同。</p>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/111866533-1d5c5200-89a9-11eb-8a0b-66d34a0748b5.png\" alt=\"table1\"></p>\n<h2 id=\"Lua-1\"><a href=\"#Lua-1\" class=\"headerlink\" title=\"Lua 1\"></a>Lua 1</h2><p>1.1 这是Lua的第一个公开版本，已经具有强大的数据描述结构，简单的语法和字节码虚拟机。<br>Lua中的所有语句都在全局环境中执行。<br>这个版本已经具有垃圾回收功能（标记-清除垃圾回收算法）。</p>\n<h2 id=\"Lua-2\"><a href=\"#Lua-2\" class=\"headerlink\" title=\"Lua 2\"></a>Lua 2</h2><p>2.1 ：通过fallbacks扩展语义以及对面向对象编程的支持。<br>2.2 ：长字符串，调试接口，更好的堆栈回溯，扩展的函数定义语法，函数的垃圾回收以及对管道的支持。<br>2.4 ：实现外部编译器luac，带有钩子的扩展调试接口以及“ getglobal”后备功能。<br>2.5 ：实现模式匹配和vararg函数。</p>\n<h2 id=\"Lua-3\"><a href=\"#Lua-3\" class=\"headerlink\" title=\"Lua 3\"></a>Lua 3</h2><p>3.0 ：tag methods替代fallbacks，可以作为后备功能的有力替代。引入auxlib（一个用于帮助编写Lua库的库），并支持条件编译。<br>3.1 ：实现匿名函数和通过“ upvalues”关闭函数。支持多种全局环境。代码重组和清理，大大减少了module 之间的依赖性。采用double精度表示数字整型。<br>3.2 ：实现调试库和表的新功能。</p>\n<h2 id=\"Lua-4\"><a href=\"#Lua-4\" class=\"headerlink\" title=\"Lua 4\"></a>Lua 4</h2><p>4.0 ：实现多重状态，为那些需要多份Lua state的应用而设计的新API。设计了一个for循环，它有两种方式：一个数字式的循环以及一个表遍历的循环。对C API重新设计了，不再有任何内置函数，所有标准库都是基于C API实现，没有通过特别的后门去访问Lua内部结构。</p>\n<h2 id=\"Lua-5\"><a href=\"#Lua-5\" class=\"headerlink\" title=\"Lua 5\"></a>Lua 5</h2><p>5.0 ：实现协程，完善词法作用域（而不是upvalues）和元表（而不是tags and tag methods）。引入了布尔值，完善尾调用和弱表。对packages的更好支持，用于加载Lua块的新API，新的错误处理协议，更好的错误消息等等。vm改为基于寄存器。<br>5.1 ：实现新的module系统，实现增量垃圾回收系统，新的varargs机制，新的长字符串和注释语法，mod和length运算符，所有类型的元表，通过luaconf.h配置方案和一个完全可重入的解析器。<br>5.2 ：实现可调用的pcall和元方法，用于全局变量的词法方案，暂时表，位运算新库，轻量级C函数，紧急垃圾回收器，goto语句和表的终结器。<br>5.3 ：实现整数，按位运算符，基本的utf-8库以及对64位和32位平台的支持。<br>5.4 ：实现新的增量垃圾回收，const，将要关闭的变量。</p>\n","tags":["lua"]},{"title":"lua虚拟机","url":"/2021/03/20/lua%E8%99%9A%E6%8B%9F%E6%9C%BA/","content":"<h2 id=\"黑盒子\"><a href=\"#黑盒子\" class=\"headerlink\" title=\"黑盒子\"></a>黑盒子</h2><p>Lua的虚拟机核心部分，没有任何的系统调用，是一个纯粹的黑盒子，正确的使用Lua，不会对系统造成任何干扰。这其中最关键的一点是，Lua让用户自行定义内存管理器，在创建Lua虚拟机时传入，这保证了Lua的整个运行状态是用户可控的。</p>\n<h2 id=\"基于寄存器的虚拟机\"><a href=\"#基于寄存器的虚拟机\" class=\"headerlink\" title=\"基于寄存器的虚拟机\"></a>基于寄存器的虚拟机</h2><p>lua从5.0开始，就把虚拟机改为基于寄存器的。<br>基于栈的虚拟机执行操作，要事先pop出数据，再将数据push入栈，字节码条数较多，但指令中不需要关心操作数的地址，在执行操作之前已经将操作数准备在楼顶上了。与基于梭的虚拟机不同，在基于寄存器的指令中，操作数是放在“CPU的寄存器”中（因为并不是物理意义上的寄存器，所以这里打了双引号）。因此，同样的操作不再需要PUSH、POP指令，取而代之的是在字节码中带上其体操作数所在的寄存器地址。 需要指令较少，但缺点是此时程序需要关注操作数所在的位置。</p>\n<p>Lua使用的是基于寄存器的虚拟机实现方式，其中很大的原因是它的设计目标之一就是尽可能高效。</p>\n<h2 id=\"lua虚拟机工作流程\"><a href=\"#lua虚拟机工作流程\" class=\"headerlink\" title=\"lua虚拟机工作流程\"></a>lua虚拟机工作流程</h2><p>lua代码是通过翻译成Lua虚拟机能识别的字节码运行的，以此它主要分为两大部分。</p>\n<h3 id=\"翻译代码以及编译为字节码\"><a href=\"#翻译代码以及编译为字节码\" class=\"headerlink\" title=\"翻译代码以及编译为字节码\"></a>翻译代码以及编译为字节码</h3><p>这部分代码负责将lua代码进行词法分析（llex.c）、语法分析等（lparser.c），最终生成字节码（lcode.c）。lopcodes.x则定义了lua虚拟机相关的字节码指令的格式以及相关的API。</p>\n<h3 id=\"lua虚拟机相关\"><a href=\"#lua虚拟机相关\" class=\"headerlink\" title=\"lua虚拟机相关\"></a>lua虚拟机相关</h3><p>在第一步中，经过分析阶段后，生成了对应的字节码，第二步就是将这些字节码装载到虚拟机中执行。Lua虚拟机相关的代码在 lvm.c中，虚拟机执行的主函数是luaV_execute ，不难想象这个函数是一个大的循环，依次从字节码中取出指令并执行。Lua虚拟机对外看到的数据结构是lua_State这个结构体将一直贯穿整个分析以及执行阶段 。 除了虚拟机的执行之外，Lua的核心部分还包括了进行函数调用和返回处理的相关代码，主要处理函数调用前后环境的准备和还原，这部分代码在 ldo.c中，垃圾回收部分的代码在 lgc.c中。Lua是一门嵌入式的脚本语言，这意味着它的设计目标之一必须满足能够与宿主系统进行交互，这部分代码在lapi.c中。</p>\n<p>总结一下，实现一个脚本语言的解释器，其核心问题有如下几个</p>\n<ul>\n<li>设计一套字节码，分析源代码文件生成字节码</li>\n<li>在虚拟机中执行字节码</li>\n<li>如何在整个执行过程中保存整个执行环境</li>\n</ul>\n<p>执行Lua文件调用的是luaL_dofile函数，它实际上是个宏，内部首先调用luaL_loadfile函数，再调用lua_pcall函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaL_dofile(L, fn) \\</span></span><br><span class=\"line\">\t(luaL_loadfile(L, fn) || lua_pcall(L, <span class=\"number\">0</span>, LUA_MULTRET, <span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p>其中 lual_loadfile函数用于进行词法和语法分析，lua_pcall用于将第一步中分析的结果（也就是字节码）放到虚拟机中执行<br>lual_loadfile函数最终会调用于f_parser函数，这是对代码进行分析的人口函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">f_parser</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">void</span> *ud)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  Proto *tf;</span><br><span class=\"line\">  Closure *cl;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SParser</span> *<span class=\"title\">p</span> =</span> cast(struct SParser *, ud);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = luaZ_lookahead(p-&gt;z);</span><br><span class=\"line\">  luaC_checkGC(L);</span><br><span class=\"line\">  tf = ((c == LUA_SIGNATURE[<span class=\"number\">0</span>]) ? luaU_undump : luaY_parser)(L, p-&gt;z,</span><br><span class=\"line\">                                                             &amp;p-&gt;buff, p-&gt;name);</span><br><span class=\"line\">  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));</span><br><span class=\"line\">  cl-&gt;l.p = tf;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tf-&gt;nups; i++)  <span class=\"comment\">/* initialize eventual upvalues */</span></span><br><span class=\"line\">    cl-&gt;l.upvals[i] = luaF_newupval(L);</span><br><span class=\"line\">  setclvalue(L, L-&gt;top, cl);</span><br><span class=\"line\">  incr_top(L);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成词法分析之后，返回了Proto类型的指针tf，然后将其绑定在新创建的Closure指针上，初始化UpValue，最后压入战中。不难想象，词法分析之后产生的字节码等相关数据都在这个Proto类型的结构体中，而这个数据又作为Closure保存了下来，留待下一步使用。<br>接着看看lua_pcall函数是如何将产生的字节码放入虚拟机中执行的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUA_API <span class=\"keyword\">int</span> <span class=\"title\">lua_pcall</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> nargs, <span class=\"keyword\">int</span> nresults, <span class=\"keyword\">int</span> errfunc)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CallS</span> <span class=\"title\">c</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">  <span class=\"keyword\">ptrdiff_t</span> func;</span><br><span class=\"line\">  lua_lock(L);</span><br><span class=\"line\">  api_checknelems(L, nargs+<span class=\"number\">1</span>);</span><br><span class=\"line\">  checkresults(L, nargs, nresults);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (errfunc == <span class=\"number\">0</span>)</span><br><span class=\"line\">    func = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    StkId o = index2adr(L, errfunc);</span><br><span class=\"line\">    api_checkvalidindex(L, o);</span><br><span class=\"line\">    func = savestack(L, o);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  c.func = L-&gt;top - (nargs+<span class=\"number\">1</span>);  <span class=\"comment\">//获取需要调用的函数指针</span></span><br><span class=\"line\">  c.nresults = nresults;</span><br><span class=\"line\">  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);</span><br><span class=\"line\">  adjustresults(L, nresults);</span><br><span class=\"line\">  lua_unlock(L);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的nargs是由函数参数传入的，在luaL_dofile中调用lua_pcall日才，这里传入的参数是0，换句话说，这里得到的函数对象指针就是前面f_parser函数中最后两句代码放入Lua梢的Closure指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">setclvalue(L, L-&gt;top, cl);</span><br><span class=\"line\">incr_top(L);</span><br></pre></td></tr></table></figure>\n<p>继续往下执行，在调用函数luaD_pcall时， 最终会执行到luaD_call函数，这其中有这么一段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (luaD_precall(L, func, nResults) == PCRLUA)  <span class=\"comment\">/* is a Lua function? */</span></span><br><span class=\"line\">    luaV_execute(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* call it */</span></span><br></pre></td></tr></table></figure>\n<p>首先，调用luaD_precall函数进行执行前的准备工作：</p>\n<ul>\n<li>从lua_State的CallInfo数组中得到一个新的CallInfo结构体，设置它的func、 base 、 top指针 。</li>\n<li>从前面分析阶段生成的 Closure指针中，取出保存下来的Proto结构体 。 前面提到过，这个结构体中保存的是分析过程完结之后生成的字节码等信息 。</li>\n<li>将这里创建的CallInfo指针的top/base指针赋值给lua_State结构体的top 、 base指针。 将Proto结构体的code成员赋值给 lua_State指针的 savedpc字段， code成员保留的就是字节码。</li>\n<li>把多余的函数参数赋值为nil；比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为nil。</li>\n</ul>\n<p>调用完luaD_precall函数之后，接着会进入luaV_execute函数，这里是虚拟机执行代码的主函数：<br>这里的pc指针存放的是虚拟机OpCode代码，它最开始从L-&gt;savepc初始化而来，而L-&gt;savepc在luaD_precall中赋值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">L-&gt;savedpc = p-&gt;code;  <span class=\"comment\">/* starting point */</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，luaV_execute函数最主要的作用就是一个大循环，将当前传人的指令依次执行。<br>最后，执行完毕后，还会调用luaD_poscall函数恢复到上一次函数调用的环境：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">luaD_poscall</span> <span class=\"params\">(lua_State *L, StkId firstResult)</span> </span>&#123;</span><br><span class=\"line\">  StkId res;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> wanted, i;</span><br><span class=\"line\">  CallInfo *ci;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;hookmask &amp; LUA_MASKRET)</span><br><span class=\"line\">    firstResult = callrethooks(L, firstResult);</span><br><span class=\"line\">  ci = L-&gt;ci--;</span><br><span class=\"line\">  res = ci-&gt;func;  <span class=\"comment\">/* res == final position of 1st result */</span></span><br><span class=\"line\">  wanted = ci-&gt;nresults;</span><br><span class=\"line\">  L-&gt;base = (ci - <span class=\"number\">1</span>)-&gt;base;  <span class=\"comment\">/* restore base */</span></span><br><span class=\"line\">  L-&gt;savedpc = (ci - <span class=\"number\">1</span>)-&gt;savedpc;  <span class=\"comment\">/* restore savedpc */</span></span><br><span class=\"line\">  <span class=\"comment\">/* move results to correct place */</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = wanted; i != <span class=\"number\">0</span> &amp;&amp; firstResult &lt; L-&gt;top; i--)</span><br><span class=\"line\">    setobjs2s(L, res++, firstResult++);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    setnilvalue(res++);</span><br><span class=\"line\">  L-&gt;top = res;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (wanted - LUA_MULTRET);  <span class=\"comment\">/* 0 iff wanted == LUA_MULTRET */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结下，大致的流程如下<br>(1 ）在f_parser函数中，对代码文件的分析返回了Proto指针。 这个指针会保存在 Closure指针中，留待后续继续使用。<br>(2）在luaD_precall 函数中，将lua_state 的saved pc指针指向第1步中Proto结构体的code指针，同时准备好函数调用时的战信息。<br>(3）在luaV_execute函数中，pc指针指向第2步中的saved pc指针，紧眼着就是一个大的循环体，依次取出其中的OpCode执行。<br>执行完毕后，调用 luaD_poscall函数恢复到上一个函数的环境。<br>因此， Lua虚拟机指令执行的两大人口函数如下：</p>\n<ul>\n<li>词法、语法分析阶段的luaY_parser。为了提高效率，Lua一次遍历脚本文件不仅完成了词法分析，还完成了语法分析，生成的OpCode存放在Proto结构体的code数组中。</li>\n<li>luaV_execute。它是虚拟机执行指令阶段的人口函数，取出第一步生成的Proto结构体中的指令执行。</li>\n</ul>\n<p>Proto是分析阶段的产物，执行阶段将使用分析阶段生成的Proto来执行虚拟机指令，在分析阶段会有许多数据结构参与其中，可它们都是临时用于分析阶段的，或者说最终是用来辅助生成Proto结构体的。<br>可以看到，Proto结构体是分析阶段和执行阶段的纽带。<br>只要抓住了Proto结构体这一个数据的流向，就能对从分析到执行的整个流程有大体的了解了<br>luaY_parser-&gt;Proto-&gt;luaV_execute</p>\n<p>到了这里，可以大致看看 Proto结构体中都有哪些数据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Function Prototypes</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proto</span> &#123;</span></span><br><span class=\"line\">  CommonHeader;</span><br><span class=\"line\">  TValue *k;  <span class=\"comment\">//函数的常盐数组</span></span><br><span class=\"line\">  Instruction *code;<span class=\"comment\">//编译生成的字节码信息，也就是前面提到的 code成员</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proto</span> **<span class=\"title\">p</span>;</span>  <span class=\"comment\">/* functions defined inside the function */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> *lineinfo;  <span class=\"comment\">/* map from opcodes to source lines */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LocVar</span> *<span class=\"title\">locvars</span>;</span>  <span class=\"comment\">/* information about local variables */</span></span><br><span class=\"line\">  TString **upvalues;  <span class=\"comment\">/* upvalue names */</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; Proto;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数的常量数组</li>\n<li>编译生成的字节码信息，也就是前面提到的code成员</li>\n<li>函数的局部变量信息</li>\n<li>保存upvalue的数组 </li>\n</ul>\n<h2 id=\"Lua虚拟机相关的数据结构与栈\"><a href=\"#Lua虚拟机相关的数据结构与栈\" class=\"headerlink\" title=\"Lua虚拟机相关的数据结构与栈\"></a>Lua虚拟机相关的数据结构与栈</h2><p>请看<a href=\"https://github.com/losophy/losophy.github.io/issues/60\">lua_state</a>里的Lua虚拟机相关的数据结构与栈</p>\n<h2 id=\"指令相关\"><a href=\"#指令相关\" class=\"headerlink\" title=\"指令相关\"></a>指令相关</h2><p><a href=\"https://github.com/losophy/losophy.github.io/issues/116\">lua指令相关</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>《Lua设计与实现》</p>\n","tags":["lua"]},{"title":"make","url":"/2021/02/28/make/","content":"<p><img src=\"https://user-images.githubusercontent.com/11263320/109392605-069d7f00-7958-11eb-9e01-51d10239f93a.jpg\" alt=\"makefile知识点\"><br><img src=\"https://user-images.githubusercontent.com/11263320/109392606-07361580-7958-11eb-9c6b-04b1574b57d4.jpg\" alt=\"makefile进阶\"></p>\n<h2 id=\"使用autotools来进行Makefile的自动生成\"><a href=\"#使用autotools来进行Makefile的自动生成\" class=\"headerlink\" title=\"使用autotools来进行Makefile的自动生成\"></a>使用autotools来进行Makefile的自动生成</h2><ul>\n<li>运行 autoscan , 自动创建两个文件： autoscan.log configure.scan<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# autoscan</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">autoscan.log configure.scan main.c</span><br></pre></td></tr></table></figure></li>\n<li>修改configure.scan的文件名为configure.in<br>修改configure.in:<br>  1.修改AC_INIT里面的参数: AC_INIT(main,1.0, <a href=\"mailto:&#x70;&#103;&#x70;&#x78;&#99;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#109;\">&#x70;&#103;&#x70;&#x78;&#99;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#109;</a>)<br>  2.添加宏AM_INIT_AUTOMAKE, 它是automake所必备的宏，也同前面一样，PACKAGE是所要产生软件套件的名称，VERSION是版本编号。<br>  3.在AC_OUTPUT后添加输出文件Makefile</li>\n</ul>\n<p>修改后的结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#                                               -*- Autoconf -*-</span><br><span class=\"line\"># Process this file with autoconf to produce a configure script.</span><br><span class=\"line\"></span><br><span class=\"line\">AC_PREREQ(2.61)</span><br><span class=\"line\">AC_INIT(main, 1.0, pgpxc@163.com)</span><br><span class=\"line\">AC_CONFIG_SRCDIR([main.c])</span><br><span class=\"line\">AC_CONFIG_HEADER([config.h])</span><br><span class=\"line\">AM_INIT_AUTOMAKE(main,1.0)</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for programs.</span><br><span class=\"line\">AC_PROG_CC</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for libraries.</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for header files.</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for typedefs, structures, and compiler characteristics.</span><br><span class=\"line\"></span><br><span class=\"line\"># Checks for library functions.</span><br><span class=\"line\"></span><br><span class=\"line\">AC_OUTPUT([Makefile])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行 aclocal, 生成一个“aclocal.m4”文件和一个缓冲文件夹autom4te.cache，该文件主要处理本地的宏定义。<br>此时的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# aclocal</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4 autom4te.cache autoscan.log configure.in configure.in~ main.c</span><br></pre></td></tr></table></figure></li>\n<li>运行 autoconf, 目的是生成 configure<br>此时的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# autoconf</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4      autoscan.log configure.in   main.c</span><br><span class=\"line\">autom4te.cache configure     configure.in~</span><br></pre></td></tr></table></figure></li>\n<li>运行 autoheader，它负责生成config.h.in文件。该工具通常会从“acconfig.h”文件中复制用户附加的符号定义，因此此处没有附加符号定义，所以不需要创建“acconfig.h”文件。<br>此时的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# autoheader</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4      autoscan.log configure     configure.in~</span><br><span class=\"line\">autom4te.cache config.h.in   configure.in main.c</span><br></pre></td></tr></table></figure></li>\n<li>下面即将运行 automake, 但在此之前应该做一下准备工作!<br>首先，创建一个 Makefile.am.这一步是创建Makefile很重要的一步，automake要用的脚本配置文件是Makefile.am，用户需要自己创建相应的文件。之后，automake工具转换成Makefile.in。<br>这个Makefile.am的内容如下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">AUTOMAKE_OPTIONS&#x3D;foreign</span><br><span class=\"line\">bin_PROGRAMS&#x3D;main</span><br><span class=\"line\">main_SOURCES&#x3D;main.c</span><br></pre></td></tr></table></figure>\n其次，使用automake对其生成“configure.in”文件，在这里使用选项“—adding-missing”可以让automake自动添加有一些必需的脚本文件。<br>运行后的状态是：<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost main]# automake --add-missing</span><br><span class=\"line\">configure.in:8: installing `./missing&#x27;</span><br><span class=\"line\">configure.in:8: installing `./install-sh&#x27;</span><br><span class=\"line\">Makefile.am: installing `./depcomp&#x27;</span><br><span class=\"line\">[root@localhost main]# ls</span><br><span class=\"line\">aclocal.m4      config.h.in   configure.in~ main.c        Makefile.in</span><br><span class=\"line\">autom4te.cache configure     depcomp        Makefile.am missing</span><br><span class=\"line\">autoscan.log    configure.in install-sh     Makefile.am~</span><br></pre></td></tr></table></figure></li>\n<li>到这里，就是我们熟悉的环节了。<br>运行configure，在这一步中，通过运行自动配置设置文件configure，把Makefile.in变成了最终的Makefile。<br>运行make，根据Makefile操作。<br>运行make install，安装到指定目录。</li>\n</ul>\n"},{"title":"lua面向对象","url":"/2021/02/23/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"<p>lua中的table就是一种对象。<br>lua中可以通过修改<a href=\"https://github.com/losophy/losophy.github.io/issues/107\">元表元方法</a>来实现面向对象。</p>\n<h2 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h2><p>table中的self相当于this。<br>首先，table与对象一样可以拥有状态。<br>其次，table也与对象一样拥有一个独立于其值的标识（一个self）。<br>最后，table与对象一样具有独立于创建者和创建地的生命周期。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account:withdraw</span><span class=\"params\">(v)</span></span></span><br><span class=\"line\">    <span class=\"built_in\">self</span>.balance = <span class=\"built_in\">self</span>.balance - v</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>lua只需使用冒号，则能隐藏self参数。</p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>一个类就像是一个创建对象的模具。我们可以利用__index元方法构造继承。<br>当访问一个table中不存在的字段时，得到的结果为nil。这是对的，但并非完全正确。实际上，这些访问会促使解释器去查找一个叫__index的元方法。如果没有这个元方法，那么访问结果如前述的为nil。否则，就由这个元方法来提供最终结果。<br>在lua中，将__index元方法用于继承很普遍，__index还可以是一个table。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setmetatable</span>(a,&#123;<span class=\"comment\">--index=b&#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account:new</span><span class=\"params\">(o)</span></span></span><br><span class=\"line\">    o = o <span class=\"keyword\">or</span> &#123;&#125; <span class=\"comment\">--如果用户没有提供table，则创建一个</span></span><br><span class=\"line\">    <span class=\"built_in\">setmetatable</span>(o,<span class=\"built_in\">self</span>)</span><br><span class=\"line\">    <span class=\"built_in\">self</span>.<span class=\"built_in\">__index</span> = <span class=\"built_in\">self</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> o</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>之前写过一篇关于lua实现面向对象的文章，借助元表和元方法实现，感觉也是有点乱。<br>我们可以参考cocos2d-x自己给出的类的实现，也即在luaBinding目录下extern.lua的文件中给出的实现：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class</span><span class=\"params\">(classname, super)</span></span></span><br><span class=\"line\">    <span class=\"comment\">--superType获取父类类型，可以使nil、function以及table.</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> superType = <span class=\"built_in\">type</span>(super)</span><br><span class=\"line\">    <span class=\"keyword\">local</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">--如果父类既不是函数也不是table则说明父类为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> superType ~= <span class=\"string\">&quot;function&quot;</span> <span class=\"keyword\">and</span> superType ~= <span class=\"string\">&quot;table&quot;</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        superType = <span class=\"literal\">nil</span></span><br><span class=\"line\">        super = <span class=\"literal\">nil</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">--如果父类的类型是函数或者是C对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> superType == <span class=\"string\">&quot;function&quot;</span> <span class=\"keyword\">or</span> (super <span class=\"keyword\">and</span> super.__ctype == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\">-- inherited from native C++ Object</span></span><br><span class=\"line\">        cls = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">--如果父类是表则复制成员并且设置这个类的继承信息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> superType == <span class=\"string\">&quot;table&quot;</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"comment\">-- 从父类copy 字段</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span> (<span class=\"string\">&quot;superTyper is table&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(super) <span class=\"keyword\">do</span> cls[k] = v <span class=\"keyword\">end</span></span><br><span class=\"line\">            cls.__create = super.__create</span><br><span class=\"line\">            cls.super    = super</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">--如果是函数类型则设置构造方法并且设置ctor函数</span></span><br><span class=\"line\">            cls.__create = super</span><br><span class=\"line\">            cls.ctor = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">--设置类型的名称</span></span><br><span class=\"line\">        cls.__cname = classname</span><br><span class=\"line\">        cls.__ctype = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">--定义该类型的创建实例的函数为基类的构造函数后复制到子类实例</span></span><br><span class=\"line\">        <span class=\"comment\">--并且调用子数的ctor方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cls.new</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\">            <span class=\"keyword\">local</span> instance = cls.__create(...)</span><br><span class=\"line\">            <span class=\"comment\">-- copy fields from class to native object</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> k,v <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(cls) <span class=\"keyword\">do</span> instance[k] = v <span class=\"keyword\">end</span></span><br><span class=\"line\">            instance.class = cls</span><br><span class=\"line\">            instance:ctor(...)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">--如果是继承自普通的lua表,则设置一下原型，并且构造实例后也会调用ctor方法</span></span><br><span class=\"line\">        <span class=\"comment\">-- inherited from Lua Object</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> super <span class=\"keyword\">then</span></span><br><span class=\"line\">            cls = &#123;&#125;</span><br><span class=\"line\">            <span class=\"built_in\">setmetatable</span>(cls, &#123;<span class=\"built_in\">__index</span> = super&#125;)</span><br><span class=\"line\">            cls.super = super</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            cls = &#123;ctor = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cls.__cname = classname</span><br><span class=\"line\">        cls.__ctype = <span class=\"number\">2</span> <span class=\"comment\">-- lua</span></span><br><span class=\"line\">        cls.<span class=\"built_in\">__index</span> = cls</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cls.new</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\">            <span class=\"keyword\">local</span> instance = <span class=\"built_in\">setmetatable</span>(&#123;&#125;, cls)</span><br><span class=\"line\">            instance.class = cls</span><br><span class=\"line\">            instance:ctor(...)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>创建对象时，可以通过className.new这种方式来创建，如</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> MySpriteClass = class(<span class=\"string\">&quot;MySpriteClass&quot;</span>,cc.Sprite)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MySpriteClass:ctor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> MySpriteClass</span><br></pre></td></tr></table></figure>\n<p>mySpriteClass 实例创建</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> mySprite = MySpriteClass.new(xxx.png)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/108814689-36622500-75ee-11eb-88a6-31a5d5bec388.png\" alt=\"1425134-20190408154553314-1254158238\"><br>classname.new()生成的instance包含一个class属性。class指向了类原型，并具有super,ctor,__cname和__ctype  4个属性<br>继承C++的类，new方法使用__create函数来创建实例<br>继承lua类，new方法使用{ }来创建实例。<br>继承Lua的类，new方法使用{ }来创建实例。</p>\n","tags":["lua"]},{"title":"mongodb的一些脚本","url":"/2021/01/24/mongodb%E7%9A%84%E4%B8%80%E4%BA%9B%E8%84%9A%E6%9C%AC/","content":"<h2 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mongod --dbpath=/data/db     #serve rup</span><br><span class=\"line\">sudo mongo                        #client up</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><h3 id=\"select-from-player\"><a href=\"#select-from-player\" class=\"headerlink\" title=\"select * from player\"></a>select * from player</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).find(&#123;&#125;) </span><br></pre></td></tr></table></figure>\n<h3 id=\"select-checkIn-from-player\"><a href=\"#select-checkIn-from-player\" class=\"headerlink\" title=\"select checkIn from player\"></a>select checkIn from player</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).find(&#123;&quot;checkIn&quot;:&#123;&quot;$exists&quot;:true&#125;&#125;) </span><br></pre></td></tr></table></figure>\n<h3 id=\"select-boss-1001-night-from-player\"><a href=\"#select-boss-1001-night-from-player\" class=\"headerlink\" title=\"select boss.1001.night from player\"></a>select boss.1001.night from player</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).find(&#123;&quot;boss.1001.night&quot;:&#123;&quot;$exists&quot;:true&#125;&#125;) </span><br></pre></td></tr></table></figure>\n<h3 id=\"update-player-set-checkIn-“”\"><a href=\"#update-player-set-checkIn-“”\" class=\"headerlink\" title=\"update player set checkIn = “”\"></a>update player set checkIn = “”</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).update(&#123;&#125;,&#123;$unset:&#123;&quot;checkIn&quot;:&quot;&quot;&#125;&#125;,false,true) </span><br></pre></td></tr></table></figure>\n<h3 id=\"update-player-set-boss-1001-night-“”\"><a href=\"#update-player-set-boss-1001-night-“”\" class=\"headerlink\" title=\"update player set boss.1001.night = “”\"></a>update player set boss.1001.night = “”</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getCollection(&#39;Player&#39;).update(&#123;&#125;,&#123;$unset:&#123;&quot;boss.1001.night&quot;:&quot;&quot;&#125;&#125;,false,true)</span><br></pre></td></tr></table></figure>","tags":["mongodb"]},{"title":"mysql备份、复制","url":"/2021/02/22/mysql%E5%A4%87%E4%BB%BD%E3%80%81%E5%A4%8D%E5%88%B6/","content":"<h2 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h2><p>将指定数据库备份到某dump文件（转储文件）中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqldump -uroot -p123 test &gt; test.dump</span><br></pre></td></tr></table></figure>\n<p>从备份文件恢复数据库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p123 test &lt; test.dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><p>mysql支持两种复制方式：基于行的复制和基于语句的复制。基于语句的复制（也称为逻辑复制）。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。<br>这意味着，在同一时间点备库上的数据可能与主库存在不一致，并且无法保证主备之间的廷迟。一些大的语句可能导致备库产生几称、几分钟甚至几个小时的廷迟。<br>主库和备库使用不同的存储引擎（不推荐）</p>\n<p>基于行的复制不会受这个问题的影响。因为它记录的是数据的更改，而不是SQL语句。如果一条语句改变了一个myisam表和一个innodb表的某些行，然后主库上发生了一次死锁，innodb表的更新会被回滚，而myisam表的更新仍会被记录到日志中并在备库重放。<br>当使用基于语句的复制方式时，如果通过不确定的方式更改数据可能会导致主备不一致。</p>\n<h3 id=\"根据备份的方法不同可以将备份分为\"><a href=\"#根据备份的方法不同可以将备份分为\" class=\"headerlink\" title=\"根据备份的方法不同可以将备份分为\"></a>根据备份的方法不同可以将备份分为</h3><p>热备、冷备、温备。<br>热备是指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响。<br>冷备非常简单，只需要备份mysql数据库的frm文件，共享表空间文件，独立表空间文件，重做日志文件，配置文件。</p>\n","tags":["mysql"]},{"title":"mysql架构","url":"/2021/02/22/mysql%E6%9E%B6%E6%9E%84/","content":"<p>MySQL是单进程多线程，而Oracle等是多进程。</p>\n<p>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 </p>\n<h2 id=\"mysql包括\"><a href=\"#mysql包括\" class=\"headerlink\" title=\"mysql包括\"></a>mysql包括</h2><ul>\n<li>DBMS数据库管理系统（实例）</li>\n<li>数据库（容器）<br>在mysql数据库中，实例与数据库的关系通常是一一对应的，但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。</li>\n</ul>\n<h2 id=\"mysql逻辑架构\"><a href=\"#mysql逻辑架构\" class=\"headerlink\" title=\"mysql逻辑架构\"></a>mysql逻辑架构</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108652560-6bdc1500-74ff-11eb-9f36-34d29dbcc2ef.jpg\" alt=\"1425134-20190311163049501-1910090477\"><br>上层是服务器层的服务和查询执行引擎，下层则是存储引擎。 </p>\n<p>除非需要用到某些InnodDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎。<br>除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题，以及一些潜在的bug和边界问题。存储引擎层和服务器层的交互已经比较复杂，更不用说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。</p>\n<p>因为MySQL是单进程多线程，所以每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>\n<h2 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108652613-86ae8980-74ff-11eb-97c2-3943134276da.jpg\" alt=\"1425134-20190315154442820-765166828\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><p>master：核心线程，主要负责将缓冲池中的数据异步刷新到磁盘。<br>IO：负责IO请求的回调处理。<br>purge：事务被提交台，其所使用的undolog可能不再需要，因此需要purge来回收已经使用并分配的undo页。<br>page cleaner：脏页的刷新操作。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>缓冲池：InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>\n<h2 id=\"InnoDB关键特性\"><a href=\"#InnoDB关键特性\" class=\"headerlink\" title=\"InnoDB关键特性\"></a>InnoDB关键特性</h2><p>插入缓冲<br>两次写<br>自适应哈希索引<br>异步IO<br>刷新邻接页</p>\n<p>关系型数据库系统和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束机制，该机制提供了一条强大而简易的途径来保证数据库中数据的完整性。</p>\n","tags":["mysql"]},{"title":"mysql数据结构","url":"/2021/02/22/mysql%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"<p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block）。</p>\n<p>InnoDB存储引擎的逻辑存储结构<br><img src=\"https://user-images.githubusercontent.com/11263320/108633531-a61dc600-74af-11eb-97f9-4f2ba133705e.jpg\" alt=\"1425134-20190316171629020-1958519047\"></p>\n<p>表空间<br>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>\n<p>段<br>因为InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶子节点（Leaf node segment），索引段即为B+树的非索引节点（Non-leaf node segment）。</p>\n<p>区<br>区是由连续页组成的空间。</p>\n<p>页<br>页是InnoDB磁盘管理的最小单位。</p>\n<p>行<br>InnoDB存储引擎是面向列的，也就说数据是按行进行存放的。</p>\n","tags":["mysql"]},{"title":"mysql：事务","url":"/2021/02/23/mysql%EF%BC%9A%E4%BA%8B%E5%8A%A1/","content":"<p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：<br>⑴ 原子性（Atomicity）<br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<p>⑵ 一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>\n<p>⑶ 隔离性（Isolation）<br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>\n<p>⑷ 持久性（Durability）<br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>\n<p>以上介绍完事务的四大特性(简称ACID)</p>\n<p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。<br>mysql服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中使用多种存储引擎是不可靠的。</p>\n<p>输入：MySQL的 ROLLBACK 命令用来回退（撤销）MySQL语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from ordertotals;</span><br><span class=\"line\">start transaction;</span><br><span class=\"line\">delete from ordertotals;</span><br><span class=\"line\">select * from ordertotals;</span><br><span class=\"line\">rollback;</span><br><span class=\"line\">select * from ordertotals;</span><br></pre></td></tr></table></figure>\n<p>养成书写start tran + commit/rollback的习惯，exec的时候不要离开现场<br>rollback 是回滚事务，只要没有commit提交，还可以恢复之前的数据。commit是提交事务，你不提交事务，你之前所有更改的数据别人在查看是看不到只能看到之前的数据，commit提交以后，别人才可看到你更新后的数据</p>\n","tags":["mysql"]},{"title":"mysql：备份、复制","url":"/2021/02/22/mysql%EF%BC%9A%E5%A4%87%E4%BB%BD%E3%80%81%E5%A4%8D%E5%88%B6/","content":"<h2 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h2><p>将指定数据库备份到某dump文件（转储文件）中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqldump -uroot -p123 test &gt; test.dump</span><br></pre></td></tr></table></figure>\n<p>从备份文件恢复数据库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -uroot -p123 test &lt; test.dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><p>mysql支持两种复制方式：基于行的复制和基于语句的复制。基于语句的复制（也称为逻辑复制）。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。<br>这意味着，在同一时间点备库上的数据可能与主库存在不一致，并且无法保证主备之间的廷迟。一些大的语句可能导致备库产生几称、几分钟甚至几个小时的廷迟。<br>主库和备库使用不同的存储引擎（不推荐）</p>\n<p>基于行的复制不会受这个问题的影响。因为它记录的是数据的更改，而不是SQL语句。如果一条语句改变了一个myisam表和一个innodb表的某些行，然后主库上发生了一次死锁，innodb表的更新会被回滚，而myisam表的更新仍会被记录到日志中并在备库重放。<br>当使用基于语句的复制方式时，如果通过不确定的方式更改数据可能会导致主备不一致。</p>\n<h3 id=\"根据备份的方法不同可以将备份分为\"><a href=\"#根据备份的方法不同可以将备份分为\" class=\"headerlink\" title=\"根据备份的方法不同可以将备份分为\"></a>根据备份的方法不同可以将备份分为</h3><p>热备、冷备、温备。<br>热备是指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响。<br>冷备非常简单，只需要备份mysql数据库的frm文件，共享表空间文件，独立表空间文件，重做日志文件，配置文件。</p>\n","tags":["mysql"]},{"title":"mysql：锁","url":"/2021/02/23/mysql%EF%BC%9A%E9%94%81/","content":"<p>锁机制用于管理对共享资源的并发访问。</p>\n<h2 id=\"行级锁\"><a href=\"#行级锁\" class=\"headerlink\" title=\"行级锁\"></a>行级锁</h2><p>行级锁只在存储引擎层实现，在服务器层没有实现。</p>\n<h2 id=\"mysql乐观锁、悲观锁\"><a href=\"#mysql乐观锁、悲观锁\" class=\"headerlink\" title=\"mysql乐观锁、悲观锁\"></a>mysql乐观锁、悲观锁</h2><p>latch门闩，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>\n<p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commt或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象</p>\n<h2 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h2><p>锁升级是指将当前锁的粒度降低。比如，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表负。如果在数据库的设计中认为锁是一种稀有资源，而且想避免锁的开销，那数据库中会频繁出现锁升级现象</p>\n","tags":["mysql"]},{"title":"mysql：数据结构","url":"/2021/02/22/mysql%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"<p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block）。</p>\n<p>InnoDB存储引擎的逻辑存储结构<br><img src=\"https://user-images.githubusercontent.com/11263320/108633531-a61dc600-74af-11eb-97f9-4f2ba133705e.jpg\" alt=\"1425134-20190316171629020-1958519047\"></p>\n<p>表空间<br>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>\n<p>段<br>因为InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶子节点（Leaf node segment），索引段即为B+树的非索引节点（Non-leaf node segment）。</p>\n<p>区<br>区是由连续页组成的空间。</p>\n<p>页<br>页是InnoDB磁盘管理的最小单位。</p>\n<p>行<br>InnoDB存储引擎是面向列的，也就说数据是按行进行存放的。</p>\n","tags":["mysql"]},{"title":"mysql：索引","url":"/2021/02/22/mysql%EF%BC%9A%E7%B4%A2%E5%BC%95/","content":"<p>聚集索引以及非聚集索引用的是B+树索引。</p>\n<h2 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h2><p>单单从定义来看是不是显得有点抽象，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址。</p>\n<h2 id=\"非聚集索引\"><a href=\"#非聚集索引\" class=\"headerlink\" title=\"非聚集索引\"></a>非聚集索引</h2><p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致</p>\n<h2 id=\"为什么要创建索引\"><a href=\"#为什么要创建索引\" class=\"headerlink\" title=\"为什么要创建索引\"></a>为什么要创建索引</h2><p>这是因为，创建索引可以大大提高系统的性能。<br>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>\n<h2 id=\"深入浅出理解索引结构\"><a href=\"#深入浅出理解索引结构\" class=\"headerlink\" title=\"深入浅出理解索引结构\"></a>深入浅出理解索引结构</h2><p>实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：</p>\n<p>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。</p>\n<p>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。</p>\n<p>通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p>\n<h2 id=\"何时使用聚集索引或非聚集索引\"><a href=\"#何时使用聚集索引或非聚集索引\" class=\"headerlink\" title=\"何时使用聚集索引或非聚集索引\"></a>何时使用聚集索引或非聚集索引</h2><p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p>\n<h2 id=\"结合实际，谈索引使用的误区\"><a href=\"#结合实际，谈索引使用的误区\" class=\"headerlink\" title=\"结合实际，谈索引使用的误区\"></a>结合实际，谈索引使用的误区</h2><p>理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。</p>\n<p>1、主键就是聚集索引<br>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。<br>通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。<br>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。<br>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。<br>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。<br>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。<br>在这里之所以提到“理论上”三字，是因为如果您的聚集索引还是盲目地建在ID这个主键上时，您的查询速度是没有这么高的，即使您在“日期”这个字段上建立的索引（非聚合索引）。</p>\n<h2 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h2><p>“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。<br>所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。<br>当然，在实践中，作为一个尽职的数据库管理员，您还要多测试一些方案，找出哪种方案效率最高、最为有效。</p>\n<p>有索引情况下，insert速度一定有影响，不过：</p>\n<ol>\n<li>你不大可能一该不停地进行insert, SQL Server能把你传来的命令缓存起来，依次执行，不会漏掉任何一个insert。</li>\n<li>你也可以建立一个相同结构但不做索引的表，insert数据先插入到这个表里，当这个表中行数达到一定行数再用insert table1 select * from table2这样的命令整批插入到有索引的那个表里。</li>\n</ol>\n<h2 id=\"InnoDB存储引擎支持以下几种常见的索引\"><a href=\"#InnoDB存储引擎支持以下几种常见的索引\" class=\"headerlink\" title=\"InnoDB存储引擎支持以下几种常见的索引\"></a>InnoDB存储引擎支持以下几种常见的索引</h2><h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>就是传统意义上的索引，B+树索引的构造类似于二叉树，根据键值快速找到数据。B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>\n<h3 id=\"全文索引\"><a href=\"#全文索引\" class=\"headerlink\" title=\"全文索引\"></a>全文索引</h3><p>通过数值比较、范围过滤就可以完成绝大多数我们需要的查询了。但是，如果你希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p>\n<h3 id=\"哈希索引\"><a href=\"#哈希索引\" class=\"headerlink\" title=\"哈希索引\"></a>哈希索引</h3><p>InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>\n<h2 id=\"mysql-键值类型\"><a href=\"#mysql-键值类型\" class=\"headerlink\" title=\"mysql 键值类型\"></a>mysql 键值类型</h2><p>普通索引 index (id name sex age loves)<br>唯一索引 unique<br>主键 primary key<br>外键 foreign key<br>全文索引 fulltext </p>\n","tags":["mysql"]},{"title":"mysql：架构","url":"/2021/02/22/mysql%EF%BC%9A%E6%9E%B6%E6%9E%84/","content":"<p>MySQL是单进程多线程，而Oracle等是多进程。</p>\n<p>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 </p>\n<h2 id=\"mysql包括\"><a href=\"#mysql包括\" class=\"headerlink\" title=\"mysql包括\"></a>mysql包括</h2><ul>\n<li>DBMS数据库管理系统（实例）</li>\n<li>数据库（容器）<br>在mysql数据库中，实例与数据库的关系通常是一一对应的，但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。</li>\n</ul>\n<h2 id=\"mysql逻辑架构\"><a href=\"#mysql逻辑架构\" class=\"headerlink\" title=\"mysql逻辑架构\"></a>mysql逻辑架构</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108652560-6bdc1500-74ff-11eb-9f36-34d29dbcc2ef.jpg\" alt=\"1425134-20190311163049501-1910090477\"><br>上层是服务器层的服务和查询执行引擎，下层则是存储引擎。 </p>\n<p>除非需要用到某些InnodDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎。<br>除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题，以及一些潜在的bug和边界问题。存储引擎层和服务器层的交互已经比较复杂，更不用说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。</p>\n<p>因为MySQL是单进程多线程，所以每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>\n<h2 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108652613-86ae8980-74ff-11eb-97c2-3943134276da.jpg\" alt=\"1425134-20190315154442820-765166828\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><p>master：核心线程，主要负责将缓冲池中的数据异步刷新到磁盘。<br>IO：负责IO请求的回调处理。<br>purge：事务被提交台，其所使用的undolog可能不再需要，因此需要purge来回收已经使用并分配的undo页。<br>page cleaner：脏页的刷新操作。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>缓冲池：InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>\n<h2 id=\"InnoDB关键特性\"><a href=\"#InnoDB关键特性\" class=\"headerlink\" title=\"InnoDB关键特性\"></a>InnoDB关键特性</h2><p>插入缓冲<br>两次写<br>自适应哈希索引<br>异步IO<br>刷新邻接页</p>\n<p>关系型数据库系统和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束机制，该机制提供了一条强大而简易的途径来保证数据库中数据的完整性。</p>\n","tags":["mysql"]},{"title":"python高级字符串格式化","url":"/2021/02/14/python%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/","content":"<p>字符串的format()函数,该方法收集位置参数和关键字参数的任意集合,并使用它们的值来替换字符串中的占位符;<br>形式为{n}(n为整数)的占位符将被format()方法第n个参数所代替;<br>形式为{name}的占位符将被参数中为name的参数所替代;<br>如果要用format()输出{xx},必须使用,否则会因为找不到对应的参数值而报错;<br>可以指定格式说明符,对输出进行更加精确地控制.<br>给每个占位符添加可选的格式说明符号,如{name:format_spec}.这种说明符可指定列宽,小数位和对齐方式.<br>一般格式[fill,align,sign,0,width,.precision,type],每一处都是可选的.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;&#123;a&#125;&#125;&quot;</span>.<span class=\"built_in\">format</span>()                   <span class=\"comment\">#&#123;a&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;a&#125;&quot;</span>.<span class=\"built_in\">format</span>()                     <span class=\"comment\">#error,里面没有为a的参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;a&#125; - &#123;b&#125;&quot;</span>.<span class=\"built_in\">format</span>(a = <span class=\"number\">100</span>,b = <span class=\"number\">200</span>)<span class=\"comment\">#100 - 200</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0&#125;,&#123;0&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"number\">22</span>)            <span class=\"comment\">#11,11</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0&#125;,&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>) <span class=\"comment\"># 11,11,22,33  中括号里面的数代表第几个参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:3d&#125;,&#123;1:4s&#125;,&#123;1:5s&#125;,&#123;2&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"string\">&quot;a&quot;</span>,<span class=\"number\">33</span>) <span class=\"comment\"># &#x27; 11,a   ,a    ,33&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:=&gt;+011.3f&#125;;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">12.12345</span>)  <span class=\"comment\">#====+12.123;用=来填充,右对齐,因为已经用=来填充了,0无效,宽度11,小数点精度后精度为3,类型为浮点数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:&gt;+011.3f&#125;;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">12.12345</span>)   <span class=\"comment\">#0000+12.123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)                <span class=\"comment\">#test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0!s:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)              <span class=\"comment\">#test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0!r:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)              <span class=\"comment\">#&#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#通过下标也行</span></span><br><span class=\"line\">a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;&#123;0[0]&#125;,&#123;0[1]&#125;&#x27;</span>.<span class=\"built_in\">format</span>(a)          <span class=\"comment\">#1,2</span></span><br></pre></td></tr></table></figure>","tags":["python"]},{"title":"redis使用lua脚本操作","url":"/2021/02/22/redis%E4%BD%BF%E7%94%A8lua%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"<p>redis支持lua脚本，通过在服务器中嵌入lua环境，redis客户端可以使用lua脚本，直接在服务器端原子地执行多个redis命令。</p>\n<h2 id=\"Redis服务器创建并修改Lua环境的整个过程由以下步骤组成\"><a href=\"#Redis服务器创建并修改Lua环境的整个过程由以下步骤组成\" class=\"headerlink\" title=\"Redis服务器创建并修改Lua环境的整个过程由以下步骤组成\"></a>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成</h2><p>①创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的<br>②载入多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作<br>③创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中 执行Redis命令的redis.call函数<br>④使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本 中引入副作用<br>⑤创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排 序，从而消除这些命令的不确定性<br>⑥创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息<br>⑦对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全 局变量添加到Lua环境中<br>⑧将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本</p>\n<p>EVAL、EVALSHA</p>\n","tags":["redis"]},{"title":"redis持久化","url":"/2021/02/22/redis%E6%8C%81%E4%B9%85%E5%8C%96/","content":"<p>Redis由于支持非常丰富的内存数据结构类型，如何把这些复杂的内存组织方式持久化到磁盘上是一个难题，所以Redis的持久化方式与传统数据库的方式有比较多的差别，Redis主要支持下面两种持久化方式，分别是：<br>定时快照方式(RDB)<br>基于语句追加文件的方式(AOF)</p>\n<p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p>\n<h2 id=\"定时快照方式-snapshot，RDB-快照\"><a href=\"#定时快照方式-snapshot，RDB-快照\" class=\"headerlink\" title=\"定时快照方式(snapshot，RDB 快照)\"></a>定时快照方式(snapshot，RDB 快照)</h2><p>该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则 通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进 程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。</p>\n<p>该持久化的主要缺点是定时快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。<br>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。<br>可以在.conf文件中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#   save &quot;&quot;</span><br><span class=\"line\">save 60 1000</span><br><span class=\"line\"></span><br><span class=\"line\"># The filename where to dump the DB</span><br><span class=\"line\">dbfilename &quot;dump.rdb&quot;</span><br></pre></td></tr></table></figure>\n<p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis&gt; SAVE</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; BGSAVE</span><br><span class=\"line\">Background saving started</span><br></pre></td></tr></table></figure>\n<h3 id=\"Redis恢复数据\"><a href=\"#Redis恢复数据\" class=\"headerlink\" title=\"Redis恢复数据\"></a>Redis恢复数据</h3><p>只要覆盖一下dump.rdb，再重启下redis就可以了。</p>\n<h2 id=\"基于语句追加方式-AOF\"><a href=\"#基于语句追加方式-AOF\" class=\"headerlink\" title=\"基于语句追加方式(AOF)\"></a>基于语句追加方式(AOF)</h2><p>aof方式实际类似mysql的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。</p>\n<p>aof的方式的主要缺点是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小 时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log,所以使用aof 的方式，Redis的读写性能也会有所下降。</p>\n<p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。 打开只需要写入conf文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n<h2 id=\"RDB-和-AOF，应该用哪一个\"><a href=\"#RDB-和-AOF，应该用哪一个\" class=\"headerlink\" title=\"RDB 和 AOF，应该用哪一个\"></a>RDB 和 AOF，应该用哪一个</h2><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>\n<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>\n<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>\n<h2 id=\"实验阶段\"><a href=\"#实验阶段\" class=\"headerlink\" title=\"实验阶段\"></a>实验阶段</h2><h3 id=\"虚拟内存方式\"><a href=\"#虚拟内存方式\" class=\"headerlink\" title=\"虚拟内存方式\"></a>虚拟内存方式</h3><p>虚拟内存方式是Redis来进行用户空间的数据换入换出的一个策略，此种方式在实现的效果上比较差，主要问题是代码复杂，重启慢，复制慢等等，目前已经被作者放弃。</p>\n<h3 id=\"diskstore方式：\"><a href=\"#diskstore方式：\" class=\"headerlink\" title=\"diskstore方式：\"></a>diskstore方式：</h3><p>diskstore方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的B-tree的方式，目前仍在实验阶段，后续是否可用我们可以拭目以待。</p>\n","tags":["redis"]},{"title":"redis在游戏开发中的应用","url":"/2021/02/22/redis%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"<p>Redis是一个新兴的NoSql数据缓存组件，与memcache类似，但是功能却比memcache多一些。<br>首先，Redis和memcache都是基于内存的，所以读取和写入速度都非常快。但是memcache只支持简单的key-value数据的存储方式，而Redis对key-value ,hash,list,set,SortSet等数据结构有很好的支持。</p>\n<p>下面就Redis在游戏的开发应用中做一些简单的介绍。</p>\n<h2 id=\"数据的缓存\"><a href=\"#数据的缓存\" class=\"headerlink\" title=\"数据的缓存\"></a>数据的缓存</h2><p>在这一点上，redis和memcache是一样的。都是把数据提前放入到内存中。当逻辑处理中需要用到数据时，先从内存中读取，相同的，写的时候也先向内存中写入，然后再操作数据库，以增加数据处理的速度。不同的是，redis带有把数据写入到硬盘的功能，具体的写入策略可以在redis的配置文件中配置。这样当主机突然出现故障时，比如断电，重启机器不会造成数据的丢失。这个在游戏的应用中特别重要。一般在游戏开发中，数据的处理会采用：缓存 + 持久化队列 + 数据库(mysql)的架构。执行的流程是先把数据写入到缓存，然后把需要持久化的数据放入到持久化队列中，启动一个守护线程，从持久化队列中不断的取出数据，并存入或更新到数据库。如果使用memcache这样没有写入到硬盘功能的缓存组件，出现故障时，持久人队列中如果还有没有处理完的数据，那么就会造成数据的丢失，引用玩家的数据出现短暂的回档。当然这些也可以自己开发一些功能去防止，但是增加了开发成本。</p>\n<h2 id=\"不丢失数据的持久化队列的实现\"><a href=\"#不丢失数据的持久化队列的实现\" class=\"headerlink\" title=\"不丢失数据的持久化队列的实现\"></a>不丢失数据的持久化队列的实现</h2><p>上面说过Redis具有把数据写入到硬盘的功能，而且支持多种数据结构。那么就可以利用Redis的list实现持久化队列，而且当机器出现故障时，不会出现队列中数据丢失的情况，重启之后，数据会自动加载到redis的list之中。<br>具体实现方法：<br>    （1）在Redis中构造一个list存储<br>    （2）一个线程使用Redis的lpush方法，向list的左边加入数据<br>    （3）另外一个线程使用Redis的rpop方法，从list取出数据进行处理，并且从list中删除了取出的数据。这样就实现了一个简单的生产者–消费者模式的队列。</p>\n<h2 id=\"对并发操作的控制（跨房间）\"><a href=\"#对并发操作的控制（跨房间）\" class=\"headerlink\" title=\"对并发操作的控制（跨房间）\"></a>对并发操作的控制（跨房间）</h2><p>一般来说，我们操作一个数据的流程是这样的，取出–处理—存储，这样在单线程中操作是没有任务问题的，但是在多线程环境中就不适用了，我们必须考虑数据同步的问题，保证数据操作的原子性。如果在游戏中，对玩家战队的属性进行更新，一般在数据库中都会保存一个TeamInfo表，里面有玩家相应的属性，比如名字，等级，金币，钻石等等。在memcache中保存一个TeamInfo对象，这时玩家获得金币，我们就需要取出玩家所有的属性，然后set金币，完成后再存储整个对象。这个时候就得考虑数据的同步了，如果在操作的时候，另外一个线程B修改了钻石，并完成了存储，而这个时候我把金币修改完成之后，再存储，这时，就出现了数据混乱的结果。考虑数据同步无非也是加锁或乐观同步。不但增加了代码量，还增加了维护的难度。而在Redis中，它支持对hash数据结构的操作。我们可以把玩家的对象按每个字段存储到redis的hash中。</p>\n<p>结构如下图：<br>当我需要更新金币时，比如增加或减少，我可以使用Redis自带的原子操作方法：hincrby(String key,String field,int value)进行操作，value是正为加，是负为减，这样就简化和避免了一些并发操作，而且这个操做还减少了对数据的操作步骤，因为没有取出，再操作的过程了，只有一次写入。而且在游戏中很少一次更新非常多的字段，如果有这样的情况，下面的方法可以解决</p>\n<h2 id=\"对事务的支持\"><a href=\"#对事务的支持\" class=\"headerlink\" title=\"对事务的支持\"></a>对事务的支持</h2><p>redis提供了一个事务操作的机制，MULTI 命令用于开启一个事务，它总是返回 OK 。<br>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。<br>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。<br>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; MULTI</span><br><span class=\"line\">OK</span><br><span class=\"line\">&gt; INCR foo</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">&gt; INCR bar</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">&gt; EXEC</span><br><span class=\"line\">1) (integer) 1</span><br><span class=\"line\">2) (integer) 1</span><br></pre></td></tr></table></figure>\n<p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC命令被调用时执行。从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p>\n<h2 id=\"提供外部的CAS行为，实现乐观锁机制\"><a href=\"#提供外部的CAS行为，实现乐观锁机制\" class=\"headerlink\" title=\"提供外部的CAS行为，实现乐观锁机制\"></a>提供外部的CAS行为，实现乐观锁机制</h2><p>在游戏开发中，有时候需要我们自己在外部实现乐观锁机制，WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为，被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。<br>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。<br>首先我们可能会这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">val &#x3D; GET mykey</span><br><span class=\"line\">val &#x3D; val + 1</span><br><span class=\"line\">SET mykey $val</span><br></pre></td></tr></table></figure>\n<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。<br>举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。<br>有了 WATCH ， 我们就可以轻松地解决这类问题了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">WATCH mykey</span><br><span class=\"line\">val &#x3D; GET mykey</span><br><span class=\"line\">val &#x3D; val + 1</span><br><span class=\"line\">MULTI</span><br><span class=\"line\">SET mykey $val</span><br><span class=\"line\">EXEC</span><br></pre></td></tr></table></figure>\n<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>\n<h2 id=\"缓存生命周期的控制\"><a href=\"#缓存生命周期的控制\" class=\"headerlink\" title=\"缓存生命周期的控制\"></a>缓存生命周期的控制</h2><p>在游戏服务器中，为了节省性能，我们没有必要把所有玩家的信息都缓存到内存中。比如有一些不常登陆的玩家，那么他的信息就没必要一直呆在缓存中了，需要清除。Redis为这个功能提供了一个方法：expire，它可以为key设置以秒为单位的生命周期，比如设置为300s，那么五分钟之后，这条记录就会在内存中删除。这样不仅可以节省内存，而且增加了服务器的性能</p>\n<h2 id=\"排行榜\"><a href=\"#排行榜\" class=\"headerlink\" title=\"排行榜\"></a>排行榜</h2><p>游戏服务器中涉及到很多排行信息，比如玩家等级排名、金钱排名、战斗力排名等。<br>一般情况下仅需要取排名的前N名就可以了，这时可以利用数据库的排序功能，或者自己维护一个元素数量有限的top集合。<br>但是有时候我们需要每一个玩家的排名，玩家的数量太多，不能利用数据库（全表排序压力太大），自己维护也会比较麻烦。<br>使用Redis可以很好的解决这个问题。它提供的有序Set，支持每个键值（比如玩家id）拥有一个分数（score），每次往这个set里添加元素，<br>Redis会对其进行排序，修改某一元素的score后，也会更新排序，在获取数据时，可以指定排序范围。<br>更重要的是，这个排序结果会被保存起来，不用在服务器启动时重新计算。<br>通过它，排行榜的实时刷新、全服排行都不再成为麻烦事。</p>\n<h2 id=\"邮件\"><a href=\"#邮件\" class=\"headerlink\" title=\"邮件\"></a>邮件</h2>","tags":["redis"]},{"title":"redis模式","url":"/2021/02/22/redis%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"单节点模式\"><a href=\"#单节点模式\" class=\"headerlink\" title=\"单节点模式\"></a>单节点模式</h2><p>执行命令：redis-server.exe redis6379.conf<br>该命令指定了配置文件，不指定的情况下默认读取的配置文件是redis.conf配置文件</p>\n<h2 id=\"主从模式（数据备份）\"><a href=\"#主从模式（数据备份）\" class=\"headerlink\" title=\"主从模式（数据备份）\"></a>主从模式（数据备份）</h2><ul>\n<li>主节点和从节点使用完全相同的服务器实现， 它们的功能（functionally）也完全一样， 但从节点通常仅用于替换失效的主节点。</li>\n<li>不过， 如果不需要保证“先写入，后读取”操作的一致性（read-after-write consistency）， 那么可以使用从节点来执行只读查询。</li>\n</ul>\n<p>配置一主二从模式，拷贝两份redis6379.conf，分别命名redis6380.conf、redis6381.conf<br>修改redis6380.conf配置文件的如下几个参数，参数前面不要出现空格：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1</span><br><span class=\"line\">port 6380</span><br><span class=\"line\">slaveof 127.0.0.1 6379  &#x2F;&#x2F; 设置该slave的master服务器为6379</span><br></pre></td></tr></table></figure>\n<p>同理修改redis6381.conf<br>分别启动master、slave1、slave2，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    redis-server.exe redis6379.conf</span><br><span class=\"line\">    redis-server.exe redis6380.conf</span><br><span class=\"line\">    redis-server.exe redis6381.conf</span><br><span class=\"line\">&#96;&#96;</span><br><span class=\"line\"> 所有节点启动后，可以在master界面看到挂载两个slave节点的日志信息</span><br><span class=\"line\"></span><br><span class=\"line\">## 哨兵模式</span><br><span class=\"line\">哨兵模式是主从模式的升级版，他会在后台有一个监控，监控当前的主机，巡逻主机下面的从机，如果某一时刻主机挂掉了，那么他会通过一种投票的机制从从机之中选举一台作为新的主机，并且，其余的从机将会连接到这个新的主机上面。</span><br><span class=\"line\"></span><br><span class=\"line\">配置一主二从三sentinel模式</span><br><span class=\"line\">redis的配置文件同主从模式下的文件配置</span><br><span class=\"line\">创建三份sentinel.conf文件，分别命名为sentinel26379.conf、sentinel26380.conf、sentinel26381.conf</span><br><span class=\"line\"></span><br><span class=\"line\">文件中的配置参数如下(另外两个配置文件同样配置)：</span><br></pre></td></tr></table></figure>\n<p>port 26379 // 当前Sentinel服务运行的端口<br>sentinel monitor mymaster 127.0.0.1 6379 2   // 去监视一个名为mymaster的主redis实例，这个主实例的IP地址为本机地址127.0.0.1，端口号为6379，而将这个主实例判断为失效至少需要2个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行<br>sentinel down-after-milliseconds mymaster 5000  // 指定了Sentinel认为Redis实例已经失效所需的毫秒数。当 实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。只有一个 Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行<br>sentinel parallel-syncs mymaster 1  // 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长<br>sentinel failover-timeout mymaster 15000 // 如果在该时间（ms）内未能完成failover操作，则认为该failover失败</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">分别启动redis服务器同主从模式下一样</span><br><span class=\"line\">分别启动sentinel服务器，命令如下：</span><br></pre></td></tr></table></figure>\n<pre><code>redis-server.exe sentinel26379.conf --sentinel  \nredis-server.exe sentinel26380.conf --sentinel  \nredis-server.exe sentinel26381.conf --sentinel</code></pre>\n<p>```</p>\n","tags":["redis"]},{"title":"redis——使用lua脚本操作","url":"/2021/02/22/redis%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8lua%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"<p>redis支持lua脚本，通过在服务器中嵌入lua环境，redis客户端可以使用lua脚本，直接在服务器端原子地执行多个redis命令。</p>\n<h2 id=\"Redis服务器创建并修改Lua环境的整个过程由以下步骤组成\"><a href=\"#Redis服务器创建并修改Lua环境的整个过程由以下步骤组成\" class=\"headerlink\" title=\"Redis服务器创建并修改Lua环境的整个过程由以下步骤组成\"></a>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成</h2><p>①创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的<br>②载入多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作<br>③创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中 执行Redis命令的redis.call函数<br>④使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本 中引入副作用<br>⑤创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排 序，从而消除这些命令的不确定性<br>⑥创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息<br>⑦对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全 局变量添加到Lua环境中<br>⑧将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本</p>\n<p>EVAL、EVALSHA</p>\n","tags":["redis"]},{"title":"redis数据结构与对象","url":"/2021/02/02/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>redis数据库每个键值对都是由对象组成<br>数据库键总是一个字符串对象；<br>而数据库键的值则可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>redis没有直接使用c语言传统字符串，而是自己构建了一种名为简单动态字符串（SDS）的抽象类型。主要是为了解决’\\0’的问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> len;         <span class=\"comment\">// buf 中已占用空间的长度 0</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;       <span class=\"comment\">// buf 中剩余可用空间的长度 5</span></span><br><span class=\"line\">　　<span class=\"keyword\">char</span> buf[];   <span class=\"comment\">// 数据空间，最后一个字节保存空字符 &#x27;r&#x27;&#x27;e&#x27;&#x27;d&#x27;&#x27;i&#x27;&#x27;s&#x27;&#x27;%0&#x27;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处（长度、结束都由len判断，分配预留free）</p>\n<ul>\n<li>可以常数复杂度获取字符串长度。</li>\n<li>杜绝缓冲区溢出</li>\n<li>减少修改字符串时带来的内存重分配次数</li>\n<li>二进制安全（二进制安全就是输入任何字节都能正确处理, 即使包含零值字节.）</li>\n<li>兼容部分c字符串函数</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表提供了高效和节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。</p>\n<p>链表在redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表为列表键的底层实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span>     <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span>     <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;                  <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);      <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);       <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);      <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *head;        <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *tail;          <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;         <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>redis的链表实现的特性：</p>\n<ul>\n<li>双端， 获取某个节点的前置节点和后置节点的复杂度都是O(1)</li>\n<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li>\n<li>带表头表尾指针，获取俩复杂度为O(1)</li>\n<li>带链表长度计数器，获取节点数量的复杂度为O(1)</li>\n<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>\n</ul>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>reds的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>\n<p>除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都比较长的字符串时，redis就会使用字典作为哈希键的底层实现。</p>\n<h3 id=\"哈希：\"><a href=\"#哈希：\" class=\"headerlink\" title=\"哈希：\"></a>哈希：</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;        <span class=\"comment\">// 键</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;                   <span class=\"comment\">// 值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span>     <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;        <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;      <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;     <span class=\"comment\">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;        <span class=\"comment\">// 该哈希表已有节点的数量</span></span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字典：\"><a href=\"#字典：\" class=\"headerlink\" title=\"字典：\"></a>字典：</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;         <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;         <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];             <span class=\"comment\">// 哈希表    </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx;    <span class=\"comment\">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators;     <span class=\"comment\">// 目前正在运行的安全迭代器的数量</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。<br>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。<br>rehashidx它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p>\n<h2 id=\"跳跃表-skiplist\"><a href=\"#跳跃表-skiplist\" class=\"headerlink\" title=\"跳跃表(skiplist)\"></a>跳跃表(skiplist)</h2><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p>\n<p>redis使用跳跃表作为有序集合键的底层实现之一。<br>和链表、字曲等数据结构被广泛地应用在redis内部不同，redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    robj *obj;     <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span>    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span>     </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span>         <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;                         <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">    &#125; level[];                                         <span class=\"comment\">// 层</span></span><br><span class=\"line\">&#125; zskiplistNode;                </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span>      <span class=\"comment\">// 表头节点和表尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;                        <span class=\"comment\">// 表中节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;                                         <span class=\"comment\">// 表中层数最大的节点的层数</span></span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/106717372-9a6e7a80-663a-11eb-9748-3beee690b9c7.JPG\" alt=\"捕1获\"></p>\n<h2 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;    <span class=\"comment\">// 编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;    <span class=\"comment\">// 集合包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];    <span class=\"comment\">// 保存元素的数组</span></span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<h2 id=\"压缩列表（为了节约内存）\"><a href=\"#压缩列表（为了节约内存）\" class=\"headerlink\" title=\"压缩列表（为了节约内存）\"></a>压缩列表（为了节约内存）</h2><p>压缩列表是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项，并且每个列表要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做列表键的底层实现。<br>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *<span class=\"title\">ziplistNew</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class=\"number\">1</span>; <span class=\"comment\">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小， 1 字节是表末端 ZIP_END 的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zmalloc(bytes);    <span class=\"comment\">// 为表头和表末端分配空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);    <span class=\"comment\">// 初始化表属性</span></span><br><span class=\"line\">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class=\"line\">    ZIPLIST_LENGTH(zl) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    zl[bytes<span class=\"number\">-1</span>] = ZIP_END;    <span class=\"comment\">// 设置表末端</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。<br>redis还在这对象系统中构建了一个引用计数技术实现的内存回收机制。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS;    <span class=\"comment\">// 对象最后一次被访问的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;    <span class=\"comment\">// 指向实际值的指针</span></span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《redis 设计与实现》</p>\n","tags":["redis"]},{"title":"redis源码：单机数据库的实现","url":"/2021/02/03/redis%E6%BA%90%E7%A0%81%EF%BC%9A%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>redis服务器将所有数据库都保存在服务器状态db数组中。<br>dbnum由conf文件database选项决定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *configfile;             <span class=\"comment\">// 配置文件的绝对路径</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hz;                       <span class=\"comment\">// serverCron() 每秒调用的次数</span></span><br><span class=\"line\">    redisDb *db;    <span class=\"comment\">// 数据库</span></span><br><span class=\"line\"></span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>分析rdb文件<br>od -c dump.rdb</p>\n<h2 id=\"redis事件驱动\"><a href=\"#redis事件驱动\" class=\"headerlink\" title=\"redis事件驱动\"></a>redis事件驱动</h2><p>redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：<br>文件事件：文件事件就是服务器对套接字操作的抽象。<br>时间事件：时间事件就是服务器对这类定时操作的抽象。</p>\n<p>redis基于reactor模式开发了自己的网络事件处理器。<br>与Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。</p>\n<h2 id=\"redis协议（aof文件写入也是这个格式）\"><a href=\"#redis协议（aof文件写入也是这个格式）\" class=\"headerlink\" title=\"redis协议（aof文件写入也是这个格式）\"></a>redis协议（aof文件写入也是这个格式）</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《redis 设计与实现》</p>\n","tags":["redis"]},{"title":"redis源码：多机数据库的实现","url":"/2021/02/04/redis%E6%BA%90%E7%A0%81%EF%BC%9A%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>2.8版本之前是主发送rdb文件给从实现复制的。效率较低。重连后同步，耗时。<br>新版本分完整同步和部分同步。完整同步和旧版一样，而部分同步则处理断线后重复制情况。</p>\n<p>分部同步由三部分组成：<br>offset偏移量<br>复制积压缓冲区<br>服务器运行id</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisServer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> runid[REDIS_RUN_ID_SIZE+<span class=\"number\">1</span>];  <span class=\"comment\">// 本服务器的 RUN ID</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> master_repl_offset;   <span class=\"comment\">// 全局复制偏移量（一个累计值）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ...  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Sentinel<br>Sentinel是特殊状态下的redis服务器，本质不用数据库。Sentinel有它自己的命令</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisCommand</span> <span class=\"title\">sentinelcmds</span>[] =</span> &#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;ping&quot;</span>,pingCommand,<span class=\"number\">1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;sentinel&quot;</span>,sentinelCommand,<span class=\"number\">-2</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;subscribe&quot;</span>,subscribeCommand,<span class=\"number\">-2</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;unsubscribe&quot;</span>,unsubscribeCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;psubscribe&quot;</span>,psubscribeCommand,<span class=\"number\">-2</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;punsubscribe&quot;</span>,punsubscribeCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;publish&quot;</span>,sentinelPublishCommand,<span class=\"number\">3</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;info&quot;</span>,sentinelInfoCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;shutdown&quot;</span>,shutdownCommand,<span class=\"number\">-1</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"number\">0</span>,<span class=\"literal\">NULL</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>sentinel中的master字典记录所以被监视的主服务器相关信息<br>字典的键是主服务器的信息<br>字典的值是主服务器对应的这个结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sentinelRedisInstance</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;      <span class=\"comment\">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;     </span><br><span class=\"line\">    <span class=\"keyword\">char</span> *runid;      <span class=\"comment\">// 实例的运行 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。</p>\n<ul>\n<li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。</li>\n<li>Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置的，会成为其局部领头Sentinel。</li>\n<li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。<h2 id=\"选出新的主服务器\"><a href=\"#选出新的主服务器\" class=\"headerlink\" title=\"选出新的主服务器\"></a>选出新的主服务器</h2>使用如下条件筛选备选node：<br>1、slave节点状态处于S_DOWN,O_DOWN,DISCONNECTED的除外<br>2、最近一次ping应答时间不超过5倍ping的间隔（假如ping的间隔为1秒，则最近一次应答延迟不应超过5秒，redis sentinel默认为1秒）<br>3、info_refresh应答不超过3倍info_refresh的间隔（原理同2,redis sentinel默认为10秒）<br>4、slave节点与master节点失去联系的时间不能超过（ (now - master-&gt;s_down_since_time) + (master-&gt;down_after_period * 10)）。总体意思是说，slave节点与master同步太不及时的（比如新启动的节点），不应该参与被选举。<br>5、Slave priority不等于0（这个是在配置文件中指定，默认配置为100）。</li>\n</ul>\n<p>从备选node中，按照如下顺序选择新的master<br>1、较低的slave_priority（这个是在配置文件中指定，默认配置为100）<br>2、较大的replication offset（每个slave在与master同步后offset自动增加）<br>3、较小的runid（每个redis实例，都会有一个runid,通常是一个40位的随机字符串,在redis启动时设置，重复概率非常小）<br>4、如果以上条件都不足以区别出唯一的节点，则会看哪个slave节点处理之前master发送的command多，就选谁。</p>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《redis 设计与实现》</p>\n","tags":["redis"]},{"title":"redis源码：数据结构与对象","url":"/2021/02/02/redis%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>redis数据库每个键值对都是由对象组成<br>数据库键总是一个字符串对象；<br>而数据库键的值则可以是字符串对象、列表对象、哈希对象、集合对象，有序集合对象。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>redis没有直接使用c语言传统字符串，而是自己构建了一种名为简单动态字符串（SDS）的抽象类型。主要是为了解决’\\0’的问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> len;         <span class=\"comment\">// buf 中已占用空间的长度 0</span></span><br><span class=\"line\">　　<span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;       <span class=\"comment\">// buf 中剩余可用空间的长度 5</span></span><br><span class=\"line\">　　<span class=\"keyword\">char</span> buf[];   <span class=\"comment\">// 数据空间，最后一个字节保存空字符 &#x27;r&#x27;&#x27;e&#x27;&#x27;d&#x27;&#x27;i&#x27;&#x27;s&#x27;&#x27;%0&#x27;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样做的好处（长度、结束都由len判断，分配预留free）</p>\n<ul>\n<li>可以常数复杂度获取字符串长度。</li>\n<li>杜绝缓冲区溢出</li>\n<li>减少修改字符串时带来的内存重分配次数</li>\n<li>二进制安全</li>\n<li>兼容部分c字符串函数</li>\n</ul>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>链表提供了高效和节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。</p>\n<p>链表在redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表为列表键的底层实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span>     <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span>     <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;                  <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);      <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);       <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);      <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    listNode *head;        <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *tail;          <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;         <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>redis的链表实现的特性：</p>\n<ul>\n<li>双端， 获取某个节点的前置节点和后置节点的复杂度都是O(1)</li>\n<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li>\n<li>带表头表尾指针，获取俩复杂度为O(1)</li>\n<li>带链表长度计数器，获取节点数量的复杂度为O(1)</li>\n<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>\n</ul>\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><p>reds的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>\n<p>除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都比较长的字符串时，redis就会使用字典作为哈希键的底层实现。</p>\n<h3 id=\"哈希：\"><a href=\"#哈希：\" class=\"headerlink\" title=\"哈希：\"></a>哈希：</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;        <span class=\"comment\">// 键</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;                   <span class=\"comment\">// 值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span>     <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    dictEntry **table;        <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;      <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;     <span class=\"comment\">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;        <span class=\"comment\">// 该哈希表已有节点的数量</span></span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字典：\"><a href=\"#字典：\" class=\"headerlink\" title=\"字典：\"></a>字典：</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type;         <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;         <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];             <span class=\"comment\">// 哈希表    </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx;    <span class=\"comment\">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators;     <span class=\"comment\">// 目前正在运行的安全迭代器的数量</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。<br>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。<br>rehashidx它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p>\n<h2 id=\"跳跃表-skiplist\"><a href=\"#跳跃表-skiplist\" class=\"headerlink\" title=\"跳跃表(skiplist)\"></a>跳跃表(skiplist)</h2><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p>\n<p>redis使用跳跃表作为有序集合键的底层实现之一。<br>和链表、字曲等数据结构被广泛地应用在redis内部不同，redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    robj *obj;     <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span>    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span>     </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span>         <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;                         <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">    &#125; level[];                                         <span class=\"comment\">// 层</span></span><br><span class=\"line\">&#125; zskiplistNode;                </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span>      <span class=\"comment\">// 表头节点和表尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;                        <span class=\"comment\">// 表中节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;                                         <span class=\"comment\">// 表中层数最大的节点的层数</span></span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-images.githubusercontent.com/11263320/106717372-9a6e7a80-663a-11eb-9748-3beee690b9c7.JPG\" alt=\"捕1获\"></p>\n<h2 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;    <span class=\"comment\">// 编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;    <span class=\"comment\">// 集合包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];    <span class=\"comment\">// 保存元素的数组</span></span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<h2 id=\"压缩列表（为了节约内存）\"><a href=\"#压缩列表（为了节约内存）\" class=\"headerlink\" title=\"压缩列表（为了节约内存）\"></a>压缩列表（为了节约内存）</h2><p>压缩列表是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项，并且每个列表要么就是小整数值，要么就是长度比较短的字符串，那么redis就会使用压缩列表来做列表键的底层实现。<br>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *<span class=\"title\">ziplistNew</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class=\"number\">1</span>; <span class=\"comment\">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小， 1 字节是表末端 ZIP_END 的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zmalloc(bytes);    <span class=\"comment\">// 为表头和表末端分配空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);    <span class=\"comment\">// 初始化表属性</span></span><br><span class=\"line\">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class=\"line\">    ZIPLIST_LENGTH(zl) = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    zl[bytes<span class=\"number\">-1</span>] = ZIP_END;    <span class=\"comment\">// 设置表末端</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。<br>redis还在这对象系统中构建了一个引用计数技术实现的内存回收机制。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObject</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;    <span class=\"comment\">// 类型</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;    <span class=\"comment\">// 编码</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> lru:REDIS_LRU_BITS;    <span class=\"comment\">// 对象最后一次被访问的时间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> refcount;    <span class=\"comment\">// 引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr;    <span class=\"comment\">// 指向实际值的指针</span></span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>","tags":["redis"]},{"title":"redis源码：独立功能的实现","url":"/2021/02/04/redis%E6%BA%90%E7%A0%81%EF%BC%9A%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"发布和订阅\"><a href=\"#发布和订阅\" class=\"headerlink\" title=\"发布和订阅\"></a>发布和订阅</h2>","tags":["redis"]},{"title":"redis设置过期方式","url":"/2021/02/22/redis%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F/","content":"<h2 id=\"redis-conf中的默认的过期策略是\"><a href=\"#redis-conf中的默认的过期策略是\" class=\"headerlink\" title=\"redis.conf中的默认的过期策略是\"></a>redis.conf中的默认的过期策略是</h2><p>volatile-lru</p>\n<h2 id=\"maxmemory-policy-六种方式\"><a href=\"#maxmemory-policy-六种方式\" class=\"headerlink\" title=\"maxmemory-policy 六种方式\"></a>maxmemory-policy 六种方式</h2><ul>\n<li>volatile-lru<br>只对设置了过期时间的key进行LRU（默认值） </li>\n<li>allkeys-lru<br>删除lru算法的key   </li>\n<li>volatile-random<br>随机删除即将过期key   </li>\n<li>allkeys-random<br>随机删除   </li>\n<li>volatile-ttl<br>删除即将过期的   </li>\n<li>noeviction<br>永不过期，返回错误</li>\n</ul>\n","tags":["redis"]},{"title":"redis：模式","url":"/2021/02/22/redis%EF%BC%9A%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"单节点模式\"><a href=\"#单节点模式\" class=\"headerlink\" title=\"单节点模式\"></a>单节点模式</h2><p>执行命令：redis-server.exe redis6379.conf<br>该命令指定了配置文件，不指定的情况下默认读取的配置文件是redis.conf配置文件</p>\n<h2 id=\"主从模式（数据备份）\"><a href=\"#主从模式（数据备份）\" class=\"headerlink\" title=\"主从模式（数据备份）\"></a>主从模式（数据备份）</h2><ul>\n<li>主节点和从节点使用完全相同的服务器实现， 它们的功能（functionally）也完全一样， 但从节点通常仅用于替换失效的主节点。</li>\n<li>不过， 如果不需要保证“先写入，后读取”操作的一致性（read-after-write consistency）， 那么可以使用从节点来执行只读查询。</li>\n</ul>\n<p>配置一主二从模式，拷贝两份redis6379.conf，分别命名redis6380.conf、redis6381.conf<br>修改redis6380.conf配置文件的如下几个参数，参数前面不要出现空格：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bind 127.0.0.1</span><br><span class=\"line\">port 6380</span><br><span class=\"line\">slaveof 127.0.0.1 6379  &#x2F;&#x2F; 设置该slave的master服务器为6379</span><br></pre></td></tr></table></figure>\n<p>同理修改redis6381.conf<br>分别启动master、slave1、slave2，命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">    redis-server.exe redis6379.conf</span><br><span class=\"line\">    redis-server.exe redis6380.conf</span><br><span class=\"line\">    redis-server.exe redis6381.conf</span><br><span class=\"line\">&#96;&#96;</span><br><span class=\"line\"> 所有节点启动后，可以在master界面看到挂载两个slave节点的日志信息</span><br><span class=\"line\"></span><br><span class=\"line\">## 哨兵模式</span><br><span class=\"line\">哨兵模式是主从模式的升级版，他会在后台有一个监控，监控当前的主机，巡逻主机下面的从机，如果某一时刻主机挂掉了，那么他会通过一种投票的机制从从机之中选举一台作为新的主机，并且，其余的从机将会连接到这个新的主机上面。</span><br><span class=\"line\"></span><br><span class=\"line\">配置一主二从三sentinel模式</span><br><span class=\"line\">redis的配置文件同主从模式下的文件配置</span><br><span class=\"line\">创建三份sentinel.conf文件，分别命名为sentinel26379.conf、sentinel26380.conf、sentinel26381.conf</span><br><span class=\"line\"></span><br><span class=\"line\">文件中的配置参数如下(另外两个配置文件同样配置)：</span><br></pre></td></tr></table></figure>\n<p>port 26379 // 当前Sentinel服务运行的端口<br>sentinel monitor mymaster 127.0.0.1 6379 2   // 去监视一个名为mymaster的主redis实例，这个主实例的IP地址为本机地址127.0.0.1，端口号为6379，而将这个主实例判断为失效至少需要2个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行<br>sentinel down-after-milliseconds mymaster 5000  // 指定了Sentinel认为Redis实例已经失效所需的毫秒数。当 实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。只有一个 Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行<br>sentinel parallel-syncs mymaster 1  // 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长<br>sentinel failover-timeout mymaster 15000 // 如果在该时间（ms）内未能完成failover操作，则认为该failover失败</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">分别启动redis服务器同主从模式下一样</span><br><span class=\"line\">分别启动sentinel服务器，命令如下：</span><br></pre></td></tr></table></figure>\n<pre><code>redis-server.exe sentinel26379.conf --sentinel  \nredis-server.exe sentinel26380.conf --sentinel  \nredis-server.exe sentinel26381.conf --sentinel</code></pre>\n<p>```</p>\n","tags":["redis"]},{"title":"redis：持久化","url":"/2021/02/22/redis%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96/","content":"<p>Redis由于支持非常丰富的内存数据结构类型，如何把这些复杂的内存组织方式持久化到磁盘上是一个难题，所以Redis的持久化方式与传统数据库的方式有比较多的差别，Redis主要支持下面两种持久化方式，分别是：<br>定时快照方式(RDB)<br>基于语句追加文件的方式(AOF)</p>\n<p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p>\n<h2 id=\"定时快照方式-snapshot，RDB-快照\"><a href=\"#定时快照方式-snapshot，RDB-快照\" class=\"headerlink\" title=\"定时快照方式(snapshot，RDB 快照)\"></a>定时快照方式(snapshot，RDB 快照)</h2><p>该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则 通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进 程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。</p>\n<p>该持久化的主要缺点是定时快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。<br>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。<br>可以在.conf文件中修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#   save &quot;&quot;</span><br><span class=\"line\">save 60 1000</span><br><span class=\"line\"></span><br><span class=\"line\"># The filename where to dump the DB</span><br><span class=\"line\">dbfilename &quot;dump.rdb&quot;</span><br></pre></td></tr></table></figure>\n<p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis&gt; SAVE</span><br><span class=\"line\">OK</span><br><span class=\"line\"></span><br><span class=\"line\">redis&gt; BGSAVE</span><br><span class=\"line\">Background saving started</span><br></pre></td></tr></table></figure>\n<h3 id=\"Redis恢复数据\"><a href=\"#Redis恢复数据\" class=\"headerlink\" title=\"Redis恢复数据\"></a>Redis恢复数据</h3><p>只要覆盖一下dump.rdb，再重启下redis就可以了。</p>\n<h2 id=\"基于语句追加方式-AOF\"><a href=\"#基于语句追加方式-AOF\" class=\"headerlink\" title=\"基于语句追加方式(AOF)\"></a>基于语句追加方式(AOF)</h2><p>aof方式实际类似mysql的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。</p>\n<p>aof的方式的主要缺点是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小 时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log,所以使用aof 的方式，Redis的读写性能也会有所下降。</p>\n<p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。 打开只需要写入conf文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n<h2 id=\"RDB-和-AOF，应该用哪一个\"><a href=\"#RDB-和-AOF，应该用哪一个\" class=\"headerlink\" title=\"RDB 和 AOF，应该用哪一个\"></a>RDB 和 AOF，应该用哪一个</h2><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>\n<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>\n<p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p>\n<h2 id=\"实验阶段\"><a href=\"#实验阶段\" class=\"headerlink\" title=\"实验阶段\"></a>实验阶段</h2><h3 id=\"虚拟内存方式\"><a href=\"#虚拟内存方式\" class=\"headerlink\" title=\"虚拟内存方式\"></a>虚拟内存方式</h3><p>虚拟内存方式是Redis来进行用户空间的数据换入换出的一个策略，此种方式在实现的效果上比较差，主要问题是代码复杂，重启慢，复制慢等等，目前已经被作者放弃。</p>\n<h3 id=\"diskstore方式：\"><a href=\"#diskstore方式：\" class=\"headerlink\" title=\"diskstore方式：\"></a>diskstore方式：</h3><p>diskstore方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的B-tree的方式，目前仍在实验阶段，后续是否可用我们可以拭目以待。</p>\n","tags":["redis"]},{"title":"skynet启动","url":"/2021/02/24/skynet%E5%90%AF%E5%8A%A8/","content":"<p>skynet 是一个为网络游戏服务器设计的轻量框架，采用单进程，多线程架构。<br>底层是c，中间层和上层都是lua。基于actor模型，使用消息队列进行内部通信。</p>\n<p>简单说，可以把 skynet 理解为一个简单的操作系统，它可以用来调度数千个 lua 虚拟机，让它们并行工作。每个 lua 虚拟机都可以接收处理其它虚拟机发送过来的消息，以及对其它虚拟机发送消息。每个 lua 虚拟机，可以看成 skynet 这个操作系统下的独立进程，你可以在 skynet 工作时启动新的进程、销毁不再使用的进程、还可以通过调试控制台监管它们。skynet 同时掌控了外部的网络数据输入，和定时器的管理；它会把这些转换为一致的（类似进程间的消息）消息输入给这些进程。</p>\n<p>例如：<br>在网络游戏中，你可以为每个在线用户创建一个 lua 虚拟机（skynet 称之为 lua 服务），姑且把它称为 agent 。用户在不和其它用户交互而仅仅自娱自乐时，agent 完全可以满足要求。agent 在用户上线时，从数据库加载关联于它的所有数据到 lua vm 中，对用户的网络请求做出反应。当然你也可以让一个 lua 服务管理多个在线用户，每个用户是 lua 虚拟机内的一个对象。<br>你还可以用独立的服务处理网络游戏中的副本（或是战场），处理玩家和玩家间，玩家协同对战 AI 的战斗。agent 会和副本服务通过消息进行交互，而不必让用户客户端直接与副本通讯。<br>我们通常建议使用一个网关服务（gate），专门监听端口，接受新连接。在用户身份确定后，再把真正的业务数据转交给特定的服务来处理。同时，网关还会负责按约定好的协议，把 TCP 连接上的数据流切分成一个个的包，而不需要业务处理服务来分割 TCP 数据流。业务处理的服务不必直接面对 socket 句柄，而由 skynet 正常的内部消息驱动即可。</p>\n<h2 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h2><p>skynet 由一个或多个进程构成，每个进程被称为一个 skynet 节点。本文描述了 skynet 节点的启动流程。<br>skynet 节点通过运行 skynet 主程序启动，必须在启动命令行传入一个 Config 文件名作为启动参数。skynet 会读取这个 config 文件获得启动需要的参数</p>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>Bootstrap第一个启动的服务是 logger ，它负责记录之后的服务中的 log 输出。logger 是一个简单的 C 服务，skynet_error 这个 C API 会把字符串发送给它。在 config 文件中，logger 配置项可以配置 log 输出的文件名，默认是 nil ，表示输出到标准输出。<br>bootstrap 这个配置项关系着 skynet 运行的第二个服务。通常通过这个服务把整个系统启动起来。默认的 bootstrap 配置项为 “snlua bootstrap” ，这意味着，skynet 会启动 snlua 这个服务，并将 bootstrap 作为参数传给它。snlua 是 lua 沙盒服务，bootstrap 会根据配置的 luaservice 匹配到最终的 lua 脚本。如果按默认配置，这个脚本应该是 service/bootstrap.lua 。<br>如无必要，你不需要更改 bootstrap 配置项，让默认的 bootstrap 脚本工作。目前的 bootstrap 脚本如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">skynet.start(function()</span><br></pre></td></tr></table></figure>","tags":["skynet"]},{"title":"skynet数据共享","url":"/2021/02/24/skynet%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/","content":"<p>当你把业务拆分到多个服务中去后，数据如何共享，可能是最易面临的问题。</p>\n<p>最简单粗暴的方法是通过消息传递数据。如果 A 服务需要 B 服务中的数据，可以由 B 服务发送一个消息，将数据打包携带过去。如果是一份数据，很多地方都需要获得它，那么用一个服务装下这组数据，提供一组查询接口即可。DataCenter 模块对此做了简单的封装。</p>\n<p>如果你仅仅需要一组只读的结构信息分享给很多服务（比如一些配置数据），你可以把数据写到一个 lua 文件中，让不同的服务加载它。Cluster 的配置文件就是这样做的。注意：默认 skynet 使用自带的修改版 lua ，会缓存 lua 源文件。当一个 lua 文件通过 loadfile 加载后，磁盘上的修改不会影响下一次加载。所以你需要直接用 io.open 打开文件，再用 load 加载内存中的 string 。</p>\n<h2 id=\"sharedata\"><a href=\"#sharedata\" class=\"headerlink\" title=\"sharedata\"></a>sharedata</h2><p>另一个更好的方法是使用 sharedata 模块。<br>当大量的服务可能需要共享一大块并不太需要更新的结构化数据，每个服务却只使用其中一小部分。你可以设想成，这些数据在开发时就放在一个数据仓库中，各个服务按需要检索出需要的部分。<br>整个工程需要的数据仓库可能规模庞大，每个服务却只需要使用其中一小部分数据，如果每个服务都把所有数据加载进内存，服务数量很多时，就因为重复加载了大量不会触碰的数据而浪费了大量内存。在开发期，却很难把数据切分成更小的粒度，因为很难时刻根据需求的变化重新切分。<br>如果使用 DataCenter 这种中心式管理方案，却无法避免每次在检索数据时都要进行一次 RPC 调用，性能或许无法承受。<br>sharedata 模块正是为了解决这种需求而设计出来的。sharedata 只支持在同一节点内（同一进程下）共享数据，如果需要跨节点，需要自行同步处理。</p>\n<p>datasheet：<br>它能做的是：把一个复杂的有一定限制的 lua 表，转换为一块 C 内存，由多个 lua 服务共享读取。</p>\n","tags":["skynet"]},{"title":"skynet源码分析：Socket","url":"/2021/02/24/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ASocket/","content":"<p>skynet 的 C API 采用异步读写，你可以使用 C 调用，监听一个端口，或发起一个 TCP 连接。但具体的操作结果要等待 skynet 的事件回调。skynet 会把结果以 PTYPE_SOCKET 类型的消息发送给发起请求的服务。（参考skynet_socket.h）<br>在处理实际业务中，这样的 API 很难使用，所以又提供了一组阻塞模式的 lua API 用于 TCP socket 的读写。它是对 C API 的封装。<br>所谓阻塞模式，实际上是利用了 lua 的 coroutine 机制。当你调用 socket api 时，服务有可能被挂起（时间片被让给其他业务处理)，待结果通过 socket 消息返回，coroutine 将延续执行。</p>\n<h2 id=\"SocketChannel\"><a href=\"#SocketChannel\" class=\"headerlink\" title=\"SocketChannel\"></a>SocketChannel</h2><p>请求回应模式是和外部服务交互时所用到的最常用模式之一。通常的协议设计方式有两种。<br>1.每个请求包对应一个回应包，由 TCP 协议保证时序。redis 的协议就是一个典型。每个 redis 请求都必须有一个回应，但不必收到回应才可以发送下一个请求。<br>2.发起每个请求时带一个唯一 session 标识，在发送回应时，带上这个标识。这样设计可以不要求每个请求都一定要有回应，且不必遵循先提出的请求先回应的时序。MongoDB 的通讯协议就是这样设计的。</p>\n<p>对于第一种模式，用 skynet 的 Socket API 很容易实现，但如果在一个 coroutine 中读写一个 socket 的话，由于读的过程是阻塞的，这会导致吞吐量下降（前一个回应没有收到时，无法发送下一个请求）。<br>对于第二种模式，需要用 skynet.fork 开启一个新线程来收取回应包，并自行和请求对应起来，实现比较繁琐。<br>所以、skynet 提供了一个更高层的封装：socket channel 。</p>\n<p>关于 socket channel 的具体用法除了阅读 lualib/socketchannel.lua （同时这也是理解 socket 模块的好材料）的实现外，也可以阅读 lualib/redis.lua 和 lualib/mongo.lua 这两个为 skynet 编写的数据库 driver 。</p>\n<h2 id=\"EPOLL封装层\"><a href=\"#EPOLL封装层\" class=\"headerlink\" title=\"EPOLL封装层\"></a>EPOLL封装层</h2><p> ./skynet-src/socket_poll.h<br>网络服务模块通常会有一个大的循环来读取网络消息，skynet也不例外，socket_server_poll函数就是来干这事的。在这个循环中将会有两个不同来源的消息系统，一个是管道消息，另一个则是网络消息了。管道消息后面会提到。网络消息是通过epoll模型的epoll_wait来读取的，采用默认的水平触发模式，这样连续读取数据较为简单。</p>\n<h2 id=\"运行流程：\"><a href=\"#运行流程：\" class=\"headerlink\" title=\"运行流程：\"></a>运行流程：</h2><p>1.在skynet_start（） 中 调用 skynet_socket_init() 初始化socket服务<br>2.每个socket 服务都有 写缓存队列，所以 框架会异步的实现读写。<br>3.socket 的open close listen apect 等操作是通过给 socket_server 的管道写入请求信息，在server_poll循环中再去处理他。<br>4.socket 在发送数据时 会尝试的直接发送数据！如果不能直接发送数据 才会把数据写入 socket 对应的写缓存 。<br><img src=\"https://user-images.githubusercontent.com/11263320/108930911-b4bbd700-7681-11eb-8dcd-ffad5e00237f.png\" alt=\"1425134-20190404141706446-2018988792\"></p>\n","tags":["skynet"]},{"title":"skynet源码分析：http","url":"/2021/02/23/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Ahttp/","content":"<p>skynet中有http server和http client的代码，用来支持http访问。在分析http之前，要先看一下url库。文件位于skyet/lualib/http/url.lua。<br>skynet 从 v0.5.0 开始提供了简单的 http 服务器的支持。skynet.httpd 是一个独立于 skynet 的，用于 http 协议解析的库，它本身依赖 socket api 的注入。使用它，你需要把读写 socket 的 API 封装好，注入到里面就可以工作。<br>skynet.sockethelper 模块将 skynet 的 Socket API 封装成 skynet.httpd 可以接受的形式：阻塞读写指定的字节数、网络错误以异常形式抛出。</p>\n<h2 id=\"httpc\"><a href=\"#httpc\" class=\"headerlink\" title=\"httpc\"></a>httpc</h2><p>skynet 提供了一个非常简单的 http 客户端模块。你可以用:</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">httpc.request(method, host, uri, recvheader, header, content)</span><br></pre></td></tr></table></figure>\n<p>来提交一个 http 请求，其中</p>\n<ul>\n<li>method 是 “GET” “POST” 等。</li>\n<li>host 为目标机的地址</li>\n<li>uri 为请求的 URI</li>\n<li>recvheader 可以是 nil 或一张空表，用于接收回应的 http 协议头。</li>\n<li>header 是自定义的 http 请求头。注：如果 header 中没有给出 host ，那么将用前面的 host 参数自动补上。</li>\n<li>content 为请求的内容。<br>它返回状态码和内容。如果网络出错，则抛出 error 。<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">httpc.dns(server, port)</span><br></pre></td></tr></table></figure>\n可以用来设置一个异步查询 dns 的服务器地址。如果你不给出地址，那么将从 /etc/resolv.conf查找地址。如果你没有调用它设置异步 dns 查询，那么 skynet 将在网络底层做同步查询。这很有可能阻塞住整个 skynet 的网络消息处理（不仅仅阻塞单个 skynet 服务）。<br>另外，httpc 还提供了简单的 httpc.get 以及 httpc.post 的封装，具体可以参考源代码。<br>如果有https的需求，可使用 lua-webclient 它是libcurl multi interface的简单封装，支持单线程，非阻塞的大量http、https请求。<br>httpc 可以通过设置 httpc.timeout 的值来控制超时时间。时间单位为 1/100 秒。</li>\n</ul>\n","tags":["skynet"]},{"title":"skynet源码分析：timer","url":"/2021/02/24/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Atimer/","content":"<p>skynet中提供了一个简单的计时器实现，可以设置一个超时时间，时间到达后给对应的服务发送消息。</p>\n<p>skynet中没有使用signal信号的方式来实现计时器，而是程序自身进行计时并处理计时器事件。另外，skynet中将时间由近及远划分为五个level，在时间复杂度和空间复杂度上达到了平衡。<br>初始化计时器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">skynet_timer_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>设置超时时间及相应的回调消息</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">skynet_timeout</span><span class=\"params\">(<span class=\"keyword\">uint32_t</span> handle, <span class=\"keyword\">int</span> time, <span class=\"keyword\">int</span> session)</span></span>; </span><br></pre></td></tr></table></figure>\n<p>程序更新时间并触发相应计时器事件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">skynet_updatetime</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>; </span><br></pre></td></tr></table></figure>","tags":["skynet"]},{"title":"skynet源码分析：服务","url":"/2021/02/23/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%9C%8D%E5%8A%A1/","content":"<p>skynet刚开始是单进程多线程的，它是由一个一个的服务组成的。在skynet上做开发，实际上就是在写服务。服务与服务之间通过消息队列进行通信。</p>\n<p>做为核心功能，Skynet 仅解决一个问题：<br>把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。模块被称为服务（Service），服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。每个服务都是被一个个消息包驱动，当没有包到来的时候，它们就会处于挂起状态，对 CPU 资源零消耗。如果需要自主逻辑，则可以利用 Skynet 系统提供的 timeout 消息，定期触发。</p>\n<p>一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。</p>\n<h2 id=\"skynet服务的本质\"><a href=\"#skynet服务的本质\" class=\"headerlink\" title=\"skynet服务的本质\"></a>skynet服务的本质</h2><p>每个skynet服务都是一个lua state，也就是一个lua虚拟机实例。而且，每个服务都是隔离的，各自使用自己独立的内存空间，服务之间通过发消息来完成数据交换。</p>\n<p>lua state本身没有多线程支持的，为了实现cpu的摊分，skynet实现上在一个线程运行多个lua state实例。而同一时间下，调度线程只运行一个服务实例。为了提高系统的并发性，skynet会启动一定数量的调度线程。同时，为了提高服务的并发性，就利用lua协程并发处理。</p>\n<p>所以，skynet的并发性有3点：<br>1、多个调度线程并发<br>2、lua协程并发处理<br>3、服务调度的切换</p>\n<p>skynet服务的设计基于Actor模型。有两个特点：</p>\n<ol>\n<li>每个Actor依次处理收到的消息</li>\n<li>不同的Actor可同时处理各自的消息<br>实现上，cpu会按照一定规则分摊给每个Actor，每个Actor不会独占cpu，在处理一定数量消息后主动让出cpu，给其他进程处理消息。</li>\n</ol>\n<h2 id=\"skynet的例子是怎么调用的\"><a href=\"#skynet的例子是怎么调用的\" class=\"headerlink\" title=\"skynet的例子是怎么调用的\"></a>skynet的例子是怎么调用的</h2><p>服务器：<br>simpledb.lua： skynet.register “SIMPLEDB” 向skynet里注册一个服务<br>agent.lua： skynet.call(“SIMPLEDB”, “text”, text) 调用相应的服务<br>main.lua： skynet.newservice(“simpledb”) 启动一个服务<br>以上函数都在\\lualib\\skynet.lua 文件内</p>\n<h2 id=\"以下是几个写服务时经常要用到的函数\"><a href=\"#以下是几个写服务时经常要用到的函数\" class=\"headerlink\" title=\"以下是几个写服务时经常要用到的函数\"></a>以下是几个写服务时经常要用到的函数</h2><p>newservice(name, …) 启动一个名为 name 的新服务。<br>uniqueservice(name, …) 启动一个唯一服务，如果服务该服务已经启动，则返回已启动的服务地址。<br>queryservice(name) 查询一个由 uniqueservice 启动的唯一服务的地址，若该服务尚未启动则等待。<br>localname(name) 返回同一进程内，用 register 注册的具名服务的地址。</p>\n<p>newservice可以在一个进程里启动多个服务，这适用于无状态的服务。<br>uniqueservice则是类似于设计模式中的单件(singleton)，这适用于需要唯一性的服务。举个例子，比如写日志，只想写一份。或者是全局共享的数据。</p>\n<h2 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h2><p>SKYNET设计综述讲到模块被称为服务。“服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。”还提到“把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。Skynet 提供了名字服务，还可以给特定的服务起一个易读的名字，而不是用 id 来指代它。id 和运行时态相关，无法保证每次启动服务，都有一致的 id ，但名字可以。”今天要分析的两个文件skynet_handle.c和skynet_handle.h就是实现名字服务的。</p>\n<p>skynet_handle.c实际上就做了两个核心的事情，一是给服务分配一个handle，二是把handle和name关联起来。<br>把handle和name关联起来比较容易懂，实际上使用一个数组，关联的时候使用二分查找到数组里查名字，如果名字不存在，就插入一个元素，然后把名字和handle关联起来。插入元素的时候，如果数组空间不足了，就扩容为原来的2倍。<br>而给服务分配handle稍复杂一些，实际上也是使用一个slot数组，数组下标使用的是一个hash，数组元素指向服务的上下文。这个hash的算法是比较简单粗暴的，就是看从handle_indx开始累计到slot_size，看中间有没有空闲的下标（也就是下标指向为null的），如果遍历完了还是没有，就把slot扩大一倍，还是没有就再扩大一倍，直到找到空位为止，或者是slot长度超出限制为止。<br>取到了handle以后呢，还要将harbor id附到handle的高8位。</p>\n<h2 id=\"每个服务分三个运行阶段\"><a href=\"#每个服务分三个运行阶段\" class=\"headerlink\" title=\"每个服务分三个运行阶段\"></a>每个服务分三个运行阶段</h2><p>首先是服务加载阶段，当服务的源文件被加载时，就会按 lua 的运行规则被执行到。这个阶段不可以调用任何有可能阻塞住该服务的 skynet api 。因为，在这个阶段中，和服务配套的 skynet 设置并没有初始化完毕。<br>然后是服务初始化阶段，由 skynet.start 这个 api 注册的初始化函数执行。这个初始化函数理论上可以调用任何 skynet api 了，但启动该服务的 skynet.newservice 这个 api 会一直等待到初始化函数结束才会返回。<br>最后是服务工作阶段，当你在初始化阶段注册了消息处理函数的话，只要有消息输入，就会触发注册的消息处理函数。这些消息都是 skynet 内部消息，外部的网络数据，定时器也会通过内部消息的形式表达出来。</p>\n<p>从 skynet 底层框架来看，每个服务就是一个消息处理器。但在应用层看来并非如此。它是利用 lua 的 coroutine 工作的。当你的服务向另一个服务发送一个请求（即一个带 session 的消息）后，可以认为当前的消息已经处理完毕，服务会被 skynet 挂起。待对应服务收到请求并做出回应（发送一个回应类型的消息）后，服务会找到挂起的 coroutine ，把回应信息传入，延续之前未完的业务流程。从使用者角度看，更像是一个独立线程在处理这个业务流程，每个业务流程有自己独立的上下文，而不像 nodejs 等其它框架中使用的 callback 模式。</p>\n<p>但框架已经提供了一个叫做 snlua 的用 C 开发的服务模块，它可以用来解析一段 Lua 脚本来实现业务逻辑。也就是说，你可以在 skynet 启动任意份 snlua 服务，只是它们承载的 Lua 脚本不同。这样，我们只使用 Lua 来进行开发就足够了。</p>\n<h2 id=\"ShareData\"><a href=\"#ShareData\" class=\"headerlink\" title=\"ShareData\"></a>ShareData</h2><p>当你把业务拆分到多个服务中去后，数据如何共享，可能是最易面临的问题。<br>最简单粗暴的方法是通过消息传递数据。如果 A 服务需要 B 服务中的数据，可以由 B 服务发送一个消息，将数据打包携带过去。如果是一份数据，很多地方都需要获得它，那么用一个服务装下这组数据，提供一组查询接口即可。DataCenter 模块对此做了简单的封装。<br>datacenter 可用来在整个 skynet 网络做跨节点的数据共享。<br>如果你仅仅需要一组只读的结构信息分享给很多服务（比如一些配置数据），你可以把数据写到一个 lua 文件中，让不同的服务加载它。Cluster 的配置文件就是这样做的。注意：默认 skynet 使用自带的修改版 lua ，会缓存 lua 源文件。当一个 lua 文件通过 loadfile 加载后，磁盘上的修改不会影响下一次加载。所以你需要直接用 io.open 打开文件，再用 load 加载内存中的 string 。</p>\n<p>另一个更好的方法是使用 sharedata 模块。<br>当大量的服务可能需要共享一大块并不太需要更新的结构化数据，每个服务却只使用其中一小部分。你可以设想成，这些数据在开发时就放在一个数据仓库中，各个服务按需要检索出需要的部分。<br>整个工程需要的数据仓库可能规模庞大，每个服务却只需要使用其中一小部分数据，如果每个服务都把所有数据加载进内存，服务数量很多时，就因为重复加载了大量不会触碰的数据而浪费了大量内存。在开发期，却很难把数据切分成更小的粒度，因为很难时刻根据需求的变化重新切分。<br>如果使用 DataCenter 这种中心式管理方案，却无法避免每次在检索数据时都要进行一次 RPC 调用，性能或许无法承受。<br>sharedata 模块正是为了解决这种需求而设计出来的。sharedata 只支持在同一节点内（同一进程下）共享数据，如果需要跨节点，需要自行同步处理。</p>\n<h2 id=\"skynet-call的实现–服务与服务的交互\"><a href=\"#skynet-call的实现–服务与服务的交互\" class=\"headerlink\" title=\"skynet call的实现–服务与服务的交互\"></a>skynet call的实现–服务与服务的交互</h2><p>如果一个服务生产了大量数据，想传给您一个服务消费，在同一进程下，是不必经过序列化过程，而只需要通过消息传递内存地址指针即可。这个优化存在 O(1) 和 O(n) 的性能差别，不可以无视。<br>架构图<br><img src=\"https://user-images.githubusercontent.com/11263320/108848571-1e08ff00-761c-11eb-9b28-77f3bdbe92c0.jpg\" alt=\"1425134-20190308091754983-2095526062\"></p>\n","tags":["skynet"]},{"title":"skynet源码分析：模块","url":"/2021/02/23/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A8%A1%E5%9D%97/","content":"<p>之前已经说过skynet的是做什么的，现在开始从模块上研究skynet的源码。</p>\n<h2 id=\"skynet各层表现\"><a href=\"#skynet各层表现\" class=\"headerlink\" title=\"skynet各层表现\"></a>skynet各层表现</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/108858906-a5a83b00-7627-11eb-9ce1-223d08f02aa8.png\" alt=\"20180315154138758\"><br>从上大概就清楚skynet的“内部”<br>而skynet源码目录结构如下：<br>3rd：第三方代码，有lua和jemalloc等。<br>lualib：使用lua写的库<br>lualib-src：使用C写并封装给lua使用的库<br>service：使用lua写的skynet的服务模块<br>service-src：使用C写的skynet的服务模块<br>skynet-src：skynet核心代码</p>\n<h2 id=\"skynet重要模块\"><a href=\"#skynet重要模块\" class=\"headerlink\" title=\"skynet重要模块\"></a>skynet重要模块</h2><p>gate.so：为整个skynet提供socket功能（解决外部连接数据读取的问题）<br>snlua.so：启动多个lua服务，skynet自带的模块中有一个重要的模块是snlua.so模块，通过snlua.so和指定lua脚本文件可以启动多个lua编写的服务，不用每个服务都是用c来编写，而且大部分逻辑都是在 lua 脚本下开发，只有需要考虑性能的模块才用 C 语言开发成库，直接提供给 lua 调用。<br>logger.so：日志模块，一个简单的日志系统,可以用来记录服务的相关信息。<br>harbar.so：（集群模块）节点服务,每个Skynet运行都是一个节点</p>\n<h2 id=\"skynet重要服务\"><a href=\"#skynet重要服务\" class=\"headerlink\" title=\"skynet重要服务\"></a>skynet重要服务</h2><p>launcher.lua：在lua中启动服务<br>skynet.lua：lua常用功能封装<br>skynet.so：lua调用skynet功能</p>\n<h2 id=\"skynet重要文件\"><a href=\"#skynet重要文件\" class=\"headerlink\" title=\"skynet重要文件\"></a>skynet重要文件</h2><p>skynet_server.c：管理服务<br>skynet_handle.c：管理服务唯一的handle<br>skynet_module.c：启动c编写的so模块<br>skynet_monitor.c：监视服务死循环<br>skynet_mq.c：消息队列<br>skynet_timer.c：定时器<br>skynet_socket.c：Socket<br>skynet_master.c：不同skynet节点服务名字中心服务<br>skynet_harbor.c：不同skynet节点通讯</p>\n<p>skynet底层代码位于skynet/skynet-src下,模块加载相关在skynet-module.c skynet-module.h这两个文件里。这里的模块在linux下指的是so，在windows下指的是dll，在skynet中指的是config中配置的cpath下的文件。</p>\n<p>每个模块需要实现四个最基本的函数，create/init/release/signal。create做内存分配。init做初始化，它可能会做一些其它的事情，比如打开网络，打开文件，函数回调挂载等等。relase做资源回收，包括内存资源，文件资源，网络资源等等，signal是发信号，比如kill信号，告诉模块该停了。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>网络部分是一个服务器最基础最核心的部分，这个技术也已经是非常成熟了，现在已经很少有人自己实现一个网络相关的库了。skynet的网络库是自己实现的。<br>实际上云风只实现了epoll和kqueue，windows上的变种请自行搜索吧。</p>\n<p>epoll和kqueue的实现分别在skynet_epoll.h和epoll_kqueue.h当中。epoll的函数其实就是epoll_create/epoll_ctl/epoll_del/epoll_wait这几个，要注意的是skynet中的epoll_create的参数是1024。所以连接数上不去的话很可能就是这里限制了。<br>skynet在skynet_poll.h中根据平台的不同包含了不同的头文件，屏蔽了平台相关性。然后在socket_server.c中实现了网络服务的逻辑。<br>然后skynet在skynet_socket.c中对socket_server.c中的逻辑再次做了一个封装，还添加了socket客户端相关的函数，就是connect/send/close之类的函数。<br>为了方便lua层使用socket，在lua-socket.c中再将对skynet_socket.c进行了一次封装。这个封装就是c语言层和lua语言层的相互转换。目前只支持tcp和udp，基于tcp上的http/websocket之类统统是不支持的。</p>\n<p>为什么操作一个网络要费这么大的劲呢，绕来绕去非常的不直观。因为skynet是基于消息的，而且每个服务都有一个monitor,每个消息处理的时候要尽可能的短，这样才不会阻塞服务里其它的请求。而connect这种明显是阻塞的，当然也可以写成非阻塞的，但是非阻塞的话，你需要不断地挂起，因为非阻塞实际上是基于select技术来实现的。而不断地挂起，这个就很麻烦，写起来很痛苦而且很容易出错。因此云风把这些都放到网络线程中来做，这样就不会影响工作线程。但是这样做也有它的缺点，那就是网络线程可能会被阻塞，网络线程被阻塞就会导致服务无响应。或者导致大量的数据包积累，引起波峰。</p>\n<h2 id=\"skynet的配置加载\"><a href=\"#skynet的配置加载\" class=\"headerlink\" title=\"skynet的配置加载\"></a>skynet的配置加载</h2><p>skynet的配置文件是以lua格式来写的。使用过skynet的都清楚skynet的启动命令是skynet config_file_name。配置文件名是作为命令行参数传给skynet进程的。<br>skynet进程启动以后，会读取config文件，然后解析这个lua文件。然后把相关的配置信息设置到lua的环境变量里。<br>C层读取配置的话是要从lua环境变量里去取的。</p>\n<p>skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，从全局消息队列中pop出一个次级消息队列时，其他线程是拿不到同一个服务，并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的<br>socket线程、timer线程甚至是worker线程，都有可能会往指定服务的次级消息队列中push消息，push函数内有加一个自旋锁，避免同时多条线程同时向一个次级消息队列push消息的惨局。</p>\n","tags":["skynet"]},{"title":"skynet源码分析：消息","url":"/2021/02/23/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%B6%88%E6%81%AF/","content":"<h2 id=\"消息队列mq\"><a href=\"#消息队列mq\" class=\"headerlink\" title=\"消息队列mq\"></a>消息队列mq</h2><p>消息队列是skynet的核心功能之一，它的功能说白了就是入队出队，先进先出，这个数据结构都有讲过。源码实现在skynet_mq.h和skynet_mq.c中。</p>\n<p>skynet的消息队列实际上是有两种，一种是全局消息队列，一种是服务消息队列。每个服务都有自己的消息队列，每个服务消息队列中都有服务的handle标识。这个涉及到消息的派发，这里就不展开了。每个服务消息队列被全局消息队列引用。<br>全局消息队列用的是经典的链表来实现的，而服务的消息队列用的是比较不直观，可能对有些人来说理解起来特别困难的循环数组来实现的。而且数组空间不够的时候，会动态扩展，容量扩展为当前容量的2倍。<br>消息队列的出队入队函数名都比较简单而且明了，push/pop。这个名字可能会带来一定的误解，如果改成enqueue/dequeue的话，就更符合它的实际功能。</p>\n<h2 id=\"消息机制之消息处理\"><a href=\"#消息机制之消息处理\" class=\"headerlink\" title=\"消息机制之消息处理\"></a>消息机制之消息处理</h2><p>kynet的消息机制准备拆成三个部分来讲，第一部分是接收处理，第二部分是分发，第三部分是消息注册。</p>\n<p>skynet是单进程多线程的，线程的种类有monitor/timer/socket/worker，monitor就是监控服务是不是陷入死循环了。timer是skynet自己实现的定时器。socket是负责网络的，这个应该是最容易被理解的。worker就是工作线程了，monitor/timer/socket都只有一个线程，唯独worker有多个线程，是可配的，不配的话是8个线程。每个工作线程有个叫worker_parm的参数。</p>\n<p>在开始讲线程之前还需要回顾一下消息队列，在第2篇中讲过全局消息队列是链表，里面链了工作消息队列，而工作消息队列内部使用的是循环数组。<br>另外还要回顾一下消息的handle，每个服务都有运行时一个独一无二的handle，这个handle可以跟名字绑定。</p>\n<h2 id=\"接收处理\"><a href=\"#接收处理\" class=\"headerlink\" title=\"接收处理\"></a>接收处理</h2><p>先总结一下，skynet_context_message_dispatch这个函数实际上就是不停地从全局消息队列里取工作队列，取到了以后呢，就一直处理这个队列里的消息。为了避免某个队列占用太多cpu，当前队列处理到一定的量，就把机会让给全局消息队列里的其它工作队列，把自己又放回全局消息队列。而这个处理的量是根据创建线程时thread_param里的weight权重来判定的，权重越大，流转的就越快，也就是说处理某个队列的消息数量就越少。这就是消息处理的主流程机制。<br>在主流程之外，还有monitor的触发和取消，每次处理前，触发monitor的检查。处理完了，取消monitor的检查。</p>\n<h2 id=\"分发\"><a href=\"#分发\" class=\"headerlink\" title=\"分发\"></a>分发</h2><p>消息的处理实际上就是对工作队列里的消息不停地调回调函数。那么消息是怎么放进消息队列的呢。带着这个疑问，让我们从lua层开始追根溯源。<br>在lua层有两个api，一个是skynet.send，这个是非阻塞发消息。另一个是skynet.call，这个是阻塞式发完消息等回应。skynet.call使用一个session来实现等待，这个session实际就是一个自增的数字，溢出了以后又从1开始。<br>skynet.send实际上就是往目标服务的消息队列里增加一条消息。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><p>skynet的消息注册，C服务和lua服务设置回调走的函数是不同的。C的回调可以直接调，但是lua的回调不行，它需要一个默认的回调C函数，将返回参数转换为lua能理解的格式，遵循lua的api协议，传递到lua层。<br>当服务是lua实现的时候，skynet底层核心框架在处理完消息以后，回调lua层服务的回调函数时，要先经过一次lua api协议的处理，将参数准备好以后，然后调用lua服务中的回调函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">skynet.dispatch(callback)----------------------&gt;proto[typename].dispach &#x3D; callback</span><br><span class=\"line\">                                                                                                                    |</span><br><span class=\"line\">skynet.core.call(skynet.dispatch_message)----&gt;tbl[k] &#x3D; skynet.dispatch_message</span><br><span class=\"line\">                                                                                                                    |</span><br><span class=\"line\">                                                                                                                    |</span><br><span class=\"line\">C dispatch_message-&gt;_cb---------------------------------------------------|</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><p>每条 skynet 消息由 6 部分构成：消息类型、session 、发起服务地址 、接收服务地址 、消息 C 指针、消息长度。<br>每个 skynet 服务都可以处理多类消息。在 skynet 中，是用 type 这个词来区分消息的。但与其说消息类型不同，不如说更接近网络端口 (port) 这个概念。每个 skynet 服务都支持 255 个不同的 port 。消息分发函数可以根据不同的 port 来为不同的消息定制不同的消息处理流程。</p>\n<h2 id=\"消息队列结构分析\"><a href=\"#消息队列结构分析\" class=\"headerlink\" title=\"消息队列结构分析\"></a>消息队列结构分析</h2><p>队列一般可以用链表来模拟，用两个指针，分别指向头节点和尾节点。尾节点指向插入数据的方向，头节点指向消耗数据的方向。skynet全局消息队列也用到了上面的数据结构</p>\n","tags":["skynet"]},{"title":"skynet源码分析：运行与主要线程worker","url":"/2021/02/23/skynet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E8%BF%90%E8%A1%8C%E4%B8%8E%E4%B8%BB%E8%A6%81%E7%BA%BF%E7%A8%8Bworker/","content":"<h2 id=\"skynet启动流程\"><a href=\"#skynet启动流程\" class=\"headerlink\" title=\"skynet启动流程\"></a>skynet启动流程</h2><p>skynet程序只有skynet-src目录，./skynet ./example/config启动<br>skynet_main.c读取配置文件，设置环境变量，调用skynet_start.c的skynet_start函数<br>skynet_start函数初始基础服务，调用_start函数启动_timer线程、socket线程、_monitor线程以及配置的多个_worker线程开始工作</p>\n<h2 id=\"skynet运行机制\"><a href=\"#skynet运行机制\" class=\"headerlink\" title=\"skynet运行机制\"></a>skynet运行机制</h2><p>skynet每个服务最重要的是设置一个callback函数，服务向另一个服务发消息都会压入这个服务的消息队列，等待_worker线程从全局队列取出一个服务的消息队列，然后再从这个消息队列取出一个消息使用这个服务的callback处理<br>游戏服务器一般会启动一个socket服务教给gate.so管理，socket服务可以接受外部msg传递到内部服务来处理。</p>\n<h2 id=\"monitor\"><a href=\"#monitor\" class=\"headerlink\" title=\"monitor\"></a>monitor</h2><p>skynet对服务的监控做得比较简陋，从设计原则上来说，这样做也是对的，因为框架层能做的，基本就是上报和打日志，上层的业务是变化万千的，不论怎么写，都可能满足不了上层的业务需求。skynet中对服务的监控实现在skynet_monitor.c和skynet_monitor.h中，当服务可能陷入死循环的时候，就打一条日志。<br>每次消息派发，都会调用skynet_monitor_trigger，一共调两次，第一次参数source和destination是真实的值，也就是不为0。第二次调是在消息派发完成的时候，source和destination都赋0。<br>如果第一次trigger调用以后，消息派发迟迟不完成，monitor线程第一次检查，会将check_version的值赋为version。然后monitor线程第二次检查，这个时候version和check_version就会相等，而且这时候destination也不为0，就会进入释放目标服务和打印报警的流程。</p>\n<h2 id=\"timer\"><a href=\"#timer\" class=\"headerlink\" title=\"timer\"></a>timer</h2><p>skynet的timer是做游戏用得比较频繁的一个功能，分析一下它的源码还是有意义的。而且核心的C源码除了timer和网络以外，已经基本分析得差不多了。其它都是跟lua c api相关，或者是跟lua交互比较多的。timer的源码在skynet-timer.c和skynet-timer.h中。<br>skynet的外部定时器是分为两部分存的，一部分存在叫near的数组里，另一部分存在一个二维数组里，分为四个级别。<br>skynet中有一个timer线程，每2.5毫秒就更新一下timer中的时间。每次更新都会对一个叫time的计数器做加1操作，所以这个计数器其实可以当作时间来看待，然后对near数组中的定时器进行触发。</p>\n<p>1.main函数<br>main函数是skynet进程的入口点，它需要一个配置文件的路径作为参数。main函数先做一些内存分配工作，然后加载配置文件里的内容。再把配置文件里的内容设置到lua环境变量_ENV。然后从_ENV里读取配置到c配置中。最后调用skynet_start。<br>2.skynet_start函数<br>skynet_start函数根据配置确定服务是不是以后台方式启动，然后初始化timer/socket/module/mq这些数据结构，给它们分配内存，填充一些必要的字段。下一步创建和注册日志logger服务，这个logger服务是C层实现的。然后创建注册snax服务，做bootstrap操作。最后调用start函数。<br>3.start函数<br>这个函数会启动timer/socket/monitor/worker线程，timer/socket/monitor线程都只有一个，唯独worker线程是多个，在配置文件中以thread=num来配置的。如果配置文件中没有配，就是8个。第个worker线程都有自己的权重值，权重值越大的，给单个服务的时间片越小。<br>线程都启动完以后，就进入pthread_join，等待线程的终止。所有线程终止以后，skynet就会退出。</p>\n","tags":["skynet"]},{"title":"skynet考古","url":"/2021/04/09/skynet%E8%80%83%E5%8F%A4/","content":"<h2 id=\"skynet版本的年表\"><a href=\"#skynet版本的年表\" class=\"headerlink\" title=\"skynet版本的年表\"></a>skynet版本的年表</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/114987859-397be200-9ec8-11eb-9d47-d0cb15c4a4b2.JPG\" alt=\"捕获\"></p>\n<h2 id=\"skynet-1\"><a href=\"#skynet-1\" class=\"headerlink\" title=\"skynet 1\"></a>skynet 1</h2><p>1.0 : 第一版released<br>1.1 : 增加socket.disconnected()<br>1.2 : 改进cluster支持，mongodb driver，redis driver，socket并发写，socket channel，service gate，udp支持，skynet.wait/wakeup。加入skynet.ignoreret，skynet.trace，skynet.context，socket.netstat，socketchannel.overload。升级Lua到5.3.5，升级jemalloc到5.1.0。<br>1.3 : 改进mysql driver，cluster，lua shared proto，socket.write。增加lua sharetable，https支持，websocket支持。升级jemalloc到5.2.1。<br>1.4 : 升级Lua到5.4.2。改进mysql driver，websocket，ssl，sproto。增加skynet.select，增加PKCS7加密算法，调试终端加入jmem，加入skynet_socket_pause，对日志增加时间戳。</p>\n","tags":["skynet"]},{"title":"skynet：cluster","url":"/2021/02/23/skynet%EF%BC%9Acluster/","content":"<p>skynet跟mq扮演的角色类似，每个skynet进程维护了一个MQ，会dispatch msg到每个skynet_context的私有mq。有skynet就没必要再在自己项目里引入MQ了。<br>skynet 支持两种集群模式。</p>\n<h2 id=\"master-slave-模式（局域网）\"><a href=\"#master-slave-模式（局域网）\" class=\"headerlink\" title=\"master/slave 模式（局域网）\"></a>master/slave 模式（局域网）</h2><p>当单台机器的处理能力达到极限后，可以考虑通过内置的 master/slave 机制来扩展。具体的配置方法见 Config 。<br>集群服务用到的配置项：</p>\n<ul>\n<li>cluster 它决定了集群配置文件的路径。</li>\n<li>standalone 如果把这个 skynet 进程作为主进程启动（skynet 可以由分布在多台机器上的多个进程构成网络），那么需要配置standalone 这一项，表示这个进程是主节点，它需要开启一个控制中心，监听一个端口，让其它节点接入。</li>\n<li>master 指定 skynet 控制中心的地址和端口，如果你配置了 standalone 项，那么这一项通常和 standalone 相同。</li>\n</ul>\n<p>每个 skynet 进程都是一个 slave 节点。但其中一个 slave 节点可以通过配置 standalone 来多启动一个 cmaster 服务，用来协调 slave 组网。对于每个 slave 节点，都内置一个 harbor 服务用于和其它 slave 节点通讯。<br>每个 skynet 服务都有一个全网唯一的地址，这个地址是一个 32bit 数字，其高 8bit 标识着它所属 slave 的号码。即 harbor id 。在 master/slave 网络中，id 为 0 是保留的。所以最多可以有 255 个 slave 节点。<br>在 master/slave 模式中，节点内的消息通讯和节点间的通讯是透明的。skynet 核心会根据目的地址的 harbor id 来决定是直接投递消息，还是把消息转发给 harbor 服务。<br>不要把这个模式用于跨机房的组网。所有 slave 节点都应该在同一局域网内（最好在同一交换机下）。不应该把系统设计成可以任意上线或下线 slave 的模式。<br>slave 的组网机制也限制了这一点。如果一个 slave 意外退出网络，这个 harbor id 就被废弃，不可再使用。这样是为了防止网络中其它服务还持有这个断开的 slave 上的服务地址；而一个新的进程以相同的 harbor id 接入时，是无法保证旧地址和新地址不重复的。</p>\n<p>cluster 模式<br>cluster 模块，它大部分用 lua 编写，只有通讯协议处理的部分涉及一个很小的 C 模块。<br>它的工作原理是这样的：<br>在每个 skynet 节点（单个进程）内，启动一个叫 clusterd 的服务。所有需要跨进程的消息投递都先把消息投递到这个服务上，再由它来转发到网络。</p>\n<p>要使用它之前，你需要编写一个 cluster 配置文件，配置集群内所有节点的名字和对应的监听端口。并将这个文件事先部署到所有节点</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">db = <span class=\"string\">&quot;127.0.0.1:2528&quot;</span></span><br></pre></td></tr></table></figure>\n<p>接下来，你需要在 db 的启动脚本里写上 cluster.open “db”<br>有两种方式可以访问到这个节点</p>\n<ul>\n<li>可以通过 cluster.call(nodename, service, …) 提起请求。这里 nodename 就是在配置表中给出的节点名。service 可以是一个字符串，或者直接是一个数字地址（如果你能从其它渠道获得地址的话）。当 service 是一个字符串时，只需要是那个节点可以见到的服务别名，可以是全局名或本地名。但更推荐是 . 开头的本地名，因为使用 cluster 模式时，似乎没有特别的理由还需要在那个节点上使用 master/slave 的架构（全局名也就没有特别的意义）。cluster.call 有可能因为 cluster 间连接不稳定而抛出 error 。但一旦因为 cluster 间连接断开而抛出 error 后，下一次调用前 cluster 间会尝试重新建立连接。</li>\n<li>可以通过 cluster.proxy(nodename, service) 生成一个本地代理。之后，就可以像访问一个本地服务一样，和这个远程服务通讯。但向这个代理服务 send 消息，有可能因为 cluster 间的连接不稳定而丢失。详见 cluster.send 的说明。</li>\n<li>如果想单向推送消息，可以调用 cluster.send(nodename, service, …) 。但注意，跨越节点推送消息有丢失消息的风险。因为 cluster 基于 tcp 连接，当 cluster 间的连接断开，cluster.send 的消息就可能丢失。而这个函数会立刻返回，所以调用者没有机会知道发送出错。</li>\n</ul>\n<p>Cluster 是去中心化的，所以需要在每台机器上都放置一份配置文件（通常是相同的）。通过调用 cluster.reload 可以让本进程重新加载配置。如果你修改了每个节点名字对应的地址，那么 reload 之后的请求都会发到新的地址。而之前没有收到回应的请求还是会在老地址上等待。如果你老的地址已经无效（通常是主动关闭了进程）那么请求方会收到一个错误。</p>\n<h2 id=\"某个节点配置多个通道\"><a href=\"#某个节点配置多个通道\" class=\"headerlink\" title=\"某个节点配置多个通道\"></a>某个节点配置多个通道</h2><p>在skynet框架中使用cluster模式，经常有消息在节点之间传递。大部分情况，我们在节点A和节点B之间只需要建立一个连接通道，但是在有些时候我们希望让一些比较独立的业务能占用一条单独的通道进行处理，不希望跟到正常的业务逻辑去抢通道资源。这个时候，我们就需要为某个节点配置多个通道了。</p>\n<p>比如，我们要在节点A中再开辟一条连接连通节点B的通道，由于一条通道就是一条tcp连接，所以我们需要为节点B再配置一个端口。我们打开集群的cluster配置文件，添加一个节点B的记录，新分配一个端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nodea &#x3D; &quot;127.0.0.1:50653&quot;</span><br><span class=\"line\">nodeb &#x3D; &quot;127.0.0.1:50654&quot;</span><br><span class=\"line\">nodeb2&#x3D; &quot;127.0.0.1:50655&quot;</span><br></pre></td></tr></table></figure>\n<p>然后重新启动节点，在节点B的启动脚本中，我们也需要在集群中打开nodeb2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cluster.open(&quot;nodeb2&quot;)</span><br></pre></td></tr></table></figure>\n<p>然后，在节点A中，我们就可以进行跨节点访问了，这个时候，我们可以分别用nodeb和nodeb2进行访问，框架将使用2条tcp通道进行分别处理。你也可以使用netsta命令，查看nodeb和nodeb2的连接情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cluster.call(&quot;nodeb&quot;,&quot;.main&quot;,&quot;xxxxxx&quot;)</span><br><span class=\"line\">cluster.call(&quot;nodeb2&quot;,&quot;.main&quot;,&quot;xxxxxx&quot;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于cluster的实现\"><a href=\"#关于cluster的实现\" class=\"headerlink\" title=\"关于cluster的实现\"></a>关于cluster的实现</h2><p>为什么要cluster：<br>除非你的业务本来就是偏重 IO 的，也就是你根本不打算利用单台硬件的多核心优势来增强计算力，抹平本机和网络的差异是没有意义的。无论硬件怎样发展，你都不可能看到主板上的总线带宽和 TCP 网络的带宽工作在同一数量级的那一天，因为这是物理基本规律决定的。<br>当你的业务需要高计算力，把 actor 放在一台机器上才可以正常的发挥 CPU 能力去合作；如果你的系统又需要分布式扩展，那么一定是有很多组独立无关的业务可以平行处理。这两类工作必须由构架系统的人自己想清楚，规划好怎么部署这些 actor ，而不可能随手把 actor 扔在分布式系统中，随便挑台硬件运行就够了。<br>恰巧网络游戏服务就是这种业务类型。多组服务器、多个游戏场景之间交互很弱，但其中的个体又需要很强的计算力。这就是 skynet 切合的应用场景。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>skynet 的核心层之上，设计了 cluster 模块。它大部分用 lua 编写，只有通讯协议处理的部分涉及一个很小的 C 模块。用 Lua 编写可以提高系统的可维护性，和网络通讯的带宽相比，Lua 相对 C 在处理数据包的性能降低是微不足道的。<br>在每个 skynet 节点（单个进程）内，启动一个叫 clusterd 的服务。所有需要跨进程的消息投递都先把消息投递到这个服务上，再由它来转发到网络。</p>\n","tags":["skynet"]},{"title":"skynet：控制台管理","url":"/2021/02/23/skynet%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%AE%A1%E7%90%86/","content":"<p>skynet 自带了一个控制台服务，可以很方便获取和调试 skynet 运行数据，而且可以热更新代码，所以，弄明白skynet控制台管理可以让你更好地使用skynet，甚至改进这个控制台服务，以满足不同业务需求。</p>\n<p>这个服务默认不会启动，需要你手动启动它，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">skynet.newservice(&quot;debug_console&quot;, 8000)</span><br></pre></td></tr></table></figure>\n<p>设计原因，调试控制台只监听本地地址 127.0.0.1 ，如果需要远程使用，需要先登录到本机，然后再连接。</p>\n<p>使用时，通过 telnet 或 nc 登录调试控制台，启动后显示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br></pre></td></tr></table></figure>\n<p>表示连接成功。</p>\n<p>注：skynet控制台不能使用上下键回溯历史命令，退格键也不能使用（改用删除键）等等，这是由于 skynet 使用了自己的 IO 库，很难接入 libreadline （不能在 readline 的 hook 中 yield）。如果希望在控制台中使用 readline 的 history 等特性，可以自己使用 rlwrap 。</p>\n<p>这时，你可以输入调试指令，输入 help 可以列出目前支持的所有指令。（不同版本结果不同）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">help</span><br><span class=\"line\">clearcache      clear lua code cache</span><br><span class=\"line\">cmem    Show C memory info</span><br><span class=\"line\">debug   debug address : debug a lua service</span><br><span class=\"line\">exit    exit address : kill a lua service</span><br><span class=\"line\">gc      gc : force every lua service do garbage collect</span><br><span class=\"line\">help    This help message</span><br><span class=\"line\">info    Info address : get service infomation</span><br><span class=\"line\">inject  inject address luascript.lua</span><br><span class=\"line\">kill    kill address : kill service</span><br><span class=\"line\">list    List all the service</span><br><span class=\"line\">logoff  logoff address</span><br><span class=\"line\">logon   logon address</span><br><span class=\"line\">mem     mem : show memory status</span><br><span class=\"line\">service List unique service</span><br><span class=\"line\">signal  signal address sig</span><br><span class=\"line\">snax    lanuch a new snax service</span><br><span class=\"line\">start   lanuch a new lua service</span><br><span class=\"line\">stat    Dump all stats</span><br><span class=\"line\">task    task address : show service task detail</span><br></pre></td></tr></table></figure>\n<p>命令的一般格式是 命令 地址 ，有些命令不带地址，会针对所有的服务。当输入地址时，可以使用 :01000001 这样的格式指代一个服务地址：由冒号开头的 8 位 16 进制数字，也可以省略前面两个数字的 harbor id 以及接下来的连续 0 ，比如 :01000001 可以简写为 1 。所有活动的服务可以输入 list 列出。</p>\n<p>常用的通用指令：<br>list 列出所有服务，以及服务的启动参数。<br>gc 对所有 lua 服务执行gc，并列出gc后所有服务的内存情况。<br>mem 列出所有 lua 服务的内存占用情况。（注：只获取 lua 服务的 lua vm 内存占用情况，如果需要 C 模块中内存使用情况，使用cmem。）<br>stat 列出所有 lua 服务的消息队列长度，以及被挂起的请求（协程）数量。<br>service 列出所有的唯一 lua 服务。<br>注意，由于这些指令是逐个向每个服务发送消息并等待回应，所以当某个 lua 服务过载时，可能需要等待很长时间才有返回。</p>\n<p>针对单个 lua 服务的指令：<br>exit address 退出指定 lua 服务<br>kill address 强制中止指定 lua 服务。<br>info address 让指定 lua 服务输出自己的内部信息（数据通过回调服务内 skynet.info_func 生成）<br>signal address sig 向服务发送一个信号，sig 默认为 0 。当一个服务陷入死循环时，默认信号会打断正在执行的 lua 字节码，并抛出 error 显示调用栈。这是针对 endless loop 的 log 的有效调试方法。（注：这里的信号并非系统信号。）<br>task address 显示一个服务中所有被挂起的请求的调用栈。<br>debug address 针对一个 lua 服务启动内置的单步调试器。<br>logon/logoff address 记录一个服务所有的输入消息（source, type, session, data, size）到文件。（生成文件的路径地址取配置 logpath） 。<br>inject address script 将 script 对应的脚本插入到指定服务中运行（通常可用于热更新补丁）。</p>\n<p>这里重点说下 info address 和 inject address script，这两个命令很重要。</p>\n<h2 id=\"获取服务内部数据-info-address\"><a href=\"#获取服务内部数据-info-address\" class=\"headerlink\" title=\"获取服务内部数据 - info address\"></a>获取服务内部数据 - info address</h2><p>前面提到，这个命令让指定 lua 服务输出自己的内部信息，数据通过回调服务内 skynet.info_func 生成。<br>下面以 example/simpledb.lua做说明，这是个典型的skynet服务。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> skynet = <span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet.manager&quot;</span>    <span class=\"comment\">-- import skynet.register</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> db = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">local</span> command = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">command.GET</span><span class=\"params\">(key)</span></span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> db[key]</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">command.SET</span><span class=\"params\">(key, value)</span></span></span><br><span class=\"line\">  <span class=\"keyword\">local</span> last = db[key]</span><br><span class=\"line\">  db[key] = value</span><br><span class=\"line\">  <span class=\"keyword\">return</span> last</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 新增的代码 -- start</span></span><br><span class=\"line\">skynet.info_func(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello mycwq!&quot;</span> <span class=\"keyword\">end</span>)</span><br><span class=\"line\"><span class=\"comment\">-- 新增的代码 -- end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">skynet.start(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">  skynet.dispatch(<span class=\"string\">&quot;lua&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(session, address, cmd, ...)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> f = command[<span class=\"built_in\">string</span>.<span class=\"built_in\">upper</span>(cmd)]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f <span class=\"keyword\">then</span></span><br><span class=\"line\">      skynet.ret(skynet.pack(f(...)))</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      <span class=\"built_in\">error</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;Unknown command %s&quot;</span>, <span class=\"built_in\">tostring</span>(cmd)))</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span>)</span><br><span class=\"line\">  skynet.register <span class=\"string\">&quot;SIMPLEDB&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<p>启动example例子，连接控制台</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:00000004       snlua cmaster</span><br><span class=\"line\">:00000005       snlua cslave</span><br><span class=\"line\">:00000007       snlua datacenterd</span><br><span class=\"line\">:00000008       snlua service_mgr</span><br><span class=\"line\">:0000000a       snlua protoloader</span><br><span class=\"line\">:0000000b       snlua console</span><br><span class=\"line\">:0000000c       snlua debug_console 8000</span><br><span class=\"line\">:0000000d       snlua simpledb</span><br><span class=\"line\">:0000000e       snlua watchdog</span><br><span class=\"line\">:0000000f       snlua gate</span><br><span class=\"line\">OK</span><br><span class=\"line\">info :0000000d</span><br><span class=\"line\">hello mycwq!</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码热更新-inject-address-script\"><a href=\"#代码热更新-inject-address-script\" class=\"headerlink\" title=\"代码热更新 - inject address script\"></a>代码热更新 - inject address script</h2><p>前面提到，这个命令将 script 对应的脚本插入到指定服务中运行<br>下面写个简单的inject例子，保存为 example/inject_simpledb.lua</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> _P <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span> <span class=\"string\">&quot;inject error!!&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> command = _P.lua.command</span><br><span class=\"line\">command.TEST = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">return</span> <span class=\"string\">&quot;TEST&quot;</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;inject ok!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>启动example例子，连接控制台</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:00000004       snlua cmaster</span><br><span class=\"line\">:00000005       snlua cslave</span><br><span class=\"line\">:00000007       snlua datacenterd</span><br><span class=\"line\">:00000008       snlua service_mgr</span><br><span class=\"line\">:0000000a       snlua protoloader</span><br><span class=\"line\">:0000000b       snlua console</span><br><span class=\"line\">:0000000c       snlua debug_console 8000</span><br><span class=\"line\">:0000000d       snlua simpledb</span><br><span class=\"line\">:0000000e       snlua watchdog</span><br><span class=\"line\">:0000000f       snlua gate</span><br><span class=\"line\">OK</span><br><span class=\"line\">inject :0000000d example/inject_simpledb.lua</span><br><span class=\"line\">inject ok!</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-rlwrap-强化-skynet-控制台\"><a href=\"#使用-rlwrap-强化-skynet-控制台\" class=\"headerlink\" title=\"使用 rlwrap 强化 skynet 控制台\"></a>使用 rlwrap 强化 skynet 控制台</h2><p>前面提到了skynet控制台不能使用上下键回溯历史命令，退格键也不能使用等，为了弥补这个不足，可以使用 rlwrap<br>这里以 centos做说明， rlwrap依赖 readline，系统必须装有 readline ，在现有很多linux系统，readline都可自动化安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum -y install readline-devel  </span><br></pre></td></tr></table></figure>\n<p>rlwrap则需要手动安装，如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zxf rlwrap-0.37.tar.gz </span><br><span class=\"line\">cd rlwrap-0.37</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>以后，skynet控制台的连接方式改成这样，就可以回溯命令了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> rlwrap nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:01000004       snlua cmaster</span><br><span class=\"line\">:01000005       snlua cslave</span><br><span class=\"line\">:01000007       snlua datacenterd</span><br><span class=\"line\">:01000008       snlua service_mgr</span><br><span class=\"line\">:0100000a       snlua protoloader</span><br><span class=\"line\">:0100000b       snlua console</span><br><span class=\"line\">:0100000c       snlua debug_console 8000</span><br><span class=\"line\">:0100000d       snlua simpledb</span><br><span class=\"line\">:0100000e       snlua watchdog</span><br><span class=\"line\">:0100000f       snlua gate</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>最后，这里列举 rlwrap常用的快捷键：<br>Ctrl+L 清屏，实际是将当前行置顶<br>Ctrl+P 上一条命令<br>Ctrl+N 下一条命令<br>Ctrl+U 从光标处删除到行首<br>Ctrl+W 向前删除一个单词<br>Ctrl+B 光标向前移动一个位置<br>Ctrl+T 光标处字符与前一个字符交换位置<br>Ctrl+Z 后台运行，使用fg调出<br>Ctrl+H 相当于删除键<br>Ctrl+J 相当于回车键<br>Ctrl+O 相当于回车键<br>Ctrl+M 相当于回车键</p>\n<p>追踪业务逻辑<br>skynet.trace() </p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>目前在 skynet 的内存分配 API 预埋了调试接口。可以通过在 make 时加上预定义宏 MEMORY_CHECK 打开。<br>例如，在 linux 下，可以用 make linux SKYNET_DEFINES=-DMEMORY_CHECK 打开。<br>btw，还有一些同学用 C 编写 lua 扩展模块没有经验，导致 lua 堆栈溢出，最终致使程序崩溃。推荐在编译 lua 的时候加上宏定义：LUA_USE_APICHECK 。</p>\n","tags":["skynet"]},{"title":"skynet：热更新 lua 代码","url":"/2021/02/23/skynet%EF%BC%9A%E7%83%AD%E6%9B%B4%E6%96%B0-lua-%E4%BB%A3%E7%A0%81/","content":"<p>skynet有两种方法热更新lua代码，clearcache和inject，文章分别对这两种方法做说明。</p>\n<h2 id=\"clearcache热更新\"><a href=\"#clearcache热更新\" class=\"headerlink\" title=\"clearcache热更新\"></a>clearcache热更新</h2><p>讲这个前，先说明下skynet代码加载的事情。因为skynet的每个服务都是一个独立的lua虚拟机，对于同一份lua代码，N个服务就要加载lua文件N次，所以，skynet做了优化，代码文件只需要加载一次到内存，其他服务复制这份内存就可以了，省了读取lua文件和解析lua语法的过程。</p>\n<p>clearcache 使用很简单，启动skynet，连接到其控制台：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">clearcache</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>但clearcache有个不可忽视的问题，每次clearcache后，不管代码有没有用到，skynet不会清理旧的内存。这会导致了多次clearcache后，skynet内存使用会越来越大<br>这是为什么？因为clearcache后，只有新起的服务会用到新代码，旧的服务还引用着旧代码。而skynet没有做引用GC的复杂逻辑，在旧服务销毁时，没有清理用不到的旧代码。</p>\n<p>或许你会很好奇，clearcache 没清的内存到底是啥？<br>这要从skynet代码共享说起，skynet加载lua代码时，对于一个代码文件使用了一个新的vm加载，然后以文件名作为key将代码索引到全局的vm中。这样，当有服务需要代码了，就从全局vm找到代码，复制一份到服务。而clearcache，就是删除这个全局的vm，然后再重建一个。这么做的好处是，执行clearcache后，不影响已有服务的运行。问题是，全局vm删了，这个vm索引的所有代码没有清理，这样，那些加载代码用的vm没做清理。</p>\n<h2 id=\"inject热更新\"><a href=\"#inject热更新\" class=\"headerlink\" title=\"inject热更新\"></a>inject热更新</h2><p>inject命令相当于注入代码到服务中，原理就是让指定服务执行某个代码文件，通过修改模块及其函数的upvalue，完成对lua模块代码或变量的替换。这个命令我在前面的文章[1]有详细介绍。<br>inject用法很简单，启动skynet，连接到其控制台:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nc 127.0.0.1 8000</span></span><br><span class=\"line\">Welcome to skynet console</span><br><span class=\"line\">list</span><br><span class=\"line\">:00000004       snlua cmaster</span><br><span class=\"line\">:00000005       snlua cslave</span><br><span class=\"line\">:00000007       snlua datacenterd</span><br><span class=\"line\">:00000008       snlua service_mgr</span><br><span class=\"line\">:0000000a       snlua protoloader</span><br><span class=\"line\">:0000000b       snlua console</span><br><span class=\"line\">:0000000c       snlua debug_console 8000</span><br><span class=\"line\">:0000000d       snlua simpledb</span><br><span class=\"line\">OK</span><br><span class=\"line\">inject :0000000d example/inject_simpledb.lua</span><br></pre></td></tr></table></figure>\n<p>inject命令的难点是，这个要注入的lua代码该怎么写。<br>下面直接改写skynet自带的example做说明：</p>\n<h1 id=\"cat-examples-simpledb-lua\"><a href=\"#cat-examples-simpledb-lua\" class=\"headerlink\" title=\"cat examples/simpledb.lua\"></a>cat examples/simpledb.lua</h1><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> skynet = <span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">require</span> <span class=\"string\">&quot;skynet.manager&quot;</span> </span><br><span class=\"line\"><span class=\"keyword\">local</span> db = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">local</span> command = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 增加了这里</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">(msg)</span></span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(msg)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 增加了这里</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">command.do_test</span><span class=\"params\">(msg)</span></span></span><br><span class=\"line\">        test(msg)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">skynet.start(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">        skynet.dispatch(<span class=\"string\">&quot;lua&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(session, address, cmd, ...)</span></span></span><br><span class=\"line\">                <span class=\"keyword\">local</span> f = command[<span class=\"built_in\">string</span>.<span class=\"built_in\">upper</span>(cmd)]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> f <span class=\"keyword\">then</span></span><br><span class=\"line\">                        skynet.ret(skynet.pack(f(...)))</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                        <span class=\"built_in\">error</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;Unknown command %s&quot;</span>, <span class=\"built_in\">tostring</span>(cmd)))</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span>)</span><br><span class=\"line\">        <span class=\"comment\">-- 增加了这里</span></span><br><span class=\"line\">        skynet.fork(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">                        skynet.sleep(<span class=\"number\">100</span>)</span><br><span class=\"line\">                        command.do_test(<span class=\"string\">&quot;itest!&quot;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span>)</span><br><span class=\"line\">        skynet.register <span class=\"string\">&quot;SIMPLEDB&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span>)</span><br></pre></td></tr></table></figure>\n<p>假设以上的 command.do_test 就是我们要热更改掉的函数。那用于inject的lua代码如下：</p>\n<h1 id=\"cat-inject-test-lua\"><a href=\"#cat-inject-test-lua\" class=\"headerlink\" title=\"cat inject_test.lua\"></a>cat inject_test.lua</h1><figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> _P <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hotfix fail, no _P define&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;hotfix begin&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 用于获取函数变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get_up</span><span class=\"params\">(f)</span></span></span><br><span class=\"line\">        <span class=\"keyword\">local</span> u = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> f <span class=\"keyword\">then</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> u</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">local</span> i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">                <span class=\"keyword\">local</span> name, value = <span class=\"built_in\">debug</span>.<span class=\"built_in\">getupvalue</span>(f, i)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> name == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> u</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                u[name] = value</span><br><span class=\"line\">                i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> u</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 获取原来的函数地址，及函数变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> command = _P.lua.command</span><br><span class=\"line\"><span class=\"keyword\">local</span> upvs = get_up(command.do_test)</span><br><span class=\"line\"><span class=\"keyword\">local</span> test = upvs.test</span><br><span class=\"line\"></span><br><span class=\"line\">command.do_test = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(msg)</span></span></span><br><span class=\"line\">    test(<span class=\"string\">&#x27;New &#x27;</span> .. msg)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;hotfix end&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>启动控制台，执行inject后，就会看到类似下面的skynet的日志：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> ./skynet examples/config</span></span><br><span class=\"line\">[:00000001] LAUNCH logger </span><br><span class=\"line\">[:00000002] LAUNCH snlua bootstrap</span><br><span class=\"line\">[:00000003] LAUNCH snlua launcher</span><br><span class=\"line\">[:00000004] LAUNCH snlua cmaster</span><br><span class=\"line\">[:00000005] LAUNCH snlua cslave</span><br><span class=\"line\">[:00000006] LAUNCH harbor 1 16777221</span><br><span class=\"line\">[:00000007] LAUNCH snlua datacenterd</span><br><span class=\"line\">[:00000008] LAUNCH snlua service_mgr</span><br><span class=\"line\">[:00000009] LAUNCH snlua main</span><br><span class=\"line\">[:0000000a] LAUNCH snlua protoloader</span><br><span class=\"line\">[:0000000b] LAUNCH snlua console</span><br><span class=\"line\">[:0000000c] LAUNCH snlua debug_console 8000</span><br><span class=\"line\">[:0000000d] LAUNCH snlua simpledb</span><br><span class=\"line\">[:0000000e] LAUNCH snlua watchdog</span><br><span class=\"line\">[:0000000f] LAUNCH snlua gate</span><br><span class=\"line\">[:0000000f] Listen on 0.0.0.0:8888</span><br><span class=\"line\">Watchdog listen on      8888</span><br><span class=\"line\">[:00000009] KILL self</span><br><span class=\"line\">[:00000002] KILL self</span><br><span class=\"line\">itest!</span><br><span class=\"line\">itest!</span><br><span class=\"line\">itest!</span><br><span class=\"line\">New itest!</span><br><span class=\"line\">New itest!</span><br></pre></td></tr></table></figure>\n<p>通过前面的分析，我们知道了，clearcache和inject两种方法都可以热更代码。clearcache比较简单，但这种方法对于已有的服务是没有效果的，只有在新的服务才生效。而inject可以热更已有的服务，但不管是inject脚本的编写，还是inject命令的执行，都相对比较繁琐。所以要根据实际的需求，选择适合的方法热更lua代码。</p>\n","tags":["skynet"]},{"title":"string：高级字符串格式化","url":"/2021/02/14/string%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/","content":"<p>字符串的format()函数,该方法收集位置参数和关键字参数的任意集合,并使用它们的值来替换字符串中的占位符;<br>形式为{n}(n为整数)的占位符将被format()方法第n个参数所代替;<br>形式为{name}的占位符将被参数中为name的参数所替代;<br>如果要用format()输出{xx},必须使用,否则会因为找不到对应的参数值而报错;<br>可以指定格式说明符,对输出进行更加精确地控制.<br>给每个占位符添加可选的格式说明符号,如{name:format_spec}.这种说明符可指定列宽,小数位和对齐方式.<br>一般格式[fill,align,sign,0,width,.precision,type],每一处都是可选的.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;&#123;a&#125;&#125;&quot;</span>.<span class=\"built_in\">format</span>()                   <span class=\"comment\">#&#123;a&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;a&#125;&quot;</span>.<span class=\"built_in\">format</span>()                     <span class=\"comment\">#error,里面没有为a的参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;a&#125; - &#123;b&#125;&quot;</span>.<span class=\"built_in\">format</span>(a = <span class=\"number\">100</span>,b = <span class=\"number\">200</span>)<span class=\"comment\">#100 - 200</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0&#125;,&#123;0&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"number\">22</span>)            <span class=\"comment\">#11,11</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0&#125;,&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>) <span class=\"comment\"># 11,11,22,33  中括号里面的数代表第几个参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:3d&#125;,&#123;1:4s&#125;,&#123;1:5s&#125;,&#123;2&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">11</span>,<span class=\"string\">&quot;a&quot;</span>,<span class=\"number\">33</span>) <span class=\"comment\"># &#x27; 11,a   ,a    ,33&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:=&gt;+011.3f&#125;;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">12.12345</span>)  <span class=\"comment\">#====+12.123;用=来填充,右对齐,因为已经用=来填充了,0无效,宽度11,小数点精度后精度为3,类型为浮点数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:&gt;+011.3f&#125;;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"number\">12.12345</span>)   <span class=\"comment\">#0000+12.123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)                <span class=\"comment\">#test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0!s:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)              <span class=\"comment\">#test</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&quot;&#123;0!r:^10&#125;&quot;</span>.<span class=\"built_in\">format</span>(a)              <span class=\"comment\">#&#x27;test&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#通过下标也行</span></span><br><span class=\"line\">a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">&#x27;&#123;0[0]&#125;,&#123;0[1]&#125;&#x27;</span>.<span class=\"built_in\">format</span>(a)          <span class=\"comment\">#1,2</span></span><br></pre></td></tr></table></figure>","tags":["python"]},{"title":"vim那些事","url":"/2021/02/13/vim%E9%82%A3%E4%BA%9B%E4%BA%8B/","content":"<h2 id=\"前方\"><a href=\"#前方\" class=\"headerlink\" title=\"前方\"></a>前方</h2><p>vim是裸机linux，最顺手的编辑工具。用好vim，修改文件就会事半功倍。</p>\n<h2 id=\"跳转查看\"><a href=\"#跳转查看\" class=\"headerlink\" title=\"跳转查看\"></a>跳转查看</h2><p>跳到文本的最后一行：按“G”,即“shift+g”<br>跳到第一行的第一个字符：先按两次“g”</p>\n","tags":["linux"]},{"title":"vscode+vps调试c程序","url":"/2021/03/03/vscode-vps%E8%B0%83%E8%AF%95c%E7%A8%8B%E5%BA%8F/","content":"<h2 id=\"使用ssh实现vscode远程连接\"><a href=\"#使用ssh实现vscode远程连接\" class=\"headerlink\" title=\"使用ssh实现vscode远程连接\"></a>使用ssh实现vscode远程连接</h2><p>在vscode安装插件remote-ssh，安装完后可以看到这个图标<br><img src=\"https://user-images.githubusercontent.com/11263320/110116260-37673380-7df2-11eb-8b71-7f0520d4c01c.JPG\" alt=\"fgfsdgs\"><br>输入vps ip就可以直接连上了</p>\n<h2 id=\"vscode调试c程序\"><a href=\"#vscode调试c程序\" class=\"headerlink\" title=\"vscode调试c程序\"></a>vscode调试c程序</h2><p>这时候如果直接debug，选择chrome，在工作目录下会出现.vscode文件夹。<br>将下面这两个文件复制到vscode下，就可以远程调试了。<br>launch.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use IntelliSense to learn about possible attributes.</span></span><br><span class=\"line\">    <span class=\"comment\">// Hover to view descriptions of existing attributes.</span></span><br><span class=\"line\">    <span class=\"comment\">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;0.2.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;(gdb) Launch&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;cppdbg&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;request&quot;</span>: <span class=\"string\">&quot;launch&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;program&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceRoot&#125;/skynet&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span>: [<span class=\"string\">&quot;examples/config&quot;</span>],</span><br><span class=\"line\">            <span class=\"attr\">&quot;stopAtEntry&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;environment&quot;</span>: [],</span><br><span class=\"line\">            <span class=\"attr\">&quot;externalConsole&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;MIMode&quot;</span>: <span class=\"string\">&quot;gdb&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;setupCommands&quot;</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class=\"line\">                    <span class=\"attr\">&quot;text&quot;</span>: <span class=\"string\">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class=\"line\">                    <span class=\"attr\">&quot;ignoreFailures&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"attr\">&quot;preLaunchTask&quot;</span>: <span class=\"string\">&quot;build-debug&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>tasks.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span>: <span class=\"string\">&quot;2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span>: <span class=\"string\">&quot;build&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;make&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span>: [<span class=\"string\">&quot;linux&quot;</span>],</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;shell&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span>: <span class=\"string\">&quot;build-debug&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;make&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span>: [<span class=\"string\">&quot;linux&quot;</span>],</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;shell&quot;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span>: <span class=\"string\">&quot;clean&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;make&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span>: [<span class=\"string\">&quot;clean&quot;</span>],</span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;shell&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据不同程序的需求，需要改写一些参数</p>\n"},{"title":"一些sql语句","url":"/2021/02/22/%E4%B8%80%E4%BA%9Bsql%E8%AF%AD%E5%8F%A5/","content":"<h2 id=\"GROUP分组\"><a href=\"#GROUP分组\" class=\"headerlink\" title=\"GROUP分组\"></a>GROUP分组</h2><p>GROUP BY 聚合函数在聚合行的时候顺序？</p>\n<p>GROUP BY 聚合函数在聚合行的时候顺序是不确定的，多次运行的结果都有可能会不同。<br>必须要用子查询或者程序逻辑来获取特定的行的结果。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> `test` <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> b <span class=\"keyword\">desc</span> limit <span class=\"number\">999999</span>) T <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> T.a</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@i</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"variable\">@i</span><span class=\"operator\">=</span><span class=\"number\">1</span></span><br><span class=\"line\">while <span class=\"variable\">@i</span><span class=\"operator\">&lt;</span><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> test (userid) <span class=\"keyword\">values</span>(<span class=\"variable\">@i</span>)</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"variable\">@i</span><span class=\"operator\">=</span><span class=\"variable\">@i</span><span class=\"operator\">+</span><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"用-临时表-While循环-的方法-对Customers表中的CompanyName列进行遍历\"><a href=\"#用-临时表-While循环-的方法-对Customers表中的CompanyName列进行遍历\" class=\"headerlink\" title=\"用 临时表 + While循环 的方法, 对Customers表中的CompanyName列进行遍历\"></a>用 临时表 + While循环 的方法, 对Customers表中的CompanyName列进行遍历</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> #temp</span><br><span class=\"line\">(</span><br><span class=\"line\">  id <span class=\"type\">int</span> <span class=\"keyword\">identity</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>),</span><br><span class=\"line\">  customer nvarchar(<span class=\"number\">50</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@customer</span> nvarchar(<span class=\"number\">50</span>)</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@n</span>        <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"variable\">@rows</span>     <span class=\"type\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@n</span><span class=\"operator\">=</span><span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> #temp(customer) <span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> companyname <span class=\"keyword\">from</span> customers</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@rows</span> <span class=\"operator\">=</span> @<span class=\"variable\">@rowcount</span></span><br><span class=\"line\"></span><br><span class=\"line\">while <span class=\"variable\">@n</span> <span class=\"operator\">&lt;=</span> <span class=\"variable\">@rows</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@customer</span> <span class=\"operator\">=</span> companyname</span><br><span class=\"line\"><span class=\"keyword\">from</span> customers</span><br><span class=\"line\">     <span class=\"keyword\">where</span> companyname<span class=\"operator\">=</span>(<span class=\"keyword\">select</span> customer <span class=\"keyword\">from</span> #temp <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"variable\">@n</span>)</span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> companyname <span class=\"keyword\">desc</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"variable\">@customer</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@n</span> <span class=\"operator\">=</span> <span class=\"variable\">@n</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"备份和恢复mysql数据库\"><a href=\"#备份和恢复mysql数据库\" class=\"headerlink\" title=\"备份和恢复mysql数据库\"></a>备份和恢复mysql数据库</h2><p>备份：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysqldump -u root -p密码 数据库名&gt;data.bak</span><br></pre></td></tr></table></figure>\n<p>恢复</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p密码 数据库名&lt;data.bak</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看mysql-的端口号\"><a href=\"#查看mysql-的端口号\" class=\"headerlink\" title=\"查看mysql 的端口号\"></a>查看mysql 的端口号</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;port&#x27;</span>;</span><br></pre></td></tr></table></figure>","tags":["mysql"]},{"title":"二叉树","url":"/2021/02/21/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前写了一些链表和排序的blog，其中有说到多链表，堆，其中提到了一种特殊的数据结构：树。<br>人们发明树结构，用于储存和搜索海量的数据。</p>\n<h2 id=\"树的种类\"><a href=\"#树的种类\" class=\"headerlink\" title=\"树的种类\"></a>树的种类</h2><p>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;<br>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；<br>二叉树：每个节点最多含有两个子树的树称为二叉树；<br>完全二叉树：二叉树的所有子树要么没有孩子，要么一定有左孩子。堆是一种完全二叉树。<br>红黑树：红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。在c++的STL中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。<br>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点（最后一层上的无子结点的结点为叶子结点）。<br>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p>\n<p>如果二叉树不是平衡的，那么它就退化为一个链表，而搜索时间也退化为一个线性函数。</p>\n<h2 id=\"树的深度\"><a href=\"#树的深度\" class=\"headerlink\" title=\"树的深度\"></a>树的深度</h2><p>定义一棵树的根结点层次为1，其他节点的层次是其父结点层次加1。一棵树中所有结点的层次的最大值称为这棵树的深度。</p>\n<h2 id=\"树的遍历\"><a href=\"#树的遍历\" class=\"headerlink\" title=\"树的遍历\"></a>树的遍历</h2><p>所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。访问结点所做的操作依赖于具体的应用问 题。 遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础。</p>\n<h2 id=\"遍历命名\"><a href=\"#遍历命名\" class=\"headerlink\" title=\"遍历命名\"></a>遍历命名</h2><p>根据访问结点操作发生位置命名：<br>① NLR：前序遍历(PreorderTraversal亦称（先序遍历））<br>——访问根结点的操作发生在遍历其左右子树之前。如10、6、4、8、14、12、16。<br>② LNR：中序遍历(InorderTraversal)<br>——访问根结点的操作发生在遍历其左右子树之中（间）。如4、6、8、10、12、14、16。<br>③ LRN：后序遍历(PostorderTraversal)<br>——访问根结点的操作发生在遍历其左右子树之后。如4、8、6、12、16、14、10。</p>\n<h2 id=\"中序遍历的投影法\"><a href=\"#中序遍历的投影法\" class=\"headerlink\" title=\"中序遍历的投影法\"></a>中序遍历的投影法</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/115009313-c03bb980-9ede-11eb-9df9-6ee7e3546184.JPG\" alt=\"捕获\"></p>\n<h2 id=\"一般二叉树的定义\"><a href=\"#一般二叉树的定义\" class=\"headerlink\" title=\"一般二叉树的定义\"></a>一般二叉树的定义</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiTNode</span>&#123;</span></span><br><span class=\"line\">    TElemType data;</span><br><span class=\"line\">    BiTNode *lchild,*rchild;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的遍历操作\"><a href=\"#二叉树的遍历操作\" class=\"headerlink\" title=\"二叉树的遍历操作\"></a>二叉树的遍历操作</h2><p>1．先序遍历（DLR）<br>先序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1） 访问根结点；<br>（2） 先序遍历根结点的左子树；<br>（3） 先序遍历根结点的右子树。</p>\n<p>先序遍历二叉树的递归算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PreOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*先序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">/*递归调用的结束条件*/</span></span><br><span class=\"line\">      Visite(bt-&gt;data);     <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\">      PreOrder(bt-&gt;lchild); <span class=\"comment\">/*先序递归遍历bt 的左子树*/</span></span><br><span class=\"line\">      PreOrder(bt-&gt;rchild); <span class=\"comment\">/*先序递归遍历bt 的右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2．中序遍历（LDR）<br>中序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）中序遍历根结点的左子树；<br>（2）访问根结点；<br>（3）中序遍历根结点的右子树。</p>\n<p>中序遍历二叉树的递归算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*中序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">/*递归调用的结束条件*/</span></span><br><span class=\"line\">     InOrder(bt-&gt;lchild); <span class=\"comment\">/*中序递归遍历bt 的左子树*/</span></span><br><span class=\"line\">     Visite(bt-&gt;data);     <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\">     InOrder(bt-&gt;rchild); <span class=\"comment\">/*中序递归遍历bt 的右子树*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3．后序遍历（LRD）<br>后序遍历的递归过程为：若二叉树为空，遍历结束。否则，<br>（1）后序遍历根结点的左子树；<br>（2）后序遍历根结点的右子树。<br>（3）访问根结点；</p>\n<p>后序遍历二叉树的递归算法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PostOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*后序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">/*递归调用的结束条件*/</span></span><br><span class=\"line\">     PostOrder(bt-&gt;lchild); <span class=\"comment\">/*后序递归遍历bt 的左子树*/</span></span><br><span class=\"line\">     PostOrder(bt-&gt;rchild); <span class=\"comment\">/*后序递归遍历bt 的右子树*/</span></span><br><span class=\"line\">     Visite(bt-&gt;data); <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从表面上看，从代码中，遍历语句的位置可以看出是什么遍历。</p>\n<p>4．层次遍历（宽度优先遍历）<br>由层次遍历的定义可以推知，在进行层次遍历时，对一层结点访问完后，再按照它们的访问次序对各个结点的左孩子和右孩子顺序访问，这样一层一层进行，先遇到的结点先访问，这与队列的操作原则比较吻合。因此，在进行层次遍历时，可设置一个队列结构，遍历从二叉树的根结点开始，首先将根结点指针入队列，然后从对头取出一个元素，每取一个元素，执行下面两个操作：<br>（1） 访问该元素所指结点；<br>（2） 若该元素所指结点的左、右孩子结点非空，则将该元素所指结点的左孩子指针和右孩子指针顺序入队。<br>此过程不断进行，当队列为空时，二叉树的层次遍历结束。</p>\n<p>在下面的层次遍历算法中，二叉树以二叉链表存放，一维数组Queue[MAXNODE]用以实现队列，变量front 和rear 分别表示当前对首元素和队尾元素在数组中的位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LevelOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*层次遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    BiTree Queue[MAXNODE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> front,rear;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    front=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    rear=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>[rear]=bt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(front!=rear)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        front++;</span><br><span class=\"line\">        Visite(<span class=\"built_in\">queue</span>[front]-&gt;data); <span class=\"comment\">/*访问队首结点的数据域*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[front]-&gt;lchild!=<span class=\"literal\">NULL</span>) <span class=\"comment\">/*将队首结点的左孩子结点入队列*/</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            rear++;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>[rear]=<span class=\"built_in\">queue</span>[front]-&gt;lchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">queue</span>[front]-&gt;rchild!=<span class=\"literal\">NULL</span>) <span class=\"comment\">/*将队首结点的右孩子结点入队列*/</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            rear++;</span><br><span class=\"line\">            <span class=\"built_in\">queue</span>[rear]=<span class=\"built_in\">queue</span>[front]-&gt;rchild;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树遍历的非递归实现\"><a href=\"#二叉树遍历的非递归实现\" class=\"headerlink\" title=\"二叉树遍历的非递归实现\"></a>二叉树遍历的非递归实现</h2><p>从二叉树各种遍历来说，各种遍历都是从根结点开始的，且在遍历过程中经过结点的路线是一样的，只是访问的时机不同而已。这一路线都是从根结点开始沿左子树深入下去，当深入到最左端，无法再深入<br>下去时，则返回，再逐一进入刚才深入时遇到结点的右子树，再进行如此的深入和返回，直到最后从根结点的右子树返回到根结点为止。先序遍历是在深入时遇到结点就访问，中序遍历是在从左子树返回时遇到结点访问，后序遍历是在从右子树返回时遇到结点访问。</p>\n<p>这种路线可以用栈来实现。其实递归在本质上就是一个栈结构。</p>\n<p>在这一过程中，返回结点的顺序与深入结点的顺序相反，即后深入先返回，正好符合栈结构后进先出的点。因此，可以用栈来帮助实现这一遍历路线。其过程如下。在沿左子树深入时，深入一个结点入栈一个结点，若为先序遍历，则在入栈之前访问之；当沿左分支深入不下去时，则返回，即从堆栈中弹出前面压入的结点，若为中序遍历，则此时访问该结点，然后从该结点的右子树继续深入；若为后序遍历，则将此结点再次入栈，然后从该结点的右子树继续深入，与前面类同，仍为深入一个结点入栈一个结点，深入不下去再返回，直到第二次从栈里弹出该结点，才访问之。</p>\n<ol>\n<li><p>先序遍历的非递归实现<br>在下面算法中，二叉树以二叉链表存放，一维数组 stack[MAXNODE] 用以实现栈，变量top 用来表示当前栈顶的位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NRPreOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*非递归先序遍历二叉树*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BiTree <span class=\"built_in\">stack</span>[MAXNODE],p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    top=<span class=\"number\">0</span>;</span><br><span class=\"line\">    p=bt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!(p==<span class=\"literal\">NULL</span>&amp;&amp;top==<span class=\"number\">0</span>))</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            Visite(p-&gt;data);   <span class=\"comment\">/*访问结点的数据域*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top&lt;MAXNODE<span class=\"number\">-1</span>) <span class=\"comment\">/*将当前指针p 压栈*/</span></span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[top]=p;</span><br><span class=\"line\">                top++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈溢出&quot;</span>)；</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            p=p-&gt;lchild; <span class=\"comment\">/*指针指向p 的左孩子*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (top&lt;=<span class=\"number\">0</span>) </span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">/*栈空时结束*/</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            top--;</span><br><span class=\"line\">            p=<span class=\"built_in\">stack</span>[top]; <span class=\"comment\">/*从栈中弹出栈顶元素*/</span></span><br><span class=\"line\">            p=p-&gt;rchild; <span class=\"comment\">/*指针指向p 的右孩子结点*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>中序遍历的非递归实现<br>中序遍历的非递归算法的实现，只需将先序遍历的非递归算法中的 Visite(p-&gt;data) 移到 p=stack[top] 和 p=p-&gt;rchild 之间即可。</p>\n</li>\n<li><p>后序遍历的非递归实现<br>由前面的讨论可知，后序遍历与先序遍历和中序遍历不同，在后序遍历过程中，结点在第一次出栈后，还需再次入栈，也就是说，结点要入两次栈，出两次栈，而访问结点是在第二次出栈时访问。因此，为了区别同一个结点指针的两次出栈，设置一标志flag，令：<br>flag = 1 -&gt; 第一次出栈，结点不能访问<br>flag = 2 -&gt; 第二次出栈，结点可以访问<br>当结点指针进、出栈时，其标志flag 也同时进、出栈。因此，可将栈中元素的数据类型定义为指针和标志flag 合并的结构体类型。定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    BiTree link;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag;</span><br><span class=\"line\">&#125; stacktype;</span><br></pre></td></tr></table></figure>\n<p>后序遍历二叉树的非递归算法如下。在算法中，一维数组 stack[MAXNODE] 用于实现栈的结构，指针变量p 指向当前要处理的结点，整型变量top 用来表示当前栈顶的位置，整型变量 sign 为结点 p 的标志量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NRPostOrder</span><span class=\"params\">(BiTree bt)</span> <span class=\"comment\">/*非递归后序遍历二叉树bt*/</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    stacktype <span class=\"built_in\">stack</span>[MAXNODE];</span><br><span class=\"line\">    BiTree p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top,sign;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bt==<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    top=<span class=\"number\">-1</span>   <span class=\"comment\">/*栈顶位置初始化*/</span></span><br><span class=\"line\">    p=bt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!(p==<span class=\"literal\">NULL</span> &amp;&amp; top==<span class=\"number\">-1</span>))</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p!=<span class=\"literal\">NULL</span>)    <span class=\"comment\">/*结点第一次进栈*/</span></span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            top++;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[top].link=p;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[top].flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">            p=p-&gt;lchild;   <span class=\"comment\">/*找该结点的左孩子*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            p=<span class=\"built_in\">stack</span>[top].link;</span><br><span class=\"line\">            sign=<span class=\"built_in\">stack</span>[top].flag;</span><br><span class=\"line\">            top--;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sign==<span class=\"number\">1</span>)   <span class=\"comment\">/*结点第二次进栈*/</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                top++;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[top].link=p;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[top].flag=<span class=\"number\">2</span>;   <span class=\"comment\">/*标记第二次出栈*/</span></span><br><span class=\"line\">                p=p-&gt;rchild;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                Visite(p-&gt;data);   <span class=\"comment\">/*访问该结点数据域值*/</span></span><br><span class=\"line\">                p=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","tags":["algorithm"]},{"title":"使用Lua处理游戏数据","url":"/2021/02/23/%E4%BD%BF%E7%94%A8Lua%E5%A4%84%E7%90%86%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE/","content":"<p>在之前lua学习：lua作配置文件里，我们学会了用lua作配置文件。<br>其实lua在游戏开发中可以作为一个强大的保存、载入游戏数据的工具。</p>\n<h2 id=\"载入游戏数据\"><a href=\"#载入游戏数据\" class=\"headerlink\" title=\"载入游戏数据\"></a>载入游戏数据</h2><p>比如说，现在我有一份表单：<br>data.xls</p>\n<p>用什么工具解析这个Excel文件并将数据载入游戏？<br>我们可以使用Lua来完成这个工作。不过要先将表单保存为csv文件（数值用逗号隔开的文件）。<br>从表单中，我们可以得知第一行是键名，剩下的行是数值。我们可以用下面的lua函数载入该csv文件并保存到表中。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetLines</span><span class=\"params\">(fileName)</span></span></span><br><span class=\"line\">    index = <span class=\"number\">0</span></span><br><span class=\"line\">    myLines = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"built_in\">io</span>.<span class=\"built_in\">lines</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;%s%s&quot;</span>, <span class=\"string\">&quot;./&quot;</span>, fileName)) <span class=\"keyword\">do</span></span><br><span class=\"line\">        index = index + <span class=\"number\">1</span></span><br><span class=\"line\">        myLines[index] = line</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> index, myLines <span class=\"comment\">--返回文件的行数和一个包括所有行的表</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>io.lines ([filename])：打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。<br>然后，可以再创建一个函数解析每行的字符，并创建表格保存该行的所有数据。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetValues</span><span class=\"params\">(myString)</span></span></span><br><span class=\"line\">    num = <span class=\"number\">0</span></span><br><span class=\"line\">    values = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> myString ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(myString,<span class=\"string\">&quot;,&quot;</span>) ~= <span class=\"literal\">nil</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">            i,j = <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(myString,<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">            num = num + <span class=\"number\">1</span></span><br><span class=\"line\">            values[num] = <span class=\"built_in\">string</span>.<span class=\"built_in\">sub</span>(myString,<span class=\"number\">1</span>, j<span class=\"number\">-1</span>)</span><br><span class=\"line\">            myString = <span class=\"built_in\">string</span>.<span class=\"built_in\">sub</span>(myString, j+<span class=\"number\">1</span>, <span class=\"built_in\">string</span>.<span class=\"built_in\">len</span>(myString))</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        num = num + <span class=\"number\">1</span> <span class=\"comment\">--接着对第二行数据</span></span><br><span class=\"line\">        values[num] = myString</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> num, values</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>string.find(s, pattern, pos)：从源字符串s找到匹配pattern返回，pos参数可选， 表示起始位置，如果匹配不成功，返回nil。<br>string.sub()：函数截取字符串s的从第i个字符到第j个字符之间的串。<br>在这个函数中，我们传入字符。通过调用string.find()和string.sub，返回数值的个数和包含了所有数值的表。通过这两个简单的处理步骤可以让用户解析几乎所有的csv文件，不论简单还是复杂的文件。</p>\n<p>我们可以写个函数测试一下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LoadDatas</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    myCharacters = &#123;&#125;</span><br><span class=\"line\">    numLines, allLines = GetLines(<span class=\"string\">&quot;data.csv&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">--读第一行的键值</span></span><br><span class=\"line\">    count, myLabels = GetValues(allLines[<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"comment\">--忽略第一行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">2</span>, numLines <span class=\"keyword\">do</span></span><br><span class=\"line\">        count, charHold = GetValues(allLines[index])</span><br><span class=\"line\">        myCharacters[index<span class=\"number\">-1</span>] = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> index2 = <span class=\"number\">1</span>, count <span class=\"keyword\">do</span></span><br><span class=\"line\">            myCharacters[index<span class=\"number\">-1</span>][index2] = charHold[index2]</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"comment\">--now print them</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">1</span>, <span class=\"number\">3</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> index2 = <span class=\"number\">1</span>, <span class=\"built_in\">table</span>.<span class=\"built_in\">getn</span>(myLabels) <span class=\"keyword\">do</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(myLabels[index2], myCharacters[index][index2])</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"保存游戏数据\"><a href=\"#保存游戏数据\" class=\"headerlink\" title=\"保存游戏数据\"></a>保存游戏数据</h2><p>我们可以利用lua内建的I/O功能来处理数据输出。只要确保输出的数据是采用合适的语法，就可以使用dofile()载入数据了。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">save</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    myFile = <span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;save_data.lua&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> myFile ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"string\">&quot;-- 游戏数据保存文件&quot;</span>)</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;%s%s&quot;</span>, <span class=\"string\">&quot;-- 文件创建于: &quot;</span>, <span class=\"built_in\">os</span>.<span class=\"built_in\">date</span>()))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"built_in\">string</span>.<span class=\"built_in\">char</span> (<span class=\"number\">10</span>))</span><br><span class=\"line\">        myFile:<span class=\"built_in\">write</span>(<span class=\"string\">&quot;myValue = 5&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">io</span>.<span class=\"built_in\">close</span>(myFile)</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"载入保存的数据\"><a href=\"#载入保存的数据\" class=\"headerlink\" title=\"载入保存的数据\"></a>载入保存的数据</h2><p>利用dofile()操作就可以恢复游戏的数据了</p>\n<h2 id=\"用lua处理log-筛取信息\"><a href=\"#用lua处理log-筛取信息\" class=\"headerlink\" title=\"用lua处理log,筛取信息\"></a>用lua处理log,筛取信息</h2><p>其实也就是一些io，string操作，没什么新的东西<br>把旧的log中想的筛取信息，写到新的文件中，具体可以参加以下代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find_player</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> logfile = <span class=\"built_in\">assert</span>(<span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;房间201.log&quot;</span>,<span class=\"string\">&quot;r&quot;</span>)) <span class=\"comment\">--打开旧文件</span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> findfile = <span class=\"built_in\">io</span>.<span class=\"built_in\">open</span>(<span class=\"string\">&quot;find_player.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>) <span class=\"comment\">--打开新文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">local</span> text = logfile:<span class=\"built_in\">read</span>(<span class=\"string\">&quot;*all&quot;</span>) <span class=\"comment\">--读入所有内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> w <span class=\"keyword\">in</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">gmatch</span>(text,<span class=\"string\">&quot;.-,&quot;</span>) <span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(w,<span class=\"string\">&quot;player userid = (%d+) level=(%d+) enter&quot;</span>) ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span> <span class=\"comment\">--查找写入相关内容到新文件</span></span><br><span class=\"line\">            findfile:<span class=\"built_in\">write</span>(w)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">string</span>.<span class=\"built_in\">find</span>(w,<span class=\"string\">&quot;player userid = (%d+) leave&quot;</span>) ~= <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">            findfile:<span class=\"built_in\">write</span>(w)</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    logfile:<span class=\"built_in\">close</span>() <span class=\"comment\">--关闭文件</span></span><br><span class=\"line\">    findfile:<span class=\"built_in\">close</span>()</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">find_player()</span><br></pre></td></tr></table></figure>","tags":["lua"]},{"title":"代码整洁之道","url":"/2021/02/15/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/","content":"<h2 id=\"使用数组代替switch分支语句降低圈复杂度\"><a href=\"#使用数组代替switch分支语句降低圈复杂度\" class=\"headerlink\" title=\"使用数组代替switch分支语句降低圈复杂度\"></a>使用数组代替switch分支语句降低圈复杂度</h2><p>在服务器开发时，很多时间会采用数组代替switch分支语句，用来降低圈复杂度。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerCallbackFunc</span> <span class=\"params\">(code, func)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> code== <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> func == <span class=\"literal\">nil</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    callbackFuncMgr[code] = func</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"圈复杂度\"><a href=\"#圈复杂度\" class=\"headerlink\" title=\"圈复杂度\"></a>圈复杂度</h3><p>在软件测试的概念里，圈复杂度用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。如果一段源码中不包含控制流语句（条件或决策点），那么这段代码的圈复杂度为1，因为这段代码中只会有一条路径；如果一段代码中仅包含一个if语句，且if语句仅有一个条件，那么这段代码的圈复杂度为2；包含两个嵌套的if语句，或是一个if语句有两个条件的代码块的圈复杂度为3。</p>\n<h2 id=\"缩写习惯\"><a href=\"#缩写习惯\" class=\"headerlink\" title=\"缩写习惯\"></a>缩写习惯</h2><p>尽量不用缩写，可读性排第一位，但可以用一些约定俗成的常见缩写。</p>\n<h2 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h2><p>作判断时尽量用&lt;判断</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">1000</span> &lt; check  <span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>这样做可以对照时间线，习惯一目了然<br><img src=\"https://user-images.githubusercontent.com/11263320/110576898-8d462d80-819c-11eb-993f-b7734c2ff5c3.JPG\" alt=\"捕获\"></p>\n"},{"title":"使用pdb调试","url":"/2021/01/24/%E4%BD%BF%E7%94%A8pdb%E8%B0%83%E8%AF%95/","content":"<h1 id=\"pdb\"><a href=\"#pdb\" class=\"headerlink\" title=\"pdb\"></a>pdb</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import pdb</span><br><span class=\"line\">pdb.set_trace()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(Pdb) h</span><br><span class=\"line\">Documented commands (type help &lt;topic&gt;):</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">EOF    bt         cont      enable  jump  pp       run      unt</span><br><span class=\"line\">a      c          continue  exit    l     q        s        until</span><br><span class=\"line\">alias  cl         d         h       list  quit     step     up</span><br><span class=\"line\">args   clear      debug     help    n     r        tbreak   w</span><br><span class=\"line\">b      commands   disable   ignore  next  restart  u        whatis</span><br><span class=\"line\">break  condition  down      j       p     return   unalias  where</span><br><span class=\"line\"></span><br><span class=\"line\">(Pdb) h c</span><br><span class=\"line\">c(ont(inue))</span><br><span class=\"line\">Continue execution, only stop when a breakpoint is encountered.</span><br></pre></td></tr></table></figure>","tags":["python"]},{"title":"删除svn冲突","url":"/2021/03/08/%E5%88%A0%E9%99%A4svn%E5%86%B2%E7%AA%81/","content":"<p>一般遇到svn冲突时，我们都下意识clean下。其实，有更加好的方法。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">G:\\project\\.svn<span class=\"operator\">&gt;</span>sqlite3.exe wc.db</span><br><span class=\"line\">SQLite version <span class=\"number\">3.7</span><span class=\"number\">.15</span><span class=\"number\">.2</span> <span class=\"number\">2013</span><span class=\"number\">-01</span><span class=\"number\">-09</span> <span class=\"number\">11</span>:<span class=\"number\">53</span>:<span class=\"number\">05</span></span><br><span class=\"line\">Enter &quot;.help&quot; <span class=\"keyword\">for</span> instructions</span><br><span class=\"line\">Enter <span class=\"keyword\">SQL</span> statements terminated <span class=\"keyword\">with</span> a &quot;;&quot;</span><br><span class=\"line\">sqlite<span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> work_queue;</span><br><span class=\"line\"><span class=\"number\">5046</span><span class=\"operator\">|</span>(file<span class=\"operator\">-</span>install Resources<span class=\"operator\">/</span>pc<span class=\"operator\">/</span>base<span class=\"operator\">/</span>effects<span class=\"operator\">/</span><span class=\"number\">500000001.</span>unity3d <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span>)</span><br><span class=\"line\">sqlite<span class=\"operator\">&gt;</span> <span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> work_queue;</span><br></pre></td></tr></table></figure>"},{"title":"单例模式","url":"/2021/02/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"<p>游戏中用到单例模式的例子很多，几乎适用于系统资源管理类中，如聊天，道具，日志等等。<br>单例模式（Singleton），保证了全局有且只有一个实例对象，保证自动地初始化该对象，使得程序在任何时候任何地方都可以访问、获取该对象。</p>\n<p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是让类自身保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p>\n<p>基本上类图都像这样：</p>\n<p>这里把构造函数定义为private或protected，可以防止外界利用new创建此类实例。而且GetInstance是一个静态的函数，主要负责创建自己的唯一实例。而且GetInstance是一个静态的函数，主要负责创建自己的唯一实例。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取某个类的单例</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetClassInstance( classname ) static_cast<span class=\"meta-string\">&lt;classname*&gt;( CMySingleton&lt;classname&gt;::GetInstance() )</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单例模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMySingleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CMySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~CMySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取全局唯一实例对象。如果还没有创建，创建她。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            m_pInstance= <span class=\"keyword\">new</span> T();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 消除全局唯一实例对象。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_pInstance;</span><br><span class=\"line\">            m_pInstance = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> T* m_pInstance;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但有时候，在多线程的程序中，多个线程同时访问Singleton，调用GetInstance()方法，会有可能造成创建多个实例。这时候就要给程序加锁。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取某个类的单例</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetClassInstance( classname ) static_cast<span class=\"meta-string\">&lt;classname*&gt;( CMySingleton&lt;classname&gt;::GetInstance() )</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单例模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CMySingleton</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    CMySingleton()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_init(&amp;m_mutex, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~CMySingleton()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_destory(&amp;m_mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取全局唯一实例对象。如果还没有创建，创建她。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T* <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;m_mutex);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_pInstance == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                m_pInstance= <span class=\"keyword\">new</span> T();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            pthread_mutex_unlock(&amp;m_mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 消除全局唯一实例对象。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Destroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;m_mutex);<span class=\"comment\">//此处无需双重检测，因为delete null并不会导致bug.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pInstance != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> m_pInstance;</span><br><span class=\"line\">            m_pInstance = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> T* m_pInstance;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> m_mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个疑惑，为什么在lock后，还需要做一次instance实例是否存在的判断？<br>当instance为null并且同时有两个纯种调用GetInstance()方法时，它们将都可以通过第一重判断。然后由于lock机制，这两个线程则只有一个进入，另一个在外排队等候，必须要其中的一个进入并出来后，另一个才能进入。而此时如果没有了第二重的判断，则第一个线程创建了实例，而第二个线程还是可以继续再创建新的实例，这就没有达到单例的目的了。</p>\n<p>总结<br>单例模式有以下的特点：<br>1 单例类只可有一个实例。<br>2 单例类必须自己创建自己这惟一的实例。<br>3 单例类必须给所有其他对象提供这一实例。<br>4 在大并发程序里，可能有多个线程同时访问单例，所以一定要记得加锁。</p>\n<p>多线程时：<br>单例模式主要有2中形式，一种是饿汉式，一种是懒汉式。<br>饿汉式：程序一加载单例模式就已经创建了，也就很饥饿嘛。因为是静态属性进行单例初始化，所以优点是线程是安全的，缺点是无论用户是否使用单例对象都会创建单例对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态属性类外初始化</span></span><br><span class=\"line\">Singleton_Hungry* Singleton_Hungry::singleton = <span class=\"keyword\">new</span> Singleton_Hungry;</span><br></pre></td></tr></table></figure>\n<p>懒汉式：当用户使用单例对象时，才去创建单例对象，所以很懒惰嘛。优点是用户不使用就不会创建对象，缺点是 当遇到多线程是，是线程不安全的，但是我们可以使用加强版的也就是线程安全的懒汉式。（上面用到的是这个）。</p>\n"},{"title":"堆与堆排序","url":"/2021/02/07/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>堆排序与快速排序，归并排序一样都是时间复杂度为O(N*logN)的几种常见排序方法。<br>堆排序是就地排序，辅助空间为O(1）。<br>它是不稳定的排序方法。（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前和排序后他们的相对位置不发生变化）</p>\n<h2 id=\"什么是堆\"><a href=\"#什么是堆\" class=\"headerlink\" title=\"什么是堆\"></a>什么是堆</h2><p>堆通常是一个可以被看做一棵树的数组对象。满足下列性质：<br>1.堆中某个节点的值总是不大于或不小于其父节点的值；<br>2.堆总是一棵完全树（完全树就是叶结点仅在层次最大的两层出现的树）。</p>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。</p>\n<h2 id=\"堆的结构\"><a href=\"#堆的结构\" class=\"headerlink\" title=\"堆的结构\"></a>堆的结构</h2><p>一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。</p>\n<h2 id=\"堆的操作\"><a href=\"#堆的操作\" class=\"headerlink\" title=\"堆的操作\"></a>堆的操作</h2><h3 id=\"建立堆\"><a href=\"#建立堆\" class=\"headerlink\" title=\"建立堆\"></a>建立堆</h3><p>一般情况下，树并不满足堆的条件，通过重新排列元素，可以建立一棵”堆化“的树。如初始表：55 12 16，堆化后为：12 55 16。</p>\n<h3 id=\"堆的插入\"><a href=\"#堆的插入\" class=\"headerlink\" title=\"堆的插入\"></a>堆的插入</h3><p>每次插入都是将新数据放在数组最后。然后树被更新以恢复堆次序。如初始表：12 22 7 ，插入新数据后，数组为12 22 7 16，然后重排树的顺序，数组为12 16 7 22。<br>可以发现从这个新数据的父结点到根结点必然为一个有序的数列。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  新加入i结点  其父结点为(i - 1) / 2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapFixup</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, temp;</span><br><span class=\"line\">\ttemp = a[i];</span><br><span class=\"line\">\tj = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;      <span class=\"comment\">//父结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; i != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[j] &lt;= temp)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ta[i] = a[j];     <span class=\"comment\">//把较大的子结点往下移动,替换它的子结点</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t\tj = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ta[i] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在最小堆中加入新的数据nNum</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapAddNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> nNum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    a[n] = nNum;</span><br><span class=\"line\">    MinHeapFixup(a, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"堆的删除\"><a href=\"#堆的删除\" class=\"headerlink\" title=\"堆的删除\"></a>堆的删除</h3><p>堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p>\n<p>如初始表：12 16 50 22，删除第0个数据后，数组为22 16 50 _，然后重排树的顺序，数组为16 22 50。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapFixdown</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, temp;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemp = a[i];</span><br><span class=\"line\">\tj = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (j &lt; n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n &amp;&amp; a[j + <span class=\"number\">1</span>] &lt; a[j]) <span class=\"comment\">//在左右孩子中找最小的</span></span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[j] &gt;= temp)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ta[i] = a[j];     <span class=\"comment\">//把较小的子结点往上移动,替换它的父结点</span></span><br><span class=\"line\">\t\ti = j;</span><br><span class=\"line\">\t\tj = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ta[i] = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在最小堆中删除数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinHeapDeleteNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tSwap(a[<span class=\"number\">0</span>], a[n - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\tMinHeapFixdown(a, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"堆化数组\"><a href=\"#堆化数组\" class=\"headerlink\" title=\"堆化数组\"></a>堆化数组</h2><p>关于怎样把一个数据进行堆化。可能很多人会想，要一个一个的从数组中取出数据来建立堆？不用。<br>比如说：int A[0] = {8,11,16,29,49,19,59,64,3,18};<br>如果把这个数组看成是一棵树，那么它的叶子结点19,59,64,3,18都分别是一个合法的堆。只要把49开始向下调整就可以了。然后再取29，16，11，9结点分别作一次向下调整操作就可以了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//建立最小堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MakeMinHeap</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">\t\tMinHeapFixdown(a, i, n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就这样，堆的操作就全部完成了。</p>\n<p>说了这么多，终于到主角登场了。<br>根据堆的性质，堆建好之后。堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。<br>由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MinheapsortTodescendarray</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSwap(a[i], a[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\tMinHeapFixdown(a, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意使用最小堆排序后是递减数组，要得到递增数组，可以使用最大堆。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>堆是一种经典的数据结构，向堆中插入、删除元素时间复杂度都是 O(lgN)， N 为堆中元素的个数，而获取最小 key 值（小根堆）的复杂度为 O(1)。</p>\n<p>libevent中的定时事件管理就是用一个以时间作为 key 的小根堆结构做的，放弃了原来的红黑树，大概就是堆比红黑树简单吧。</p>\n","tags":["algorithm"]},{"title":"工厂模式","url":"/2021/02/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"<p>现在的网游更新很快，要延长网络游戏生命周期的方法是，更新，不断地更新，不断的将新内容呈现于玩家面前。这要求游戏程序的设计要有弹性，代码的重用至关重要。</p>\n<p>今天就说说游戏中的工厂模式。<br>说到工厂模式，有简单工厂模式，工厂方法模式，抽象工厂模式。</p>\n<p>（一）简单工厂模式<br>ps：面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。<br>主要用于创建对象。新添加类时，不会影响以前的系统代码。核心思想是用一个工厂来根据输入的条件产生不同的类，然后根据不同类的virtual函数得到不同的结果。</p>\n<p>（工厂类与基类为关联关系）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">COperation</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_nFirst;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_nSecond;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">GetResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> dResult=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddOperation</span> :</span> <span class=\"keyword\">public</span> COperation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">GetResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_nFirst+m_nSecond;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//减法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubOperation</span> :</span> <span class=\"keyword\">public</span> COperation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">GetResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_nFirst-m_nSecond;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//工厂类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CCalculatorFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> COperation* <span class=\"title\">Create</span><span class=\"params\">(<span class=\"keyword\">char</span> cOperator)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">COperation* <span class=\"title\">CCalculatorFactory::Create</span><span class=\"params\">(<span class=\"keyword\">char</span> cOperator)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    COperation *oper;</span><br><span class=\"line\">    <span class=\"comment\">//在C#中可以用反射来取消判断时用的switch，在C++中用什么呢？RTTI？？</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (cOperator)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">        oper=<span class=\"keyword\">new</span> AddOperation();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">        oper=<span class=\"keyword\">new</span> SubOperation();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        oper=<span class=\"keyword\">new</span> AddOperation();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">    COperation * op=CCalculatorFactory::Create(<span class=\"string\">&#x27;-&#x27;</span>);</span><br><span class=\"line\">    op-&gt;m_nFirst=a;</span><br><span class=\"line\">    op-&gt;m_nSecond=b;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;op-&gt;GetResult()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优：适用于不同情况创建不同的类时。<br>劣：客户端必须要知道基类和工厂类，耦合性差。</p>\n<p>（二）工厂方法模式<br>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但简单工厂模式中不遵守开放－封闭原则。代码耦合性差。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"comment\">//实例基类，相当于Product(为了方便，没用抽象)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeiFeng</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Sweep</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;雷锋扫地&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//学雷锋的大学生，相当于ConcreteProduct</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>:</span> <span class=\"keyword\">public</span> LeiFeng</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Sweep</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;大学生扫地&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//学雷锋的志愿者，相当于ConcreteProduct</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Volenter</span>:</span> <span class=\"keyword\">public</span> LeiFeng</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Sweep</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;志愿者&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//工场基类Creator</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeiFengFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> LeiFeng* <span class=\"title\">CreateLeiFeng</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LeiFeng();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//工场具体类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentFactory</span> :</span> <span class=\"keyword\">public</span> LeiFengFactory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> LeiFeng* <span class=\"title\">CreateLeiFeng</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolenterFactory</span> :</span> <span class=\"keyword\">public</span> LeiFengFactory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> LeiFeng* <span class=\"title\">CreateLeiFeng</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Volenter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>客户端</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LeiFengFactory *sf=<span class=\"keyword\">new</span> LeiFengFactory();</span><br><span class=\"line\">    LeiFeng *s=sf-&gt;CreateLeiFeng();</span><br><span class=\"line\">    s-&gt;Sweep();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> sf;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优：修正了简单工厂模式中不遵守开放－封闭原则。工厂方法模式把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</p>\n<p>（三）抽象工厂模式<br>提供一个创建一系列相关或相互依赖的接口，而无需指定它们的具体类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用户抽象接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IUser</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> :</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetUser</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertUser</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//部门抽象接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IDepartment</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetDepartment</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertDepartment</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ACCESS用户</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CAccessUser</span> :</span> <span class=\"keyword\">public</span> IUser</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Access GetUser&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Access InsertUser&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ACCESS部门</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CAccessDepartment</span> :</span> <span class=\"keyword\">public</span> IDepartment</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetDepartment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Access GetDepartment&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertDepartment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Access InsertDepartment&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SQL用户</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSqlUser</span> :</span> <span class=\"keyword\">public</span> IUser</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Sql User&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;Sql User&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SQL部门类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSqlDepartment</span>:</span> <span class=\"keyword\">public</span> IDepartment</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">GetDepartment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;sql getDepartment&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">InsertDepartment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;sql insertdepartment&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//抽象工厂</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IFactory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IUser* <span class=\"title\">CreateUser</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDepartment* <span class=\"title\">CreateDepartment</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ACCESS工厂</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccessFactory</span> :</span> <span class=\"keyword\">public</span> IFactory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IUser* <span class=\"title\">CreateUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span>  CAccessUser();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDepartment* <span class=\"title\">CreateDepartment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CAccessDepartment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//SQL工厂</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlFactory</span> :</span> <span class=\"keyword\">public</span> IFactory</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IUser* <span class=\"title\">CreateUser</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span>  CSqlUser();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDepartment* <span class=\"title\">CreateDepartment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CSqlDepartment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>客户端：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    IFactory* factory= <span class=\"keyword\">new</span> SqlFactory();</span><br><span class=\"line\">    IUser* user=factory-&gt;CreateUser();</span><br><span class=\"line\">    IDepartment* depart = factory-&gt;CreateDepartment();</span><br><span class=\"line\">    user-&gt;GetUser();</span><br><span class=\"line\">    depart-&gt;GetDepartment();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"快速排序","url":"/2021/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>快速排序是对冒泡排序的一种改进。它的基本思想是：通过一次排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一不部分的所有数据都要小，然后再按次方法对这两部分数据分别进行快速排序，整个排序过程可以递归或者非递归进行，以此达到整个数据变成有序序列。</p>\n<p>像合并排序一样，快速排序也是基于分治模式的。下面是对一个典型子数组A[p..r]排序的分治过程的三个步骤：</p>\n<ul>\n<li>分解<br>数组A[p..r]]被划分成两个（可能空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A(q)，而且，小于等于A[q+1..r]中的元素。下标q也在这个划分过程中进行计算。</li>\n<li>解决<br>通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]排序。</li>\n<li>合并<br>因为两个子数组是就地排序的，将它们的合并不需要操作：整个数组A[p..r]已排序</li>\n</ul>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">QUICKSORT(A,p,r)</span><br><span class=\"line\">if p&lt;r</span><br><span class=\"line\">   then q&#x3D;PARTITION(A,p,r)</span><br><span class=\"line\">        QUICKSORT(A,p,q-1)</span><br><span class=\"line\">        QUICKSORT(A,q+1,r)</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组划分\"><a href=\"#数组划分\" class=\"headerlink\" title=\"数组划分\"></a>数组划分</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PARTITION(A,p,r)</span><br><span class=\"line\">x&#x3D;A[r]</span><br><span class=\"line\">i&#x3D;p-1</span><br><span class=\"line\">for j&#x3D;p to r-1</span><br><span class=\"line\">    do if A[j]&lt;&#x3D;x</span><br><span class=\"line\">          then i&#x3D;i+1</span><br><span class=\"line\">               exchange A[i]&lt;-&gt;A[j]</span><br><span class=\"line\">exchange A[i+1]&lt;-&gt;A[r]</span><br><span class=\"line\">return i+1</span><br></pre></td></tr></table></figure>\n<h2 id=\"选取枢纽元问题\"><a href=\"#选取枢纽元问题\" class=\"headerlink\" title=\"选取枢纽元问题\"></a>选取枢纽元问题</h2><p>1、糟糕的方法<br>     通常的做法是选择数组中第一个元素作为枢纽元，如果输入是随机的，那么这是可以接受的。但是，如果输入序列是预排序的或者是反序的，那么依据这样的枢纽元进行划分则会出现相当糟糕的情况，因为可能所有的元素不是被划入S1，就是都被划入S2中。 </p>\n<p>2、较好的方法<br>    一个比较好的做法是随机选取枢纽元，一般来说，这种策略是比较妥当的。 </p>\n<p>3、三数取取中值方法<br>    例如，输入序列为  8, 1, 4, 9, 6, 3, 5, 2, 7, 0 ，它的左边元素为8，右边元素为0，中间位置|<em>left+right）/2</em>|上的元素为6，于是枢纽元为6.显然，使用三数中值分割法消除了预排序输入的坏情形，并且减少了快速排序大约5%（此为前人实验所得数据，无法具体证明）的运行时间。</p>\n","tags":["algorithm"]},{"title":"怎样看mysql性能","url":"/2021/02/22/%E6%80%8E%E6%A0%B7%E7%9C%8Bmysql%E6%80%A7%E8%83%BD/","content":"<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow%&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow%&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<h2 id=\"连接数\"><a href=\"#连接数\" class=\"headerlink\" title=\"连接数\"></a>连接数</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;max_connections&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<h2 id=\"进程使用情况\"><a href=\"#进程使用情况\" class=\"headerlink\" title=\"进程使用情况\"></a>进程使用情况</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">global</span> status <span class=\"keyword\">like</span> ‘Thread<span class=\"operator\">%</span>’; </span><br></pre></td></tr></table></figure>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>mysql数据库常见的日志文件有：<br>错误日志（error log）<br>二进制日志（binlog）<br>慢查询日志（slow query log）<br>查询日志（log）</p>\n","tags":["mysql"]},{"title":"把lua文本文件“编译”成二进制的文本","url":"/2021/02/23/%E6%8A%8Alua%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E2%80%9C%E7%BC%96%E8%AF%91%E2%80%9D%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%96%87%E6%9C%AC/","content":"<p>当你发布lua时，你或许不想用户看到你的lua源码，更不想用户修改你的lua代码和系统内部的秘密，那就需要用别的方式来发布。</p>\n<p>最终的文本文件可以通过lua作者提供的标准发布版本中的程序来执行。这个程序称做luac.exe，把lua文本文件“编译”成二进制的文件。这样就可以让别人更难知道你的游戏是如何运行的，采用了什么技术。</p>\n<p>当写好一个lua文件后，可以通过一个典型的编译命令去“编译”这个文件：</p>\n<p>这一行代码会编译helloworld.lua脚本并在helloworld文件中生成二进制数据。<br>lua解析器并不关心你传给它的是文本文件还是二进制文件，也不关心扩展名是什么。</p>\n<p>用这个方法，就不用担心别人可以看到你的代码了。</p>\n<p>当require一个模块mod.sub时，require会用原始的模块名“mod.sub”作为key来查询table package.loaded和package.preload，其中，模块名中的点在搜索中没有任何意义。<br>当搜索一个定义子模块的文件时，require会将点转换为另一个字符，通常就是系统的目录分隔符。转换之后require就像搜索其他名称一样来搜索这个名称。<br>所以最好的方法是在编译完lua脚本后，也把二进制文件改成.lua后缀。</p>\n","tags":["lua"]},{"title":"日志分析工具","url":"/2021/02/16/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/","content":"<p>grep查找, sed 编辑, awk 根据内容分析并处理.</p>\n<ul>\n<li>grep(关键字: 截取)<br>文本搜集工具, 结合正则表达式非常强大</li>\n<li>awk(关键字:分析&amp;处理)<br>一行一行的分析处理</li>\n<li>sed(关键字: 编辑)<br>以行为单位的文本编辑工具 sed可以直接修改档案<br>sed 是一种新型的，非交互式的编辑器。它能执行与编辑器 vi 和 ex 相同的编辑任务。sed 编辑器没有提供交互式使用方式，使用者只能在命令行输入编辑命令、指定文件名，然后在屏幕上查看输出。 sed 编辑器没有破坏性，它不会修改文件，除非使用 shell 重定向来保存输出结果。默认情况下，所有的输出行都被打印到屏幕上。</li>\n<li>sort命令<br>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。’</li>\n</ul>\n<h2 id=\"根据日志查看一个服务的qps\"><a href=\"#根据日志查看一个服务的qps\" class=\"headerlink\" title=\"根据日志查看一个服务的qps\"></a>根据日志查看一个服务的qps</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tail -f XXX.log</span><br></pre></td></tr></table></figure>\n<p>命令：tail -f XXX.log | grep recommend.components.KeywordService | cut -d’ ‘ -f2 | cut -d’:’ -f3 | uniq -c<br>说明：取增量 | 一个请求取一行 | 把时间截取出来 | 把秒数截取出来 | 去重取计数</p>\n","tags":["linux"]},{"title":"查看linux的情况","url":"/2021/02/22/%E6%9F%A5%E7%9C%8Blinux%E7%9A%84%E6%83%85%E5%86%B5/","content":"<h2 id=\"查看进程内存占用情况\"><a href=\"#查看进程内存占用情况\" class=\"headerlink\" title=\"查看进程内存占用情况\"></a>查看进程内存占用情况</h2><p>以直接使用top命令后，查看%MEM的内容。可以选择按进程查看或者按用户查看，如想查看oracle用户的进程内存使用情况的话可以使用如下的命令：</p>\n<p>(1)top<br>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器<br>可以直接使用top命令后，查看%MEM的内容。可以选择按进程查看或者按用户查看，如想查看oracle用户的进程内存使用情况的话可以使用如下的命令：<br>$ top -u oracle</p>\n<h3 id=\"与ps的不同\"><a href=\"#与ps的不同\" class=\"headerlink\" title=\"与ps的不同\"></a>与ps的不同</h3><p>ps看到的是命令执行瞬间的进程信息,而top可以持续的监视<br>ps只是查看进程,而top还可以监视系统性能,如平均负载,cpu和内存的消耗</p>\n<h2 id=\"打印某个程序的线程栈\"><a href=\"#打印某个程序的线程栈\" class=\"headerlink\" title=\"打印某个程序的线程栈\"></a>打印某个程序的线程栈</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pstack $pid</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看存储空间\"><a href=\"#查看存储空间\" class=\"headerlink\" title=\"查看存储空间\"></a>查看存储空间</h2><p>先看看根目录下面<br>du -sh /* </p>\n<p>下面这条命令就是显示所有隐藏文件和非隐藏文件的大小并根据占用空间排序的语句<br>du -sh .[!.]* * | sort -hr  </p>\n<p>看磁盘使用情况<br>df -h</p>\n<h2 id=\"查看系统信息\"><a href=\"#查看系统信息\" class=\"headerlink\" title=\"查看系统信息\"></a>查看系统信息</h2><p>lsb_release -a</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">No LSB modules are available.</span><br><span class=\"line\">Distributor ID: Ubuntu</span><br><span class=\"line\">Description:    Ubuntu 16.04.5 LTS</span><br><span class=\"line\">Release:        16.04</span><br><span class=\"line\">Codename:       xenial</span><br></pre></td></tr></table></figure>\n<p>uname -a</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Linux coding.ide 3.10.107-1-tlinux2_kvm_guest-0046.cd.nosign #1 SMP Wed Jan 31 15:25:12 CST 2018 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure>","tags":["linux"]},{"title":"游戏中的Lua","url":"/2021/02/23/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84Lua/","content":"<p>lua作为一种脚本语言，可以快速地开发游戏的原型。提高游戏的开发效率。<br>最熟悉不过的就是作为魔兽世界、博德之门、愤怒的小鸟等游戏的脚本语言。</p>\n<p>但是，具体来说，lua在游戏中可以做什么呢？<br>在游戏中，lua可以用来完成下面这些工作：<br>● 编辑游戏的用户界面<br>● 定义、存储和管理基础游戏数据<br>● 管理实时游戏事件<br>● 创建和维护开发者友好的游戏存储和载入系统<br>● 编写游戏游戏的人工智能系统<br>● 创建功能原型，可以之后用高性能语言移植</p>\n<h2 id=\"编辑游戏界面\"><a href=\"#编辑游戏界面\" class=\"headerlink\" title=\"编辑游戏界面\"></a>编辑游戏界面</h2><p>进行界面布局、管理用户输入并且输出游戏数据。提高了界面设计的灵活性，为程序员节省不少时间。</p>\n<h2 id=\"管理游戏数据\"><a href=\"#管理游戏数据\" class=\"headerlink\" title=\"管理游戏数据\"></a>管理游戏数据</h2><p>Lua可以让游戏存储系统更为简单，可以令Lua更方便地和数据库交互。方便按照需要修改、增加和缩减游戏数据。Lua本身并没有可以直接访问外部数据库的能力，但可以用C/C++开发访问数据库的组件，然后再利用LuaGlue函数整合该组件来达到目的。</p>\n<h2 id=\"处理游戏事件\"><a href=\"#处理游戏事件\" class=\"headerlink\" title=\"处理游戏事件\"></a>处理游戏事件</h2><p>其实就是利用lua与C/C++交互，在C/C++开发的事件系统中，用Lua来接收和处理这些事件。</p>\n<h2 id=\"保存和读取游戏状态\"><a href=\"#保存和读取游戏状态\" class=\"headerlink\" title=\"保存和读取游戏状态\"></a>保存和读取游戏状态</h2><p>利用Lua标准的输入/输出函数，编写一个函数来保存游戏数据到可执行的Lua脚本中是很好的方法。而且还可以利用脚本编译函数来为游戏数据加密。</p>\n<h2 id=\"游戏中的人工智能\"><a href=\"#游戏中的人工智能\" class=\"headerlink\" title=\"游戏中的人工智能\"></a>游戏中的人工智能</h2><p>这里说的人工智能不是那些对性能要求很好的算法。像路径寻找这些数据运算量很大的工作，计算机需要反复测试可能的路径来寻找最短或者最直接的路径，就需要用到C/C++这类底层语言来实现。但一些依赖有限的数据集合和参数的人工智能就更适合用Lua来编写了。</p>\n<h2 id=\"快速构建原型\"><a href=\"#快速构建原型\" class=\"headerlink\" title=\"快速构建原型\"></a>快速构建原型</h2><p>Lua是构建可移植的核心游戏功能原型的不错工具。在游戏开发中，可以先用Lua构建出算法的结构，如果碰到有高性能需求的函数就可以用底层语言来实现。</p>\n<h2 id=\"动态加载调试\"><a href=\"#动态加载调试\" class=\"headerlink\" title=\"动态加载调试\"></a>动态加载调试</h2><p>这也是脚本的一个普遍功能，只需要应用重新加载脚本，就可以完成修改，调试的时候不用再等系统“慢慢编译了”。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Lua的优点是可以快速地编写简单的游戏模型，并快速验证和迭代想法。在游戏开发领域，Lua和C/C++是一个功能十分强大的组合，使游戏开发更加随心所欲。</p>\n","tags":["lua"]},{"title":"用插件将 issues内容转换成博客的内容","url":"/2021/01/24/%E7%94%A8%E6%8F%92%E4%BB%B6%E5%B0%86-issues%E5%86%85%E5%AE%B9%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%86%85%E5%AE%B9/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前已经用<a href=\"https://github.com/losophy/losophy.github.io/issues/6\">Hexo+GitHub Pages博客搭建</a></p>\n<p>Hexo默认文章存放于source分支，没有评论系统，不过都可以通过插件进行扩展。本文介绍如何将hexo的文章与评论存放于Github Issue中（issue内容为博客内容，issue评论为博客评论）。</p>\n<h2 id=\"使用github-issue存放文章\"><a href=\"#使用github-issue存放文章\" class=\"headerlink\" title=\"使用github issue存放文章\"></a>使用github issue存放文章</h2><p>这种方案主要优点是，可以专心写博客系统，不用关注Hexo本身内容。还可以直接使用GitHub的图床（已墙），使用GitHub图床非常简单，把图片文件拖到编辑框就行了。</p>\n<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><p>npm install hexo-migrator-github-issue –save</p>\n<h2 id=\"导入文章\"><a href=\"#导入文章\" class=\"headerlink\" title=\"导入文章\"></a>导入文章</h2><p>hexo migrate github-issue 你的Github用户名/你存放hexo的仓库名</p>\n<p>然后生成部署即可。<br>hexo g<br>hexo d</p>\n<h2 id=\"使用github-issue存放评论\"><a href=\"#使用github-issue存放评论\" class=\"headerlink\" title=\"使用github issue存放评论\"></a>使用github issue存放评论</h2>","tags":["blog"]},{"title":"线程，进程，锁，协程","url":"/2021/02/22/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E9%94%81%EF%BC%8C%E5%8D%8F%E7%A8%8B/","content":"<p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。</p>\n<p>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈、局部变量和指令指针。</p>\n<h2 id=\"线程和进程的区别和优劣\"><a href=\"#线程和进程的区别和优劣\" class=\"headerlink\" title=\"线程和进程的区别和优劣\"></a>线程和进程的区别和优劣</h2><ul>\n<li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li>\n<li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li>\n<li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li>\n<li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li>\n</ul>\n<h2 id=\"线程：锁\"><a href=\"#线程：锁\" class=\"headerlink\" title=\"线程：锁\"></a>线程：锁</h2><p>互斥锁、自旋锁、读写锁和条件变量</p>\n<h3 id=\"互斥锁（mutex-lock）\"><a href=\"#互斥锁（mutex-lock）\" class=\"headerlink\" title=\"互斥锁（mutex lock）\"></a>互斥锁（mutex lock）</h3><p><strong>一条线程加锁锁住临界区，另一条线程尝试访问改临界区的时候，会发生阻塞，并进入休眠状态。临界区是锁lock和unlock之间的代码片段，一般是多条线程能够共同访问的部分。</strong><br>具体说明：假设一台机器上的cpu有两个核心core0和core1，现在有线程A、B、C，此时core0运行线程A，core1运行线程B，此时线程B使用Mutex锁，锁住一个临界区，当线程A试图访问该临界区时，因为线程B已经将其锁住，因此线程A被挂起，进入休眠状态，此时core0进行上下文切换，将线程A放入休眠队列中，然后core0运行线程C，当线程B完成临界区的流程并执行解锁之后，线程A又会被唤醒，core0重新运行线程A</p>\n<h3 id=\"自旋锁（spinlock）\"><a href=\"#自旋锁（spinlock）\" class=\"headerlink\" title=\"自旋锁（spinlock）\"></a>自旋锁（spinlock）</h3><p><strong>一条线程加锁锁住临界区，另一条线程尝试访问该临界区的时候，会发生阻塞，但是不会进入休眠状态，并且不断轮询该锁，直至原来锁住临界区的线程解锁。</strong><br>具体说明：假设一台机器上有两个核心core0和core1，现在有线程A、B、C，此时core0运行线程A，core1运行线程B，此时线程B调用spin lock锁住临界区，当线程A尝试访问该临界区时，因为B已经加锁，此时线程A会阻塞，并且不断轮询该锁，不会交出core0的使用权，当线程B释放锁时，A开始执行临界区逻辑</p>\n<h3 id=\"读写锁（readers–writer-lock）\"><a href=\"#读写锁（readers–writer-lock）\" class=\"headerlink\" title=\"读写锁（readers–writer lock）\"></a>读写锁（readers–writer lock）</h3><p>一共三种状态</p>\n<ul>\n<li>读状态时加锁，此时为共享锁，当一个线程加了读锁时，其他线程如果也尝试以读模式进入临界区，那么不会发生阻塞，直接访问临界区</li>\n<li>写状态时加锁，此时为独占锁，当某个线程加了写锁，那么其他线程尝试访问该临界区（不论是读还是写），都会阻塞等待</li>\n<li>不加锁<br>某线程加读取锁时，允许其他线程以读模式进入，此时如果有一个线程尝试以写模式访问临界区时，该线程会被阻塞，而其后尝试以读方式访问该临界区的线程也会被阻塞<br>读写锁适合在读远大于写的情形中使用</li>\n</ul>\n<h3 id=\"条件变量（condition-variables）\"><a href=\"#条件变量（condition-variables）\" class=\"headerlink\" title=\"条件变量（condition variables）\"></a>条件变量（condition variables）</h3><p>假设A,B,C三条线程，其中B,C线程加了condwait锁并投入睡眠，而A线程则在某个条件触发时，会通过signal通知B,C线程，从而唤醒B和C线程。</p>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><p>从概念上讲线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作地运行。就是说，一个具有多个协同程序的程序在任意时刻只能运行一个协同程序，并且正在运行的协同程序只会在其显式地要求挂起（suspend）时，它的执行才会暂停。</p>\n","tags":["linux"]},{"title":"网络游戏服务器开发注意事项","url":"/2021/03/09/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"<h2 id=\"逻辑问题\"><a href=\"#逻辑问题\" class=\"headerlink\" title=\"逻辑问题\"></a>逻辑问题</h2><p>==判断限制太死了，少用点<br>使用while true时，可能造成死循环，应该添加保险措施，必现因为逻辑问题导致的死循环</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> weaponType ~= sword <span class=\"keyword\">do</span></span><br><span class=\"line\">    check = check + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"number\">1000</span> &lt; check <span class=\"keyword\">then</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>递归调用也有可能会出现堆栈溢出，也需要加上保险措施</p>\n<p>local不能热更，用local时，要考虑会不会有热更的情况<br>因为不同语言的版本会共用一套代码，不同时区发时间会有问题，同步会有问题，改用发时间戳<br>禁止广泛采用param arg等表示某一类参数，统一加上对应的模块或功能特性声明，比如：CreateRole(roleParam)</p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><p>协议字段要小，省宽带<br>协议接口目录统一，方便热更新</p>\n<h2 id=\"检查验收\"><a href=\"#检查验收\" class=\"headerlink\" title=\"检查验收\"></a>检查验收</h2><p>查看传入参数判空，长命名，默认值，参数检测，snsaerro中断会发生的问题<br>用户登录时，不要有中断发生<br>用户登录时，所有下推合成一个包发送</p>\n<p>所有的物品接口是遵循这个规律的（物品先扣再发）：<br>1.检测<br>2.扣钱、资源<br>3.发物品,修改数据</p>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h3><p>odm不要设计成第一层就用map，后续加字段会很困难</p>\n<h3 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h3><p>数据库用cache，定时存入<br>因为mysql写入的数据都是冷数据（只增，部分读），所以处理比较简单<br>（核查记录，邮件）这些业务交给网页部门，服务器拿网页接口</p>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>配置文件转换时，不要出现值为2.0这种错误</p>\n<h3 id=\"编写validate-lua\"><a href=\"#编写validate-lua\" class=\"headerlink\" title=\"编写validate.lua\"></a>编写validate.lua</h3><p>每新增配置表，策划有可能会配置错误的项目都需要添加检测。确保跑validate时，不会因配置错误，而出现程序出错。</p>\n<h2 id=\"时间戳\"><a href=\"#时间戳\" class=\"headerlink\" title=\"时间戳\"></a>时间戳</h2><p>传时间戳，不要传时间字符，跨时间，会影响不同语言版本的逻辑</p>\n<h2 id=\"计量\"><a href=\"#计量\" class=\"headerlink\" title=\"计量\"></a>计量</h2><p>尽是用‱，少用%</p>\n"},{"title":"虚拟文件系统","url":"/2021/02/09/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>它是允许和操作系统使用不同的文件系统实现的接口。</p>\n<h2 id=\"分层结构\"><a href=\"#分层结构\" class=\"headerlink\" title=\"分层结构\"></a>分层结构</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/107371276-124b1200-6b1f-11eb-9cb4-41adcfc6297a.png\" alt=\"屏幕快照 2021-02-09 下午9 37 21\"></p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>对所有不同文件系统的抽象</p>\n<h2 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h2><ul>\n<li>提供相同的文件和文件系统接口</li>\n<li>管理所有文件和文件系统关联的数据结构</li>\n<li>高效查询例程，遍历文件系统</li>\n<li>与特定文件系统模块的交互</li>\n</ul>\n<h2 id=\"文件系统基本数据结构\"><a href=\"#文件系统基本数据结构\" class=\"headerlink\" title=\"文件系统基本数据结构\"></a>文件系统基本数据结构</h2><h3 id=\"文件卷控制块（Unix-superblock）\"><a href=\"#文件卷控制块（Unix-superblock）\" class=\"headerlink\" title=\"文件卷控制块（Unix: superblock）\"></a>文件卷控制块（Unix: superblock）</h3><ul>\n<li>每个文件系统一个</li>\n<li>文件系统详细信息</li>\n<li>块、块大小、空余块、计数/ 指针等</li>\n</ul>\n<h3 id=\"文件控制块（Unix-vnode或者inode）\"><a href=\"#文件控制块（Unix-vnode或者inode）\" class=\"headerlink\" title=\"文件控制块（Unix: vnode或者inode）\"></a>文件控制块（Unix: vnode或者inode）</h3><ul>\n<li>每个文件一个</li>\n<li>文件详细信息</li>\n<li>访问权限、拥有者、大小、数据块位置等</li>\n</ul>\n<h3 id=\"目录项（Linux-dentry）\"><a href=\"#目录项（Linux-dentry）\" class=\"headerlink\" title=\"目录项（Linux: dentry）\"></a>目录项（Linux: dentry）</h3><ul>\n<li>每个目录项一个（目录和文件）</li>\n<li>将目录项数据结构及树型布局编码成树型数据结构</li>\n<li>指向文件控制块、父目录、子目录等</li>\n</ul>\n<h2 id=\"文件系统的组织视图\"><a href=\"#文件系统的组织视图\" class=\"headerlink\" title=\"文件系统的组织视图\"></a>文件系统的组织视图</h2><p><img src=\"https://user-images.githubusercontent.com/11263320/107373169-2f80e000-6b21-11eb-91ea-5e68e24bac7e.png\" alt=\"屏幕快照 2021-02-09 下午9 52 38\"></p>\n<h2 id=\"文件系统的存储\"><a href=\"#文件系统的存储\" class=\"headerlink\" title=\"文件系统的存储\"></a>文件系统的存储</h2><p>持久存储在外存中，存储设备的数据块中<br>当需要时加载进内存</p>\n<ul>\n<li>卷控制模块：当文件系统挂载时进入内存</li>\n<li>文件控制块：当文件被访问时进入内存</li>\n<li>目录节点：在遍历一个文件路径时进入内存</li>\n</ul>\n<h3 id=\"文件系统的存储视图\"><a href=\"#文件系统的存储视图\" class=\"headerlink\" title=\"文件系统的存储视图\"></a>文件系统的存储视图</h3><p><img src=\"https://user-images.githubusercontent.com/11263320/107374773-ea5dad80-6b22-11eb-9710-f59ed5a38305.png\" alt=\"屏幕快照 2021-02-09 下午10 04 13\"></p>\n","tags":["linux"]},{"title":"计算机业余英语","url":"/2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%9A%E4%BD%99%E8%8B%B1%E8%AF%AD/","content":"<p>knapsack-&gt;背包<br>copy-&gt;游戏副本<br>redPacket-&gt;红包</p>\n<h2 id=\"常见缩写化简字段名大小\"><a href=\"#常见缩写化简字段名大小\" class=\"headerlink\" title=\"常见缩写化简字段名大小\"></a>常见缩写化简字段名大小</h2><p>level-&gt;lv<br>current-&gt;cur</p>\n"},{"title":"软件设计那么事","url":"/2021/02/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E9%82%A3%E4%B9%88%E4%BA%8B/","content":"<h2 id=\"软件生命周期-Systems-Development-Life-Cycle\"><a href=\"#软件生命周期-Systems-Development-Life-Cycle\" class=\"headerlink\" title=\"软件生命周期(Systems Development Life Cycle )\"></a>软件生命周期(Systems Development Life Cycle )</h2><p>需求分析-&gt;设计-&gt;编码-&gt;测试-&gt;发布-&gt;维护</p>\n<h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>这阶段是软件开发的最初阶段，也是最重要的阶段。明确的需求，可以在之后的开发中，少走弯路。<br>这个阶段也要和需求方共同讨论，有时候也需要开会，集中各参与者的意见。</p>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><p>这阶段要对整个软件系统进行设计，确定要用什么技术，什么方法，怎样的设计模式。</p>\n<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>将软件设计的结果转换成计算机可运行的程序代码。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>对软件进行测试，黑白盒测试。</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>测试没有问题后，就可以上线发布。是一些新功能，或者是一些bug补丁。</p>\n<h3 id=\"维护\"><a href=\"#维护\" class=\"headerlink\" title=\"维护\"></a>维护</h3><p>软件维护是软件生命周期中持续时间最长的阶段。软件的维护包括纠错性维护和改进性维护两个方面。</p>\n"},{"title":"进程间通信ipc、线程间通信","url":"/2021/02/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1ipc%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>进程间通信(IPC,Inter-Process Communication)指至少两个进程或线程间传送数据或信号的一些技术或方法。<br>进程是计算机系统分配资源的最小单位(严格说来是线程)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。（但是采用了某种形式的内核开销，降低了性能）</p>\n<h2 id=\"常用的进程间通信\"><a href=\"#常用的进程间通信\" class=\"headerlink\" title=\"常用的进程间通信\"></a>常用的进程间通信</h2><h3 id=\"管道（包括无名管道和命名管道）\"><a href=\"#管道（包括无名管道和命名管道）\" class=\"headerlink\" title=\"管道（包括无名管道和命名管道）\"></a>管道（包括无名管道和命名管道）</h3><p>管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。<br>无名管道，是 UNIX 系统IPC最古老的形式。基于管道文件操作。<br>管道通信特点是：速度慢，容量有限，只有父子进程能通讯（FIFO：任何进程间都能通讯，但速度慢）</p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>是消息的链接表，存放在内核中。特点是容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</p>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<br>特点是不能传递复杂消息，只能用来同步。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>指两个或多个进程共享一个给定的存储区。是最快的一种 IPC，因为进程是直接对内存进行存取。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。<br>特点是能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</p>\n<h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p>socket一般指套接字。所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。<br>特点是I/O复用提供一种能力，这种能力使得当一个I/O条件满足时，进程能够及时得到这个信息。适合（远程过程调用、集群）。</p>\n<h2 id=\"几种线程间的通信机制\"><a href=\"#几种线程间的通信机制\" class=\"headerlink\" title=\"几种线程间的通信机制\"></a>几种线程间的通信机制</h2><h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h3><ul>\n<li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li>\n<li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li>\n<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\n</ul>\n<h3 id=\"信号量机制\"><a href=\"#信号量机制\" class=\"headerlink\" title=\"信号量机制\"></a>信号量机制</h3><p>包括无名线程信号量与有名线程信号量</p>\n<h3 id=\"信号机制\"><a href=\"#信号机制\" class=\"headerlink\" title=\"信号机制\"></a>信号机制</h3><p>类似于进程间的信号处理。</p>\n<p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p>\n","tags":["linux"]},{"title":"连接Github与本地","url":"/2021/01/25/%E8%BF%9E%E6%8E%A5Github%E4%B8%8E%E6%9C%AC%E5%9C%B0/","content":"<h2 id=\"配置用户名和邮箱\"><a href=\"#配置用户名和邮箱\" class=\"headerlink\" title=\"配置用户名和邮箱\"></a>配置用户名和邮箱</h2><p>首先输入下面命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;你的github用户名&quot;</span><br><span class=\"line\">git config --global user.email &quot;你的github注册邮箱&quot;</span><br></pre></td></tr></table></figure>\n<p>用户名和邮箱根据你注册github的信息自行修改。</p>\n<h2 id=\"上传SSH-key\"><a href=\"#上传SSH-key\" class=\"headerlink\" title=\"上传SSH key\"></a>上传SSH key</h2><p>生成密钥SSH key：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;你的注册邮箱&quot;</span><br></pre></td></tr></table></figure>\n<p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。<br>cmd中cat ~/.ssh/id_rsa.pub<br>将输出的内容复制到框中，点击确定保存。<br>输入ssh -T <a href=\"mailto:&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#109;\">&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#109;</a>，出现你的用户名，那就成功了。</p>\n","tags":["git"]},{"title":"lua环境与模块","url":"/2021/02/23/lua%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%A8%A1%E5%9D%97/","content":"<p>Lua实现了一个安全的运行环境、一套自动内存管理机制、优秀的字符串处理能力和动态大小数据的处理功能。</p>\n<p>我们都知道，只要应用程序加入lua解析器的功能，就能解析lua脚本。那lua脚本是怎样执行的？<br>我们通常用dofile去打开编译一个lua脚本。当应用程序调用dofile后，在执行完脚本后，才能后到主程序中，这lua脚本相当于一个函数。要等函数执行完才能回到主程序中。<br>在lua脚本中，一般有变量，函数，这些东西都保存在一个常规的table中，这个table称为“环境”。</p>\n<h2 id=\"loadfile、dofile、require\"><a href=\"#loadfile、dofile、require\" class=\"headerlink\" title=\"loadfile、dofile、require\"></a>loadfile、dofile、require</h2><p>loadfile——只加载编译，不运行<br>dofile——执行<br>require——只执行一次</p>\n<p>用require函数只能加载一次,因为它的特性是:<br>1、require函数会搜索目录加载文件<br>2、require会判断是否文件已经加载避免重复加载同一文件。<br>但当有一些特殊的需求需要反复加载某个lua文件，那如何实现反复加载一个lua文件?<br>答案是:二次加载前加这一句<br>package.loaded[luafile] = nil</p>\n<h2 id=\"环境相关的变量\"><a href=\"#环境相关的变量\" class=\"headerlink\" title=\"环境相关的变量\"></a>环境相关的变量</h2><p>这里首先分析几个与环境相关的特殊变量一–Global表 、 env表 、 registry表以及UpValue 。<br>关于前3个表，需要注意以下几点 。</p>\n<ul>\n<li>Global表存放在 lua State结构体中也称为G表 。 每个 lua State结构体都有一个对应的G表。 不用多说，这个表就是存放全局变量的。</li>\n<li>env表存放在Closure结构体中，也就是每个函数有自己独立的一个环境 。</li>\n<li>registry表是全局唯一的，它存放在global_State结构体中，这个结构体在整个运行环境中只有一个。</li>\n</ul>\n<p>在讲解OP G ETG LOBAL 以及OP SETG LOBA L指令时说到，查找一个全局变量的操作，其实更精确地说，是在当前函数的 env表中查找 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> OP_GETGLOBAL: &#123;</span><br><span class=\"line\">        TValue g;</span><br><span class=\"line\">        TValue *rb = KBx(i);</span><br><span class=\"line\">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class=\"line\">        lua_assert(ttisstring(rb));</span><br><span class=\"line\">        Protect(luaV_gettable(L, &amp;g, rb, ra));</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"keyword\">case</span> OP_SETGLOBAL: &#123;</span><br><span class=\"line\">        TValue g;</span><br><span class=\"line\">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class=\"line\">        lua_assert(ttisstring(KBx(i)));</span><br><span class=\"line\">        Protect(luaV_settable(L, &amp;g, KBx(i), ra));</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这两个操作都是到函数对应的Closure指针中的巴nv表去查询数据 。 这里仍然需要提醒一下前面提到的一点，即使对一个没有任何函数的代码而言，分析完毕之后都对应一个Closure 。 因此，这里提到的“当前函数环境”，指的不一定是某一个具体的函数，也可能是一个Lua文件 。</p>\n<p>Lua提供了几个API来读取当前函数的环境，分别是getfenv和 setfenv<br>因此，如果执行以下代码：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setfenv</span>(<span class=\"number\">1</span>,&#123;&#125;)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n<p>实际上找不到Lua标准库提供的 print函数，并且会提示报错attempt to call global ’庐山’（a nilvalue） 。 原因就是首先使用 setfenv 函数将当前函数的 env表置为一个空表，此时在当前函数的 env表中查找不到这个名字的函数。</p>\n<p>下面来看看函数的 env表是如何创建的 。 在创建一个Closure对象时，都会调用getcurrenv函数来获取当前的环境表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Table *<span class=\"title\">getcurrenv</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (L-&gt;ci == L-&gt;base_ci)  <span class=\"comment\">/* no enclosing function? */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hvalue(gt(L));  <span class=\"comment\">/* use global table as environment */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Closure *func = curr_func(L);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func-&gt;c.env;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它将区分如下两种情况</p>\n<ul>\n<li>如果该函数不是内嵌函数，那么直接返回G表</li>\n<li>再则，如果是内嵌函数，就返回其母函数的 env表</li>\n</ul>\n<p>在创建一个新的 Closure时，会调用这个函数返回的结果，对新的Closure的环境进行赋值。这里可以看出， env表会逐层继承。</p>\n<p>接着来看看registry表的作用，该表存放在global_State结构体中，因此里面的内容可供多个 lua State访问 。 另外，这个表只能由 C代码访问， Lua代码不能访问 。 除此之外，它和普通的表没有什么区别 。</p>\n<p>但是需要注意的是，使用普通的对表进行赋值的API对registry表进行赋值时，应该使用字符串类型的键。 LuaAPI中对外提供了接口 lua_ref 、 lua_unre于和lua_getref ，用于提供在registry表中存取唯一的数字键。 通过这组API ，使用者不需要关心给某个需要存放到registry表的数据如何分配一个全局唯一的键，由 Lua解释器自己来保证这一点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \\</span></span><br><span class=\"line\">      (lua_pushstring(L, <span class=\"string\">&quot;unlocked references are obsolete&quot;</span>), lua_error(L), <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))</span></span><br></pre></td></tr></table></figure>\n<p>接着来看看这里面lual ref和 lu a L unref函数的实现。 需要说明的是，在调用 luaL ref函数之前，需要存放的数据已经位于枝顶：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">int</span> <span class=\"title\">luaL_ref</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ref;</span><br><span class=\"line\">  t = abs_index(L, t);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lua_isnil(L, <span class=\"number\">-1</span>)) &#123;</span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove from stack */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> LUA_REFNIL;  <span class=\"comment\">/* `nil&#x27; has a unique fixed reference */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_rawgeti(L, t, FREELIST_REF);  <span class=\"comment\">/* get first free element */</span></span><br><span class=\"line\">  ref = (<span class=\"keyword\">int</span>)lua_tointeger(L, <span class=\"number\">-1</span>);  <span class=\"comment\">/* ref = t[FREELIST_REF] */</span></span><br><span class=\"line\">  lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove it from stack */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ref != <span class=\"number\">0</span>) &#123;  <span class=\"comment\">/* any free element? */</span></span><br><span class=\"line\">    lua_rawgeti(L, t, ref);  <span class=\"comment\">/* remove it from list */</span></span><br><span class=\"line\">    lua_rawseti(L, t, FREELIST_REF);  <span class=\"comment\">/* (t[FREELIST_REF] = t[ref]) */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* no free elements */</span></span><br><span class=\"line\">    ref = (<span class=\"keyword\">int</span>)lua_objlen(L, t);</span><br><span class=\"line\">    ref++;  <span class=\"comment\">/* create new reference */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_rawseti(L, t, ref);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ref;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">void</span> <span class=\"title\">luaL_unref</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> ref)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ref &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    t = abs_index(L, t);</span><br><span class=\"line\">    lua_rawgeti(L, t, FREELIST_REF);</span><br><span class=\"line\">    lua_rawseti(L, t, ref);  <span class=\"comment\">/* t[ref] = t[FREELIST_REF] */</span></span><br><span class=\"line\">    lua_pushinteger(L, ref);</span><br><span class=\"line\">    lua_rawseti(L, t, FREELIST_REF);  <span class=\"comment\">/* t[FREELIST_REF] = ref */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的设计其实很巧妙，仅使用一个数组就模拟了一个链表的实现，其原理如下</p>\n<ul>\n<li>FREELIST_REF用于保存当前registry表中可用键的索引，每次需要存储之前，都会先到这里拿到当前存放的值。</li>\n<li>如果拿出来的值是0 ，说明当前的h巳list中还没有数据，直接返回当前registry表的数据盐作为新的索引 。</li>\n<li>当调用 lual unref释放一个索引值的时候，将该索引值返回 FREELIST REF链表中 。</li>\n</ul>\n<p>下图演示了分配可用索引前后freelist的变化<br><img src=\"https://user-images.githubusercontent.com/11263320/113692378-126f2480-9700-11eb-99a2-8a8d4bbea09a.JPG\" alt=\"捕获\"><br>最后来看UpValue 。 前面谈到， registry表提供的是全局变量的存储， env表提供的是函数内全局变茸的存储，而UpValue用于提供函数内静态变量的存储，这些变量存储的地方，倒不是某个特殊的表，其实就是换算成对应的UpValue的索引值来访问函数的UpValue数组而已<br>接着我们来看一个关键的函数index2adr ，这个函数集中处理了所有索引值转换为械地址值的操作，不论该索’寻｜是椅上元素的索引，还是前面这几种特殊变量的索引：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** pseudo-indices</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_REGISTRYINDEX\t(-10000)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_ENVIRONINDEX\t(-10001)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LUA_GLOBALSINDEX\t(-10002)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lua_upvalueindex(i)\t(LUA_GLOBALSINDEX-(i))</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> TValue *<span class=\"title\">index2adr</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (idx &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    TValue *o = L-&gt;base + (idx - <span class=\"number\">1</span>);</span><br><span class=\"line\">    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o &gt;= L-&gt;top) <span class=\"keyword\">return</span> cast(TValue *, luaO_nilobject);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idx &gt; LUA_REGISTRYINDEX) &#123;</span><br><span class=\"line\">    api_check(L, idx != <span class=\"number\">0</span> &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L-&gt;top + idx;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">switch</span> (idx) &#123;  <span class=\"comment\">/* pseudo-indices */</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_REGISTRYINDEX: <span class=\"keyword\">return</span> registry(L);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_ENVIRONINDEX: &#123;</span><br><span class=\"line\">      Closure *func = curr_func(L);</span><br><span class=\"line\">      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &amp;L-&gt;env;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_GLOBALSINDEX: <span class=\"keyword\">return</span> gt(L);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">      Closure *func = curr_func(L);</span><br><span class=\"line\">      idx = LUA_GLOBALSINDEX - idx;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (idx &lt;= func-&gt;c.nupvalues)</span><br><span class=\"line\">                ? &amp;func-&gt;c.upvalue[idx<span class=\"number\">-1</span>]</span><br><span class=\"line\">                : cast(TValue *, luaO_nilobject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的逻辑主要是根据传人的 idx的几种情况，分别返回不同的值。</p>\n<ul>\n<li>如果 idx &gt;O ，那么以 idx值为索引，返回基于 lua State的 base指针的值，也就是相对于战底向上的偏移值。</li>\n<li>如果 idx&gt;LUA_REGISTRYINDEX ，则以 idx值为索引，返回基于 l ua_State的top指针的值，也就是相对于钱顶向下的偏移值。</li>\n<li>如果是LUA_REGISTRYINDEX ，那么返回 registry表。</li>\n<li>如果是LUA ENVIRONINDEX ，那么返回当前函数的env表。</li>\n<li>如果是LUA GLOBALSINDEX ，那么返回Global表。</li>\n<li>如果以上都不符合，那么将根据情况返回当前函数的叩value数组中的值。</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>这一节将讲解Lua模块相关的知识点，首先介绍模块的加载、编写等原理，然后介绍热更新原理。</p>\n<h3 id=\"模块的加载\"><a href=\"#模块的加载\" class=\"headerlink\" title=\"模块的加载\"></a>模块的加载</h3><p>在Lua内部，所有模块的注册都在linit.c的函数lual_openlibs 中提供。 可以看到，它依次访问lualibs数组中的成员，这些成员定义了每个模块的模块名及相应的模块注册函数，依次调用每个模块的注册函数完成模块的注册 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> luaL_Reg lualibs[] = &#123;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;&quot;</span>, luaopen_base&#125;,</span><br><span class=\"line\">  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,</span><br><span class=\"line\">  &#123;LUA_TABLIBNAME, luaopen_table&#125;,</span><br><span class=\"line\">  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class=\"line\">  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br><span class=\"line\">  &#123;LUA_STRLIBNAME, luaopen_string&#125;,</span><br><span class=\"line\">  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,</span><br><span class=\"line\">  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class=\"line\">  &#123;<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">void</span> <span class=\"title\">luaL_openlibs</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> luaL_Reg *lib = lualibs;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; lib-&gt;func; lib++) &#123;</span><br><span class=\"line\">    lua_pushcfunction(L, lib-&gt;func);</span><br><span class=\"line\">    lua_pushstring(L, lib-&gt;name);</span><br><span class=\"line\">    lua_call(L, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体lual_Reg有两个变量，分别是模块名以及模块初始化函数。 可以看到，第一个模块是base模块，其模块名是一个空字符串，因此访问这个模块的函数不需要加模块名前缀，比如我们熟悉的 print 函数就是属于这个模块的 。 这就是在调用 print函数时，不需要在前面加模块名前缀的原因 。 这里就以 base模块为例来讲解模块的注册过程。</p>\n<p>加载base模块最终会调用 base_open函数，下面我们看看这个函数里面最核心的几行代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">base_open</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* set global _G */</span></span><br><span class=\"line\">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class=\"line\">  lua_setglobal(L, <span class=\"string\">&quot;_G&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* open lib into global table */</span></span><br><span class=\"line\">  luaL_register(L, <span class=\"string\">&quot;_G&quot;</span>, base_funcs);</span><br></pre></td></tr></table></figure>\n<p>最开始的两句首先将 LUA_GLOBA LSINDEX对应的值压人拢中，接着调用 lua_setglobal(L ,二C ”） ; , e n 当在 lua_State 的 l_gt表中查找工C”时，查找到的是索引值为 LUA_GLOBALSINDEX的表 。如果觉得有点绕，可以简单理解为，在C表满足这个等式＿G = _G ［二G”］ 。 也就是这个叫＿G的表内部有一个key为二G”的表是指向自己的 。 可以在Lua命令行中执行print(_G ）和 print(_G ［”＿G”］）看看输出结果，来验证一下这个结论。</p>\n<p>我猜想这么处理的理由是 ： 为了让G表和其他表使用同样的机制 。 查找变量时，最终会一直顺着层次往上查到G表中，这是很自然的事情 。 所以，为了也能按照这个机制顺利地查找到自己，于是在G表中有一个同名成员指向自己 。</p>\n<p>好了，前两句的作用已经分析完毕，其结果有以下两个 ：</p>\n<ul>\n<li>＿G = _G [”_G”]</li>\n<li>G表的值压入函数枝中方便后面的调用 。</li>\n</ul>\n<p>所以，这个G表的注册操作需要在所有模块注册之前进行。</p>\n<p>在第63 1行中， base_fu n cs也是一个lual_Reg数组，上面的操作会将base_funcs数组中的函数注册到G表中，但是里面还有些细节需要看看。 这个操作最终会调用函数luaI←openlib:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">void</span> <span class=\"title\">luaI_openlib</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *libname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">const</span> luaL_Reg *l, <span class=\"keyword\">int</span> nup)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (libname) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = libsize(l);</span><br><span class=\"line\">    <span class=\"comment\">/* check whether lib already exists */</span></span><br><span class=\"line\">    luaL_findtable(L, LUA_REGISTRYINDEX, <span class=\"string\">&quot;_LOADED&quot;</span>, size);</span><br><span class=\"line\">    lua_getfield(L, <span class=\"number\">-1</span>, libname);  <span class=\"comment\">/* get _LOADED[libname] */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lua_istable(L, <span class=\"number\">-1</span>)) &#123;  <span class=\"comment\">/* not found? */</span></span><br><span class=\"line\">      lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove previous result */</span></span><br><span class=\"line\">      <span class=\"comment\">/* try global variable (and create one if it does not exist) */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        luaL_error(L, <span class=\"string\">&quot;name conflict for module &quot;</span> LUA_QS, libname);</span><br><span class=\"line\">      lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">      lua_setfield(L, <span class=\"number\">-3</span>, libname);  <span class=\"comment\">/* _LOADED[libname] = new table */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lua_remove(L, <span class=\"number\">-2</span>);  <span class=\"comment\">/* remove _LOADED table */</span></span><br><span class=\"line\">    lua_insert(L, -(nup+<span class=\"number\">1</span>));  <span class=\"comment\">/* move library table to below upvalues */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; l-&gt;name; l++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;nup; i++)  <span class=\"comment\">/* copy upvalues to the top */</span></span><br><span class=\"line\">      lua_pushvalue(L, -nup);</span><br><span class=\"line\">    lua_pushcclosure(L, l-&gt;func, nup);</span><br><span class=\"line\">    lua_setfield(L, -(nup+<span class=\"number\">2</span>), l-&gt;name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_pop(L, nup);  <span class=\"comment\">/* remove upvalues */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注册这些函数之前，首先会到registry ［二LOADED＂］表中查找该库，如果不存在，则在G表中查找这个库，若不存在则创建一个表。<br>因此，不管是Lua内部的库还是外部使用require引用的库，首先会到 registry ［”一LOADED ”］ 中存放该库的表。 最后，再遍历传进来的函数指针数组，完成库函数的注册。<br>比如，注册as . print时，首先将print函数绑定在一个函数指针上，再去l_registry[_LOADED]和G表中查询名为OS的库是否存在，不存在则创建一个表，即 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">G[”OS<span class=\"string\">&quot;] = &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>紧跟着注册print函数，即： G ［”os ”］［ ” print ”］＝待注册的函数指针。<br>这样在调用os . print(1）时，首先根据OS到G表中查找对应的表，再在这个表中查找print成员得到函数指针，最后完成函数的调用 。</p>\n<h3 id=\"模块的编写\"><a href=\"#模块的编写\" class=\"headerlink\" title=\"模块的编写\"></a>模块的编写</h3><p>在定义Lua模块时，第一句代码一般都是module(xxx ） 。 module调用的对应C函数是loadlib.c中的函数ll_module:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ll_module</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *modname = luaL_checkstring(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> loaded = lua_gettop(L) + <span class=\"number\">1</span>;  <span class=\"comment\">/* index of _LOADED table */</span></span><br><span class=\"line\">  lua_getfield(L, LUA_REGISTRYINDEX, <span class=\"string\">&quot;_LOADED&quot;</span>);</span><br><span class=\"line\">  lua_getfield(L, loaded, modname);  <span class=\"comment\">/* get _LOADED[modname] */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_istable(L, <span class=\"number\">-1</span>)) &#123;  <span class=\"comment\">/* not found? */</span></span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);  <span class=\"comment\">/* remove previous result */</span></span><br><span class=\"line\">    <span class=\"comment\">/* try global variable (and create one if it does not exist) */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, modname, <span class=\"number\">1</span>) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> luaL_error(L, <span class=\"string\">&quot;name conflict for module &quot;</span> LUA_QS, modname);</span><br><span class=\"line\">    lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    lua_setfield(L, loaded, modname);  <span class=\"comment\">/* _LOADED[modname] = new table */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* check whether table already has a _NAME field */</span></span><br><span class=\"line\">  lua_getfield(L, <span class=\"number\">-1</span>, <span class=\"string\">&quot;_NAME&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_isnil(L, <span class=\"number\">-1</span>))  <span class=\"comment\">/* is table an initialized module? */</span></span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* no; initialize it */</span></span><br><span class=\"line\">    lua_pop(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">    modinit(L, modname);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">  setfenv(L);</span><br><span class=\"line\">  dooptions(L, loaded - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码的前半部分首先根据module(XXX）中的模块名去registry [“_LOADED”］表中查找，如果找不到，则创建一个新表，这个表为＿G ［” xxx叮＝ registry ［二LOADED ”］［ “XXX ＂］ 。 换言之，这个名为xxx 的模块本质上是一个表，这个表存储了这个模块中的所有变革－以及函数，它既可以通过一G ［” xxx”］来访问，也可以通过registry ［二 LOADED ”］［ “XXX ”］来访问 。<br>紧跟着，在modi nit 函数中，将这个表的成员 K NAME 、 PACKAGE分别赋值。<br>最后，调用 setfenv将该模块对应的环境置空 。 根据前面的分析， setfenv将该模块对应的环境置空就是将这个模块分析完毕之后返回的Closure对应的env环境表置空 。 这意味着，前面的所有全局变量都看不见了，比如下面的代码中 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">myprint=<span class=\"built_in\">print</span></span><br><span class=\"line\">myprint(”<span class=\"number\">1</span>”)</span><br><span class=\"line\"><span class=\"built_in\">module</span>(”test”)</span><br><span class=\"line\">myprint (” <span class=\"number\">2</span>”)</span><br></pre></td></tr></table></figure>\n<p>这里首先将全局函数printl赋值给全局变量myprint ，第二行代码可以正常调用这个函数。但当调用module声明 test模块之后，在此之前的全局变量myprint被清空，第四行代码调用myprint函数时就会报错，错误信息是attempt to call global ‘myprint’(a nil value），因为此时已经查不到这个变量了 。<br>如果写下的是module(xxx,package . seeall）呢？它将会调用后面的dooptions 函数并且最后调用 package.seeall对应的处理函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ll_seeall</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  luaL_checktype(L, <span class=\"number\">1</span>, LUA_TTABLE);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lua_getmetatable(L, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    lua_createtable(L, <span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">/* create new metatable */</span></span><br><span class=\"line\">    lua_pushvalue(L, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    lua_setmetatable(L, <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class=\"line\">  lua_setfield(L, <span class=\"number\">-2</span>, <span class=\"string\">&quot;__index&quot;</span>);  <span class=\"comment\">/* mt.__index = _G */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数就两个作用 ： 一个是创建该模块对应表的metatable ， 另一个是将meta表的 index指向 G表。 也就是说，所有在该模块中找不到的变量都会去 G表中查找 。 可以看到，这里的操作并不会把环境表清空 。 因此，如果把前面的代码改成这样，就可以正确执行：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">myprint=<span class=\"built_in\">print</span></span><br><span class=\"line\">myprint(” test ”)</span><br><span class=\"line\">morlule (”test <span class=\"string\">&#x27;’, package. seeall)</span></span><br><span class=\"line\"><span class=\"string\">myprint(”test”) </span></span><br></pre></td></tr></table></figure>\n<p>根据前面对module函数的分析，得出以下几个结论。</p>\n<ul>\n<li>创建模块时会创建一个表，该表挂载在registry ［ ”一LOADED ＇ ’ ］、＿G ［模块名］下 。 自然而然地，该模块中的变量（函数也是一种变量）就会挂载到这个表里面 。</li>\n<li>在 module 函数的参数中写下 package.seeall将会创建该表的 metatable ，同时该表的index将指向 G表。 简单地说，这个模块将可以看到所有全局环境下的变量（这里再提醒一次，函数也是一种变量） 。</li>\n</ul>\n<p>明白了 module 背后的作用，再来看看 require 函数，它对应的处理函数是 loadlib.c 中的ll_require 函数，这个函数做了如下几件事情 。</p>\n<ul>\n<li>首先在 registry[ “_LOADED”］表中查找该库，如果已存在，说明是已经加载过的模块，不再重复加载直接返回。</li>\n<li>在当前环境表中查找 loaders变量，这里存放的是所有加载器组成的数组 。 在 Lua代码中，有4个loader :<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> lua_CFunction loaders[] =</span><br><span class=\"line\">  &#123;loader_preload, loader_Lua, loader_C, loader_Croot, <span class=\"literal\">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>\n加载时，会依次调用 loaders数组中的四种 loader 。 如果加载的结果在Lua找中返回的是函数（前面提过，分析完Lua源代码文件，返回的是Closure ），那么说明加载成功，不再继续往下调用其他的 loader加载模块 。<br>最后，调用lua call函数尝试加载该模块。 加载之前，在L回校中压入一个哨兵值sentinel,如果加载完毕之后这个值没有被改动过，则说明加载完毕，将registry ［ ”＿LOADED”］赋值为true表示加载成功 。</li>\n</ul>\n<h3 id=\"模块的热更新原理\"><a href=\"#模块的热更新原理\" class=\"headerlink\" title=\"模块的热更新原理\"></a>模块的热更新原理</h3><p>能很好地支持代码热更新机制，是开发时选择使用脚本语言的原因之一 。 热更新的好处很在于，能在不重启程序或者发布新版本的情况下更新脚本，给调试和线上解决问题带来很大的便利，对开发效率有很大的提升 。<br>下面就来谈谈如何实现热更新 。先简单回顾之前提过的模块和lrequire机制 。 Lua内部提供了一个require 函数来实现模块的加载，它做的事情主要有以下几个。</p>\n<ul>\n<li>在registry ［二LOADED”］表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码 。</li>\n<li>依次调用注册的 loader来加载模块 。</li>\n<li>将加载过的模块赋值给registry ［”一LOADED ＂］表。<br>而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua虚拟机认为它之前没有加载过。 查看Lua代码可以发现 ， registry ［”一LOADED ”］表实际上对应的是package.loaded表，这在以下函数中有体现：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LUALIB_API <span class=\"keyword\">int</span> <span class=\"title\">luaopen_package</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"comment\">/* create new type _LOADLIB */</span></span><br><span class=\"line\">  luaL_newmetatable(L, <span class=\"string\">&quot;_LOADLIB&quot;</span>);</span><br><span class=\"line\">  lua_pushcfunction(L, gctm);</span><br><span class=\"line\">  lua_setfield(L, <span class=\"number\">-2</span>, <span class=\"string\">&quot;__gc&quot;</span>);</span><br></pre></td></tr></table></figure>\n因此，事情就很简单了，需要提供require_ex函数，可以把它理解为require的增强版 。 使用这个函数，可以动态更新某个模块的代码：<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">干unction require_ex( _mname )</span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"built_in\">string</span> .<span class=\"built_in\">format</span>(<span class=\"string\">&quot;require_ex ＝喃5 ”，＿mname) )</span></span><br><span class=\"line\"><span class=\"string\">if package.loaded[_mname] then</span></span><br><span class=\"line\"><span class=\"string\">print( string.format(”require_ex module[ %s] reload”,_mname))</span></span><br><span class=\"line\"><span class=\"string\">end</span></span><br><span class=\"line\"><span class=\"string\">package .loaded[_mname] = nil</span></span><br><span class=\"line\"><span class=\"string\">require( _mname )</span></span><br><span class=\"line\"><span class=\"string\">end</span></span><br></pre></td></tr></table></figure>\n这个函数做的事情一目了然 。 首先，判断是否曾经加载过这个模块，如果有，则打印一条日志，表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。</li>\n</ul>\n<p>一般热更新都是函数的实现，所以需要对全局变量做一些保护 。 比如，当前某全局变量为 100 ，表示某个操作已经进行了 100次，它不能因为热更新重置为0 ，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样 ：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a <span class=\"keyword\">or</span> o</span><br></pre></td></tr></table></figure>\n<p>这个原理很简单，只有当前a这个变量没有初始值的时候才会赋值为0 ，而后面不管这个Lua文件被加载多少次， a者~J之会因为重新加载了Lua代码而发生改变 。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《lua设计与实现》</p>\n","tags":["lua"]},{"title":"lua gc","url":"/2021/03/22/lua-gc/","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>GC算法的原理大体就是：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，可以删除 。<br>这里的关键在于，如何找出没有“引用”的对象。<br>使用引用计数的GC算法，会在一个对象被引用的情况下将该对象的引用计数加一 ，反之减一。 如果引用计数为0 ，那么就是没有引用的对象。 引用计数算法的优点是不需要扫描每个对象，对象本身的引用计数只需要减到0，就会被回收。 缺点是会有循环引用问题<br>另一种算法是标记清除算法（ Mark and Sweep ）。 它的原理是每一次做GC的时候，首先扫描并且标记系统中 的所有对象，被扫描并且标记到的对象认为是可达的（ reachable ），这些对象不会被回收；反之，没有被标记的对象认为是可以回收的 。 Lua采用的就是这种算法 。</p>\n<h2 id=\"双色标记清除算法\"><a href=\"#双色标记清除算法\" class=\"headerlink\" title=\"双色标记清除算法\"></a>双色标记清除算法</h2><p>早期的Lua 5.0使用的是双色标记清除算法，该算法的原理是 ：系统中的每个对象非黑即白，也就是要么被引用，要么没有被引用。<br>具体操作是这样的：</p>\n<ul>\n<li>每个新创建的对象的颜色为白色</li>\n<li>在初始化阶段，边历root链表中的对象，并将其加入到对象链表中</li>\n<li>在标记阶段，当对象链表中还有未扫描的元素，从中取出一个对象并将其标记为黑色，边历这个对象关联的其他所有对象，标记为黑色</li>\n<li>在回收阶段，追历所有对象，如果为白色，这些对象就是没有被引用的对象，逐个回收。否则，这些对象是被引用的对象 ， 重新加入对象链表中等待丁一轮的GC检查。<br><img src=\"https://user-images.githubusercontent.com/11263320/112426112-4cd8d900-8d72-11eb-91d9-6b23756e362f.JPG\" alt=\"捕获\"><br>这个算法的缺陷在于，每个对象的状态是“二元”的，每个对象只可能有一种状态，不能有其他中间状态，这就要求这个算法每次做GC操作时不可被打断地一次性扫描并清除完所有对象。<br>如果在遍历对象链表时标记每个对象颜色的过程中被打断，此时新增了一个对象，那么应该将这个对象标记为白色还是黑色？如果标记为白色，假如GC已经到了回收阶段，那么这个对象就会在没有遍历其关联对象的情况下被回收；如果标记为黑色，假如GC已经到了回收阶段，那么这个对象在本轮GC中并没有被扫描过就认为是不必回<br>收的 。 可以看到，在双色标记清除算法中，标记阶段和回收阶段必须合在一起完成。<br>不能被打断，也就意味着每次GC操作的代价极大。在GC过程中，程序必须暂停下来，不能进行其他操作。</li>\n</ul>\n<h2 id=\"三色增量标记清除算法\"><a href=\"#三色增量标记清除算法\" class=\"headerlink\" title=\"三色增量标记清除算法\"></a>三色增量标记清除算法</h2><p>从Lua 5.1 开始，采用了在该算法的基础上改进的三色增量标记清除算法。与前面的算法相比，这个算法中每个对象的颜色多了一种（实际上，在Lua中是4种，后面再展开讨论）。 这样的好处在于：它不必再要求GC一次性扫描完所有的对象，这个GC过程可以是增量的，可以被中断再恢复并继续进行的 。<br>3种颜色的分类如下：</p>\n<ul>\n<li>白色： 当前对象为待访问状态，表示对象还没有被GC标记过，这也是任何一个对象创建后的初始状态。 换言之，如果一个对象在结束GC扫描过程后仍然是白色，则说明该对象没有被系统中的任何一个对象所引用，可以回收其空间了 。</li>\n<li>灰色： 当前对象为待扫描状态，表示对象已经被GC访问过，但是该对象引用的其他对象还没有被访问到 。</li>\n<li>黑色： 当前对象为己扫描状态，表示对象已经被GC访问过，并且该对象引用的其他对象也被访问过了 。<br><img src=\"https://user-images.githubusercontent.com/11263320/112426834-9544c680-8d73-11eb-97eb-ca4ada95361d.JPG\" alt=\"捕获\"><br>具体操作是这样的：</li>\n<li>每个新创建的对象颜色为白色</li>\n<li>初始化阶段，远历 root 节点中引用的对象，从白色置为灰色，并且放入到灰色节点列表中</li>\n<li>标记阶段，当灰色链表中还有未扫描的元素，从中取出一个对象并将其标记为黑色，遍历这个对象关联的其他所有对象．如果是白色，标记为灰色，加入灰色链表中。</li>\n<li>回收阶段，遍历所有对象，如果为白色，这些对象都是没有被引用的对象，逐个回收。否则，重新加入对象链求中等待丁一轮的 GC检查</li>\n</ul>\n<p>可以看到，引入了灰色节点的概念后，算法不再要求一次性完整执行完毕，而是可以把已经扫描但是其引用的对象还未被扫描的对象置为灰色。 在标记阶段中，只要灰色节点集合中还有元素在，那么这个标记过程就会继续下去，即使中间被打断转而执行其他操作了，也没有关系 。</p>\n<p>然而即使是这样，却仍然有另一个没有解决的问题。 从上面的算法可以看出，没有被引用的对象的颜色在扫描过程中始终保持不变，为白色 。 那么，假如一个对象在GC过程的标记阶段之后创建，根据前面对颜色的描述，它应该是白色的，这样在紧跟着的回收阶段，这个对象就会在没有被扫描标记的情况下被认为是没有被引用的对象而删除 。</p>\n<p>因此， Lua的GC算法除了前面的三色概念之外，又细分出来一个“双白色”的概念 。 简单地说， Lua中的白色分为“当前白色”和“非当前臼色”。 这两种白色的状态交替使用，第N；欠GC使用的是第一种白色，那么下一次就是另外一种，以此类推。</p>\n<p>代码在回收时会做判断，如果某个对象的白色不是此次GC使用的白色状态，那么将不会认为是没有被引用的对象而回收，这样的白色对象将留在下一次GC中进行扫描，因为在下一次GC中上一次幸免的白色将成为这次的回收颜色。</p>\n<h2 id=\"GC的全流程\"><a href=\"#GC的全流程\" class=\"headerlink\" title=\"GC的全流程\"></a>GC的全流程</h2><p>Lua内部用一个宏表示哪些数据类型需要进行GC ( Garbage Collection ，垃圾回收）操作 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> iscollectable(o) (ttype(o) &gt;= LUA TSTRING)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到， LUA TSTRING （包括 LUA TSTRING ）之后的数据类型都需要进行GC操作 。</p>\n<p>需要进行GC操作的数据类型都会有一个CommonHeader宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>\n<p>next：GCObject链表指针，这个指针将所有GC对象都链接在一起形成链表<br>tt：表示数据的类型，即<a href=\"https://github.com/losophy/losophy.github.io/issues/109\">lua数据类型</a>的宏 。<br>marked : 标记字段，用于存储前面提到的几种颜色。<br>marked具体值定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">** Layout for bit use in `marked&#x27; field:</span></span><br><span class=\"line\"><span class=\"comment\">** bit 0 - object is white (type 0)</span></span><br><span class=\"line\"><span class=\"comment\">** bit 1 - object is white (type 1)</span></span><br><span class=\"line\"><span class=\"comment\">** bit 2 - object is black</span></span><br><span class=\"line\"><span class=\"comment\">** bit 3 - for userdata: has been finalized</span></span><br><span class=\"line\"><span class=\"comment\">** bit 3 - for tables: has weak keys</span></span><br><span class=\"line\"><span class=\"comment\">** bit 4 - for tables: has weak values</span></span><br><span class=\"line\"><span class=\"comment\">** bit 5 - object is fixed (should not be collected)</span></span><br><span class=\"line\"><span class=\"comment\">** bit 6 - object is &quot;super&quot; fixed (only the main thread)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WHITE0BIT\t0 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WHITE1BIT\t1   </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BLACKBIT\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FINALIZEDBIT\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KEYWEAKBIT\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> VALUEWEAKBIT\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FIXEDBIT\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SFIXEDBIT\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WHITEBITS\tbit2mask(WHITE0BIT, WHITE1BIT)</span></span><br></pre></td></tr></table></figure>\n<p>这里WHITE OBIT和WHITE1BIT就是前面提到的两种 白色状态，称为0型白色和 l型白色。 当前的白色见lobal_State 中的 currentwhite ，而otherwhit e宏用于表示非当前GC将要回收的白色类型 。 切换白色，需要使用 changewhite宏 ； 要得到当前的白色状态，则使用luaC_white宏 。</p>\n<p>FINALIZEDBIT用于标记没有被引用需要回收的 udata 。 u data 的处理与其他数据类型不同，<br>由于它是用户传人的数据，它的回收可能会调用用户注册的GC函数，所以统一来处理。<br>KEYWE A KBIT和VALUEWE A KBIT用于标记弱表中键／值的weak属性 。FIXEDBIT和 SFIXEDBIT用于表示该对象不可回收，其中 F IX ED BIT仅用于 lua State对象自身的标记，而SFIXEDBIT标记了一系列Lua语法中的关键字对应的字符串为不可回收字符串，具体可以看看l u aX i n it 函数的实现</p>\n<p>在保存全局状态的global_State结构体中，有以下几个与GC相关的数据成员</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">global_State</span> &#123;</span></span><br><span class=\"line\">  lu_byte currentwhite;<span class=\"comment\">//存放当前GC的白色</span></span><br><span class=\"line\">  lu_byte gcstate;  <span class=\"comment\">//存放GC状态，分别有以下几种 ： GCS pause （暂停阶段） 、 GCSpropagate（传播阶段，用于遍历灰色节点检查对象的引用情况）、 GCSsweepstring （字符串回收阶段） , GCSsweep （回收阶段，用于对除了字符串之外的所有其他数据类型进行回收）和GCSfinalize （终止阶段） 。</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sweepstrgc;  <span class=\"comment\">//字符串回收阶段，每次针对字符串散列桶的一组字符串进行回收，这个值用于记录对应的散列桶索引 。</span></span><br><span class=\"line\">  GCObject *rootgc;  <span class=\"comment\">//存放待GC对象的链表，所有对象创建之后都会放入该链表中</span></span><br><span class=\"line\">  GCObject **sweepgc; <span class=\"comment\">//待处理的回收数据都存放在rootgc链表中，由于回收阶段不是一次性全部回收这个链表的所有数据，所以使用这个变量来保存当前回收的位置，下一次从这个位置开始继续回收操作</span></span><br><span class=\"line\">  GCObject *gray;  <span class=\"comment\">//存放灰色节点的链表</span></span><br><span class=\"line\">  GCObject *grayagain; <span class=\"comment\">//存放需要一次性扫描处理的灰色节点链表，也就是说，这个链表上所有数据的处理需要一步到位，不能被打断</span></span><br><span class=\"line\">  GCObject *weak;  <span class=\"comment\">//存放弱表的链表</span></span><br><span class=\"line\">  GCObject *tmudata;  <span class=\"comment\">//所有带有GC元方法的 udata存放在一个链表中，这个成员指向这千链表的最后一个元素</span></span><br><span class=\"line\">  lu_mem GCthreshold;<span class=\"comment\">//开始进行GC的阔值，当totalbytes大于这个值时开始自动GC</span></span><br><span class=\"line\">  lu_mem totalbytes;  <span class=\"comment\">//当前分配的内存大小</span></span><br><span class=\"line\">  lu_mem estimate; <span class=\"comment\">//一个估计值，用于保存实际在用的内存大小 </span></span><br><span class=\"line\">  lu_mem gcdept;  <span class=\"comment\">//用于在单次GC之前保存待回收的数据大小</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> gcpause;  <span class=\"comment\">//用于控制下一轮GC开始的时机</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> gcstepmul; <span class=\"comment\">//控制GC的回收速度</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; global_State;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新创建对象\"><a href=\"#新创建对象\" class=\"headerlink\" title=\"新创建对象\"></a>新创建对象</h3><p>从前面的分析可以知道，对于每个新创建的对象，最基本的操作就是将对象的颜色设置为白色，意指本次GC还未扫描到的对象，同时将对象挂载到扫描过程会遍历的链表上 。 基本思想就是如此，但是针对不同的数据类型，会有不同的处理。</p>\n<p>一般的数据类型调用的是luaC_link函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_link</span> <span class=\"params\">(lua_State *L, GCObject *o, lu_byte tt)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  o-&gt;gch.next = g-&gt;rootgc;</span><br><span class=\"line\">  g-&gt;rootgc = o;</span><br><span class=\"line\">  o-&gt;gch.marked = luaC_white(g);</span><br><span class=\"line\">  o-&gt;gch.tt = tt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数做的事情为：</p>\n<ul>\n<li>将对象挂载到 rootgc链表上</li>\n<li>设置颜色为白色</li>\n<li>设置数据的类型</li>\n</ul>\n<p>但是UpValue和udata类型的数据的创建过程有些不一样<br>先来看UpValue，新建一个UpValue类型的数据，调用的是luaC_linkupval函数 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_linkupval</span> <span class=\"params\">(lua_State *L, UpVal *uv)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  GCObject *o = obj2gco(uv);</span><br><span class=\"line\">  o-&gt;gch.next = g-&gt;rootgc;  <span class=\"comment\">/* link upvalue into `rootgc&#x27; list */</span></span><br><span class=\"line\">  g-&gt;rootgc = o;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isgray(o)) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;gcstate == GCSpropagate) &#123;</span><br><span class=\"line\">      gray2black(o);  <span class=\"comment\">/* closed upvalues need barrier */</span></span><br><span class=\"line\">      luaC_barrier(L, uv, uv-&gt;v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* sweep phase: sweep it (turning it into white) */</span></span><br><span class=\"line\">      makewhite(g, o);</span><br><span class=\"line\">      lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的疑问是，前面的数据类型在最开始的时候 ，都是将颜色设置为白色，而针对UpValue,则是根据颜色是不是灰色来做后面的一些操作 。 原因在于， UpValue是针对已有对象的间接引用，所以它的处理在对象颜色是灰色的情况下区分了两种情况 。</p>\n<ul>\n<li>如果当前在扫描阶段，那么将对象从灰色变成黑色 。 需要注意的是，到这一步需要加barrier </li>\n<li>如果不是在扫描阶段，都置为白色 。 第705行的注释说到这一步，将其回 收， 其实这个表达并不完全准确 。 这里置为白色，我的理解和创建其他类型数据的函数luaC link一样，都是一个创建对象的正常流程 。</li>\n</ul>\n<p>再来看udata数据的创建：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Udata *<span class=\"title\">luaS_newudata</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">size_t</span> s, Table *e)</span> </span>&#123;</span><br><span class=\"line\">  Udata *u;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s &gt; MAX_SIZET - <span class=\"keyword\">sizeof</span>(Udata))</span><br><span class=\"line\">    luaM_toobig(L);</span><br><span class=\"line\">  u = cast(Udata *, luaM_malloc(L, s + <span class=\"keyword\">sizeof</span>(Udata)));</span><br><span class=\"line\">  u-&gt;uv.marked = luaC_white(G(L));  <span class=\"comment\">/* is not finalized */</span></span><br><span class=\"line\">  u-&gt;uv.tt = LUA_TUSERDATA;</span><br><span class=\"line\">  u-&gt;uv.len = s;</span><br><span class=\"line\">  u-&gt;uv.metatable = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  u-&gt;uv.env = e;</span><br><span class=\"line\">  <span class=\"comment\">/* chain it on udata list (after main thread) */</span></span><br><span class=\"line\">  u-&gt;uv.next = G(L)-&gt;mainthread-&gt;next;</span><br><span class=\"line\">  G(L)-&gt;mainthread-&gt;next = obj2gco(u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>任何时候创建的 udata ，在GC链表中都会放在mainthread之后 。 除此之外，这类型的数据与其他数据并无差别 。 之所以这么做，是因为udata是用户注册的C数据。 在回收时，我们可能会调用用户注册的函数，此时就需要把这些udata统一放在一个地方来处理，这样做是为了方便编写代码 。 </p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>前面提到过， Lua的GC过程是增聋的 、 中间可以被打断的，每一次单独进入 GC时，都会根据当前GC所处的阶段来进行不同的处理，这个人口函数是singlestep。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (g-&gt;gcstate) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> GCSpause: &#123;</span><br><span class=\"line\">    markroot(L);  <span class=\"comment\">/* start a new collection */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>初始化阶段将从root节点出发，遍历rootl连表上的所有节点，将它们的颜色从白色变成灰色，加入到gray链表中 。 初始化阶段的人口是markroot函数 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* mark root set */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">markroot</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  g-&gt;gray = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  g-&gt;grayagain = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  g-&gt;weak = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  markobject(g, g-&gt;mainthread);</span><br><span class=\"line\">  <span class=\"comment\">/* make global table be traversed before main stack */</span></span><br><span class=\"line\">  markvalue(g, gt(g-&gt;mainthread));</span><br><span class=\"line\">  markvalue(g, registry(L));</span><br><span class=\"line\">  markmt(g);</span><br><span class=\"line\">  g-&gt;gcstate = GCSpropagate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 markobject和『『1arkvalue函数都用于标记对象的颜色为灰色，不同的是前者是针对object而后者是针对TValue ，它们最终都会调用reallymarkobject 函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reallymarkobject</span> <span class=\"params\">(global_State *g, GCObject *o)</span> </span>&#123;</span><br><span class=\"line\">  lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));</span><br><span class=\"line\">  white2gray(o);</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TSTRING: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TUSERDATA: &#123;</span><br><span class=\"line\">      Table *mt = gco2u(o)-&gt;metatable;</span><br><span class=\"line\">      gray2black(o);  <span class=\"comment\">/* udata are never gray */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mt) markobject(g, mt);</span><br><span class=\"line\">      markobject(g, gco2u(o)-&gt;env);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TUPVAL: &#123;</span><br><span class=\"line\">      UpVal *uv = gco2uv(o);</span><br><span class=\"line\">      markvalue(g, uv-&gt;v);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (uv-&gt;v == &amp;uv-&gt;u.value)  <span class=\"comment\">/* closed? */</span></span><br><span class=\"line\">        gray2black(o);  <span class=\"comment\">/* open upvalues are never black */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TFUNCTION: &#123;</span><br><span class=\"line\">      gco2cl(o)-&gt;c.gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TTABLE: &#123;</span><br><span class=\"line\">      gco2h(o)-&gt;gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TTHREAD: &#123;</span><br><span class=\"line\">      gco2th(o)-&gt;gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TPROTO: &#123;</span><br><span class=\"line\">      gco2p(o)-&gt;gclist = g-&gt;gray;</span><br><span class=\"line\">      g-&gt;gray = o;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: lua_assert(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，对于绝大部分类型的对象，这里只是简单地将其颜色改变为灰色并加入到gray链表中，但是有几个类型是区别处理的</p>\n<ul>\n<li>对于字符串类型的数据，由于这种类型没有引用其他数据，所以略过将其颜色改为灰色的流程，直接将不是黑色的字符串对象回收即可 。</li>\n<li>对于 udata类型的数据，因为这种类型永远也不会引用其他数据，所以这里也是一步到位，直接将其标记为黑色。 另外，对于这种类型，还需要标记对应的metatable和env表。</li>\n<li>对于UpValue类型的数据，如果当前是close状态的话，那么该UpValue 已经没有与其他数据的引用关系了，可以直接标记为黑色 。 至于open状态的 UpValue ，由于其引用状态可能会频繁发生变动，所以留待后面的remarkupvals函数进行原子性的标记</li>\n</ul>\n<h3 id=\"扫描标记阶段\"><a href=\"#扫描标记阶段\" class=\"headerlink\" title=\"扫描标记阶段\"></a>扫描标记阶段</h3><p>扫描阶段就是遍历灰色对象链表来分析对象的引用情况，这个阶段是GC所有阶段中步骤最长的 。 整个过程分为两部分。 第一步首先遍历gray链表来标记所有数据，在这个过程中，有些数据需要重新扫描，这些数据会放在grayagain链表中，调用 atomic 函数重新进行扫描。 而第二步则是遍历grayagain链表，一次性扫描其中的数据 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> GCSpropagate: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;gray)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> propagatemark(g);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* no more `gray&#x27; objects */</span></span><br><span class=\"line\">        atomic(L);  <span class=\"comment\">/* finish mark phase */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这一步将扫描所有gray链表中的对象，将它们及其引用到的对象标记成黑色 。 需要注意的是，前面的初始化阶段是一次到位的，而这一步却可以多次进行，每次扫描之后会返回本次扫描标记的对象大小之和，其入口函数是propagatemark ，再次扫描时，只要gray链表中还有待扫描的对象，就继续执行这个函数进行标记 。 当灰色链表已经遍历完毕时，进入atomic函数中完成标记阶段。</p>\n<p>可以看到，第一步遍历gray链表中对象的处理是可以中断的，而第二步调用atomic 函数的操作是原子的、不能被打断的，这也是atomic函数的名字由来 。 这是Lua 5.1 的GC算法优于之前版本的GC算法的原因之一 ： 可以增量地来进行数据扫描，不会因为一次GC扫描操作导致整个系统被卡住很久 。</p>\n<p>propagatemark 函数与前面的 reallymarkobject 函数做的事情其实差不多，都是对对象标记颜色的动作 。 区别在于，这里将对象从灰色标记成黑色，表示这个对象及其所引用的对象都已经标记过 。 另一个区别在于，前面的流程不会递归对一个对象所引用的对象进行标记，而这里会根据不同的类型调用对应向土raverse＊函数进行标记。 在实际工作中，对每种类型的对象的处理还不太一样，下面逐个类型来看看 。</p>\n<h4 id=\"扫描Table对象\"><a href=\"#扫描Table对象\" class=\"headerlink\" title=\"扫描Table对象\"></a>扫描Table对象</h4><p>在tra versetable函数中，如果扫描到该表是弱表，那么将会把该对象加入weak链表中，这个链表将在扫描阶段的最后一步进行一次不能中断的处理，这部分将在后面谈到 。 同时，如果该表是弱表，那么将该对象回退到灰色状态，重新进行扫描。 在不是弱表的情况下，将遍历标记表的散列部分及数组部分的所有元素 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> LUA_TTABLE: &#123;</span><br><span class=\"line\">      Table *h = gco2h(o);</span><br><span class=\"line\">      g-&gt;gray = h-&gt;gclist;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (traversetable(g, h))  <span class=\"comment\">/* table is weak? */</span></span><br><span class=\"line\">        black2gray(o);  <span class=\"comment\">/* keep it gray */</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(Table) + <span class=\"keyword\">sizeof</span>(TValue) * h-&gt;sizearray +</span><br><span class=\"line\">                             <span class=\"keyword\">sizeof</span>(Node) * sizenode(h);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"扫描函数对象\"><a href=\"#扫描函数对象\" class=\"headerlink\" title=\"扫描函数对象\"></a>扫描函数对象</h4><p>针对函数对象，进行处理的函数是traverseclosure ，该函数主要是对函数中的所有 UpValue进行标记。 相关代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> LUA_TFUNCTION: &#123;</span><br><span class=\"line\">      Closure *cl = gco2cl(o);</span><br><span class=\"line\">      g-&gt;gray = cl-&gt;c.gclist;</span><br><span class=\"line\">      traverseclosure(g, cl);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (cl-&gt;c.isC) ? sizeCclosure(cl-&gt;c.nupvalues) :</span><br><span class=\"line\">                           sizeLclosure(cl-&gt;l.nupvalues);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"扫描线程对象\"><a href=\"#扫描线程对象\" class=\"headerlink\" title=\"扫描线程对象\"></a>扫描线程对象</h4><p>针对线程对象，这里的处理是将该对象从gcli st中摘下来，放入grayaga in链表中，同时将颜色退回到灰色，以备后面的原子阶段再做一次扫描 。 因为t hread上关联的对象是Lua运行时的状态，变化很频繁，所以这里只是简单地放在grayagain链表中 ， 后面再一次性标记完毕 。 相关代码如下 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> LUA_TTHREAD: &#123;</span><br><span class=\"line\">      lua_State *th = gco2th(o);</span><br><span class=\"line\">      g-&gt;gray = th-&gt;gclist;</span><br><span class=\"line\">      th-&gt;gclist = g-&gt;grayagain;</span><br><span class=\"line\">      g-&gt;grayagain = o;</span><br><span class=\"line\">      black2gray(o);</span><br><span class=\"line\">      traversestack(g, th);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(lua_State) + <span class=\"keyword\">sizeof</span>(TValue) * th-&gt;stacksize +</span><br><span class=\"line\">                                 <span class=\"keyword\">sizeof</span>(CallInfo) * th-&gt;size_ci;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"扫描proto对象\"><a href=\"#扫描proto对象\" class=\"headerlink\" title=\"扫描proto对象\"></a>扫描proto对象</h4><p>最后一种特殊类型是 Proto类型，将会调用traverseproto函数标记一个 Proto数据中的文件名、字符串 、 upvalue 、局部变量等所有被引用的对象 。</p>\n<h4 id=\"扫描其余的类型\"><a href=\"#扫描其余的类型\" class=\"headerlink\" title=\"扫描其余的类型\"></a>扫描其余的类型</h4><p>就是简单地调用gray2black将颜色从灰色置为黑色就好了</p>\n<h4 id=\"barrier操作\"><a href=\"#barrier操作\" class=\"headerlink\" title=\"barrier操作\"></a>barrier操作</h4><p>从前面的描述可以知道，分步增量式的扫描标记算法中间可以被打断以执行其他操作，此时就会出现新增加的对象与已经被扫描过的对象之间会有引用关系的变化，而算法中需要保证不会出现黑色对象引用的对象中有白色对象的情况，于是需要两种不同的处理</p>\n<ul>\n<li>标记过程向前走一步。 这种情况指的是，如果一个新创建对象的颜色是白色，而它被一个黑色对象引用了，那么将这个对象的颜色从白色变成灰色，也就是这个GC过程中的进度向前走了一步。</li>\n<li>标记过程向后走一步 。 与前面的情况一样，但是此时是将黑色的对象回退到灰色，也就是这个原先已经被标记为黑色的对象需要重新被扫描，这相当于在GC过程中向后走了一步 。<br>在代码中，最终调用 luaC ba rr ierf函数的都是向前走的操作；反之，调用luaC barrierback的操作则是向后走的操作：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_barrier(L,p,v) &#123; <span class=\"meta-keyword\">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(p)))  \\</span></span><br><span class=\"line\">\tluaC_barrierf(L,obj2gco(p),gcvalue(v)); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_barriert(L,t,v) &#123; <span class=\"meta-keyword\">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(t)))  \\</span></span><br><span class=\"line\">\tluaC_barrierback(L,t); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_objbarrier(L,p,o)  \\</span></span><br><span class=\"line\">\t&#123; <span class=\"keyword\">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(p))) \\</span><br><span class=\"line\">\t\tluaC_barrierf(L,obj2gco(p),obj2gco(o)); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_objbarriert(L,t,o)  \\</span></span><br><span class=\"line\">   &#123; <span class=\"keyword\">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(t))) luaC_barrierback(L,t); &#125;</span><br></pre></td></tr></table></figure>\n可以看到，回退操作仅针对Table类型的对象，而其他类型的对象都是向前操作 。<br>Table是Lua中最常见的数据结构，而且一个Tab le与其关联的k町、 va lue之间是 l t~N的对应关系 。 如果针对Table对象做的是向前的标记操作，那么就意味着：但凡一个Table只要有新增的对象，都帘要将这个新对象标记为灰色并加入gray链表中等待扫描。<br>实际上，这样会有不必要的开销 。 所以，针对Table类型的对象，使用的是针对该Table对象本身要做的向后操作，这样不论有多少个对象新增至UTable中，只要改变了一次，就将这个Table对象回退到灰色状态，等待重新扫描 。 但是这里需要注意的是，对Table对象进行回退操作时，并不是将它放入gray链表中，因为这样做实际上还会出现前面提到的多次反复标记的问题。 针对Table对象，对它执行回退操作，是将它加入到 grayagain链表中，用于在扫描完毕gray链表之后再进行一次性的原子扫描：<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_barrierback</span> <span class=\"params\">(lua_State *L, Table *t)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  GCObject *o = obj2gco(t);</span><br><span class=\"line\">  lua_assert(isblack(o) &amp;&amp; !isdead(g, o));</span><br><span class=\"line\">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class=\"line\">  black2gray(o);  <span class=\"comment\">/* make table gray (again) */</span></span><br><span class=\"line\">  t-&gt;gclist = g-&gt;grayagain;</span><br><span class=\"line\">  g-&gt;grayagain = o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n可以看到，需要进行barrierback操作的对象，最后并没有如新建对象那样加入gray链表中，而是加入grayagain列表中，避免一个对象频繁地进行“被回退－扫描－回退－扫描”过程 。 既然需要重新扫描，那么一次J性地放在grayagain链表中就可以了 。 至于如何回收grayagain链表中的数据，下面将说明</li>\n</ul>\n<p>而相对地，向前的操作就简单多了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_barrierf</span> <span class=\"params\">(lua_State *L, GCObject *o, GCObject *v)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span><br><span class=\"line\">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class=\"line\">  lua_assert(ttype(&amp;o-&gt;gch) != LUA_TTABLE);</span><br><span class=\"line\">  <span class=\"comment\">/* must keep invariant? */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g-&gt;gcstate == GCSpropagate)</span><br><span class=\"line\">    reallymarkobject(g, v);  <span class=\"comment\">/* restore invariant */</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>  <span class=\"comment\">/* don&#x27;t mind */</span></span><br><span class=\"line\">    makewhite(g, o);  <span class=\"comment\">/* mark as white just to avoid other barriers */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只要当前的GC没有在扫描标记阶段，就标记这个对象，否则将对象标记为白色，等待下一次的GC<br>当gray链表中没有对象时，并不能马上进入下一个阶段，这是因为前面还有未处理的数据，这一步需要一次性不被中断地完成，其人口是atomic函数<br>前面提到Lua的增量式GC算法分为多个阶段，可以被中断，然而这一步则例外。 这一步将处理弱表链表和前面提到的grayagain链表，是扫描阶段的最后一步，不可中断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">atomic</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> udsize;  <span class=\"comment\">/* total size of userdata to be finalized */</span></span><br><span class=\"line\">  <span class=\"comment\">/* remark occasional upvalues of (maybe) dead threads */</span></span><br><span class=\"line\">  remarkupvals(g);</span><br><span class=\"line\">  <span class=\"comment\">/* traverse objects cautch by write barrier and by &#x27;remarkupvals&#x27; */</span></span><br><span class=\"line\">  propagateall(g);</span><br><span class=\"line\">  <span class=\"comment\">/* remark weak tables */</span></span><br><span class=\"line\">  g-&gt;gray = g-&gt;weak;</span><br><span class=\"line\">  g-&gt;weak = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  lua_assert(!iswhite(obj2gco(g-&gt;mainthread)));</span><br><span class=\"line\">  markobject(g, L);  <span class=\"comment\">/* mark running thread */</span></span><br><span class=\"line\">  markmt(g);  <span class=\"comment\">/* mark basic metatables (again) */</span></span><br><span class=\"line\">  propagateall(g);</span><br><span class=\"line\">  <span class=\"comment\">/* remark gray again */</span></span><br><span class=\"line\">  g-&gt;gray = g-&gt;grayagain;</span><br><span class=\"line\">  g-&gt;grayagain = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  propagateall(g);</span><br><span class=\"line\">  udsize = luaC_separateudata(L, <span class=\"number\">0</span>);  <span class=\"comment\">/* separate userdata to be finalized */</span></span><br><span class=\"line\">  marktmu(g);  <span class=\"comment\">/* mark `preserved&#x27; userdata */</span></span><br><span class=\"line\">  udsize += propagateall(g);  <span class=\"comment\">/* remark, to propagate `preserveness&#x27; */</span></span><br><span class=\"line\">  cleartable(g-&gt;weak);  <span class=\"comment\">/* remove collected objects from weak tables */</span></span><br><span class=\"line\">  <span class=\"comment\">/* flip current white */</span></span><br><span class=\"line\">  g-&gt;currentwhite = cast_byte(otherwhite(g));</span><br><span class=\"line\">  g-&gt;sweepstrgc = <span class=\"number\">0</span>;</span><br><span class=\"line\">  g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class=\"line\">  g-&gt;gcstate = GCSsweepstring;</span><br><span class=\"line\">  g-&gt;estimate = g-&gt;totalbytes - udsize;  <span class=\"comment\">/* first estimate */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数中，我们分别做了以下几个操作</p>\n<ul>\n<li>调用remarkupvals 函数去标记open状态的UpValue ，这一步完毕之后， gray链表又会有新的对象，于是需要调用 propagateall再次将gray链表中的对象标记一下 。</li>\n<li>修改gray链表指针，使其指向管理弱表的weak指针，同时标记当前的 Lua_State指针以及基本的meta表。</li>\n<li>修改gray链表指针指向grayagain指针，同样是调用propagateall函数进行遍历扫描操作。</li>\n<li>调用luaC_separateudatax;fudata进行处理。</li>\n<li>在第548行，还将当前白色类型切换到了下一次GC操作的白色类型 。</li>\n<li>修改状态到下个回收阶段。</li>\n</ul>\n<p>现在就可以谈谈前面提到的对udata进行处理的luaC_separateudata 函数了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* move `dead&#x27; udata that need finalization to list `tmudata&#x27; */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">luaC_separateudata</span> <span class=\"params\">(lua_State *L, <span class=\"keyword\">int</span> all)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> deadmem = <span class=\"number\">0</span>;</span><br><span class=\"line\">  GCObject **p = &amp;g-&gt;mainthread-&gt;next;</span><br><span class=\"line\">  GCObject *curr;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((curr = *p) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))</span><br><span class=\"line\">      p = &amp;curr-&gt;gch.next;  <span class=\"comment\">/* don&#x27;t bother with them */</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fasttm(L, gco2u(curr)-&gt;metatable, TM_GC) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      markfinalized(gco2u(curr));  <span class=\"comment\">/* don&#x27;t need finalization */</span></span><br><span class=\"line\">      p = &amp;curr-&gt;gch.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* must call its gc method */</span></span><br><span class=\"line\">      deadmem += sizeudata(gco2u(curr));</span><br><span class=\"line\">      markfinalized(gco2u(curr));</span><br><span class=\"line\">      *p = curr-&gt;gch.next;</span><br><span class=\"line\">      <span class=\"comment\">/* link `curr&#x27; at the end of `tmudata&#x27; list */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;tmudata == <span class=\"literal\">NULL</span>)  <span class=\"comment\">/* list is empty? */</span></span><br><span class=\"line\">        g-&gt;tmudata = curr-&gt;gch.next = curr;  <span class=\"comment\">/* creates a circular list */</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        curr-&gt;gch.next = g-&gt;tmudata-&gt;gch.next;</span><br><span class=\"line\">        g-&gt;tmudata-&gt;gch.next = curr;</span><br><span class=\"line\">        g-&gt;tmudata = curr;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> deadmem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它主要对mainthread之后的对象进行遍历（前面谈到了将udata放在mai nthread之后，这是为了统一放在一个地方，方便处理），然后进行如下的操作 。</p>\n<ul>\n<li>如果该对象不需要回收，就继续处理下一个对象。</li>\n<li>否则，先看该对象有没有注册GC函数，如果没有，就直接标记该对象的状态是finalized 。</li>\n<li>否则，除了标记该对象为 finalized之外，还将这些对象加入tmudata链表中 。 同样，这里将udata放在一个链表中也是为了统一处理，后面将会提至Ufina l ized状态的处理。</li>\n</ul>\n<h3 id=\"回收阶段\"><a href=\"#回收阶段\" class=\"headerlink\" title=\"回收阶段\"></a>回收阶段</h3><p>回收阶段分为两步，一步是针对字符串类型的回收，另一步则是针对其他类型对象的回收 ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> GCSsweepstring: &#123;</span><br><span class=\"line\">      lu_mem old = g-&gt;totalbytes;</span><br><span class=\"line\">      sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  <span class=\"comment\">/* nothing more to sweep? */</span></span><br><span class=\"line\">        g-&gt;gcstate = GCSsweep;  <span class=\"comment\">/* end sweep-string phase */</span></span><br><span class=\"line\">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class=\"line\">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> GCSWEEPCOST;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">case</span> GCSsweep: &#123;</span><br><span class=\"line\">      lu_mem old = g-&gt;totalbytes;</span><br><span class=\"line\">      g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (*g-&gt;sweepgc == <span class=\"literal\">NULL</span>) &#123;  <span class=\"comment\">/* nothing more to sweep? */</span></span><br><span class=\"line\">        checkSizes(L);</span><br><span class=\"line\">        g-&gt;gcstate = GCSfinalize;  <span class=\"comment\">/* end sweep phase */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class=\"line\">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> GCSWEEPMAX*GCSWEEPCOST;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>针对字符串类型的数据，每次调用sweepwholelist函数回收字符串散列桶数组中的一个字符串链表，其中每次操作的散列桶索引值存放在sweepstrgc变量中 。 当所有字符串散列桶数据全部遍历完毕时，切换到下一个状态GCSsweep进行其他数据的回收</p>\n<p>对于其他类型数据的回收，我们调用sweeplist函数进行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> GCObject **<span class=\"title\">sweeplist</span> <span class=\"params\">(lua_State *L, GCObject **p, lu_mem count)</span> </span>&#123;</span><br><span class=\"line\">  GCObject *curr;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> deadmask = otherwhite(g);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((curr = *p) != <span class=\"literal\">NULL</span> &amp;&amp; count-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr-&gt;gch.tt == LUA_TTHREAD)  <span class=\"comment\">/* sweep open upvalues of each thread */</span></span><br><span class=\"line\">      sweepwholelist(L, &amp;gco2th(curr)-&gt;openupval);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((curr-&gt;gch.marked ^ WHITEBITS) &amp; deadmask) &#123;  <span class=\"comment\">/* not dead? */</span></span><br><span class=\"line\">      lua_assert(!isdead(g, curr) || testbit(curr-&gt;gch.marked, FIXEDBIT));</span><br><span class=\"line\">      makewhite(g, curr);  <span class=\"comment\">/* make it white (for next cycle) */</span></span><br><span class=\"line\">      p = &amp;curr-&gt;gch.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">/* must erase `curr&#x27; */</span></span><br><span class=\"line\">      lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));</span><br><span class=\"line\">      *p = curr-&gt;gch.next;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curr == g-&gt;rootgc)  <span class=\"comment\">/* is the first element of the list? */</span></span><br><span class=\"line\">        g-&gt;rootgc = curr-&gt;gch.next;  <span class=\"comment\">/* adjust first */</span></span><br><span class=\"line\">      freeobj(L, curr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里我们首先拿到otherwhite ，这表示本次GC操作不可以被回收的白色类型 。 后面就是依次遍历链表中的数据，判断每个对象的白色是否满足被回收的颜色条件。</p>\n<h3 id=\"结束阶段\"><a href=\"#结束阶段\" class=\"headerlink\" title=\"结束阶段\"></a>结束阶段</h3><p>走到了最后一步回收阶段，这一阶段主要针对tmudata链表进行处理，在所有数据都处理完毕后，重新将GC状态切换到暂停状态，这表示下一次新的GC可以开始了 。 相关代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> GCSfinalize: &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (g-&gt;tmudata) &#123;</span><br><span class=\"line\">        GCTM(L);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g-&gt;estimate &gt; GCFINALIZECOST)</span><br><span class=\"line\">          g-&gt;estimate -= GCFINALIZECOST;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> GCFINALIZECOST;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        g-&gt;gcstate = GCSpause;  <span class=\"comment\">/* end collection */</span></span><br><span class=\"line\">        g-&gt;gcdept = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>到了结束阶段，其实也可以中断。 只要tmudata链表中还有对象，就一直调用GCTM函数来处理。 前面提到， tmudata链表是用来存放所有自带GC元方法的 udata对象，因此这里的工作就是调用这些注册的GC元方法进行对象回收：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">GCTM</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  GCObject *o = g-&gt;tmudata-&gt;gch.next;  <span class=\"comment\">/* get first element */</span></span><br><span class=\"line\">  Udata *udata = rawgco2u(o);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> TValue *tm;</span><br><span class=\"line\">  <span class=\"comment\">/* remove udata from `tmudata&#x27; */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (o == g-&gt;tmudata)  <span class=\"comment\">/* last element? */</span></span><br><span class=\"line\">    g-&gt;tmudata = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    g-&gt;tmudata-&gt;gch.next = udata-&gt;uv.next;</span><br><span class=\"line\">  udata-&gt;uv.next = g-&gt;mainthread-&gt;next;  <span class=\"comment\">/* return it to `root&#x27; list */</span></span><br><span class=\"line\">  g-&gt;mainthread-&gt;next = o;</span><br><span class=\"line\">  makewhite(g, o);</span><br><span class=\"line\">  tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tm != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    lu_byte oldah = L-&gt;allowhook;</span><br><span class=\"line\">    lu_mem oldt = g-&gt;GCthreshold;</span><br><span class=\"line\">    L-&gt;allowhook = <span class=\"number\">0</span>;  <span class=\"comment\">/* stop debug hooks during GC tag method */</span></span><br><span class=\"line\">    g-&gt;GCthreshold = <span class=\"number\">2</span>*g-&gt;totalbytes;  <span class=\"comment\">/* avoid GC steps */</span></span><br><span class=\"line\">    setobj2s(L, L-&gt;top, tm);</span><br><span class=\"line\">    setuvalue(L, L-&gt;top+<span class=\"number\">1</span>, udata);</span><br><span class=\"line\">    L-&gt;top += <span class=\"number\">2</span>;</span><br><span class=\"line\">    luaD_call(L, L-&gt;top - <span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    L-&gt;allowhook = oldah;  <span class=\"comment\">/* restore hooks */</span></span><br><span class=\"line\">    g-&gt;GCthreshold = oldt;  <span class=\"comment\">/* restore threshold */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>GCTM函数的主要逻辑就是循环遍历tmudata链表中的对象，针对每个对象调用 fasttm函数，其中会使用GC元方法来进行对象的回收。</p>\n<p>当所有操作都完成， tmudata链表中不再有对象了，此时一个GC的完整流程就走完了， Lua将GC状态切换到GCSpause ，等待下一次的GC操作 </p>\n<h2 id=\"进度控制\"><a href=\"#进度控制\" class=\"headerlink\" title=\"进度控制\"></a>进度控制</h2><p>在Lua代码中，有两种回收方式，一种是自动回收，一种是由用户自己调用API来触发一次回收。<br>自动回收会在每次调用内存分配相关的操作时检查是再满足触发条件，这个操作在宏luaC_checkGC中进行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> luaC_checkGC(L) &#123; \\</span></span><br><span class=\"line\">  condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - <span class=\"number\">1</span>)); \\</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \\</span><br><span class=\"line\">\tluaC_step(L); &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，触发自动化GC的条件就是： totalbytes大于等于GCthreshold值。 在这两个变量中， totalbytes用于保存当前分配的内存大小，而GCthreshold保存的是一个｜竭值，这个值可以由一些参数影响和控制，由此改变触发的条件。<br>由于自动GC会在使用者不知道的情况下触发，不太可控，因而很多人选择关闭它，具体操作就是通过将GCthreshold设置为一个非常大的值来达到一直不满足自动触发条件。<br>接下来，看看手动 GC受哪些参数影响 。 首先， estimate 和 gcpause两个成员将影响每次GCthreshold 的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> setthreshold(g)  (g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)</span></span><br></pre></td></tr></table></figure>\n<p>这里estimate是一个预估的当前使用的内存数量，而gcpause则是一个百分比，这个宏的作用就是按照估计值的百分比计算出新的阔值来 。 其中， gcpause通过lua_gc这个C接口来进行设置。 可以看到，百分比越大，下一次开始GC的时间就会越长 。</p>\n<p>另一个影响GC进度的参数是gcstepmul成员，它同样可以通过 lua_gc来设置。 这个参数将影响每次手动GC时调用 singlestep函数的次数，从而影响到GC回收的速度：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">luaC_step</span> <span class=\"params\">(lua_State *L)</span> </span>&#123;</span><br><span class=\"line\">  global_State *g = G(L);</span><br><span class=\"line\">  l_mem lim = (GCSTEPSIZE/<span class=\"number\">100</span>) * g-&gt;gcstepmul;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lim == <span class=\"number\">0</span>)</span><br><span class=\"line\">    lim = (MAX_LUMEM<span class=\"number\">-1</span>)/<span class=\"number\">2</span>;  <span class=\"comment\">/* no limit */</span></span><br><span class=\"line\">  g-&gt;gcdept += g-&gt;totalbytes - g-&gt;GCthreshold;</span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    lim -= singlestep(L);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;gcstate == GCSpause)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span> (lim &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g-&gt;gcstate != GCSpause) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (g-&gt;gcdept &lt; GCSTEPSIZE)</span><br><span class=\"line\">      g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE;  <span class=\"comment\">/* - lim/g-&gt;gcstepmul;*/</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      g-&gt;gcdept -= GCSTEPSIZE;</span><br><span class=\"line\">      g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    lua_assert(g-&gt;totalbytes &gt;= g-&gt;estimate);</span><br><span class=\"line\">    setthreshold(g);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面简要说明这个函数中各行代码的作用 。</p>\n<ul>\n<li>第 612～614 行： GCSTEPSIZE 是一个宏，表示每次 GC 的步长大小 。 使用这个宏以及gcstepmul参数，可以计算出这一次回收计划至少回收的内存数量 。</li>\n<li>第615行： gcdept用于在每次回收之前累加当前使用内存到阔值之间的差值，用于后面计算下一次触发GC的阑值。</li>\n<li>第616-620行 ：当计划待回收内存还没有回收完之前，一直循环调用 singlestep 函数来进行回收，除非这里完成了完整的GC。</li>\n<li>第621 ～631 行 ：完成回收之后，设置下一次触发回收操作的 ｜胡值 。 如果此时状态不是GCSpause ，那么表示没有完成一个 GC ， 此时分两种情况来处理：如果前面保存的 gcdept太小，小于GCSTEPSIZE ，那么下一次阔值就设置得比当前使用内存大GCSTEPSIZE ，即只要再多分配 GCSTEPSIZE 的内存就会再次触发 GC ；否则将 gcdept 减去 GCSTEPSIZE ，将GCthreshold设置得跟 totalbytes一样，以求尽快触发下一次GC 。 如果完成了一个 GC,那么调用 setthreshold来计算下一次GC的阔值。 可以看到 setthreshold只会在一次GC完成之后被调用，而不会影响没有完成的GC全流程 。 因此， setthreshold影响的是两次完整GC之间的时长 。 而gcdept参数会在每次GC完毕之后重新清零，它用于保存一次完整GC的内部状态 。</li>\n</ul>\n<p>同时，还需要注意的一点是，这个过程会改变GCthreshold的值，所以如果希望关闭自动GC,还需要在手动执行完一次GC之后重新设置关闭自动GC 。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>《Lua设计与实现》<br>New Garbage Collector 详见<a href=\"http://wiki.luajit.org/New-Garbage-Collector\">http://wiki.luajit.org/New-Garbage-Collector</a></p>\n","tags":["lua"]}]