<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="losophy">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="losophy">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="losophy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>losophy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/losophy" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">losophy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/9a7f448e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/9a7f448e.html" class="post-title-link" itemprop="url">Jenkins</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 22:01:11" itemprop="dateCreated datePublished" datetime="2021-04-21T22:01:11+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Jenkins是一款由Java开发的开源软件项目，旨在提供一个开放易用的软件平台，使持续集成变成可能。</p>
<h2 id="通过Docker安装和启动Jenkins"><a href="#通过Docker安装和启动Jenkins" class="headerlink" title="通过Docker安装和启动Jenkins"></a>通过Docker安装和启动Jenkins</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins:1.554.1</span><br></pre></td></tr></table></figure>
<p>拉取镜像之后，我们先创建目录，然后就可以启动Jenkins的Container了，我们要把Jenkins的文件存储地址挂载到主机上，万一Jenkins的服务器重装或者迁移，我们都可以很方便地把之前的项目配置保留，否则就只能进入Container的文件系统里去复制了。另外，Jenkins会搭建在内网的服务器上，而非生产服务器，如果外网能直接访问，那么可能会造成一定的风险。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /var/jenkins_home</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -d --name myjenkins -p 49001:8080 -v /var/jenkins_home:/var/jenkins_home jenkins</span></span><br></pre></td></tr></table></figure>
<p>这样我们就顺利启动了Jenkins的服务，8080端口是Jenkins的默认监听端口，我们把它映射到了本地主机的49001端口，要注意把搭建Jenkins服务器的iptables关闭，一切顺利的话，我们就可以看到Jenkins的欢迎页面了。建议创建几个用户和权限，方便多人协同操作。<br><img src="https://user-images.githubusercontent.com/11263320/117755231-6a90cd80-b24e-11eb-89c2-01ad9bb291e8.JPG" alt="捕获"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/33b1eb02.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/33b1eb02.html" class="post-title-link" itemprop="url">skynet考古</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 22:02:05" itemprop="dateCreated datePublished" datetime="2021-04-09T22:02:05+08:00">2021-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="skynet版本的年表"><a href="#skynet版本的年表" class="headerlink" title="skynet版本的年表"></a>skynet版本的年表</h2><p><img src="https://user-images.githubusercontent.com/11263320/114987859-397be200-9ec8-11eb-9d47-d0cb15c4a4b2.JPG" alt="捕获"></p>
<h2 id="skynet-1"><a href="#skynet-1" class="headerlink" title="skynet 1"></a>skynet 1</h2><p>1.0 : 第一版released<br>1.1 : 增加socket.disconnected()<br>1.2 : 改进cluster支持，mongodb driver，redis driver，socket并发写，socket channel，service gate，udp支持，skynet.wait/wakeup。加入skynet.ignoreret，skynet.trace，skynet.context，socket.netstat，socketchannel.overload。升级Lua到5.3.5，升级jemalloc到5.1.0。<br>1.3 : 改进mysql driver，cluster，lua shared proto，socket.write。增加lua sharetable，https支持，websocket支持。升级jemalloc到5.2.1。<br>1.4 : 升级Lua到5.4.2。改进mysql driver，websocket，ssl，sproto。增加skynet.select，增加PKCS7加密算法，调试终端加入jmem，加入skynet_socket_pause，对日志增加时间戳。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/e0582cf9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/e0582cf9.html" class="post-title-link" itemprop="url">Hexo替换主题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 17:35:29" itemprop="dateCreated datePublished" datetime="2021-04-09T17:35:29+08:00">2021-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/6">Hexo+GitHub Pages博客搭建</a>搭建了博客，这里将替换hexo的主题。这个<a target="_blank" rel="noopener" href="https://hexo.io/themes/">网站</a>有很多主题可以供我们去选择。我们这次安装主题也是上面这些主题中其中一个，它就是 NexT。</p>
<h2 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h2><p>将主题克隆到themes目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;博客存放的目录&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/11263320/114160164-36797280-9959-11eb-95be-9fe07290a533.JPG" alt="gff"></p>
<h2 id="使用NexT主题"><a href="#使用NexT主题" class="headerlink" title="使用NexT主题"></a>使用NexT主题</h2><p>打开_config.yml文件，该文件为站点配置文件，存放位置如下图所示：<br><img src="https://user-images.githubusercontent.com/11263320/114160272-54df6e00-9959-11eb-907e-16f6e9a907f5.JPG" alt="fgsdfgs"><br>将主题修改为next<br><img src="https://user-images.githubusercontent.com/11263320/114160330-632d8a00-9959-11eb-80dd-fd3020941291.JPG" alt="hgdfshdg"></p>
<h2 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/11263320/114160707-ccad9880-9959-11eb-98b5-9baa2c65bb07.JPG" alt="捕获"><br>这里可能会出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro&#x2F;post.swig‘ as post_template %&#125;“</span><br></pre></td></tr></table></figure>
<p>原因是hexo在5.0之后把swig给删除了需要自己手动安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/258de02f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/258de02f.html" class="post-title-link" itemprop="url">使用ChunkSpy反编译Lua文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-08 22:56:39" itemprop="dateCreated datePublished" datetime="2021-04-08T22:56:39+08:00">2021-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ChunkSpy的工作原理是根据 luac编译之后的二进制文件格式进行解析 。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/post/258de02f.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/fd55994a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/fd55994a.html" class="post-title-link" itemprop="url">lua字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 14:41:12" itemprop="dateCreated datePublished" datetime="2021-03-22T14:41:12+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>c语言没有自带字符串类型，这导致有非常多的用c写的软件都自己实现一个处理字符串的类型。<br>一般来说，要表示一个字符串，核心就是以下两个数据：</p>
<ul>
<li>字符串长度 </li>
<li>指向存放字符串内存数据的指针</li>
</ul>
<p>Lua 自己的字符串类型的实现也没有绕过这两个核心内容</p>
<h2 id="内化的字符串"><a href="#内化的字符串" class="headerlink" title="内化的字符串"></a>内化的字符串</h2><ul>
<li>在Lua虚拟机中存在一个全局的数据区，用来存放当前系统中的所有字符串 </li>
<li>同一个字符串数据，在Lua虚拟机中只可能有一份副本，一个字符串一旦创建，将是不可变更的 </li>
<li>变量存放的仅是字符串的引用，而不是其实际内容</li>
</ul>
<p>Lua在字符串实现上使用内化这种方案（hash）的优点在于，进行字符串数据的比较和查找操作时，性能会提升不少，因为这两个操作的核心都是字符串的比较。传统的字符串比较算法是根据字符串长度逐位来进行对比，这个时间复杂度与字符串长度线性相关；而内化之后，在已知字符串散列值的情况下，只需要一次整数的比较即可。这个实现还有另一大好处，那就是空间优化，多份<br>相同的字符串在整个系统中只存在一份副本。Lua是一个在设计之初就把性能、资源占用等放在重要位置的语言，这里再一次得到了体现。<br>当然，这个实现并不是完全没有缺陷的。以前面描述的创建字符串的过程来说，在创建一个新的字符串时，首先会检查系统中是否有相同的数据，只有不存在的情况下才创建，这与直接创建字符串相比，多了一次查找过程。 </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** String headers for string table</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CommonHeader;</span><br><span class="line">    lu_byte reserved;<span class="comment">//是否是Lua虚拟机中的保留字符串，1不会在GC阶段被回收</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;<span class="comment">//字符串的散列值</span></span><br><span class="line">    <span class="keyword">size_t</span> len;<span class="comment">//字符串长度 </span></span><br><span class="line">  &#125; tsv;</span><br><span class="line">&#125; TString;</span><br></pre></td></tr></table></figure>
<p>可以看到，这是一个联合体，其目的是为了让TString数据类型按照 L_Umaxalign类型来对齐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.</span></span><br><span class="line"><span class="comment">** CHANGE it if your system requires alignments larger than double. (For</span></span><br><span class="line"><span class="comment">** instance, if your system supports long doubles and they must be</span></span><br><span class="line"><span class="comment">** aligned in 16-byte boundaries, then you should add long double in the</span></span><br><span class="line"><span class="comment">** union.) Probably you do not need to change this.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUAI_USER_ALIGNMENT_T	union &#123; double u; void *s; long l; &#125;</span></span><br></pre></td></tr></table></figure>
<p>在C语言中， struct/union这样的复合数据类型是按照这个类型中最大对齐革·的数据来对齐的，所以这里就是按照double类型的对齐量来对齐的。 之所以要进行对齐操作，是为了在CPU读取数据时性能更高 。</p>
<p>Lua会把系统中的所有字符串存在一个全局的地方，这个全局变量就是global_state的 strt成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> &#123;</span></span><br><span class="line">  stringtable strt;  <span class="comment">/* hash table for strings */</span></span><br><span class="line">  ...</span><br><span class="line">&#125; global_State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> &#123;</span></span><br><span class="line">  GCObject **hash;<span class="comment">//这是一个散列数组，专门用于存放字符串</span></span><br><span class="line">  ...</span><br><span class="line">&#125; stringtable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  GCheader gch;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">TString</span> <span class="title">ts</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当新创建一个字符串TString时，首先根据散列算法算出散列值，这就是strt数组的索引值。如果这里已经有元素，则使用链表串接起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TString *<span class="title">luaS_newlstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (l1=l; l1&gt;=step; l1-=step)  <span class="comment">/* compute hash */</span></span><br><span class="line">    h = h ^ ((h&lt;&lt;<span class="number">5</span>)+(h&gt;&gt;<span class="number">2</span>)+cast(<span class="keyword">unsigned</span> <span class="keyword">char</span>, str[l1<span class="number">-1</span>]));</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (ts-&gt;tsv.len == l &amp;&amp; (<span class="built_in">memcmp</span>(str, getstr(ts), l) == <span class="number">0</span>)) &#123;<span class="comment">//found</span></span><br><span class="line">      <span class="comment">/* string may be dead */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(G(L), o)) changewhite(o);</span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newlstr(L, str, l, h);  <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">newlstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">unsigned</span> <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ts = cast(TString *, luaM_malloc(L, (l+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)+<span class="keyword">sizeof</span>(TString)));</span><br><span class="line">  ts-&gt;tsv.len = l;</span><br><span class="line">  ts-&gt;tsv.hash = h;</span><br><span class="line">  ts-&gt;tsv.marked = luaC_white(G(L));</span><br><span class="line">  ts-&gt;tsv.tt = LUA_TSTRING;</span><br><span class="line">  ts-&gt;tsv.reserved = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(ts+<span class="number">1</span>, str, l*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  ((<span class="keyword">char</span> *)(ts+<span class="number">1</span>))[l] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">/* ending 0 */</span></span><br><span class="line">  tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  h = lmod(h, tb-&gt;size);</span><br><span class="line">  ts-&gt;tsv.next = tb-&gt;hash[h];  <span class="comment">/* chain new entry */</span></span><br><span class="line">  tb-&gt;hash[h] = obj2gco(ts);</span><br><span class="line">  tb-&gt;nuse++;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/11263320/111952507-3afff780-8b20-11eb-8aa4-400918ef6e1d.JPG" alt="捕获"></p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>当数据量非常大时，分配到每个桶上的数据也会非常多，这样一次查找也退化成了一次线性的查找过程。Lua中也考虑了这种情况，所以有一个重新散列（ rehash ）的过程，这就是当字符串数据非常多时，会重新分配桶的数量，降低每个桶上分配到的数据数量，这个过程在函数luaS_resize中。</p>
<p>有两处关于luaS_resize函数的调用</p>
<ul>
<li>lgc.c的checkSizes函数：这里会进行检查，如果此时桶的数量太大，比如是实际存放的字符串数量的4倍，那么会将散列桶数组减少为原来的一半。</li>
<li>lstring.c的newlstr函数：如果此时字符串的数量大于桶数组的数量，且桶数组的数量小于MAX_INT/2，那么就进行翻倍的扩容。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Lua设计与实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/6349ecd2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/6349ecd2.html" class="post-title-link" itemprop="url">lua Table</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 01:50:00" itemprop="dateCreated datePublished" datetime="2021-03-22T01:50:00+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>table实现了关联数组，即可以同时用数字和字符串索引的数组。<br>table是一种强大的语言构造。因为table的泛型特点，简化了使用lua编写程序所用的数据结构和算法。</p>
<h2 id="哈希与数组"><a href="#哈希与数组" class="headerlink" title="哈希与数组"></a>哈希与数组</h2><p>直到Lua 4.0为止，table都是作为纯哈希表实现的，所有的键值对都是显式存储的。在Lua 5.0版本引入了table的混合表示：每个table包含了一个哈希部分和一个数组部分，两个部分都可以是空的。Lua检测一个table是不是作为一个数组来使用，并自动将数字索引的值移动到数组部分，而非原本的存储在哈希部分。这种分裂只在底层实现层次进行；访问table域是透明的，即使是对虚拟机来说。table会自动根据内容使用两个部分。<br>这个混合机制有两个优点。第一，访问整型key的操作会变得更快了，因为不再需要哈希。第二，更重要的是，数组部分只占原来哈希部分的一半大小，因为哈希部分需要同时存储key和value，而数组部分的key已经隐含在下标了。结果是，如果一个table是作为数组使用的，它的表现就像数组一样，只要它的整型key是密集分布的。而且，哈希部分没有内存或者时间的代价，因为作为数组使用时，哈希部分不存在。反过来说，如果table是作为记录使用而非数组，那么数组部分就是空的。这些节省下来的内存是重要的。</p>
<h2 id="Lua核心突出角色"><a href="#Lua核心突出角色" class="headerlink" title="Lua核心突出角色"></a>Lua核心突出角色</h2><p>从Lua 4.0开始，全局变量就存储在普通的Lua table里，称为全局table。Lua 5.0用元表和元方法取代了tag和tag方法（Lua 3.0引入的）。元表是普通的Lua table，元方法是作为元表的域存储的。Lua 5.0也引入了环境table，可以附加到Lua函数上；它们就是Lua函数索引的全局环境。Lua 5.1将环境变量table扩展到C函数、userdata和协程，取代了全局的环境变量。这些改动简化了Lua的实现、Lua和C程序员所用的API，因为全局变量和元方法可以在Lua里操控，不再需要特殊函数了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先看看表的数据类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span> </span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of `node&#x27; array */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span><span class="comment">//存放该表的元表</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">//指向数组部分的指针</span></span><br><span class="line">  Node *node;  <span class="comment">//指向该表的散列桶数组起始位置的指针 </span></span><br><span class="line">  Node *lastfree;  <span class="comment">//指向该表散列桶数组的最后位置的指针</span></span><br><span class="line">  GCObject *gclist; <span class="comment">//GC相关的链表</span></span><br><span class="line">  <span class="keyword">int</span> sizearray;  <span class="comment">//数组部分的大小</span></span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>
<p>lu_byte_flags：这是一个byte类型的数据，用于表示这个表中提供了哪些元方法。最开始这个flags是空的，也就是0，当查找一次之后，如果该表中存在某个元方法，那么将该元方法对应的flag bit置为1，这样下一次查找时只需要比较这个bit就行了。每个元方法对应的bit定义在ltm. h文件中。<br>lu_byte_lsizenode：该表中以2为底的散列表大小的对数值。同时由此可知，散列表部分的大小一定是2的幕，即如果散列桶数组要扩展的话，也是以每次在原大小基础上乘以2的形式扩展。</p>
<p>从Node类型来看，它包含两个成员，一个是key，另一个是value（TValue）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">TKey</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">/* for chaining */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>
<h2 id="表查找"><a href="#表查找" class="headerlink" title="表查找"></a>表查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** search function for integers</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TValue *<span class="title">luaH_getnum</span> <span class="params">(Table *t, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */</span></span><br><span class="line">  <span class="keyword">if</span> (cast(<span class="keyword">unsigned</span> <span class="keyword">int</span>, key<span class="number">-1</span>) &lt; cast(<span class="keyword">unsigned</span> <span class="keyword">int</span>, t-&gt;sizearray))</span><br><span class="line">    <span class="keyword">return</span> &amp;t-&gt;<span class="built_in">array</span>[key<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_Number nk = cast_num(key);</span><br><span class="line">    Node *n = hashnum(t, nk);</span><br><span class="line">    <span class="keyword">do</span> &#123;  <span class="comment">/* check whether `key&#x27; is somewhere in the chain */</span></span><br><span class="line">      <span class="keyword">if</span> (ttisnumber(gkey(n)) &amp;&amp; luai_numeq(nvalue(gkey(n)), nk))</span><br><span class="line">        <span class="keyword">return</span> gval(n);  <span class="comment">/* that&#x27;s it */</span></span><br><span class="line">      <span class="keyword">else</span> n = gnext(n);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n);</span><br><span class="line">    <span class="keyword">return</span> luaO_nilobject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如采输入的Key是一个正坐数，并且它的位＞0 &amp;&amp; ＜= 数组且大小，尝试在数组部分查找。<br>如果不是，尝试在散列表部分查找，计算出该Key的散列值，根据此散列值访问Node数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该Key为止。<br>可以看到，即使是一个正整数的key，其存储部分也不见得会一定落在数组部分，这完全取决于它的大小是再落在了当前数组可容纳的空间范围内。也解释了ipairs遍历断裂的问题。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0</span> <span class="comment">-- 1作为数组部分存储下来</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span> <span class="comment">--100存储到散列表部分中</span></span><br></pre></td></tr></table></figure>
<h2 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h2><p>当找不到对应的key时，最终都会调用内部的 newkey函数分配一个新的key来返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** inserts a new key into a hash table; first, check whether key&#x27;s main </span></span><br><span class="line"><span class="comment">** position is free. If not, check whether colliding node is in its main </span></span><br><span class="line"><span class="comment">** position or not: if it is not, move colliding node to an empty place and </span></span><br><span class="line"><span class="comment">** put new key in its main position; otherwise (colliding node is in its main </span></span><br><span class="line"><span class="comment">** position), new key goes to an empty position. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TValue *<span class="title">newkey</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *key)</span> </span>&#123;</span><br><span class="line">  Node *mp = mainposition(t, key);</span><br><span class="line">  <span class="keyword">if</span> (!ttisnil(gval(mp)) || mp == dummynode) &#123;</span><br><span class="line">    Node *othern;</span><br><span class="line">    Node *n = getfreepos(t);  <span class="comment">/* get a free place */</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;  <span class="comment">/* cannot find a free place? */</span></span><br><span class="line">      rehash(L, t, key);  <span class="comment">/* grow table */</span></span><br><span class="line">      <span class="keyword">return</span> luaH_set(L, t, key);  <span class="comment">/* re-insert key into grown table */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_assert(n != dummynode);</span><br><span class="line">    othern = mainposition(t, key2tval(mp));</span><br><span class="line">    <span class="keyword">if</span> (othern != mp) &#123;  <span class="comment">/* is colliding node out of its main position? */</span></span><br><span class="line">      <span class="comment">/* yes; move colliding node into free position */</span></span><br><span class="line">      <span class="keyword">while</span> (gnext(othern) != mp) othern = gnext(othern);  <span class="comment">/* find previous */</span></span><br><span class="line">      gnext(othern) = n;  <span class="comment">/* redo the chain with `n&#x27; in place of `mp&#x27; */</span></span><br><span class="line">      *n = *mp;  <span class="comment">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class="line">      gnext(mp) = <span class="literal">NULL</span>;  <span class="comment">/* now `mp&#x27; is free */</span></span><br><span class="line">      setnilvalue(gval(mp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* colliding node is in its own main position */</span></span><br><span class="line">      <span class="comment">/* new node will go into free position */</span></span><br><span class="line">      gnext(n) = gnext(mp);  <span class="comment">/* chain new position */</span></span><br><span class="line">      gnext(mp) = n;</span><br><span class="line">      mp = n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  gkey(mp)-&gt;value = key-&gt;value; gkey(mp)-&gt;tt = key-&gt;tt;</span><br><span class="line">  luaC_barriert(L, t, key);</span><br><span class="line">  lua_assert(ttisnil(gval(mp)));</span><br><span class="line">  <span class="keyword">return</span> gval(mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>散列表部分的数据组织是，首先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织<br>上述代码主要操作：</p>
<ul>
<li>根据key来查找其所在散列桶的mainposition，如果返回的结果中，该Node的值为nil，那么直接将key赋值并且返回Node的TValue指针就可以了。</li>
<li>再则说明该mainposition上已经有其他数据了，需要重新分配空间给这个新的 key ，然后将这个新的Node串联到对应的散列桶上 。<br>可见，整个过程都是在散列桶部分进行的，理由是即使key是一个数字，也已经在调用 newkey函数之前进行了查找，结果却没有找到，所以这个key都会进入散列桶部分来查找。</li>
</ul>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>以上操作涉及重新对表空间进行分配的情况。入口函数是rehash，顾名思义，这个两数的作用就是为了做重新散列操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rehash</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *ek)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nasize, na;</span><br><span class="line">  <span class="keyword">int</span> nums[MAXBITS+<span class="number">1</span>];  <span class="comment">/* nums[i] = number of keys between 2^(i-1) and 2^i */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> totaluse;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=MAXBITS; i++) nums[i] = <span class="number">0</span>;  <span class="comment">/* reset counts */</span></span><br><span class="line">  nasize = numusearray(t, nums);  <span class="comment">/* count keys in array part */</span></span><br><span class="line">  totaluse = nasize;  <span class="comment">/* all those keys are integer keys */</span></span><br><span class="line">  totaluse += numusehash(t, nums, &amp;nasize);  <span class="comment">/* count keys in hash part */</span></span><br><span class="line">  <span class="comment">/* count extra key */</span></span><br><span class="line">  nasize += countint(ek, nums);</span><br><span class="line">  totaluse++;</span><br><span class="line">  <span class="comment">/* compute new size for array part */</span></span><br><span class="line">  na = computesizes(nums, &amp;nasize);</span><br><span class="line">  <span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">  resize(L, t, nasize, totaluse - na);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码主要操作：</p>
<ul>
<li>分配一个位图nums，将其中的所有位置0。这个位图的意义在于：nums数组中第 i个元素存放的是key在2{i- l）和i之间的元素数量。</li>
<li>遍历Lua表中的数组部分，计算其中的元素数量，更新对应的nums数组中的元素数量( numusearray函数）。</li>
<li>遍历 lua表中的散列桶部分，因为其中也可能存放了正整数，需要根据这里的正整数数量更新对应的nums数组元素数量（numusehash函数）</li>
<li>此时nums数组已经有了当前这个Table中所有正整数的分配统计，逐个遍历nums数组，获得其范围区间内所包含的整数数量大于50%的最大索引，作为重新散列之后的数组大小，超过这个范围的正整数，就分配到散列桶部分了（ computesizes函数）</li>
<li>根据上面计算得到的调整后的数组和散列桶大小调整表（ resize 函数）。</li>
</ul>
<p>在重新散列的过程中，除了增大Lua表的大小以容纳新的数据之外，还希望能借此机会对原有的数组和散列桶部分进行调整，让两部分都尽可能发挥其存储的最高容纳效率。那么，这里的标准是什么呢？希望在调整过后，数组在每一个2次方位置容纳的元素数量都超过该范围的50%。 能达到这个目标的话，就认为这个数组范围发挥了最大的效率。</p>
<p>当数字键值的统计跑完之后，得到了这个数组每个元素的数据，也就是得到了落在每个范围内的数据数量。接着会计算怎样才能最大限度地使用这部分空间 。这个算法由函数computesizes实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computesizes</span> <span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> *narray)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> twotoi;  <span class="comment">/* 2^i */</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">/* number of elements smaller than 2^i */</span></span><br><span class="line">  <span class="keyword">int</span> na = <span class="number">0</span>;  <span class="comment">/* number of elements to go to array part */</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;  <span class="comment">/* optimal size for array part */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, twotoi = <span class="number">1</span>; twotoi/<span class="number">2</span> &lt; *narray; i++, twotoi *= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      a += nums[i];</span><br><span class="line">      <span class="keyword">if</span> (a &gt; twotoi/<span class="number">2</span>) &#123;  <span class="comment">/* more than half elements present? */</span></span><br><span class="line">        n = twotoi;  <span class="comment">/* optimal size (till now) */</span></span><br><span class="line">        na = a;  <span class="comment">/* all elements smaller than n will go to array part */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == *narray) <span class="keyword">break</span>;  <span class="comment">/* all elements already counted */</span></span><br><span class="line">  &#125;</span><br><span class="line">  *narray = n;</span><br><span class="line">  lua_assert(*narray/<span class="number">2</span> &lt;= na &amp;&amp; na &lt;= *narray);</span><br><span class="line">  <span class="keyword">return</span> na;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>在一般算法库的设计中，针对容器类的迭代，会提供一个迭代器的数据，这个数据主要用于维护当前迭代到容器的哪部分数据了，下次再根据这个位置查找下一部分数据。表迭代不是这样设计的，很大的原因是为了兼容数组部分和散列桶部分的访问 。 迭代操作传入的不是一个迭代器，而是key。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaH_next</span> <span class="params">(lua_State *L, Table *t, StkId key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = findindex(L, t, key);  <span class="comment">/* find original element */</span></span><br><span class="line">  <span class="keyword">for</span> (i++; i &lt; t-&gt;sizearray; i++) &#123;  <span class="comment">/* try first array part */</span></span><br><span class="line">    <span class="keyword">if</span> (!ttisnil(&amp;t-&gt;<span class="built_in">array</span>[i])) &#123;  <span class="comment">/* a non-nil value? */</span></span><br><span class="line">      setnvalue(key, cast_num(i+<span class="number">1</span>));</span><br><span class="line">      setobj2s(L, key+<span class="number">1</span>, &amp;t-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i -= t-&gt;sizearray; i &lt; sizenode(t); i++) &#123;  <span class="comment">/* then hash part */</span></span><br><span class="line">    <span class="keyword">if</span> (!ttisnil(gval(gnode(t, i)))) &#123;  <span class="comment">/* a non-nil value? */</span></span><br><span class="line">      setobj2s(L, key, key2tval(gnode(t, i)));</span><br><span class="line">      setobj2s(L, key+<span class="number">1</span>, gval(gnode(t, i)));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no more elements */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是在数组部分还是散列桶部分查找数据，查找成功都会返回该key的下一个数据。<br>这个函数一开始就进入findindex中进行查询，并区分数组和散列桶部分。findindex函数的返回结果是一个整数索引，如果这个索引在表的sizearray之内，则说明落入到数组部分，否则就落入到散列桶部分。在luaH_next函数中使用这个返回值时，看起来是两个循环，实际上已经根据这个值的范围进行了区分，不会同一个key走入两个循环中。而在返回散列桶部分时，这个索引值为”sizearray＋对应散列柏索引的值”。</p>
<h2 id="取长度操作"><a href="#取长度操作" class="headerlink" title="取长度操作"></a>取长度操作</h2><p>在Lua中，可以使用#符号对表进行取长度操作。对Lua中的表进行取长度操作时，如果没有提供该表的元方法_len，那么该操作只针对该表的序列（ sequence ）部分进行。 “序列”指的是表的一个子集{1 … n}，其中 n是一个正整数，并且里面每个键对应的数据都不为nil。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Try to find a boundary in table `t&#x27;. A `boundary&#x27; is an integer index</span></span><br><span class="line"><span class="comment">** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaH_getn</span> <span class="params">(Table *t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j = t-&gt;sizearray;</span><br><span class="line">  <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; ttisnil(&amp;t-&gt;<span class="built_in">array</span>[j - <span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="comment">/* there is a boundary in the array part: (binary) search for it */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j - i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> m = (i+j)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (ttisnil(&amp;t-&gt;<span class="built_in">array</span>[m - <span class="number">1</span>])) j = m;</span><br><span class="line">      <span class="keyword">else</span> i = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* else must find a boundary in hash part */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;node == dummynode)  <span class="comment">/* hash part is empty? */</span></span><br><span class="line">    <span class="keyword">return</span> j;  <span class="comment">/* that is easy... */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> unbound_search(t, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果表中混合了这两种风格的数据，那么优先取数组部分的长度。如果表存在数组部分，在数组部分二分查找返回位置。如果前面的数组部分查不到满足条件的数据，进入散列表部分查找。<br>所以，尽量不要将一个表混用数组和散列桶部分，即一个表最好只存放一类数据。Lua的实现上确实提供了两者统一表示的遍历，但是这不意味着使用者就应该混用这两种方式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Lua设计与实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/ba161a39.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/ba161a39.html" class="post-title-link" itemprop="url">lua gc</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 01:22:15" itemprop="dateCreated datePublished" datetime="2021-03-22T01:22:15+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GC算法的原理大体就是：遍历系统中的所有对象，看哪些对象没有被引用，没有引用关系的就认为是可以回收的对象，可以删除 。<br>这里的关键在于，如何找出没有“引用”的对象。<br>使用引用计数的GC算法，会在一个对象被引用的情况下将该对象的引用计数加一 ，反之减一。 如果引用计数为0 ，那么就是没有引用的对象。 引用计数算法的优点是不需要扫描每个对象，对象本身的引用计数只需要减到0，就会被回收。 缺点是会有循环引用问题<br>另一种算法是标记清除算法（ Mark and Sweep ）。 它的原理是每一次做GC的时候，首先扫描并且标记系统中 的所有对象，被扫描并且标记到的对象认为是可达的（ reachable ），这些对象不会被回收；反之，没有被标记的对象认为是可以回收的 。 Lua采用的就是这种算法 。</p>
<h2 id="双色标记清除算法"><a href="#双色标记清除算法" class="headerlink" title="双色标记清除算法"></a>双色标记清除算法</h2><p>早期的Lua 5.0使用的是双色标记清除算法，该算法的原理是 ：系统中的每个对象非黑即白，也就是要么被引用，要么没有被引用。<br>具体操作是这样的：</p>
<ul>
<li>每个新创建的对象的颜色为白色</li>
<li>在初始化阶段，边历root链表中的对象，并将其加入到对象链表中</li>
<li>在标记阶段，当对象链表中还有未扫描的元素，从中取出一个对象并将其标记为黑色，边历这个对象关联的其他所有对象，标记为黑色</li>
<li>在回收阶段，追历所有对象，如果为白色，这些对象就是没有被引用的对象，逐个回收。否则，这些对象是被引用的对象 ， 重新加入对象链表中等待丁一轮的GC检查。<br><img src="https://user-images.githubusercontent.com/11263320/112426112-4cd8d900-8d72-11eb-91d9-6b23756e362f.JPG" alt="捕获"><br>这个算法的缺陷在于，每个对象的状态是“二元”的，每个对象只可能有一种状态，不能有其他中间状态，这就要求这个算法每次做GC操作时不可被打断地一次性扫描并清除完所有对象。<br>如果在遍历对象链表时标记每个对象颜色的过程中被打断，此时新增了一个对象，那么应该将这个对象标记为白色还是黑色？如果标记为白色，假如GC已经到了回收阶段，那么这个对象就会在没有遍历其关联对象的情况下被回收；如果标记为黑色，假如GC已经到了回收阶段，那么这个对象在本轮GC中并没有被扫描过就认为是不必回<br>收的 。 可以看到，在双色标记清除算法中，标记阶段和回收阶段必须合在一起完成。<br>不能被打断，也就意味着每次GC操作的代价极大。在GC过程中，程序必须暂停下来，不能进行其他操作。</li>
</ul>
<h2 id="三色增量标记清除算法"><a href="#三色增量标记清除算法" class="headerlink" title="三色增量标记清除算法"></a>三色增量标记清除算法</h2><p>从Lua 5.1 开始，采用了在该算法的基础上改进的三色增量标记清除算法。与前面的算法相比，这个算法中每个对象的颜色多了一种（实际上，在Lua中是4种，后面再展开讨论）。 这样的好处在于：它不必再要求GC一次性扫描完所有的对象，这个GC过程可以是增量的，可以被中断再恢复并继续进行的 。<br>3种颜色的分类如下：</p>
<ul>
<li>白色： 当前对象为待访问状态，表示对象还没有被GC标记过，这也是任何一个对象创建后的初始状态。 换言之，如果一个对象在结束GC扫描过程后仍然是白色，则说明该对象没有被系统中的任何一个对象所引用，可以回收其空间了 。</li>
<li>灰色： 当前对象为待扫描状态，表示对象已经被GC访问过，但是该对象引用的其他对象还没有被访问到 。</li>
<li>黑色： 当前对象为己扫描状态，表示对象已经被GC访问过，并且该对象引用的其他对象也被访问过了 。<br><img src="https://user-images.githubusercontent.com/11263320/112426834-9544c680-8d73-11eb-97eb-ca4ada95361d.JPG" alt="捕获"><br>具体操作是这样的：</li>
<li>每个新创建的对象颜色为白色</li>
<li>初始化阶段，远历 root 节点中引用的对象，从白色置为灰色，并且放入到灰色节点列表中</li>
<li>标记阶段，当灰色链表中还有未扫描的元素，从中取出一个对象并将其标记为黑色，遍历这个对象关联的其他所有对象．如果是白色，标记为灰色，加入灰色链表中。</li>
<li>回收阶段，遍历所有对象，如果为白色，这些对象都是没有被引用的对象，逐个回收。否则，重新加入对象链求中等待丁一轮的 GC检查</li>
</ul>
<p>可以看到，引入了灰色节点的概念后，算法不再要求一次性完整执行完毕，而是可以把已经扫描但是其引用的对象还未被扫描的对象置为灰色。 在标记阶段中，只要灰色节点集合中还有元素在，那么这个标记过程就会继续下去，即使中间被打断转而执行其他操作了，也没有关系 。</p>
<p>然而即使是这样，却仍然有另一个没有解决的问题。 从上面的算法可以看出，没有被引用的对象的颜色在扫描过程中始终保持不变，为白色 。 那么，假如一个对象在GC过程的标记阶段之后创建，根据前面对颜色的描述，它应该是白色的，这样在紧跟着的回收阶段，这个对象就会在没有被扫描标记的情况下被认为是没有被引用的对象而删除 。</p>
<p>因此， Lua的GC算法除了前面的三色概念之外，又细分出来一个“双白色”的概念 。 简单地说， Lua中的白色分为“当前白色”和“非当前臼色”。 这两种白色的状态交替使用，第N；欠GC使用的是第一种白色，那么下一次就是另外一种，以此类推。</p>
<p>代码在回收时会做判断，如果某个对象的白色不是此次GC使用的白色状态，那么将不会认为是没有被引用的对象而回收，这样的白色对象将留在下一次GC中进行扫描，因为在下一次GC中上一次幸免的白色将成为这次的回收颜色。</p>
<h2 id="GC的全流程"><a href="#GC的全流程" class="headerlink" title="GC的全流程"></a>GC的全流程</h2><p>Lua内部用一个宏表示哪些数据类型需要进行GC ( Garbage Collection ，垃圾回收）操作 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iscollectable(o) (ttype(o) &gt;= LUA TSTRING)</span></span><br></pre></td></tr></table></figure>
<p>可以看到， LUA TSTRING （包括 LUA TSTRING ）之后的数据类型都需要进行GC操作 。</p>
<p>需要进行GC操作的数据类型都会有一个CommonHeader宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>
<p>next：GCObject链表指针，这个指针将所有GC对象都链接在一起形成链表<br>tt：表示数据的类型，即<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/109">lua数据类型</a>的宏 。<br>marked : 标记字段，用于存储前面提到的几种颜色。<br>marked具体值定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Layout for bit use in `marked&#x27; field:</span></span><br><span class="line"><span class="comment">** bit 0 - object is white (type 0)</span></span><br><span class="line"><span class="comment">** bit 1 - object is white (type 1)</span></span><br><span class="line"><span class="comment">** bit 2 - object is black</span></span><br><span class="line"><span class="comment">** bit 3 - for userdata: has been finalized</span></span><br><span class="line"><span class="comment">** bit 3 - for tables: has weak keys</span></span><br><span class="line"><span class="comment">** bit 4 - for tables: has weak values</span></span><br><span class="line"><span class="comment">** bit 5 - object is fixed (should not be collected)</span></span><br><span class="line"><span class="comment">** bit 6 - object is &quot;super&quot; fixed (only the main thread)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE0BIT	0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE1BIT	1   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACKBIT	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINALIZEDBIT	3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYWEAKBIT	3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUEWEAKBIT	4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIXEDBIT	5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFIXEDBIT	6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)</span></span><br></pre></td></tr></table></figure>
<p>这里WHITE OBIT和WHITE1BIT就是前面提到的两种 白色状态，称为0型白色和 l型白色。 当前的白色见lobal_State 中的 currentwhite ，而otherwhit e宏用于表示非当前GC将要回收的白色类型 。 切换白色，需要使用 changewhite宏 ； 要得到当前的白色状态，则使用luaC_white宏 。</p>
<p>FINALIZEDBIT用于标记没有被引用需要回收的 udata 。 u data 的处理与其他数据类型不同，<br>由于它是用户传人的数据，它的回收可能会调用用户注册的GC函数，所以统一来处理。<br>KEYWE A KBIT和VALUEWE A KBIT用于标记弱表中键／值的weak属性 。FIXEDBIT和 SFIXEDBIT用于表示该对象不可回收，其中 F IX ED BIT仅用于 lua State对象自身的标记，而SFIXEDBIT标记了一系列Lua语法中的关键字对应的字符串为不可回收字符串，具体可以看看l u aX i n it 函数的实现</p>
<p>在保存全局状态的global_State结构体中，有以下几个与GC相关的数据成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> &#123;</span></span><br><span class="line">  lu_byte currentwhite;<span class="comment">//存放当前GC的白色</span></span><br><span class="line">  lu_byte gcstate;  <span class="comment">//存放GC状态，分别有以下几种 ： GCS pause （暂停阶段） 、 GCSpropagate（传播阶段，用于遍历灰色节点检查对象的引用情况）、 GCSsweepstring （字符串回收阶段） , GCSsweep （回收阶段，用于对除了字符串之外的所有其他数据类型进行回收）和GCSfinalize （终止阶段） 。</span></span><br><span class="line">  <span class="keyword">int</span> sweepstrgc;  <span class="comment">//字符串回收阶段，每次针对字符串散列桶的一组字符串进行回收，这个值用于记录对应的散列桶索引 。</span></span><br><span class="line">  GCObject *rootgc;  <span class="comment">//存放待GC对象的链表，所有对象创建之后都会放入该链表中</span></span><br><span class="line">  GCObject **sweepgc; <span class="comment">//待处理的回收数据都存放在rootgc链表中，由于回收阶段不是一次性全部回收这个链表的所有数据，所以使用这个变量来保存当前回收的位置，下一次从这个位置开始继续回收操作</span></span><br><span class="line">  GCObject *gray;  <span class="comment">//存放灰色节点的链表</span></span><br><span class="line">  GCObject *grayagain; <span class="comment">//存放需要一次性扫描处理的灰色节点链表，也就是说，这个链表上所有数据的处理需要一步到位，不能被打断</span></span><br><span class="line">  GCObject *weak;  <span class="comment">//存放弱表的链表</span></span><br><span class="line">  GCObject *tmudata;  <span class="comment">//所有带有GC元方法的 udata存放在一个链表中，这个成员指向这千链表的最后一个元素</span></span><br><span class="line">  lu_mem GCthreshold;<span class="comment">//开始进行GC的阔值，当totalbytes大于这个值时开始自动GC</span></span><br><span class="line">  lu_mem totalbytes;  <span class="comment">//当前分配的内存大小</span></span><br><span class="line">  lu_mem estimate; <span class="comment">//一个估计值，用于保存实际在用的内存大小 </span></span><br><span class="line">  lu_mem gcdept;  <span class="comment">//用于在单次GC之前保存待回收的数据大小</span></span><br><span class="line">  <span class="keyword">int</span> gcpause;  <span class="comment">//用于控制下一轮GC开始的时机</span></span><br><span class="line">  <span class="keyword">int</span> gcstepmul; <span class="comment">//控制GC的回收速度</span></span><br><span class="line">  ...</span><br><span class="line">&#125; global_State;</span><br></pre></td></tr></table></figure>
<h3 id="新创建对象"><a href="#新创建对象" class="headerlink" title="新创建对象"></a>新创建对象</h3><p>从前面的分析可以知道，对于每个新创建的对象，最基本的操作就是将对象的颜色设置为白色，意指本次GC还未扫描到的对象，同时将对象挂载到扫描过程会遍历的链表上 。 基本思想就是如此，但是针对不同的数据类型，会有不同的处理。</p>
<p>一般的数据类型调用的是luaC_link函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_link</span> <span class="params">(lua_State *L, GCObject *o, lu_byte tt)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  o-&gt;gch.next = g-&gt;rootgc;</span><br><span class="line">  g-&gt;rootgc = o;</span><br><span class="line">  o-&gt;gch.marked = luaC_white(g);</span><br><span class="line">  o-&gt;gch.tt = tt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数做的事情为：</p>
<ul>
<li>将对象挂载到 rootgc链表上</li>
<li>设置颜色为白色</li>
<li>设置数据的类型</li>
</ul>
<p>但是UpValue和udata类型的数据的创建过程有些不一样<br>先来看UpValue，新建一个UpValue类型的数据，调用的是luaC_linkupval函数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_linkupval</span> <span class="params">(lua_State *L, UpVal *uv)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = obj2gco(uv);</span><br><span class="line">  o-&gt;gch.next = g-&gt;rootgc;  <span class="comment">/* link upvalue into `rootgc&#x27; list */</span></span><br><span class="line">  g-&gt;rootgc = o;</span><br><span class="line">  <span class="keyword">if</span> (isgray(o)) &#123; </span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcstate == GCSpropagate) &#123;</span><br><span class="line">      gray2black(o);  <span class="comment">/* closed upvalues need barrier */</span></span><br><span class="line">      luaC_barrier(L, uv, uv-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* sweep phase: sweep it (turning it into white) */</span></span><br><span class="line">      makewhite(g, o);</span><br><span class="line">      lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的疑问是，前面的数据类型在最开始的时候 ，都是将颜色设置为白色，而针对UpValue,则是根据颜色是不是灰色来做后面的一些操作 。 原因在于， UpValue是针对已有对象的间接引用，所以它的处理在对象颜色是灰色的情况下区分了两种情况 。</p>
<ul>
<li>如果当前在扫描阶段，那么将对象从灰色变成黑色 。 需要注意的是，到这一步需要加barrier </li>
<li>如果不是在扫描阶段，都置为白色 。 第705行的注释说到这一步，将其回 收， 其实这个表达并不完全准确 。 这里置为白色，我的理解和创建其他类型数据的函数luaC link一样，都是一个创建对象的正常流程 。</li>
</ul>
<p>再来看udata数据的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Udata *<span class="title">luaS_newudata</span> <span class="params">(lua_State *L, <span class="keyword">size_t</span> s, Table *e)</span> </span>&#123;</span><br><span class="line">  Udata *u;</span><br><span class="line">  <span class="keyword">if</span> (s &gt; MAX_SIZET - <span class="keyword">sizeof</span>(Udata))</span><br><span class="line">    luaM_toobig(L);</span><br><span class="line">  u = cast(Udata *, luaM_malloc(L, s + <span class="keyword">sizeof</span>(Udata)));</span><br><span class="line">  u-&gt;uv.marked = luaC_white(G(L));  <span class="comment">/* is not finalized */</span></span><br><span class="line">  u-&gt;uv.tt = LUA_TUSERDATA;</span><br><span class="line">  u-&gt;uv.len = s;</span><br><span class="line">  u-&gt;uv.metatable = <span class="literal">NULL</span>;</span><br><span class="line">  u-&gt;uv.env = e;</span><br><span class="line">  <span class="comment">/* chain it on udata list (after main thread) */</span></span><br><span class="line">  u-&gt;uv.next = G(L)-&gt;mainthread-&gt;next;</span><br><span class="line">  G(L)-&gt;mainthread-&gt;next = obj2gco(u);</span><br><span class="line">  <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何时候创建的 udata ，在GC链表中都会放在mainthread之后 。 除此之外，这类型的数据与其他数据并无差别 。 之所以这么做，是因为udata是用户注册的C数据。 在回收时，我们可能会调用用户注册的函数，此时就需要把这些udata统一放在一个地方来处理，这样做是为了方便编写代码 。 </p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>前面提到过， Lua的GC过程是增聋的 、 中间可以被打断的，每一次单独进入 GC时，都会根据当前GC所处的阶段来进行不同的处理，这个人口函数是singlestep。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (g-&gt;gcstate) &#123;</span><br><span class="line">  <span class="keyword">case</span> GCSpause: &#123;</span><br><span class="line">    markroot(L);  <span class="comment">/* start a new collection */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>初始化阶段将从root节点出发，遍历rootl连表上的所有节点，将它们的颜色从白色变成灰色，加入到gray链表中 。 初始化阶段的人口是markroot函数 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mark root set */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markroot</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  g-&gt;gray = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">  markobject(g, g-&gt;mainthread);</span><br><span class="line">  <span class="comment">/* make global table be traversed before main stack */</span></span><br><span class="line">  markvalue(g, gt(g-&gt;mainthread));</span><br><span class="line">  markvalue(g, registry(L));</span><br><span class="line">  markmt(g);</span><br><span class="line">  g-&gt;gcstate = GCSpropagate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 markobject和『『1arkvalue函数都用于标记对象的颜色为灰色，不同的是前者是针对object而后者是针对TValue ，它们最终都会调用reallymarkobject 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reallymarkobject</span> <span class="params">(global_State *g, GCObject *o)</span> </span>&#123;</span><br><span class="line">  lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">  white2gray(o);</span><br><span class="line">  <span class="keyword">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSTRING: &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TUSERDATA: &#123;</span><br><span class="line">      Table *mt = gco2u(o)-&gt;metatable;</span><br><span class="line">      gray2black(o);  <span class="comment">/* udata are never gray */</span></span><br><span class="line">      <span class="keyword">if</span> (mt) markobject(g, mt);</span><br><span class="line">      markobject(g, gco2u(o)-&gt;env);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TUPVAL: &#123;</span><br><span class="line">      UpVal *uv = gco2uv(o);</span><br><span class="line">      markvalue(g, uv-&gt;v);</span><br><span class="line">      <span class="keyword">if</span> (uv-&gt;v == &amp;uv-&gt;u.value)  <span class="comment">/* closed? */</span></span><br><span class="line">        gray2black(o);  <span class="comment">/* open upvalues are never black */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TFUNCTION: &#123;</span><br><span class="line">      gco2cl(o)-&gt;c.gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTABLE: &#123;</span><br><span class="line">      gco2h(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTHREAD: &#123;</span><br><span class="line">      gco2th(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_TPROTO: &#123;</span><br><span class="line">      gco2p(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">      g-&gt;gray = o;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: lua_assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于绝大部分类型的对象，这里只是简单地将其颜色改变为灰色并加入到gray链表中，但是有几个类型是区别处理的</p>
<ul>
<li>对于字符串类型的数据，由于这种类型没有引用其他数据，所以略过将其颜色改为灰色的流程，直接将不是黑色的字符串对象回收即可 。</li>
<li>对于 udata类型的数据，因为这种类型永远也不会引用其他数据，所以这里也是一步到位，直接将其标记为黑色。 另外，对于这种类型，还需要标记对应的metatable和env表。</li>
<li>对于UpValue类型的数据，如果当前是close状态的话，那么该UpValue 已经没有与其他数据的引用关系了，可以直接标记为黑色 。 至于open状态的 UpValue ，由于其引用状态可能会频繁发生变动，所以留待后面的remarkupvals函数进行原子性的标记</li>
</ul>
<h3 id="扫描标记阶段"><a href="#扫描标记阶段" class="headerlink" title="扫描标记阶段"></a>扫描标记阶段</h3><p>扫描阶段就是遍历灰色对象链表来分析对象的引用情况，这个阶段是GC所有阶段中步骤最长的 。 整个过程分为两部分。 第一步首先遍历gray链表来标记所有数据，在这个过程中，有些数据需要重新扫描，这些数据会放在grayagain链表中，调用 atomic 函数重新进行扫描。 而第二步则是遍历grayagain链表，一次性扫描其中的数据 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GCSpropagate: &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;gray)</span><br><span class="line">        <span class="keyword">return</span> propagatemark(g);</span><br><span class="line">      <span class="keyword">else</span> &#123;  <span class="comment">/* no more `gray&#x27; objects */</span></span><br><span class="line">        atomic(L);  <span class="comment">/* finish mark phase */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一步将扫描所有gray链表中的对象，将它们及其引用到的对象标记成黑色 。 需要注意的是，前面的初始化阶段是一次到位的，而这一步却可以多次进行，每次扫描之后会返回本次扫描标记的对象大小之和，其入口函数是propagatemark ，再次扫描时，只要gray链表中还有待扫描的对象，就继续执行这个函数进行标记 。 当灰色链表已经遍历完毕时，进入atomic函数中完成标记阶段。</p>
<p>可以看到，第一步遍历gray链表中对象的处理是可以中断的，而第二步调用atomic 函数的操作是原子的、不能被打断的，这也是atomic函数的名字由来 。 这是Lua 5.1 的GC算法优于之前版本的GC算法的原因之一 ： 可以增量地来进行数据扫描，不会因为一次GC扫描操作导致整个系统被卡住很久 。</p>
<p>propagatemark 函数与前面的 reallymarkobject 函数做的事情其实差不多，都是对对象标记颜色的动作 。 区别在于，这里将对象从灰色标记成黑色，表示这个对象及其所引用的对象都已经标记过 。 另一个区别在于，前面的流程不会递归对一个对象所引用的对象进行标记，而这里会根据不同的类型调用对应向土raverse＊函数进行标记。 在实际工作中，对每种类型的对象的处理还不太一样，下面逐个类型来看看 。</p>
<h4 id="扫描Table对象"><a href="#扫描Table对象" class="headerlink" title="扫描Table对象"></a>扫描Table对象</h4><p>在tra versetable函数中，如果扫描到该表是弱表，那么将会把该对象加入weak链表中，这个链表将在扫描阶段的最后一步进行一次不能中断的处理，这部分将在后面谈到 。 同时，如果该表是弱表，那么将该对象回退到灰色状态，重新进行扫描。 在不是弱表的情况下，将遍历标记表的散列部分及数组部分的所有元素 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (o-&gt;gch.tt) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TTABLE: &#123;</span><br><span class="line">      Table *h = gco2h(o);</span><br><span class="line">      g-&gt;gray = h-&gt;gclist;</span><br><span class="line">      <span class="keyword">if</span> (traversetable(g, h))  <span class="comment">/* table is weak? */</span></span><br><span class="line">        black2gray(o);  <span class="comment">/* keep it gray */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">sizeof</span>(Table) + <span class="keyword">sizeof</span>(TValue) * h-&gt;sizearray +</span><br><span class="line">                             <span class="keyword">sizeof</span>(Node) * sizenode(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描函数对象"><a href="#扫描函数对象" class="headerlink" title="扫描函数对象"></a>扫描函数对象</h4><p>针对函数对象，进行处理的函数是traverseclosure ，该函数主要是对函数中的所有 UpValue进行标记。 相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LUA_TFUNCTION: &#123;</span><br><span class="line">      Closure *cl = gco2cl(o);</span><br><span class="line">      g-&gt;gray = cl-&gt;c.gclist;</span><br><span class="line">      traverseclosure(g, cl);</span><br><span class="line">      <span class="keyword">return</span> (cl-&gt;c.isC) ? sizeCclosure(cl-&gt;c.nupvalues) :</span><br><span class="line">                           sizeLclosure(cl-&gt;l.nupvalues);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描线程对象"><a href="#扫描线程对象" class="headerlink" title="扫描线程对象"></a>扫描线程对象</h4><p>针对线程对象，这里的处理是将该对象从gcli st中摘下来，放入grayaga in链表中，同时将颜色退回到灰色，以备后面的原子阶段再做一次扫描 。 因为t hread上关联的对象是Lua运行时的状态，变化很频繁，所以这里只是简单地放在grayagain链表中 ， 后面再一次性标记完毕 。 相关代码如下 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LUA_TTHREAD: &#123;</span><br><span class="line">      lua_State *th = gco2th(o);</span><br><span class="line">      g-&gt;gray = th-&gt;gclist;</span><br><span class="line">      th-&gt;gclist = g-&gt;grayagain;</span><br><span class="line">      g-&gt;grayagain = o;</span><br><span class="line">      black2gray(o);</span><br><span class="line">      traversestack(g, th);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">sizeof</span>(lua_State) + <span class="keyword">sizeof</span>(TValue) * th-&gt;stacksize +</span><br><span class="line">                                 <span class="keyword">sizeof</span>(CallInfo) * th-&gt;size_ci;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描proto对象"><a href="#扫描proto对象" class="headerlink" title="扫描proto对象"></a>扫描proto对象</h4><p>最后一种特殊类型是 Proto类型，将会调用traverseproto函数标记一个 Proto数据中的文件名、字符串 、 upvalue 、局部变量等所有被引用的对象 。</p>
<h4 id="扫描其余的类型"><a href="#扫描其余的类型" class="headerlink" title="扫描其余的类型"></a>扫描其余的类型</h4><p>就是简单地调用gray2black将颜色从灰色置为黑色就好了</p>
<h4 id="barrier操作"><a href="#barrier操作" class="headerlink" title="barrier操作"></a>barrier操作</h4><p>从前面的描述可以知道，分步增量式的扫描标记算法中间可以被打断以执行其他操作，此时就会出现新增加的对象与已经被扫描过的对象之间会有引用关系的变化，而算法中需要保证不会出现黑色对象引用的对象中有白色对象的情况，于是需要两种不同的处理</p>
<ul>
<li>标记过程向前走一步。 这种情况指的是，如果一个新创建对象的颜色是白色，而它被一个黑色对象引用了，那么将这个对象的颜色从白色变成灰色，也就是这个GC过程中的进度向前走了一步。</li>
<li>标记过程向后走一步 。 与前面的情况一样，但是此时是将黑色的对象回退到灰色，也就是这个原先已经被标记为黑色的对象需要重新被扫描，这相当于在GC过程中向后走了一步 。<br>在代码中，最终调用 luaC ba rr ierf函数的都是向前走的操作；反之，调用luaC barrierback的操作则是向后走的操作：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_barrier(L,p,v) &#123; <span class="meta-keyword">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(p)))  \</span></span><br><span class="line">	luaC_barrierf(L,obj2gco(p),gcvalue(v)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_barriert(L,t,v) &#123; <span class="meta-keyword">if</span> (valiswhite(v) &amp;&amp; isblack(obj2gco(t)))  \</span></span><br><span class="line">	luaC_barrierback(L,t); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_objbarrier(L,p,o)  \</span></span><br><span class="line">	&#123; <span class="keyword">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(p))) \</span><br><span class="line">		luaC_barrierf(L,obj2gco(p),obj2gco(o)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_objbarriert(L,t,o)  \</span></span><br><span class="line">   &#123; <span class="keyword">if</span> (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(t))) luaC_barrierback(L,t); &#125;</span><br></pre></td></tr></table></figure>
可以看到，回退操作仅针对Table类型的对象，而其他类型的对象都是向前操作 。<br>Table是Lua中最常见的数据结构，而且一个Tab le与其关联的k町、 va lue之间是 l t~N的对应关系 。 如果针对Table对象做的是向前的标记操作，那么就意味着：但凡一个Table只要有新增的对象，都帘要将这个新对象标记为灰色并加入gray链表中等待扫描。<br>实际上，这样会有不必要的开销 。 所以，针对Table类型的对象，使用的是针对该Table对象本身要做的向后操作，这样不论有多少个对象新增至UTable中，只要改变了一次，就将这个Table对象回退到灰色状态，等待重新扫描 。 但是这里需要注意的是，对Table对象进行回退操作时，并不是将它放入gray链表中，因为这样做实际上还会出现前面提到的多次反复标记的问题。 针对Table对象，对它执行回退操作，是将它加入到 grayagain链表中，用于在扫描完毕gray链表之后再进行一次性的原子扫描：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_barrierback</span> <span class="params">(lua_State *L, Table *t)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = obj2gco(t);</span><br><span class="line">  lua_assert(isblack(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">  black2gray(o);  <span class="comment">/* make table gray (again) */</span></span><br><span class="line">  t-&gt;gclist = g-&gt;grayagain;</span><br><span class="line">  g-&gt;grayagain = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，需要进行barrierback操作的对象，最后并没有如新建对象那样加入gray链表中，而是加入grayagain列表中，避免一个对象频繁地进行“被回退－扫描－回退－扫描”过程 。 既然需要重新扫描，那么一次J性地放在grayagain链表中就可以了 。 至于如何回收grayagain链表中的数据，下面将说明</li>
</ul>
<p>而相对地，向前的操作就简单多了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_barrierf</span> <span class="params">(lua_State *L, GCObject *o, GCObject *v)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span><br><span class="line">  lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">  lua_assert(ttype(&amp;o-&gt;gch) != LUA_TTABLE);</span><br><span class="line">  <span class="comment">/* must keep invariant? */</span></span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcstate == GCSpropagate)</span><br><span class="line">    reallymarkobject(g, v);  <span class="comment">/* restore invariant */</span></span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">/* don&#x27;t mind */</span></span><br><span class="line">    makewhite(g, o);  <span class="comment">/* mark as white just to avoid other barriers */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只要当前的GC没有在扫描标记阶段，就标记这个对象，否则将对象标记为白色，等待下一次的GC<br>当gray链表中没有对象时，并不能马上进入下一个阶段，这是因为前面还有未处理的数据，这一步需要一次性不被中断地完成，其人口是atomic函数<br>前面提到Lua的增量式GC算法分为多个阶段，可以被中断，然而这一步则例外。 这一步将处理弱表链表和前面提到的grayagain链表，是扫描阶段的最后一步，不可中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomic</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">size_t</span> udsize;  <span class="comment">/* total size of userdata to be finalized */</span></span><br><span class="line">  <span class="comment">/* remark occasional upvalues of (maybe) dead threads */</span></span><br><span class="line">  remarkupvals(g);</span><br><span class="line">  <span class="comment">/* traverse objects cautch by write barrier and by &#x27;remarkupvals&#x27; */</span></span><br><span class="line">  propagateall(g);</span><br><span class="line">  <span class="comment">/* remark weak tables */</span></span><br><span class="line">  g-&gt;gray = g-&gt;weak;</span><br><span class="line">  g-&gt;weak = <span class="literal">NULL</span>;</span><br><span class="line">  lua_assert(!iswhite(obj2gco(g-&gt;mainthread)));</span><br><span class="line">  markobject(g, L);  <span class="comment">/* mark running thread */</span></span><br><span class="line">  markmt(g);  <span class="comment">/* mark basic metatables (again) */</span></span><br><span class="line">  propagateall(g);</span><br><span class="line">  <span class="comment">/* remark gray again */</span></span><br><span class="line">  g-&gt;gray = g-&gt;grayagain;</span><br><span class="line">  g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  propagateall(g);</span><br><span class="line">  udsize = luaC_separateudata(L, <span class="number">0</span>);  <span class="comment">/* separate userdata to be finalized */</span></span><br><span class="line">  marktmu(g);  <span class="comment">/* mark `preserved&#x27; userdata */</span></span><br><span class="line">  udsize += propagateall(g);  <span class="comment">/* remark, to propagate `preserveness&#x27; */</span></span><br><span class="line">  cleartable(g-&gt;weak);  <span class="comment">/* remove collected objects from weak tables */</span></span><br><span class="line">  <span class="comment">/* flip current white */</span></span><br><span class="line">  g-&gt;currentwhite = cast_byte(otherwhite(g));</span><br><span class="line">  g-&gt;sweepstrgc = <span class="number">0</span>;</span><br><span class="line">  g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class="line">  g-&gt;gcstate = GCSsweepstring;</span><br><span class="line">  g-&gt;estimate = g-&gt;totalbytes - udsize;  <span class="comment">/* first estimate */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我们分别做了以下几个操作</p>
<ul>
<li>调用remarkupvals 函数去标记open状态的UpValue ，这一步完毕之后， gray链表又会有新的对象，于是需要调用 propagateall再次将gray链表中的对象标记一下 。</li>
<li>修改gray链表指针，使其指向管理弱表的weak指针，同时标记当前的 Lua_State指针以及基本的meta表。</li>
<li>修改gray链表指针指向grayagain指针，同样是调用propagateall函数进行遍历扫描操作。</li>
<li>调用luaC_separateudatax;fudata进行处理。</li>
<li>在第548行，还将当前白色类型切换到了下一次GC操作的白色类型 。</li>
<li>修改状态到下个回收阶段。</li>
</ul>
<p>现在就可以谈谈前面提到的对udata进行处理的luaC_separateudata 函数了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* move `dead&#x27; udata that need finalization to list `tmudata&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">luaC_separateudata</span> <span class="params">(lua_State *L, <span class="keyword">int</span> all)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">size_t</span> deadmem = <span class="number">0</span>;</span><br><span class="line">  GCObject **p = &amp;g-&gt;mainthread-&gt;next;</span><br><span class="line">  GCObject *curr;</span><br><span class="line">  <span class="keyword">while</span> ((curr = *p) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))</span><br><span class="line">      p = &amp;curr-&gt;gch.next;  <span class="comment">/* don&#x27;t bother with them */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fasttm(L, gco2u(curr)-&gt;metatable, TM_GC) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      markfinalized(gco2u(curr));  <span class="comment">/* don&#x27;t need finalization */</span></span><br><span class="line">      p = &amp;curr-&gt;gch.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* must call its gc method */</span></span><br><span class="line">      deadmem += sizeudata(gco2u(curr));</span><br><span class="line">      markfinalized(gco2u(curr));</span><br><span class="line">      *p = curr-&gt;gch.next;</span><br><span class="line">      <span class="comment">/* link `curr&#x27; at the end of `tmudata&#x27; list */</span></span><br><span class="line">      <span class="keyword">if</span> (g-&gt;tmudata == <span class="literal">NULL</span>)  <span class="comment">/* list is empty? */</span></span><br><span class="line">        g-&gt;tmudata = curr-&gt;gch.next = curr;  <span class="comment">/* creates a circular list */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        curr-&gt;gch.next = g-&gt;tmudata-&gt;gch.next;</span><br><span class="line">        g-&gt;tmudata-&gt;gch.next = curr;</span><br><span class="line">        g-&gt;tmudata = curr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deadmem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它主要对mainthread之后的对象进行遍历（前面谈到了将udata放在mai nthread之后，这是为了统一放在一个地方，方便处理），然后进行如下的操作 。</p>
<ul>
<li>如果该对象不需要回收，就继续处理下一个对象。</li>
<li>否则，先看该对象有没有注册GC函数，如果没有，就直接标记该对象的状态是finalized 。</li>
<li>否则，除了标记该对象为 finalized之外，还将这些对象加入tmudata链表中 。 同样，这里将udata放在一个链表中也是为了统一处理，后面将会提至Ufina l ized状态的处理。</li>
</ul>
<h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><p>回收阶段分为两步，一步是针对字符串类型的回收，另一步则是针对其他类型对象的回收 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GCSsweepstring: &#123;</span><br><span class="line">      lu_mem old = g-&gt;totalbytes;</span><br><span class="line">      sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  <span class="comment">/* nothing more to sweep? */</span></span><br><span class="line">        g-&gt;gcstate = GCSsweep;  <span class="comment">/* end sweep-string phase */</span></span><br><span class="line">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">return</span> GCSWEEPCOST;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> GCSsweep: &#123;</span><br><span class="line">      lu_mem old = g-&gt;totalbytes;</span><br><span class="line">      g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span><br><span class="line">      <span class="keyword">if</span> (*g-&gt;sweepgc == <span class="literal">NULL</span>) &#123;  <span class="comment">/* nothing more to sweep? */</span></span><br><span class="line">        checkSizes(L);</span><br><span class="line">        g-&gt;gcstate = GCSfinalize;  <span class="comment">/* end sweep phase */</span></span><br><span class="line">      &#125;</span><br><span class="line">      lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">      g-&gt;estimate -= old - g-&gt;totalbytes;</span><br><span class="line">      <span class="keyword">return</span> GCSWEEPMAX*GCSWEEPCOST;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>针对字符串类型的数据，每次调用sweepwholelist函数回收字符串散列桶数组中的一个字符串链表，其中每次操作的散列桶索引值存放在sweepstrgc变量中 。 当所有字符串散列桶数据全部遍历完毕时，切换到下一个状态GCSsweep进行其他数据的回收</p>
<p>对于其他类型数据的回收，我们调用sweeplist函数进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> GCObject **<span class="title">sweeplist</span> <span class="params">(lua_State *L, GCObject **p, lu_mem count)</span> </span>&#123;</span><br><span class="line">  GCObject *curr;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">int</span> deadmask = otherwhite(g);</span><br><span class="line">  <span class="keyword">while</span> ((curr = *p) != <span class="literal">NULL</span> &amp;&amp; count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curr-&gt;gch.tt == LUA_TTHREAD)  <span class="comment">/* sweep open upvalues of each thread */</span></span><br><span class="line">      sweepwholelist(L, &amp;gco2th(curr)-&gt;openupval);</span><br><span class="line">    <span class="keyword">if</span> ((curr-&gt;gch.marked ^ WHITEBITS) &amp; deadmask) &#123;  <span class="comment">/* not dead? */</span></span><br><span class="line">      lua_assert(!isdead(g, curr) || testbit(curr-&gt;gch.marked, FIXEDBIT));</span><br><span class="line">      makewhite(g, curr);  <span class="comment">/* make it white (for next cycle) */</span></span><br><span class="line">      p = &amp;curr-&gt;gch.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* must erase `curr&#x27; */</span></span><br><span class="line">      lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));</span><br><span class="line">      *p = curr-&gt;gch.next;</span><br><span class="line">      <span class="keyword">if</span> (curr == g-&gt;rootgc)  <span class="comment">/* is the first element of the list? */</span></span><br><span class="line">        g-&gt;rootgc = curr-&gt;gch.next;  <span class="comment">/* adjust first */</span></span><br><span class="line">      freeobj(L, curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里我们首先拿到otherwhite ，这表示本次GC操作不可以被回收的白色类型 。 后面就是依次遍历链表中的数据，判断每个对象的白色是否满足被回收的颜色条件。</p>
<h3 id="结束阶段"><a href="#结束阶段" class="headerlink" title="结束阶段"></a>结束阶段</h3><p>走到了最后一步回收阶段，这一阶段主要针对tmudata链表进行处理，在所有数据都处理完毕后，重新将GC状态切换到暂停状态，这表示下一次新的GC可以开始了 。 相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GCSfinalize: &#123;</span><br><span class="line">      <span class="keyword">if</span> (g-&gt;tmudata) &#123;</span><br><span class="line">        GCTM(L);</span><br><span class="line">        <span class="keyword">if</span> (g-&gt;estimate &gt; GCFINALIZECOST)</span><br><span class="line">          g-&gt;estimate -= GCFINALIZECOST;</span><br><span class="line">        <span class="keyword">return</span> GCFINALIZECOST;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        g-&gt;gcstate = GCSpause;  <span class="comment">/* end collection */</span></span><br><span class="line">        g-&gt;gcdept = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到了结束阶段，其实也可以中断。 只要tmudata链表中还有对象，就一直调用GCTM函数来处理。 前面提到， tmudata链表是用来存放所有自带GC元方法的 udata对象，因此这里的工作就是调用这些注册的GC元方法进行对象回收：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GCTM</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = g-&gt;tmudata-&gt;gch.next;  <span class="comment">/* get first element */</span></span><br><span class="line">  Udata *udata = rawgco2u(o);</span><br><span class="line">  <span class="keyword">const</span> TValue *tm;</span><br><span class="line">  <span class="comment">/* remove udata from `tmudata&#x27; */</span></span><br><span class="line">  <span class="keyword">if</span> (o == g-&gt;tmudata)  <span class="comment">/* last element? */</span></span><br><span class="line">    g-&gt;tmudata = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    g-&gt;tmudata-&gt;gch.next = udata-&gt;uv.next;</span><br><span class="line">  udata-&gt;uv.next = g-&gt;mainthread-&gt;next;  <span class="comment">/* return it to `root&#x27; list */</span></span><br><span class="line">  g-&gt;mainthread-&gt;next = o;</span><br><span class="line">  makewhite(g, o);</span><br><span class="line">  tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);</span><br><span class="line">  <span class="keyword">if</span> (tm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lu_byte oldah = L-&gt;allowhook;</span><br><span class="line">    lu_mem oldt = g-&gt;GCthreshold;</span><br><span class="line">    L-&gt;allowhook = <span class="number">0</span>;  <span class="comment">/* stop debug hooks during GC tag method */</span></span><br><span class="line">    g-&gt;GCthreshold = <span class="number">2</span>*g-&gt;totalbytes;  <span class="comment">/* avoid GC steps */</span></span><br><span class="line">    setobj2s(L, L-&gt;top, tm);</span><br><span class="line">    setuvalue(L, L-&gt;top+<span class="number">1</span>, udata);</span><br><span class="line">    L-&gt;top += <span class="number">2</span>;</span><br><span class="line">    luaD_call(L, L-&gt;top - <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    L-&gt;allowhook = oldah;  <span class="comment">/* restore hooks */</span></span><br><span class="line">    g-&gt;GCthreshold = oldt;  <span class="comment">/* restore threshold */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCTM函数的主要逻辑就是循环遍历tmudata链表中的对象，针对每个对象调用 fasttm函数，其中会使用GC元方法来进行对象的回收。</p>
<p>当所有操作都完成， tmudata链表中不再有对象了，此时一个GC的完整流程就走完了， Lua将GC状态切换到GCSpause ，等待下一次的GC操作 </p>
<h2 id="进度控制"><a href="#进度控制" class="headerlink" title="进度控制"></a>进度控制</h2><p>在Lua代码中，有两种回收方式，一种是自动回收，一种是由用户自己调用API来触发一次回收。<br>自动回收会在每次调用内存分配相关的操作时检查是再满足触发条件，这个操作在宏luaC_checkGC中进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaC_checkGC(L) &#123; \</span></span><br><span class="line">  condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize - EXTRA_STACK - <span class="number">1</span>)); \</span><br><span class="line">  <span class="keyword">if</span> (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \</span><br><span class="line">	luaC_step(L); &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，触发自动化GC的条件就是： totalbytes大于等于GCthreshold值。 在这两个变量中， totalbytes用于保存当前分配的内存大小，而GCthreshold保存的是一个｜竭值，这个值可以由一些参数影响和控制，由此改变触发的条件。<br>由于自动GC会在使用者不知道的情况下触发，不太可控，因而很多人选择关闭它，具体操作就是通过将GCthreshold设置为一个非常大的值来达到一直不满足自动触发条件。<br>接下来，看看手动 GC受哪些参数影响 。 首先， estimate 和 gcpause两个成员将影响每次GCthreshold 的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> setthreshold(g)  (g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)</span></span><br></pre></td></tr></table></figure>
<p>这里estimate是一个预估的当前使用的内存数量，而gcpause则是一个百分比，这个宏的作用就是按照估计值的百分比计算出新的阔值来 。 其中， gcpause通过lua_gc这个C接口来进行设置。 可以看到，百分比越大，下一次开始GC的时间就会越长 。</p>
<p>另一个影响GC进度的参数是gcstepmul成员，它同样可以通过 lua_gc来设置。 这个参数将影响每次手动GC时调用 singlestep函数的次数，从而影响到GC回收的速度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_step</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  l_mem lim = (GCSTEPSIZE/<span class="number">100</span>) * g-&gt;gcstepmul;</span><br><span class="line">  <span class="keyword">if</span> (lim == <span class="number">0</span>)</span><br><span class="line">    lim = (MAX_LUMEM<span class="number">-1</span>)/<span class="number">2</span>;  <span class="comment">/* no limit */</span></span><br><span class="line">  g-&gt;gcdept += g-&gt;totalbytes - g-&gt;GCthreshold;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    lim -= singlestep(L);</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcstate == GCSpause)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (lim &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;gcstate != GCSpause) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;gcdept &lt; GCSTEPSIZE)</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE;  <span class="comment">/* - lim/g-&gt;gcstepmul;*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      g-&gt;gcdept -= GCSTEPSIZE;</span><br><span class="line">      g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_assert(g-&gt;totalbytes &gt;= g-&gt;estimate);</span><br><span class="line">    setthreshold(g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面简要说明这个函数中各行代码的作用 。</p>
<ul>
<li>第 612～614 行： GCSTEPSIZE 是一个宏，表示每次 GC 的步长大小 。 使用这个宏以及gcstepmul参数，可以计算出这一次回收计划至少回收的内存数量 。</li>
<li>第615行： gcdept用于在每次回收之前累加当前使用内存到阔值之间的差值，用于后面计算下一次触发GC的阑值。</li>
<li>第616-620行 ：当计划待回收内存还没有回收完之前，一直循环调用 singlestep 函数来进行回收，除非这里完成了完整的GC。</li>
<li>第621 ～631 行 ：完成回收之后，设置下一次触发回收操作的 ｜胡值 。 如果此时状态不是GCSpause ，那么表示没有完成一个 GC ， 此时分两种情况来处理：如果前面保存的 gcdept太小，小于GCSTEPSIZE ，那么下一次阔值就设置得比当前使用内存大GCSTEPSIZE ，即只要再多分配 GCSTEPSIZE 的内存就会再次触发 GC ；否则将 gcdept 减去 GCSTEPSIZE ，将GCthreshold设置得跟 totalbytes一样，以求尽快触发下一次GC 。 如果完成了一个 GC,那么调用 setthreshold来计算下一次GC的阔值。 可以看到 setthreshold只会在一次GC完成之后被调用，而不会影响没有完成的GC全流程 。 因此， setthreshold影响的是两次完整GC之间的时长 。 而gcdept参数会在每次GC完毕之后重新清零，它用于保存一次完整GC的内部状态 。</li>
</ul>
<p>同时，还需要注意的一点是，这个过程会改变GCthreshold的值，所以如果希望关闭自动GC,还需要在手动执行完一次GC之后重新设置关闭自动GC 。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Lua设计与实现》<br>New Garbage Collector 详见<a target="_blank" rel="noopener" href="http://wiki.luajit.org/New-Garbage-Collector">http://wiki.luajit.org/New-Garbage-Collector</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/a563683a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/a563683a.html" class="post-title-link" itemprop="url">lua虚拟机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 20:14:29" itemprop="dateCreated datePublished" datetime="2021-03-20T20:14:29+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="黑盒子"><a href="#黑盒子" class="headerlink" title="黑盒子"></a>黑盒子</h2><p>Lua的虚拟机核心部分，没有任何的系统调用，是一个纯粹的黑盒子，正确的使用Lua，不会对系统造成任何干扰。这其中最关键的一点是，Lua让用户自行定义内存管理器，在创建Lua虚拟机时传入，这保证了Lua的整个运行状态是用户可控的。</p>
<h2 id="基于寄存器的虚拟机"><a href="#基于寄存器的虚拟机" class="headerlink" title="基于寄存器的虚拟机"></a>基于寄存器的虚拟机</h2><p>lua从5.0开始，就把虚拟机改为基于寄存器的。<br>基于栈的虚拟机执行操作，要事先pop出数据，再将数据push入栈，字节码条数较多，但指令中不需要关心操作数的地址，在执行操作之前已经将操作数准备在楼顶上了。与基于梭的虚拟机不同，在基于寄存器的指令中，操作数是放在“CPU的寄存器”中（因为并不是物理意义上的寄存器，所以这里打了双引号）。因此，同样的操作不再需要PUSH、POP指令，取而代之的是在字节码中带上其体操作数所在的寄存器地址。 需要指令较少，但缺点是此时程序需要关注操作数所在的位置。</p>
<p>Lua使用的是基于寄存器的虚拟机实现方式，其中很大的原因是它的设计目标之一就是尽可能高效。</p>
<h2 id="lua虚拟机工作流程"><a href="#lua虚拟机工作流程" class="headerlink" title="lua虚拟机工作流程"></a>lua虚拟机工作流程</h2><p>lua代码是通过翻译成Lua虚拟机能识别的字节码运行的，以此它主要分为两大部分。</p>
<h3 id="翻译代码以及编译为字节码"><a href="#翻译代码以及编译为字节码" class="headerlink" title="翻译代码以及编译为字节码"></a>翻译代码以及编译为字节码</h3><p>这部分代码负责将lua代码进行词法分析（llex.c）、语法分析等（lparser.c），最终生成字节码（lcode.c）。lopcodes.x则定义了lua虚拟机相关的字节码指令的格式以及相关的API。</p>
<h3 id="lua虚拟机相关"><a href="#lua虚拟机相关" class="headerlink" title="lua虚拟机相关"></a>lua虚拟机相关</h3><p>在第一步中，经过分析阶段后，生成了对应的字节码，第二步就是将这些字节码装载到虚拟机中执行。Lua虚拟机相关的代码在 lvm.c中，虚拟机执行的主函数是luaV_execute ，不难想象这个函数是一个大的循环，依次从字节码中取出指令并执行。Lua虚拟机对外看到的数据结构是lua_State这个结构体将一直贯穿整个分析以及执行阶段 。 除了虚拟机的执行之外，Lua的核心部分还包括了进行函数调用和返回处理的相关代码，主要处理函数调用前后环境的准备和还原，这部分代码在 ldo.c中，垃圾回收部分的代码在 lgc.c中。Lua是一门嵌入式的脚本语言，这意味着它的设计目标之一必须满足能够与宿主系统进行交互，这部分代码在lapi.c中。</p>
<p>总结一下，实现一个脚本语言的解释器，其核心问题有如下几个</p>
<ul>
<li>设计一套字节码，分析源代码文件生成字节码</li>
<li>在虚拟机中执行字节码</li>
<li>如何在整个执行过程中保存整个执行环境</li>
</ul>
<p>执行Lua文件调用的是luaL_dofile函数，它实际上是个宏，内部首先调用luaL_loadfile函数，再调用lua_pcall函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaL_dofile(L, fn) \</span></span><br><span class="line">	(luaL_loadfile(L, fn) || lua_pcall(L, <span class="number">0</span>, LUA_MULTRET, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>其中 lual_loadfile函数用于进行词法和语法分析，lua_pcall用于将第一步中分析的结果（也就是字节码）放到虚拟机中执行<br>lual_loadfile函数最终会调用于f_parser函数，这是对代码进行分析的人口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f_parser</span> <span class="params">(lua_State *L, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  Proto *tf;</span><br><span class="line">  Closure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(struct SParser *, ud);</span><br><span class="line">  <span class="keyword">int</span> c = luaZ_lookahead(p-&gt;z);</span><br><span class="line">  luaC_checkGC(L);</span><br><span class="line">  tf = ((c == LUA_SIGNATURE[<span class="number">0</span>]) ? luaU_undump : luaY_parser)(L, p-&gt;z,</span><br><span class="line">                                                             &amp;p-&gt;buff, p-&gt;name);</span><br><span class="line">  cl = luaF_newLclosure(L, tf-&gt;nups, hvalue(gt(L)));</span><br><span class="line">  cl-&gt;l.p = tf;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tf-&gt;nups; i++)  <span class="comment">/* initialize eventual upvalues */</span></span><br><span class="line">    cl-&gt;l.upvals[i] = luaF_newupval(L);</span><br><span class="line">  setclvalue(L, L-&gt;top, cl);</span><br><span class="line">  incr_top(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成词法分析之后，返回了Proto类型的指针tf，然后将其绑定在新创建的Closure指针上，初始化UpValue，最后压入战中。不难想象，词法分析之后产生的字节码等相关数据都在这个Proto类型的结构体中，而这个数据又作为Closure保存了下来，留待下一步使用。<br>接着看看lua_pcall函数是如何将产生的字节码放入虚拟机中执行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="keyword">int</span> <span class="title">lua_pcall</span> <span class="params">(lua_State *L, <span class="keyword">int</span> nargs, <span class="keyword">int</span> nresults, <span class="keyword">int</span> errfunc)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CallS</span> <span class="title">c</span>;</span></span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">ptrdiff_t</span> func;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  api_checknelems(L, nargs+<span class="number">1</span>);</span><br><span class="line">  checkresults(L, nargs, nresults);</span><br><span class="line">  <span class="keyword">if</span> (errfunc == <span class="number">0</span>)</span><br><span class="line">    func = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    StkId o = index2adr(L, errfunc);</span><br><span class="line">    api_checkvalidindex(L, o);</span><br><span class="line">    func = savestack(L, o);</span><br><span class="line">  &#125;</span><br><span class="line">  c.func = L-&gt;top - (nargs+<span class="number">1</span>);  <span class="comment">//获取需要调用的函数指针</span></span><br><span class="line">  c.nresults = nresults;</span><br><span class="line">  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);</span><br><span class="line">  adjustresults(L, nresults);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的nargs是由函数参数传入的，在luaL_dofile中调用lua_pcall日才，这里传入的参数是0，换句话说，这里得到的函数对象指针就是前面f_parser函数中最后两句代码放入Lua梢的Closure指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setclvalue(L, L-&gt;top, cl);</span><br><span class="line">incr_top(L);</span><br></pre></td></tr></table></figure>
<p>继续往下执行，在调用函数luaD_pcall时， 最终会执行到luaD_call函数，这其中有这么一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (luaD_precall(L, func, nResults) == PCRLUA)  <span class="comment">/* is a Lua function? */</span></span><br><span class="line">    luaV_execute(L, <span class="number">1</span>);  <span class="comment">/* call it */</span></span><br></pre></td></tr></table></figure>
<p>首先，调用luaD_precall函数进行执行前的准备工作：</p>
<ul>
<li>从lua_State的CallInfo数组中得到一个新的CallInfo结构体，设置它的func、 base 、 top指针 。</li>
<li>从前面分析阶段生成的 Closure指针中，取出保存下来的Proto结构体 。 前面提到过，这个结构体中保存的是分析过程完结之后生成的字节码等信息 。</li>
<li>将这里创建的CallInfo指针的top/base指针赋值给lua_State结构体的top 、 base指针。 将Proto结构体的code成员赋值给 lua_State指针的 savedpc字段， code成员保留的就是字节码。</li>
<li>把多余的函数参数赋值为nil；比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为nil。</li>
</ul>
<p>调用完luaD_precall函数之后，接着会进入luaV_execute函数，这里是虚拟机执行代码的主函数：<br>这里的pc指针存放的是虚拟机OpCode代码，它最开始从L-&gt;savepc初始化而来，而L-&gt;savepc在luaD_precall中赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L-&gt;savedpc = p-&gt;code;  <span class="comment">/* starting point */</span></span><br></pre></td></tr></table></figure>
<p>可以看到，luaV_execute函数最主要的作用就是一个大循环，将当前传人的指令依次执行。<br>最后，执行完毕后，还会调用luaD_poscall函数恢复到上一次函数调用的环境：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaD_poscall</span> <span class="params">(lua_State *L, StkId firstResult)</span> </span>&#123;</span><br><span class="line">  StkId res;</span><br><span class="line">  <span class="keyword">int</span> wanted, i;</span><br><span class="line">  CallInfo *ci;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKRET)</span><br><span class="line">    firstResult = callrethooks(L, firstResult);</span><br><span class="line">  ci = L-&gt;ci--;</span><br><span class="line">  res = ci-&gt;func;  <span class="comment">/* res == final position of 1st result */</span></span><br><span class="line">  wanted = ci-&gt;nresults;</span><br><span class="line">  L-&gt;base = (ci - <span class="number">1</span>)-&gt;base;  <span class="comment">/* restore base */</span></span><br><span class="line">  L-&gt;savedpc = (ci - <span class="number">1</span>)-&gt;savedpc;  <span class="comment">/* restore savedpc */</span></span><br><span class="line">  <span class="comment">/* move results to correct place */</span></span><br><span class="line">  <span class="keyword">for</span> (i = wanted; i != <span class="number">0</span> &amp;&amp; firstResult &lt; L-&gt;top; i--)</span><br><span class="line">    setobjs2s(L, res++, firstResult++);</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    setnilvalue(res++);</span><br><span class="line">  L-&gt;top = res;</span><br><span class="line">  <span class="keyword">return</span> (wanted - LUA_MULTRET);  <span class="comment">/* 0 iff wanted == LUA_MULTRET */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下，大致的流程如下<br>(1 ）在f_parser函数中，对代码文件的分析返回了Proto指针。 这个指针会保存在 Closure指针中，留待后续继续使用。<br>(2）在luaD_precall 函数中，将lua_state 的saved pc指针指向第1步中Proto结构体的code指针，同时准备好函数调用时的战信息。<br>(3）在luaV_execute函数中，pc指针指向第2步中的saved pc指针，紧眼着就是一个大的循环体，依次取出其中的OpCode执行。<br>执行完毕后，调用 luaD_poscall函数恢复到上一个函数的环境。<br>因此， Lua虚拟机指令执行的两大人口函数如下：</p>
<ul>
<li>词法、语法分析阶段的luaY_parser。为了提高效率，Lua一次遍历脚本文件不仅完成了词法分析，还完成了语法分析，生成的OpCode存放在Proto结构体的code数组中。</li>
<li>luaV_execute。它是虚拟机执行指令阶段的人口函数，取出第一步生成的Proto结构体中的指令执行。</li>
</ul>
<p>Proto是分析阶段的产物，执行阶段将使用分析阶段生成的Proto来执行虚拟机指令，在分析阶段会有许多数据结构参与其中，可它们都是临时用于分析阶段的，或者说最终是用来辅助生成Proto结构体的。<br>可以看到，Proto结构体是分析阶段和执行阶段的纽带。<br>只要抓住了Proto结构体这一个数据的流向，就能对从分析到执行的整个流程有大体的了解了<br>luaY_parser-&gt;Proto-&gt;luaV_execute</p>
<p>到了这里，可以大致看看 Proto结构体中都有哪些数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Function Prototypes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  TValue *k;  <span class="comment">//函数的常盐数组</span></span><br><span class="line">  Instruction *code;<span class="comment">//编译生成的字节码信息，也就是前面提到的 code成员</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>  <span class="comment">/* functions defined inside the function */</span></span><br><span class="line">  <span class="keyword">int</span> *lineinfo;  <span class="comment">/* map from opcodes to source lines */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LocVar</span> *<span class="title">locvars</span>;</span>  <span class="comment">/* information about local variables */</span></span><br><span class="line">  TString **upvalues;  <span class="comment">/* upvalue names */</span></span><br><span class="line">  ...</span><br><span class="line">&#125; Proto;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的常量数组</li>
<li>编译生成的字节码信息，也就是前面提到的code成员</li>
<li>函数的局部变量信息</li>
<li>保存upvalue的数组 </li>
</ul>
<h2 id="Lua虚拟机相关的数据结构与栈"><a href="#Lua虚拟机相关的数据结构与栈" class="headerlink" title="Lua虚拟机相关的数据结构与栈"></a>Lua虚拟机相关的数据结构与栈</h2><p>请看<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/60">lua_state</a>里的Lua虚拟机相关的数据结构与栈</p>
<h2 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h2><p><a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/116">lua指令相关</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Lua设计与实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/ac3dad1f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/ac3dad1f.html" class="post-title-link" itemprop="url">lua数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-20 15:50:49" itemprop="dateCreated datePublished" datetime="2021-03-20T15:50:49+08:00">2021-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><p>Lua的类型系统是相对稳定的。很长时间里，Lua只有6个基本类型：nil，number，string，table，function和userdata（实际上，直到Lua 3.0为止，之前的C函数和Lua函数有不同的内部类型，但是这个差异对于调用者是透明的）。唯一真正的改变来自于Lua 5.0，这个版本引入了两个新类型：thread和boolean。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNONE	(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNIL	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TBOOLEAN	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TLIGHTUSERDATA	2        <span class="comment">//void *</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNUMBER	3                        <span class="comment">//lua3后采用double精度表示数字整型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TSTRING	4                        <span class="comment">//TString</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TTABLE	5                        <span class="comment">//Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TFUNCTION	6                <span class="comment">//CClosure、LClosure</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TUSERDATA	7                <span class="comment">//void *</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TTHREAD	8                        <span class="comment">//协程</span></span></span><br></pre></td></tr></table></figure>
<p>变量第一次赋值之前，值为nil。</p>
<h2 id="第一类值"><a href="#第一类值" class="headerlink" title="第一类值"></a>第一类值</h2><p>lua中所有值都是第一类值，他们可以存在变量中（无论全局变量还是局部变量）或table中，可以作为函数参数，可以作为返回值。</p>
<h2 id="Lua通用数据结构的实现"><a href="#Lua通用数据结构的实现" class="headerlink" title="Lua通用数据结构的实现"></a>Lua通用数据结构的实现</h2><h3 id="C语言中实现通用数据结构的一般做法"><a href="#C语言中实现通用数据结构的一般做法" class="headerlink" title="C语言中实现通用数据结构的一般做法"></a>C语言中实现通用数据结构的一般做法</h3><p>如果要使用一个通用的数据结构来表示不同的数据类型，一般的做法是</p>
<ul>
<li>需要一个字段来存储数据的类型</li>
<li>需要存储不同的数据类型的数据 </li>
</ul>
<p>这里有这两种<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61200681/what-are-the-pros-and-cons-of-these-twoa-common-data-structure-to-represent-dif">实现方法</a></p>
<ol>
<li>定义一个公共的数据结构作为基础类型，里面存储的都是表达这个数据的基础信息，其他具体的类型是从这里派生出来的 。 这就是一般的面向对象的思路。</li>
<li> 使用联舍（ union ）来将所有数据包进来</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>上面两种做法各有利弊 。 在Lua代码中，一般采用两种做法相结合的方式<br>Lua需要进行GC操作的数据类型都会有一个CommonHeader宏定义的成员，并且这个成员在结构体定义的最开始部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommoHeader GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure>
<p>任何需要进行垃圾回收处理的Lua数据类型，必然以 CommonHeader作为该结构体定义的最开始部分。如果熟悉C++类的实现原理，可以将CommoHeader这个成员理解为一个基类的所有成员，而其他需要回收处理的数据类型均从这个基类继承下来，所以它们的结构体定义的开始部分就是这个成员。</p>
<p>还有一个名为GCheader的结构体，其中的成员只有Common Header</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common header in struct form</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCheader</span> &#123;</span></span><br><span class="line">    CommonHeader;</span><br><span class="line">&#125; GCheader;</span><br></pre></td></tr></table></figure>
<p>于是，在Lua中就使用了GCObject联合体将所有需要进行垃圾回收的数据类型囊括了进来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all collectable objects</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  GCheader gch;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">TString</span> <span class="title">ts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Udata</span> <span class="title">u</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> <span class="title">cl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> <span class="title">h</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> <span class="title">uv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> <span class="title">th</span>;</span>  <span class="comment">/* thread */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>GCObject这个联合体，将所有需要进行垃圾回收的数据类型全部囊括其中，这样定位和查找不同类型的数据时就方便多了。</p>
<p>还有几种数据类型是不需要进行垃圾回收的，Lua中将GCObject和它们一起放在了联合体Value中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  GCObject *gc;</span><br><span class="line">  <span class="keyword">void</span> *p;<span class="comment">//LUA_TLIGHTUSERDATA</span></span><br><span class="line">  lua_Number n;<span class="comment">//LUA_TNUMBER</span></span><br><span class="line">  <span class="keyword">int</span> b;<span class="comment">//LUA_TBOOLEAN</span></span><br><span class="line">&#125; Value;</span><br></pre></td></tr></table></figure>
<p>到了这一步 ，差不多可以表示Lua中所有的数据类型了。但是还欠缺一点东西，那就是这些数据到底是什么类型的。于是Lua代码中又有了TValue，它用于将Value和类型结合在一起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefields	Value value; int tt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>
<p>前面提到过， Lua同时采用了两种方式来做到数据统一。根据前面的分析，这表现在以下两个方面。</p>
<ul>
<li>具体类型中有CommonHeader 用来存放所有数据类型都通用的字段</li>
<li>TValue作为统一表示所有数据的数据结构，内部使用了联合体Value将所有数据都包起来</li>
</ul>
<p>在具体的代码中，TValue用于统一地表示数据，而一旦知道了具体的类型，就需要使用具体的类型了。因此，代码中有不少涉及TValue与具体类型之间转换的代码，其主要逻辑都是将TValue中的tt、value与具体类型的数据进行转换。<br>如将 lua Number转换为TValue的宏 setnvalue：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> setnvalue(obj,x) \</span></span><br><span class="line">  &#123; TValue *i_o=(obj); i_o-&gt;value.n=(x); i_o-&gt;tt=LUA_TNUMBER; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Lua设计与实现》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/e141c56e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/e141c56e.html" class="post-title-link" itemprop="url">lua元表和元方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 22:43:30" itemprop="dateCreated datePublished" datetime="2021-03-19T22:43:30+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 16:05:25" itemprop="dateModified" datetime="2021-05-12T16:05:25+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="元表的由来"><a href="#元表的由来" class="headerlink" title="元表的由来"></a>元表的由来</h2><p>Lua2.1灵活语义问世，极大的增加了Lua的表达能力，从此，灵活语义就变成了Lua的标志。</p>
<p>灵活语义的一个目标是允许table作为对象和类的基础。为了实现这个目标，需要实现table的继承。另一个目标是将userdata变成应用数据的天然代理，可以作为函数参数而不只是一个句柄。userdata希望能够索引，就好像他们只是一个table，可供调用他们身上的方法。所以fallback机制的实现，让Lua把未定义行为交给程序员处理，而不是直接在语言本身实现这些特性。</p>
<p>Lua2.1提供了fallback机制，支持以下行为：table索引，算术操作符，字符串拼接，顺序比较，函数调用。当这些操作应用到“错误”的类型上，对应的fallback就会被调用到，允许程序员决定Lua如何处理。table索引fallback允许userdata和其它值类型表现的跟表一样。定义当Key不在table时的fallback，从而实现多种形式的继承（通过委托）。为了完善面向对象编程，添加了两个语法糖：function a:foo(…)就好比function a.foo(self,…)一样，以及a:foo(…)作为a.foo(a, …)的语法糖。</p>
<p>Lua2.1里引入的fallback机制，可以很好的支持灵活扩展的语义，但这个机制是全局的：每个事件只有一个钩子。这让共享或重用代码变的很艰难，因为同一事件的fallback在模块里只能定义一次，不能共存。Lua 3.0解决了fallback冲突问题。fallback替换为tag方法：钩子是以(event, tag)的形式挂在字典里的。Tags是在Lua2.1引入的整数标签，可以附在userdata上。最初的动机是希望同类的C对象，在Lua里都有相同的tag(不过，Lua没有强迫要对Tag提供解释)。Lua3.0里对所有值类型提供了tag支持，以支持对应的tag方法。</p>
<p>标记方法机制工作的很好，一直存续到Lua 5.0为止。在Lua 5.0实现了元表和元方法来取代标记和标记方法。元表只是普通的Lua table，所以可以用Lua直接操作，不需要特殊函数。就像标记一样，元表可以用来表示userdata和table的用户定义类型：所有“同类”对象应该共享同一个元表。不像标记，元表和他们的内容会在所有引用消失后自动被回收掉。（相反，标记和标记方法会等到程序结束才会被回收。）元表的引入同时简化了实现：标记方法需要在Lua核心代码里添加特殊的私有表示方法，元表主要就是标准的table机制。<br>下面的代码展示了Lua 5.0里，继承是如何实现的。index元方法取代了index标记，元表里则是用__index域来表示。代码通过将b的元表里的__index域指向a，实现了b继承a。（一般情况下，index元方法都是函数，但允许它设为table，以直接支持简单的委托继承。）</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=Window&#123;x=<span class="number">100</span>, y=<span class="number">200</span>, color=<span class="string">&quot;red&quot;</span>&#125;</span><br><span class="line">b=Window&#123;x=<span class="number">300</span>, y=<span class="number">400</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(b, &#123;<span class="built_in">__index</span> = a&#125;)</span><br><span class="line"><span class="built_in">print</span>(b.color) —&gt;red</span><br></pre></td></tr></table></figure>
<h2 id="元方法"><a href="#元方法" class="headerlink" title="元方法"></a>元方法</h2><p>在Lua中有一个元表，也就是上面说的metatable，我们可以通过元表来修改一个值得行为，使其在面对一个非预定义的操作时执行一个指定的操作。比如，现在有两个table类型的变量a和b，我们可以通过metatable定义如何计算表达式a+b<br>我们是使用getmetatable来获取一个table或userdata类型变量的元表，当创建新的table变量时，使用getmetatable去获得元表，将返回nil；同理，我们也可以使用setmetatable去设置一个table或userdata类型变量的元表<br>在table中，我可以重新定义的元方法有以下几个</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__add</span>(a, b) <span class="comment">--加法</span></span><br><span class="line"><span class="built_in">__sub</span>(a, b) <span class="comment">--减法</span></span><br><span class="line"><span class="built_in">__mul</span>(a, b) <span class="comment">--乘法</span></span><br><span class="line"><span class="built_in">__div</span>(a, b) <span class="comment">--除法</span></span><br><span class="line"><span class="built_in">__mod</span>(a, b) <span class="comment">--取模</span></span><br><span class="line"><span class="built_in">__pow</span>(a, b) <span class="comment">--乘幂</span></span><br><span class="line"><span class="built_in">__unm</span>(a) <span class="comment">--相反数</span></span><br><span class="line"><span class="built_in">__concat</span>(a, b) <span class="comment">--连接</span></span><br><span class="line"><span class="built_in">__len</span>(a) <span class="comment">--长度</span></span><br><span class="line"><span class="built_in">__eq</span>(a, b) <span class="comment">--相等</span></span><br><span class="line"><span class="built_in">__lt</span>(a, b) <span class="comment">--小于</span></span><br><span class="line"><span class="built_in">__le</span>(a, b) <span class="comment">--小于等于</span></span><br><span class="line"><span class="built_in">__index</span>(a, b) <span class="comment">--索引查询</span></span><br><span class="line"><span class="built_in">__newindex</span>(a, b, c) <span class="comment">--索引更新（PS：不懂的话，后面会有讲）</span></span><br><span class="line"><span class="built_in">__call</span>(a, ...) <span class="comment">--执行方法调用</span></span><br><span class="line"><span class="built_in">__tostring</span>(a) <span class="comment">--字符串输出</span></span><br><span class="line"><span class="built_in">__metatable</span> <span class="comment">--保护元表</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《The evolution of Lua》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <!--
  <p class="site-author-name" itemprop="name">losophy</p>
  -->
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">losophy</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
