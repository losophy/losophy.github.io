<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="losophy">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="losophy">
<meta property="og:locale">
<meta property="article:author" content="losophy">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/6/"/>





  <title>losophy</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/losophy" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">losophy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/skynet%E6%B6%88%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/skynet%E6%B6%88%E6%81%AF/" itemprop="url">skynet消息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T21:26:42+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列mq"><a href="#消息队列mq" class="headerlink" title="消息队列mq"></a>消息队列mq</h2><p>消息队列是skynet的核心功能之一，它的功能说白了就是入队出队，先进先出，这个数据结构都有讲过。源码实现在skynet_mq.h和skynet_mq.c中。</p>
<p>skynet的消息队列实际上是有两种，一种是全局消息队列，一种是服务消息队列。每个服务都有自己的消息队列，每个服务消息队列中都有服务的handle标识。这个涉及到消息的派发，这里就不展开了。每个服务消息队列被全局消息队列引用。<br>全局消息队列用的是经典的链表来实现的，而服务的消息队列用的是比较不直观，可能对有些人来说理解起来特别困难的循环数组来实现的。而且数组空间不够的时候，会动态扩展，容量扩展为当前容量的2倍。<br>消息队列的出队入队函数名都比较简单而且明了，push/pop。这个名字可能会带来一定的误解，如果改成enqueue/dequeue的话，就更符合它的实际功能。</p>
<h2 id="消息机制之消息处理"><a href="#消息机制之消息处理" class="headerlink" title="消息机制之消息处理"></a>消息机制之消息处理</h2><p>kynet的消息机制准备拆成三个部分来讲，第一部分是接收处理，第二部分是分发，第三部分是消息注册。</p>
<p>skynet是单进程多线程的，线程的种类有monitor/timer/socket/worker，monitor就是监控服务是不是陷入死循环了。timer是skynet自己实现的定时器。socket是负责网络的，这个应该是最容易被理解的。worker就是工作线程了，monitor/timer/socket都只有一个线程，唯独worker有多个线程，是可配的，不配的话是8个线程。每个工作线程有个叫worker_parm的参数。</p>
<p>在开始讲线程之前还需要回顾一下消息队列，在第2篇中讲过全局消息队列是链表，里面链了工作消息队列，而工作消息队列内部使用的是循环数组。<br>另外还要回顾一下消息的handle，每个服务都有运行时一个独一无二的handle，这个handle可以跟名字绑定。</p>
<h2 id="接收处理"><a href="#接收处理" class="headerlink" title="接收处理"></a>接收处理</h2><p>先总结一下，skynet_context_message_dispatch这个函数实际上就是不停地从全局消息队列里取工作队列，取到了以后呢，就一直处理这个队列里的消息。为了避免某个队列占用太多cpu，当前队列处理到一定的量，就把机会让给全局消息队列里的其它工作队列，把自己又放回全局消息队列。而这个处理的量是根据创建线程时thread_param里的weight权重来判定的，权重越大，流转的就越快，也就是说处理某个队列的消息数量就越少。这就是消息处理的主流程机制。<br>在主流程之外，还有monitor的触发和取消，每次处理前，触发monitor的检查。处理完了，取消monitor的检查。</p>
<h2 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h2><p>消息的处理实际上就是对工作队列里的消息不停地调回调函数。那么消息是怎么放进消息队列的呢。带着这个疑问，让我们从lua层开始追根溯源。<br>在lua层有两个api，一个是skynet.send，这个是非阻塞发消息。另一个是skynet.call，这个是阻塞式发完消息等回应。skynet.call使用一个session来实现等待，这个session实际就是一个自增的数字，溢出了以后又从1开始。<br>skynet.send实际上就是往目标服务的消息队列里增加一条消息。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>skynet的消息注册，C服务和lua服务设置回调走的函数是不同的。C的回调可以直接调，但是lua的回调不行，它需要一个默认的回调C函数，将返回参数转换为lua能理解的格式，遵循lua的api协议，传递到lua层。<br>当服务是lua实现的时候，skynet底层核心框架在处理完消息以后，回调lua层服务的回调函数时，要先经过一次lua api协议的处理，将参数准备好以后，然后调用lua服务中的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">skynet.dispatch(callback)----------------------&gt;proto[typename].dispach &#x3D; callback</span><br><span class="line">                                                                                                                    |</span><br><span class="line">skynet.core.call(skynet.dispatch_message)----&gt;tbl[k] &#x3D; skynet.dispatch_message</span><br><span class="line">                                                                                                                    |</span><br><span class="line">                                                                                                                    |</span><br><span class="line">C dispatch_message-&gt;_cb---------------------------------------------------|</span><br></pre></td></tr></table></figure>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>每条 skynet 消息由 6 部分构成：消息类型、session 、发起服务地址 、接收服务地址 、消息 C 指针、消息长度。<br>每个 skynet 服务都可以处理多类消息。在 skynet 中，是用 type 这个词来区分消息的。但与其说消息类型不同，不如说更接近网络端口 (port) 这个概念。每个 skynet 服务都支持 255 个不同的 port 。消息分发函数可以根据不同的 port 来为不同的消息定制不同的消息处理流程。</p>
<h2 id="消息队列结构分析"><a href="#消息队列结构分析" class="headerlink" title="消息队列结构分析"></a>消息队列结构分析</h2><p>队列一般可以用链表来模拟，用两个指针，分别指向头节点和尾节点。尾节点指向插入数据的方向，头节点指向消耗数据的方向。skynet全局消息队列也用到了上面的数据结构</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/skynet%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/skynet%E6%9C%8D%E5%8A%A1/" itemprop="url">skynet服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T21:14:13+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>skynet刚开始是单进程多线程的，它是由一个一个的服务组成的。在skynet上做开发，实际上就是在写服务。服务与服务之间通过消息队列进行通信。</p>
<p>做为核心功能，Skynet 仅解决一个问题：<br>把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。模块被称为服务（Service），服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。每个服务都是被一个个消息包驱动，当没有包到来的时候，它们就会处于挂起状态，对 CPU 资源零消耗。如果需要自主逻辑，则可以利用 Skynet 系统提供的 timeout 消息，定期触发。</p>
<p>一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。</p>
<h2 id="skynet服务的本质"><a href="#skynet服务的本质" class="headerlink" title="skynet服务的本质"></a>skynet服务的本质</h2><p>每个skynet服务都是一个lua state，也就是一个lua虚拟机实例。而且，每个服务都是隔离的，各自使用自己独立的内存空间，服务之间通过发消息来完成数据交换。</p>
<p>lua state本身没有多线程支持的，为了实现cpu的摊分，skynet实现上在一个线程运行多个lua state实例。而同一时间下，调度线程只运行一个服务实例。为了提高系统的并发性，skynet会启动一定数量的调度线程。同时，为了提高服务的并发性，就利用lua协程并发处理。</p>
<p>所以，skynet的并发性有3点：<br>1、多个调度线程并发<br>2、lua协程并发处理<br>3、服务调度的切换</p>
<p>skynet服务的设计基于Actor模型。有两个特点：</p>
<ol>
<li>每个Actor依次处理收到的消息</li>
<li>不同的Actor可同时处理各自的消息<br>实现上，cpu会按照一定规则分摊给每个Actor，每个Actor不会独占cpu，在处理一定数量消息后主动让出cpu，给其他进程处理消息。</li>
</ol>
<h2 id="skynet的例子是怎么调用的"><a href="#skynet的例子是怎么调用的" class="headerlink" title="skynet的例子是怎么调用的"></a>skynet的例子是怎么调用的</h2><p>服务器：<br>simpledb.lua： skynet.register “SIMPLEDB” 向skynet里注册一个服务<br>agent.lua： skynet.call(“SIMPLEDB”, “text”, text) 调用相应的服务<br>main.lua： skynet.newservice(“simpledb”) 启动一个服务<br>以上函数都在\lualib\skynet.lua 文件内</p>
<h2 id="以下是几个写服务时经常要用到的函数"><a href="#以下是几个写服务时经常要用到的函数" class="headerlink" title="以下是几个写服务时经常要用到的函数"></a>以下是几个写服务时经常要用到的函数</h2><p>newservice(name, …) 启动一个名为 name 的新服务。<br>uniqueservice(name, …) 启动一个唯一服务，如果服务该服务已经启动，则返回已启动的服务地址。<br>queryservice(name) 查询一个由 uniqueservice 启动的唯一服务的地址，若该服务尚未启动则等待。<br>localname(name) 返回同一进程内，用 register 注册的具名服务的地址。</p>
<p>newservice可以在一个进程里启动多个服务，这适用于无状态的服务。<br>uniqueservice则是类似于设计模式中的单件(singleton)，这适用于需要唯一性的服务。举个例子，比如写日志，只想写一份。或者是全局共享的数据。</p>
<h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>SKYNET设计综述讲到模块被称为服务。“服务间可以自由发送消息。每个模块可以向 Skynet 框架注册一个 callback 函数，用来接收发给它的消息。”还提到“把一个符合规范的 C 模块，从动态库（so 文件）中启动起来，绑定一个永不重复（即使模块退出）的数字 id 做为其 handle 。Skynet 提供了名字服务，还可以给特定的服务起一个易读的名字，而不是用 id 来指代它。id 和运行时态相关，无法保证每次启动服务，都有一致的 id ，但名字可以。”今天要分析的两个文件skynet_handle.c和skynet_handle.h就是实现名字服务的。</p>
<p>skynet_handle.c实际上就做了两个核心的事情，一是给服务分配一个handle，二是把handle和name关联起来。<br>把handle和name关联起来比较容易懂，实际上使用一个数组，关联的时候使用二分查找到数组里查名字，如果名字不存在，就插入一个元素，然后把名字和handle关联起来。插入元素的时候，如果数组空间不足了，就扩容为原来的2倍。<br>而给服务分配handle稍复杂一些，实际上也是使用一个slot数组，数组下标使用的是一个hash，数组元素指向服务的上下文。这个hash的算法是比较简单粗暴的，就是看从handle_indx开始累计到slot_size，看中间有没有空闲的下标（也就是下标指向为null的），如果遍历完了还是没有，就把slot扩大一倍，还是没有就再扩大一倍，直到找到空位为止，或者是slot长度超出限制为止。<br>取到了handle以后呢，还要将harbor id附到handle的高8位。</p>
<h2 id="每个服务分三个运行阶段"><a href="#每个服务分三个运行阶段" class="headerlink" title="每个服务分三个运行阶段"></a>每个服务分三个运行阶段</h2><p>首先是服务加载阶段，当服务的源文件被加载时，就会按 lua 的运行规则被执行到。这个阶段不可以调用任何有可能阻塞住该服务的 skynet api 。因为，在这个阶段中，和服务配套的 skynet 设置并没有初始化完毕。<br>然后是服务初始化阶段，由 skynet.start 这个 api 注册的初始化函数执行。这个初始化函数理论上可以调用任何 skynet api 了，但启动该服务的 skynet.newservice 这个 api 会一直等待到初始化函数结束才会返回。<br>最后是服务工作阶段，当你在初始化阶段注册了消息处理函数的话，只要有消息输入，就会触发注册的消息处理函数。这些消息都是 skynet 内部消息，外部的网络数据，定时器也会通过内部消息的形式表达出来。</p>
<p>从 skynet 底层框架来看，每个服务就是一个消息处理器。但在应用层看来并非如此。它是利用 lua 的 coroutine 工作的。当你的服务向另一个服务发送一个请求（即一个带 session 的消息）后，可以认为当前的消息已经处理完毕，服务会被 skynet 挂起。待对应服务收到请求并做出回应（发送一个回应类型的消息）后，服务会找到挂起的 coroutine ，把回应信息传入，延续之前未完的业务流程。从使用者角度看，更像是一个独立线程在处理这个业务流程，每个业务流程有自己独立的上下文，而不像 nodejs 等其它框架中使用的 callback 模式。</p>
<p>但框架已经提供了一个叫做 snlua 的用 C 开发的服务模块，它可以用来解析一段 Lua 脚本来实现业务逻辑。也就是说，你可以在 skynet 启动任意份 snlua 服务，只是它们承载的 Lua 脚本不同。这样，我们只使用 Lua 来进行开发就足够了。</p>
<h2 id="ShareData"><a href="#ShareData" class="headerlink" title="ShareData"></a>ShareData</h2><p>当你把业务拆分到多个服务中去后，数据如何共享，可能是最易面临的问题。<br>最简单粗暴的方法是通过消息传递数据。如果 A 服务需要 B 服务中的数据，可以由 B 服务发送一个消息，将数据打包携带过去。如果是一份数据，很多地方都需要获得它，那么用一个服务装下这组数据，提供一组查询接口即可。DataCenter 模块对此做了简单的封装。<br>datacenter 可用来在整个 skynet 网络做跨节点的数据共享。<br>如果你仅仅需要一组只读的结构信息分享给很多服务（比如一些配置数据），你可以把数据写到一个 lua 文件中，让不同的服务加载它。Cluster 的配置文件就是这样做的。注意：默认 skynet 使用自带的修改版 lua ，会缓存 lua 源文件。当一个 lua 文件通过 loadfile 加载后，磁盘上的修改不会影响下一次加载。所以你需要直接用 io.open 打开文件，再用 load 加载内存中的 string 。</p>
<p>另一个更好的方法是使用 sharedata 模块。<br>当大量的服务可能需要共享一大块并不太需要更新的结构化数据，每个服务却只使用其中一小部分。你可以设想成，这些数据在开发时就放在一个数据仓库中，各个服务按需要检索出需要的部分。<br>整个工程需要的数据仓库可能规模庞大，每个服务却只需要使用其中一小部分数据，如果每个服务都把所有数据加载进内存，服务数量很多时，就因为重复加载了大量不会触碰的数据而浪费了大量内存。在开发期，却很难把数据切分成更小的粒度，因为很难时刻根据需求的变化重新切分。<br>如果使用 DataCenter 这种中心式管理方案，却无法避免每次在检索数据时都要进行一次 RPC 调用，性能或许无法承受。<br>sharedata 模块正是为了解决这种需求而设计出来的。sharedata 只支持在同一节点内（同一进程下）共享数据，如果需要跨节点，需要自行同步处理。</p>
<h2 id="skynet-call的实现–服务与服务的交互"><a href="#skynet-call的实现–服务与服务的交互" class="headerlink" title="skynet call的实现–服务与服务的交互"></a>skynet call的实现–服务与服务的交互</h2><p>如果一个服务生产了大量数据，想传给您一个服务消费，在同一进程下，是不必经过序列化过程，而只需要通过消息传递内存地址指针即可。这个优化存在 O(1) 和 O(n) 的性能差别，不可以无视。<br>架构图<br><img src="https://user-images.githubusercontent.com/11263320/108848571-1e08ff00-761c-11eb-9b28-77f3bdbe92c0.jpg" alt="1425134-20190308091754983-2095526062"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E5%8D%8F%E7%A8%8B/" itemprop="url">lua协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T16:09:56+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>协同程序与线程差不多，也就是一条执行序列，拥有自己独立的栈、局部变量和指令指针，同时又与其他协同程序共享全局变量和其他大部分东西。<br>一个具有多个协同程序的程序在任意时刻只能运行一个协同程序。</p>
<p>lua将所有关于协同程序的函数放置在一个名为“coroutine”的table中。</p>
<p>一个协同程序可以处于4种不同的状态：挂起、运行、死亡和正常。<br>程序初创建：挂起<br>程序运行：运行<br>程序结束：死亡<br>程序被其实程序唤醒：正常</p>
<p>co_create 传一个函数参数，用来创建协程。返回一个“thread”对象</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a,b)</span></span></span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+b,a-b)</span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co,<span class="number">20</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>与协同程序之间的对称性区别相比，协同程序与generator（Python所提供的）之间的区别很大。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>协程实现的两个关键点在于：</p>
<ul>
<li>协程状态的保存</li>
<li>不同协程之间的数据通信机制 </li>
</ul>
<p>在Lua1-t码中，使用的是lua State结构体来表示协程，这与Lua虚拟机用的是同一个数据结构 。 这一点可以从创建协程的函数lua newthread中看出来，唯一有区别的是， Lua协程的类型是LUA TTHREAD 。 换言之，在Lua源码的处理中， Lua协程与Lua虚拟机的表现形式并没有太大差异，也许这样做是为了实现方便。 前面提到过，一个协程有自己私有的环境，不会因为协程的切换而发生改变 。</p>
<p>接下来，我们来看看如何在不同协程之间通信，或者说Lua协程间数据的交换。 前面提到过resume和 yield 函数的参数就是用来做协程数据交换的，现在来看看里面的实现 。 奥秘就在函数lua_xmove 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="keyword">void</span> <span class="title">lua_xmove</span> <span class="params">(lua_State *from, lua_State *to, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">  lua_lock(to);</span><br><span class="line">  api_checknelems(from, n);</span><br><span class="line">  api_check(from, G(from) == G(to));</span><br><span class="line">  api_check(from, to-&gt;ci-&gt;top - to-&gt;top &gt;= n);</span><br><span class="line">  from-&gt;top -= n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    setobj2s(to, to-&gt;top++, from-&gt;top + i);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码做的事情就是，从from协程中移动n个数据到 to协程中 。 当然在移动之前，数据要在from协程的战顶上准备好。<br>创建协程在函数luaB cocreate中进行．</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">luaB_cocreate</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  lua_State *NL = lua_newthread(L);</span><br><span class="line">  luaL_argcheck(L, lua_isfunction(L, <span class="number">1</span>) &amp;&amp; !lua_iscfunction(L, <span class="number">1</span>), <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;Lua function expected&quot;</span>);</span><br><span class="line">  lua_pushvalue(L, <span class="number">1</span>);  <span class="comment">/* move function to top */</span></span><br><span class="line">  lua_xmove(L, NL, <span class="number">1</span>);  <span class="comment">/* move function from L to NL */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明白了前面的内容，理解创建协程的过程就不难了，这里主要做了以下几件事情。</p>
<ul>
<li>调用lua newthread创建lua State结构体。</li>
<li>检查当前楼顶的元素是不是一个函数对象，因为需要一个函数作为协程开始运行时的主函数。 这个主函数必须是Lua函数， C函数将会报错。</li>
<li>将协程主函数压人当前 lua State 的楼中，然后调用 lua xmove 将该函数从当前的lua State移动到新创建的协程的 lua State战中 。</li>
</ul>
<p>了解了Lua协程实现相关的数据结构，接下来看看最核心的两个操作resume和yield是如何实现的 。<br>resume操作在函数 luaB_coresume 中实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">luaB_coresume</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  lua_State *co = lua_tothread(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  luaL_argcheck(L, co, <span class="number">1</span>, <span class="string">&quot;coroutine expected&quot;</span>);</span><br><span class="line">  r = auxresume(L, co, lua_gettop(L) - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    lua_pushboolean(L, <span class="number">0</span>);</span><br><span class="line">    lua_insert(L, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">/* return false + error message */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>);</span><br><span class="line">    lua_insert(L, -(r + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;  <span class="comment">/* return true + `resume&#x27; returns */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里主要做几件事情：</p>
<ul>
<li>检查当前枝顶元素是不是协程指针。</li>
<li>调用辅助函数auxresume进行实际的resume操作。</li>
<li>根据auxresume的返回值来做不同的处理。 当返回值小于0时，说明 resume操作出错，并且此时出错信息在樵顶，因此压入false以及出错消息；否则， auxresume的返回值表示执行resume操作时返回的参数数量，这种情况下压人true以及这些返回参数。<br>auxresume 函数的实现如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">auxresume</span> <span class="params">(lua_State *L, lua_State *co, <span class="keyword">int</span> narg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">if</span> (!lua_checkstack(co, narg))</span><br><span class="line">    luaL_error(L, <span class="string">&quot;too many arguments to resume&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (lua_status(co) == <span class="number">0</span> &amp;&amp; lua_gettop(co) == <span class="number">0</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;cannot resume dead coroutine&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_xmove(L, co, narg);</span><br><span class="line">  status = lua_resume(co, narg);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="number">0</span> || status == LUA_YIELD) &#123;</span><br><span class="line">    <span class="keyword">int</span> nres = lua_gettop(co);</span><br><span class="line">    <span class="keyword">if</span> (!lua_checkstack(L, nres))</span><br><span class="line">      luaL_error(L, <span class="string">&quot;too many results to resume&quot;</span>);</span><br><span class="line">    lua_xmove(co, L, nres);  <span class="comment">/* move yielded values */</span></span><br><span class="line">    <span class="keyword">return</span> nres;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_xmove(co, L, <span class="number">1</span>);  <span class="comment">/* move error message */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它主要做如下操作 。</li>
<li>检查数据的合法性 。</li>
<li>将参数通过lua xmove函数传递到待启动的协程中，调用 lua resume函数执行协程代码 。</li>
<li>当 lua_resume函数返回时，说明该协程已经执行完毕，通过lua_xmove函数将yield传入的参数传递回启动该协程的协程。<br>auxresume函数会调用 lua resume 函数，在 lua resume 函数中进行一些检查，比如当前的状态是否合理，调用层次是否过多，最终使用 luaD_rawrunprotected 函数来保护调用 resume 函数 。resume 函数的代码如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resume</span> <span class="params">(lua_State *L, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">  StkId firstArg = cast(StkId, ud);</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;status == <span class="number">0</span>) &#123;  <span class="comment">/* start coroutine? */</span></span><br><span class="line">    lua_assert(ci == L-&gt;base_ci &amp;&amp; firstArg &gt; L-&gt;base);</span><br><span class="line">    <span class="keyword">if</span> (luaD_precall(L, firstArg - <span class="number">1</span>, LUA_MULTRET) != PCRLUA)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* resuming from previous yield */</span></span><br><span class="line">    lua_assert(L-&gt;status == LUA_YIELD);</span><br><span class="line">    L-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!f_isLua(ci)) &#123;  <span class="comment">/* `common&#x27; yield? */</span></span><br><span class="line">      <span class="comment">/* finish interrupted execution of `OP_CALL&#x27; */</span></span><br><span class="line">      lua_assert(GET_OPCODE(*((ci<span class="number">-1</span>)-&gt;savedpc - <span class="number">1</span>)) == OP_CALL ||</span><br><span class="line">                 GET_OPCODE(*((ci<span class="number">-1</span>)-&gt;savedpc - <span class="number">1</span>)) == OP_TAILCALL);</span><br><span class="line">      <span class="keyword">if</span> (luaD_poscall(L, firstArg))  <span class="comment">/* complete it... */</span></span><br><span class="line">        L-&gt;top = L-&gt;ci-&gt;top;  <span class="comment">/* and correct top if not multiple results */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">/* yielded inside a hook: just continue its execution */</span></span><br><span class="line">      L-&gt;base = L-&gt;ci-&gt;base;</span><br><span class="line">  &#125;</span><br><span class="line">  luaV_execute(L, cast_int(L-&gt;ci - L-&gt;base_ci));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个函数做了以下的事情</li>
<li>如果当前协程的状态是0 ，那么说明它是第一次执行 resume操作，此时调用 luaD_precall做函数调用前的准备工作。 如果luaD_precall函数的返回值不是PCRLUA ，说明是在C函数中进行resume操作的，此时并不需要后面的 luaV execute函数，就直接返回了 。</li>
<li>否则就从之前的 YIELD状态中继续执行，首先将协程的状态置为0 ，其次判断此时口的类型，如果不是Lua函数，说明之前是被中断的函数调用，此时调用luaD_poscall函数继续完成未完的函数操作；否则只需要调整 base指针指向之前的ci的base指针即可 。</li>
<li>以上的几种情况最终都会调用 luaV_execute 函数来进入 Lua虚拟机中执行 。 这里可以看到，由于使用了同样的结构lua State来表示Lua虚拟机和Lua协程，在表达Lua虚拟机的执行和协程的执行上，两者都是统一使用 luaV execute函数，方便了实现。</li>
</ul>
<p>yield操作在函数lua_yield 中进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="keyword">int</span> <span class="title">lua_yield</span> <span class="params">(lua_State *L, <span class="keyword">int</span> nresults)</span> </span>&#123;</span><br><span class="line">  luai_userstateyield(L, nresults);</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;nCcalls &gt; <span class="number">0</span>)</span><br><span class="line">    luaG_runerror(L, <span class="string">&quot;attempt to yield across metamethod/C-call boundary&quot;</span>);</span><br><span class="line">  L-&gt;base = L-&gt;top - nresults;  <span class="comment">/* protect stack slots below */</span></span><br><span class="line">  L-&gt;status = LUA_YIELD;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数做的事情相比起来就简单多了，就是将协程执行状态至为YIELD ，这样可以终止luaV_execute函数的循环。<br><img src="https://user-images.githubusercontent.com/11263320/113825795-fdec6400-97b3-11eb-8f8f-40a19ca2088f.JPG" alt="捕获"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/" itemprop="url">lua函数与闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T15:59:44+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在lua中，函数是一种第一类值，它们具有特定的词法域。<br>lua当中函数是一个值，他可以存在变量中（无论全局变量还是局部变量）或table中，可以作为函数参数，可以作为返回值。</p>
<h2 id="upvalue"><a href="#upvalue" class="headerlink" title="upvalue"></a>upvalue</h2><p>词法域：当一个函数内嵌套另一个函数的时候，内函数可以访问外部函数的局部变量。这也意味着lua完全可以包含“λ演算（Lambda Calculus）”。<br>这个特性在以下场景特别有用：匿名函数作为高阶函数的参数，用于table遍历和模式匹配。</p>
<p>在lua中，函数可以看作一个“值”，由一些表达式创建的。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">network = &#123;</span><br><span class="line">    &#123;name = <span class="string">&quot;grauna&quot;</span>, IP = <span class="string">&quot;210.26.30.34&quot;</span>&#125;</span><br><span class="line">    &#123;name = <span class="string">&quot;arraial&quot;</span>, IP = <span class="string">&quot;210.26.30.23&quot;</span>&#125;</span><br><span class="line">    &#123;name = <span class="string">&quot;lua&quot;</span>, IP = <span class="string">&quot;210.26.23.12&quot;</span>&#125;</span><br><span class="line">    &#123;name = <span class="string">&quot;derain&quot;</span>, IP = <span class="string">&quot;210.26.23.20&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(network, <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span> <span class="keyword">return</span>(a.name&gt;b.name) <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>这种用法叫匿名函数，在语句中显示出了极好的便捷性。</p>
<h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>如果说C++式的面向对象编程是把一组函数绑定到特定数据类型上的话，那么闭包可以说是把一组数据绑定到特定函数上。<br>闭包通过调用含有一个内部函数加上该外部函数持有的外部局部变量（upvalue）的外部函数（就是工厂）产生的一个实例函数<br>闭包组成：外部函数+外部函数创建的upvalue+内部函数（闭包函数）</p>
<p>Lua中只有闭包，函数是闭包一种特殊情况。</p>
<h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><p>当一个变参函数被调用，对应…的参数将会收集到一个叫arg的table里。这种方式虽然很简单便捷，但是要把这些参数传给另一个函数，就需要解包这个table。因为程序员经常将参数传递给另一个函数，Lua 5.1允许…用于参数列表和赋值表达式的右值。这避免了没必要的创建arg table。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url">lua面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T15:44:34+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lua中的table就是一种对象。<br>lua中可以通过修改<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/107">元表元方法</a>来实现面向对象。</p>
<h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>table中的self相当于this。<br>首先，table与对象一样可以拥有状态。<br>其次，table也与对象一样拥有一个独立于其值的标识（一个self）。<br>最后，table与对象一样具有独立于创建者和创建地的生命周期。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:withdraw</span><span class="params">(v)</span></span></span><br><span class="line">    <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>lua只需使用冒号，则能隐藏self参数。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>一个类就像是一个创建对象的模具。我们可以利用__index元方法构造继承。<br>当访问一个table中不存在的字段时，得到的结果为nil。这是对的，但并非完全正确。实际上，这些访问会促使解释器去查找一个叫__index的元方法。如果没有这个元方法，那么访问结果如前述的为nil。否则，就由这个元方法来提供最终结果。<br>在lua中，将__index元方法用于继承很普遍，__index还可以是一个table。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(a,&#123;<span class="comment">--index=b&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:new</span><span class="params">(o)</span></span></span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125; <span class="comment">--如果用户没有提供table，则创建一个</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(o,<span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>之前写过一篇关于lua实现面向对象的文章，借助元表和元方法实现，感觉也是有点乱。<br>我们可以参考cocos2d-x自己给出的类的实现，也即在luaBinding目录下extern.lua的文件中给出的实现：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class</span><span class="params">(classname, super)</span></span></span><br><span class="line">    <span class="comment">--superType获取父类类型，可以使nil、function以及table.</span></span><br><span class="line">    <span class="keyword">local</span> superType = <span class="built_in">type</span>(super)</span><br><span class="line">    <span class="keyword">local</span> cls</span><br><span class="line"></span><br><span class="line">    <span class="comment">--如果父类既不是函数也不是table则说明父类为空</span></span><br><span class="line">    <span class="keyword">if</span> superType ~= <span class="string">&quot;function&quot;</span> <span class="keyword">and</span> superType ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">        superType = <span class="literal">nil</span></span><br><span class="line">        super = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--如果父类的类型是函数或者是C对象</span></span><br><span class="line">    <span class="keyword">if</span> superType == <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> (super <span class="keyword">and</span> super.__ctype == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- inherited from native C++ Object</span></span><br><span class="line">        cls = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">--如果父类是表则复制成员并且设置这个类的继承信息</span></span><br><span class="line">        <span class="keyword">if</span> superType == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 从父类copy 字段</span></span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;superTyper is table&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(super) <span class="keyword">do</span> cls[k] = v <span class="keyword">end</span></span><br><span class="line">            cls.__create = super.__create</span><br><span class="line">            cls.super    = super</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">--如果是函数类型则设置构造方法并且设置ctor函数</span></span><br><span class="line">            cls.__create = super</span><br><span class="line">            cls.ctor = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--设置类型的名称</span></span><br><span class="line">        cls.__cname = classname</span><br><span class="line">        cls.__ctype = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">--定义该类型的创建实例的函数为基类的构造函数后复制到子类实例</span></span><br><span class="line">        <span class="comment">--并且调用子数的ctor方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">cls.new</span><span class="params">(...)</span></span></span><br><span class="line">            <span class="keyword">local</span> instance = cls.__create(...)</span><br><span class="line">            <span class="comment">-- copy fields from class to native object</span></span><br><span class="line">            <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(cls) <span class="keyword">do</span> instance[k] = v <span class="keyword">end</span></span><br><span class="line">            instance.class = cls</span><br><span class="line">            instance:ctor(...)</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">--如果是继承自普通的lua表,则设置一下原型，并且构造实例后也会调用ctor方法</span></span><br><span class="line">        <span class="comment">-- inherited from Lua Object</span></span><br><span class="line">        <span class="keyword">if</span> super <span class="keyword">then</span></span><br><span class="line">            cls = &#123;&#125;</span><br><span class="line">            <span class="built_in">setmetatable</span>(cls, &#123;<span class="built_in">__index</span> = super&#125;)</span><br><span class="line">            cls.super = super</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cls = &#123;ctor = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        cls.__cname = classname</span><br><span class="line">        cls.__ctype = <span class="number">2</span> <span class="comment">-- lua</span></span><br><span class="line">        cls.<span class="built_in">__index</span> = cls</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">cls.new</span><span class="params">(...)</span></span></span><br><span class="line">            <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, cls)</span><br><span class="line">            instance.class = cls</span><br><span class="line">            instance:ctor(...)</span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>创建对象时，可以通过className.new这种方式来创建，如</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> MySpriteClass = class(<span class="string">&quot;MySpriteClass&quot;</span>,cc.Sprite)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MySpriteClass:ctor</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MySpriteClass</span><br></pre></td></tr></table></figure>
<p>mySpriteClass 实例创建</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> mySprite = MySpriteClass.new(xxx.png)</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/11263320/108814689-36622500-75ee-11eb-88a6-31a5d5bec388.png" alt="1425134-20190408154553314-1254158238"><br>classname.new()生成的instance包含一个class属性。class指向了类原型，并具有super,ctor,__cname和__ctype  4个属性<br>继承C++的类，new方法使用__create函数来创建实例<br>继承lua类，new方法使用{ }来创建实例。<br>继承Lua的类，new方法使用{ }来创建实例。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/%E6%8A%8Alua%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E2%80%9C%E7%BC%96%E8%AF%91%E2%80%9D%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%96%87%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/%E6%8A%8Alua%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E2%80%9C%E7%BC%96%E8%AF%91%E2%80%9D%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%96%87%E6%9C%AC/" itemprop="url">把lua文本文件“编译”成二进制的文本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T15:14:21+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当你发布lua时，你或许不想用户看到你的lua源码，更不想用户修改你的lua代码和系统内部的秘密，那就需要用别的方式来发布。</p>
<p>最终的文本文件可以通过lua作者提供的标准发布版本中的程序来执行。这个程序称做luac.exe，把lua文本文件“编译”成二进制的文件。这样就可以让别人更难知道你的游戏是如何运行的，采用了什么技术。</p>
<p>当写好一个lua文件后，可以通过一个典型的编译命令去“编译”这个文件：</p>
<p>这一行代码会编译helloworld.lua脚本并在helloworld文件中生成二进制数据。<br>lua解析器并不关心你传给它的是文本文件还是二进制文件，也不关心扩展名是什么。</p>
<p>用这个方法，就不用担心别人可以看到你的代码了。</p>
<p>当require一个模块mod.sub时，require会用原始的模块名“mod.sub”作为key来查询table package.loaded和package.preload，其中，模块名中的点在搜索中没有任何意义。<br>当搜索一个定义子模块的文件时，require会将点转换为另一个字符，通常就是系统的目录分隔符。转换之后require就像搜索其他名称一样来搜索这个名称。<br>所以最好的方法是在编译完lua脚本后，也把二进制文件改成.lua后缀。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/%E4%BD%BF%E7%94%A8Lua%E5%A4%84%E7%90%86%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/%E4%BD%BF%E7%94%A8Lua%E5%A4%84%E7%90%86%E6%B8%B8%E6%88%8F%E6%95%B0%E6%8D%AE/" itemprop="url">使用Lua处理游戏数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T15:05:14+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前lua学习：lua作配置文件里，我们学会了用lua作配置文件。<br>其实lua在游戏开发中可以作为一个强大的保存、载入游戏数据的工具。</p>
<h2 id="载入游戏数据"><a href="#载入游戏数据" class="headerlink" title="载入游戏数据"></a>载入游戏数据</h2><p>比如说，现在我有一份表单：<br>data.xls</p>
<p>用什么工具解析这个Excel文件并将数据载入游戏？<br>我们可以使用Lua来完成这个工作。不过要先将表单保存为csv文件（数值用逗号隔开的文件）。<br>从表单中，我们可以得知第一行是键名，剩下的行是数值。我们可以用下面的lua函数载入该csv文件并保存到表中。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLines</span><span class="params">(fileName)</span></span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    myLines = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s&quot;</span>, <span class="string">&quot;./&quot;</span>, fileName)) <span class="keyword">do</span></span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">        myLines[index] = line</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> index, myLines <span class="comment">--返回文件的行数和一个包括所有行的表</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>io.lines ([filename])：打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。<br>然后，可以再创建一个函数解析每行的字符，并创建表格保存该行的所有数据。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValues</span><span class="params">(myString)</span></span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    values = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> myString ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">string</span>.<span class="built_in">find</span>(myString,<span class="string">&quot;,&quot;</span>) ~= <span class="literal">nil</span> <span class="keyword">do</span></span><br><span class="line">            i,j = <span class="built_in">string</span>.<span class="built_in">find</span>(myString,<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            num = num + <span class="number">1</span></span><br><span class="line">            values[num] = <span class="built_in">string</span>.<span class="built_in">sub</span>(myString,<span class="number">1</span>, j<span class="number">-1</span>)</span><br><span class="line">            myString = <span class="built_in">string</span>.<span class="built_in">sub</span>(myString, j+<span class="number">1</span>, <span class="built_in">string</span>.<span class="built_in">len</span>(myString))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        num = num + <span class="number">1</span> <span class="comment">--接着对第二行数据</span></span><br><span class="line">        values[num] = myString</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> num, values</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>string.find(s, pattern, pos)：从源字符串s找到匹配pattern返回，pos参数可选， 表示起始位置，如果匹配不成功，返回nil。<br>string.sub()：函数截取字符串s的从第i个字符到第j个字符之间的串。<br>在这个函数中，我们传入字符。通过调用string.find()和string.sub，返回数值的个数和包含了所有数值的表。通过这两个简单的处理步骤可以让用户解析几乎所有的csv文件，不论简单还是复杂的文件。</p>
<p>我们可以写个函数测试一下</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoadDatas</span><span class="params">()</span></span></span><br><span class="line">    myCharacters = &#123;&#125;</span><br><span class="line">    numLines, allLines = GetLines(<span class="string">&quot;data.csv&quot;</span>)</span><br><span class="line">    <span class="comment">--读第一行的键值</span></span><br><span class="line">    count, myLabels = GetValues(allLines[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">--忽略第一行</span></span><br><span class="line">    <span class="keyword">for</span> index = <span class="number">2</span>, numLines <span class="keyword">do</span></span><br><span class="line">        count, charHold = GetValues(allLines[index])</span><br><span class="line">        myCharacters[index<span class="number">-1</span>] = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index2 = <span class="number">1</span>, count <span class="keyword">do</span></span><br><span class="line">            myCharacters[index<span class="number">-1</span>][index2] = charHold[index2]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--now print them</span></span><br><span class="line">    <span class="keyword">for</span> index = <span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> index2 = <span class="number">1</span>, <span class="built_in">table</span>.<span class="built_in">getn</span>(myLabels) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">print</span>(myLabels[index2], myCharacters[index][index2])</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="保存游戏数据"><a href="#保存游戏数据" class="headerlink" title="保存游戏数据"></a>保存游戏数据</h2><p>我们可以利用lua内建的I/O功能来处理数据输出。只要确保输出的数据是采用合适的语法，就可以使用dofile()载入数据了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line">    myFile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;save_data.lua&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> myFile ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="string">&quot;-- 游戏数据保存文件&quot;</span>)</span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">char</span> (<span class="number">10</span>))</span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">char</span> (<span class="number">10</span>))</span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s&quot;</span>, <span class="string">&quot;-- 文件创建于: &quot;</span>, <span class="built_in">os</span>.<span class="built_in">date</span>()))</span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">char</span> (<span class="number">10</span>))</span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">char</span> (<span class="number">10</span>))</span><br><span class="line">        myFile:<span class="built_in">write</span>(<span class="string">&quot;myValue = 5&quot;</span>)</span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">close</span>(myFile)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="载入保存的数据"><a href="#载入保存的数据" class="headerlink" title="载入保存的数据"></a>载入保存的数据</h2><p>利用dofile()操作就可以恢复游戏的数据了</p>
<h2 id="用lua处理log-筛取信息"><a href="#用lua处理log-筛取信息" class="headerlink" title="用lua处理log,筛取信息"></a>用lua处理log,筛取信息</h2><p>其实也就是一些io，string操作，没什么新的东西<br>把旧的log中想的筛取信息，写到新的文件中，具体可以参加以下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find_player</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> logfile = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;房间201.log&quot;</span>,<span class="string">&quot;r&quot;</span>)) <span class="comment">--打开旧文件</span></span><br><span class="line">    <span class="keyword">local</span> findfile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;find_player.txt&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="comment">--打开新文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> text = logfile:<span class="built_in">read</span>(<span class="string">&quot;*all&quot;</span>) <span class="comment">--读入所有内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(text,<span class="string">&quot;.-,&quot;</span>) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(w,<span class="string">&quot;player userid = (%d+) level=(%d+) enter&quot;</span>) ~= <span class="literal">nil</span> <span class="keyword">then</span> <span class="comment">--查找写入相关内容到新文件</span></span><br><span class="line">            findfile:<span class="built_in">write</span>(w)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">find</span>(w,<span class="string">&quot;player userid = (%d+) leave&quot;</span>) ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">            findfile:<span class="built_in">write</span>(w)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    logfile:<span class="built_in">close</span>() <span class="comment">--关闭文件</span></span><br><span class="line">    findfile:<span class="built_in">close</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">find_player()</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E4%B8%8EC-C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B4%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E4%B8%8EC-C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B4%E5%90%88/" itemprop="url">lua与C/C++程序的整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T14:41:02+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lua与C/C++交互，主要靠lua API和向lua注册好的函数。如下图</p>
<p>注：LuaGlue就是让Lua脚本中可调用的C++函数的接口。即那些注册的函数。<br>这里起关键作用的要数lua_State的结构，这就得讲一下Lua环境和Lua Stack。</p>
<h2 id="Lua环境"><a href="#Lua环境" class="headerlink" title="Lua环境"></a>Lua环境</h2><p>Lua环境由所有可操作的数据构成，如编译好的函数、变量以及其他运行时内存。这些数据保存在一个称做lua_State的结构中。所有Lua应用程序都要求至少有一个lua_State，如果需要还可以有多个（如需要为两个不同的系统保存不同的数据时）。</p>
<h2 id="Lua-Stack"><a href="#Lua-Stack" class="headerlink" title="Lua Stack"></a>Lua Stack</h2><p>对于我们来说，Lua环境是用来发送和接收数据的地方，它利用栈（Lua Stack）来达到该目的。所有的数据交换，无论是Lua到C/C++语言或C/C++语言到Lua都通过这个栈来完成。Lua栈不同于系统栈，它只能通过Lua的API函数访问。</p>
<h2 id="注册到Lua中的函数"><a href="#注册到Lua中的函数" class="headerlink" title="注册到Lua中的函数"></a>注册到Lua中的函数</h2><p>所有注册到Lua中的函数都具有相同的原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*lua_Function)</span><span class="params">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数仅有一个参数，即Lua的状态。它返回一个整数，表示其压入栈中的返回值数量。因此函数无须在压入结果前清空栈。在它返回后，Lua会自动删除栈中结果之下的内容。</p>
<p>在Lua使用这个函数前，必须注册这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lua_pushcfunction</span> <span class="params">(lua_State *L, lua_CFunction f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将一个 C 函数压入堆栈。 这个函数接收一个 C 函数指针，并将一个类型为 function 的 Lua 值 压入堆栈。当这个栈顶的值被调用时，将触发对应的 C 函数。<br>这种方法需要重新编译Lua的执行程序，才能在Lua程序中使用这个新函数。但用下面的方法会更好，直接将C函数链接到lua。</p>
<h2 id="Lua调用C函数"><a href="#Lua调用C函数" class="headerlink" title="Lua调用C函数"></a>Lua调用C函数</h2><p>Lua调用C函数时，并不依赖于函数名、包的位置或可见性规则，而只依赖于注册时传入的函数地址。当用C函数扩展Lua时，最好将代码设计为一个C模块。因为现在只注册一个函数，但说之后可能会需要更多的函数。辅助库为这项工作提供了一个函数luaL_register，这个函数接收一些C函数及其名称，并将这些函数注册到一个与模块同名的table中。例如，假设创建一个模块，其中包含了这个luaglue函数。首先，必须定义这个模块函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">luaglue</span><span class="params">(lua_state *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，声明一个数组，其中包含模块中所有函数及名称。这个数组元素的类型为luaL_Reg结构，该结构有两个字段，一个字符串和一个函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_Reg</span> <span class="title">mylib</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;dir&quot;</span>,l_dir&#125;,</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;<span class="comment">//结尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，声明一个主函数，其中用到了luaL_register:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_mylib</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     luaL_register(L,<span class="string">&quot;mylib&quot;</span>,mylib);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中luaL_register原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaL_register</span> <span class="params">(lua_State *L,<span class="keyword">const</span> <span class="keyword">char</span> *libname,<span class="keyword">const</span> luaL_Reg *l)</span></span>;</span><br></pre></td></tr></table></figure>
<p>luaL_register根据给定的名称（“mylib”）创建（或复用）一个table，并用数组mylib中的信息填充这个table。在luaL_Register返回时，会将这个table留在栈中。最后，luaopen_mylib函数返回1，表示将这个table返回给Lua。<br>ps：打开一个库，当libname为null时，该函数注册所有在luaL_Reg上的函数，不为null时，该函数会创建一个table，根据libname注册不与libname关联的函数。<br>当写完c模块后，必须将其链接到解释器。如果Lua解释器支持动态链接的话，那么最简便的方法是使用动态链接机制。在这种情况中，必须将c代码编译成动态链接库，并将这个库放入C路径（LUA_CPATH）中。然后，便可以用require从Lua中加载这个模块：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">&quot;mylib&quot;</span></span><br></pre></td></tr></table></figure>
<p>这名调用会将动态库mylib链接到Lua，并会寻找luaopen_mylib函数，将其注册为一个Lua函数，然后调用它以打开模块。<br>如果解释器不支持动态链接，那么就必须用新的模块来重新编译Lua。此外，还需要以某种方式来告诉解释器，它应在打开一个新状态的同时打开这个模块。最简单的做法是，将luaopen_mylib加到luaL_openlibs会打开的标准库列表中，这个列表在文件linit.c中。</p>
<p>从C++程序员的观点来看，Lua像一个“黑盒子”，为一些服务处理命令和调用。Lua通常作为最上层接口直接和程序使用者和游戏玩家打交道，在核心程序处理之前接受并响应输入。</p>
<h2 id="lua-tinker"><a href="#lua-tinker" class="headerlink" title="lua_tinker"></a>lua_tinker</h2><p>如果嫌麻烦，不想手动写这些代码的话，我推荐lua_tinker。也就只有两个文件，lua_tinker.h，lua_tinker.cpp。<br>环境配置，首先你需要搭建一个可以用lua的开发环境，这里网上有很多，我就不多说了。然后再将lua_tinker的lua_tinker.h和lua_tinker.cpp添加到你的工程中就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lua_tinker::def(L, <span class="string">&quot;cpp_func&quot;</span>, cpp_func); <span class="comment">//在L栈中注册C++函数</span></span><br><span class="line">lua_tinker::dofile(L, <span class="string">&quot;sample1.lua&quot;</span>); <span class="comment">//加载lua文件</span></span><br><span class="line"><span class="keyword">int</span> result = lua_tinker::call&lt;<span class="keyword">int</span>&gt;(L, <span class="string">&quot;lua_func&quot;</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">//调用lua中的function lua_func</span></span><br><span class="line"></span><br><span class="line">lua_tinker::class_add(L,<span class="string">&quot;classA&quot;</span>);<span class="comment">//在lua中注册类</span></span><br><span class="line">lua_tinker::class_con(L,lua_tinker::constructor&lt;classA&gt;);<span class="comment">//在lua中注册构造函数</span></span><br><span class="line">lua_tinker::class_mem(L,<span class="string">&quot;memName&quot;</span>,&amp;classA::memName);</span><br></pre></td></tr></table></figure>
<p>用lua_tinker::call是要注意，参数不支持智能指针</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84Lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84Lua/" itemprop="url">游戏中的Lua</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T14:07:27+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lua作为一种脚本语言，可以快速地开发游戏的原型。提高游戏的开发效率。<br>最熟悉不过的就是作为魔兽世界、博德之门、愤怒的小鸟等游戏的脚本语言。</p>
<p>但是，具体来说，lua在游戏中可以做什么呢？<br>在游戏中，lua可以用来完成下面这些工作：<br>● 编辑游戏的用户界面<br>● 定义、存储和管理基础游戏数据<br>● 管理实时游戏事件<br>● 创建和维护开发者友好的游戏存储和载入系统<br>● 编写游戏游戏的人工智能系统<br>● 创建功能原型，可以之后用高性能语言移植</p>
<h2 id="编辑游戏界面"><a href="#编辑游戏界面" class="headerlink" title="编辑游戏界面"></a>编辑游戏界面</h2><p>进行界面布局、管理用户输入并且输出游戏数据。提高了界面设计的灵活性，为程序员节省不少时间。</p>
<h2 id="管理游戏数据"><a href="#管理游戏数据" class="headerlink" title="管理游戏数据"></a>管理游戏数据</h2><p>Lua可以让游戏存储系统更为简单，可以令Lua更方便地和数据库交互。方便按照需要修改、增加和缩减游戏数据。Lua本身并没有可以直接访问外部数据库的能力，但可以用C/C++开发访问数据库的组件，然后再利用LuaGlue函数整合该组件来达到目的。</p>
<h2 id="处理游戏事件"><a href="#处理游戏事件" class="headerlink" title="处理游戏事件"></a>处理游戏事件</h2><p>其实就是利用lua与C/C++交互，在C/C++开发的事件系统中，用Lua来接收和处理这些事件。</p>
<h2 id="保存和读取游戏状态"><a href="#保存和读取游戏状态" class="headerlink" title="保存和读取游戏状态"></a>保存和读取游戏状态</h2><p>利用Lua标准的输入/输出函数，编写一个函数来保存游戏数据到可执行的Lua脚本中是很好的方法。而且还可以利用脚本编译函数来为游戏数据加密。</p>
<h2 id="游戏中的人工智能"><a href="#游戏中的人工智能" class="headerlink" title="游戏中的人工智能"></a>游戏中的人工智能</h2><p>这里说的人工智能不是那些对性能要求很好的算法。像路径寻找这些数据运算量很大的工作，计算机需要反复测试可能的路径来寻找最短或者最直接的路径，就需要用到C/C++这类底层语言来实现。但一些依赖有限的数据集合和参数的人工智能就更适合用Lua来编写了。</p>
<h2 id="快速构建原型"><a href="#快速构建原型" class="headerlink" title="快速构建原型"></a>快速构建原型</h2><p>Lua是构建可移植的核心游戏功能原型的不错工具。在游戏开发中，可以先用Lua构建出算法的结构，如果碰到有高性能需求的函数就可以用底层语言来实现。</p>
<h2 id="动态加载调试"><a href="#动态加载调试" class="headerlink" title="动态加载调试"></a>动态加载调试</h2><p>这也是脚本的一个普遍功能，只需要应用重新加载脚本，就可以完成修改，调试的时候不用再等系统“慢慢编译了”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lua的优点是可以快速地编写简单的游戏模型，并快速验证和迭代想法。在游戏开发领域，Lua和C/C++是一个功能十分强大的组合，使游戏开发更加随心所欲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" itemprop="url">lua与配置文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T13:55:15+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lua的一项重要用途就是作为一种配置语言（configuration language）。<br>目前，我们常用的配置文件格式有XML和ini,  XML层次分明，但其缺点就是写起来太繁杂，对一些关键字如&lt;&gt;之类的处理比较特殊。而ini呢，配置不够灵活，只有简单的段-<br>键-值模式，对于一些多层结构的配置，或者一些列表类型的配置，就显得力不从心了，往往需要编码人员自己分割字符串。<br>Lua脚本非常简洁清晰，是非常适合做配置文件的，无论是映射表型配置，还是列表型配置，还是简单的键值配置，lua都可以完全胜任。而且lua格式清新简洁，一看就懂。</p>
<p>下面的代码主要是读变量和table。<br>mycon.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--my config </span></span><br><span class="line"></span><br><span class="line">width = <span class="number">300</span></span><br><span class="line">height = <span class="number">400</span></span><br><span class="line"></span><br><span class="line">luat_Test1=&#123;a=<span class="number">123</span>, b=<span class="number">456</span>, c=<span class="number">789</span>&#125;</span><br><span class="line">luat_Test2=&#123;<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里说个题外话，Lua不会根据一个范围的值来创建表，而是根据设定的单个值来创建表内容，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textTable &#x3D; &#123;&#125;</span><br><span class="line">textTable[2000] &#x3D; &quot;hello 2000!&quot;</span><br></pre></td></tr></table></figure>
<p>这里虽然会生成许多未使用的Key，但不必担心这个方法会牺牲任何表的存储空间。<br>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//如不用extern会出现连接错误，编译成了C++文件  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>   </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lua.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lauxlib.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lualib.h&quot;</span>  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;lua5.1.lib&quot;</span>)  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadVariable</span> <span class="params">(lua_State *L,<span class="keyword">int</span> *width,<span class="keyword">int</span> *height)</span></span>&#123;  </span><br><span class="line">    lua_getglobal(L,<span class="string">&quot;width&quot;</span>);   <span class="comment">//获得Lua中变量的值，将其放入栈中  </span></span><br><span class="line">    lua_getglobal(L,<span class="string">&quot;height&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(!lua_isnumber(L,<span class="number">-2</span>))     <span class="comment">//栈顶为-1，然后依次减少  </span></span><br><span class="line">        luaL_error(L,<span class="string">&quot;`width&#x27; should be a number\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(!lua_isnumber(L,<span class="number">-1</span>))  </span><br><span class="line">        luaL_error(L,<span class="string">&quot;`height&#x27; should be a number\n&quot;</span>);  </span><br><span class="line">    *width = (<span class="keyword">int</span>)lua_tonumber(L,<span class="number">-2</span>);    <span class="comment">//将栈顶元素转化为数字  </span></span><br><span class="line">    *height = (<span class="keyword">int</span>)lua_tonumber(L,<span class="number">-1</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;width is %d ,height is %d\n\n&quot;</span>,*width,*height);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadTableFromItem</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableName, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableItem)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    lua_getglobal(L, lpszTableName);  </span><br><span class="line">  </span><br><span class="line">    lua_pushstring(L, lpszTableItem);<span class="comment">//首先把元素的名字压入栈顶  </span></span><br><span class="line">    lua_gettable(L, <span class="number">-2</span>);<span class="comment">//值会放在栈顶，同时刚才压入的元素名字被弹出  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s.%s=%d\n&quot;</span>, lpszTableName, lpszTableItem, (<span class="keyword">int</span>)lua_tonumber(L, <span class="number">-1</span>));  </span><br><span class="line">    lua_pop(L, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadTableFromIndex</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableName, <span class="keyword">int</span> index)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    lua_getglobal(L, lpszTableName);  </span><br><span class="line">    lua_rawgeti(L, <span class="number">-1</span>, index);<span class="comment">//获得第一个元素  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s[%d]=%d\n&quot;</span>, lpszTableName, index, (<span class="keyword">int</span>)lua_tonumber(L, <span class="number">-1</span>));  </span><br><span class="line">    lua_pop(L, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnumTableItem</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableName)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    lua_getglobal(L, lpszTableName);  </span><br><span class="line">    <span class="keyword">int</span> it = lua_gettop(L);  </span><br><span class="line">    lua_pushnil(L);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enum %s:&quot;</span>, lpszTableName);  </span><br><span class="line">    <span class="keyword">while</span>(lua_next(L, it))<span class="comment">//用lua_next可以遍历这个数组  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %d&quot;</span>, (<span class="keyword">int</span>)lua_tonumber(L, <span class="number">-1</span>));  </span><br><span class="line">        lua_pop(L, <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);  </span><br><span class="line">    lua_pop(L, <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param error!\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> *filename = argv[<span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    lua_State *L = lua_open();  </span><br><span class="line">    luaL_openlibs(L);  <span class="comment">//新版本库添加的方法  </span></span><br><span class="line">    <span class="keyword">if</span>(luaL_loadfile(L,filename) || lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))&#123;  </span><br><span class="line">        luaL_error(L,<span class="string">&quot;loadfile error! %s \n&quot;</span>,lua_tostring(L,<span class="number">-1</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> w=<span class="number">1</span>,h=<span class="number">2</span>;  </span><br><span class="line">    ReadVariable(L,&amp;w,&amp;h);  </span><br><span class="line">  </span><br><span class="line">    ReadTableFromItem(L, <span class="string">&quot;luat_Test1&quot;</span>, <span class="string">&quot;a&quot;</span>);  <span class="comment">// 等价与lua代码：print(luat_Test1.a)  </span></span><br><span class="line">    ReadTableFromItem(L, <span class="string">&quot;luat_Test1&quot;</span>, <span class="string">&quot;b&quot;</span>);  </span><br><span class="line">    ReadTableFromItem(L, <span class="string">&quot;luat_Test1&quot;</span>, <span class="string">&quot;c&quot;</span>);  </span><br><span class="line">    EnumTableItem(L, <span class="string">&quot;luat_Test1&quot;</span>);    <span class="comment">// 枚举Table  </span></span><br><span class="line">  </span><br><span class="line">    ReadTableFromIndex(L, <span class="string">&quot;luat_Test2&quot;</span>, <span class="number">1</span>);  <span class="comment">// 等价与lua代码：print(luat_Test1[1])  </span></span><br><span class="line">    ReadTableFromIndex(L, <span class="string">&quot;luat_Test2&quot;</span>, <span class="number">2</span>);  </span><br><span class="line">    ReadTableFromIndex(L, <span class="string">&quot;luat_Test2&quot;</span>, <span class="number">3</span>);  </span><br><span class="line">    EnumTableItem(L, <span class="string">&quot;luat_Test2&quot;</span>);  </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于配置文件安全的问题，一般会将这些lua文件进行加密。</p>
<h2 id="excel转lua"><a href="#excel转lua" class="headerlink" title="excel转lua"></a>excel转lua</h2><p>配置文件多数以excel转lua的方式配置，网上也有很多相关工具。例如用xlrd</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>用[]表示数组，如</p>
<ul>
<li>[123456,123457]表示两个物品</li>
<li>[1,1001001,1]表示物品的类型、code、数量</li>
<li>如果要配置多种数据，可以使用json<h3 id="多key配置"><a href="#多key配置" class="headerlink" title="多key配置"></a>多key配置</h3>这个要写个配置文件，明确是用哪些字段作key<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3>可以按这个格式<blockquote>
<p>2019-1-1 1:00:00</p>
</blockquote>
</li>
</ul>
<p>再根据需求转时间戳</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">losophy</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
