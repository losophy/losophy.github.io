<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="losophy">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="losophy">
<meta property="og:locale">
<meta property="article:author" content="losophy">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/6/"/>





  <title>losophy</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/losophy" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">losophy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84Lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84Lua/" itemprop="url">游戏中的Lua</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T14:07:27+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lua作为一种脚本语言，可以快速地开发游戏的原型。提高游戏的开发效率。<br>最熟悉不过的就是作为魔兽世界、博德之门、愤怒的小鸟等游戏的脚本语言。</p>
<p>但是，具体来说，lua在游戏中可以做什么呢？<br>在游戏中，lua可以用来完成下面这些工作：<br>● 编辑游戏的用户界面<br>● 定义、存储和管理基础游戏数据<br>● 管理实时游戏事件<br>● 创建和维护开发者友好的游戏存储和载入系统<br>● 编写游戏游戏的人工智能系统<br>● 创建功能原型，可以之后用高性能语言移植</p>
<h2 id="编辑游戏界面"><a href="#编辑游戏界面" class="headerlink" title="编辑游戏界面"></a>编辑游戏界面</h2><p>进行界面布局、管理用户输入并且输出游戏数据。提高了界面设计的灵活性，为程序员节省不少时间。</p>
<h2 id="管理游戏数据"><a href="#管理游戏数据" class="headerlink" title="管理游戏数据"></a>管理游戏数据</h2><p>Lua可以让游戏存储系统更为简单，可以令Lua更方便地和数据库交互。方便按照需要修改、增加和缩减游戏数据。Lua本身并没有可以直接访问外部数据库的能力，但可以用C/C++开发访问数据库的组件，然后再利用LuaGlue函数整合该组件来达到目的。</p>
<h2 id="处理游戏事件"><a href="#处理游戏事件" class="headerlink" title="处理游戏事件"></a>处理游戏事件</h2><p>其实就是利用lua与C/C++交互，在C/C++开发的事件系统中，用Lua来接收和处理这些事件。</p>
<h2 id="保存和读取游戏状态"><a href="#保存和读取游戏状态" class="headerlink" title="保存和读取游戏状态"></a>保存和读取游戏状态</h2><p>利用Lua标准的输入/输出函数，编写一个函数来保存游戏数据到可执行的Lua脚本中是很好的方法。而且还可以利用脚本编译函数来为游戏数据加密。</p>
<h2 id="游戏中的人工智能"><a href="#游戏中的人工智能" class="headerlink" title="游戏中的人工智能"></a>游戏中的人工智能</h2><p>这里说的人工智能不是那些对性能要求很好的算法。像路径寻找这些数据运算量很大的工作，计算机需要反复测试可能的路径来寻找最短或者最直接的路径，就需要用到C/C++这类底层语言来实现。但一些依赖有限的数据集合和参数的人工智能就更适合用Lua来编写了。</p>
<h2 id="快速构建原型"><a href="#快速构建原型" class="headerlink" title="快速构建原型"></a>快速构建原型</h2><p>Lua是构建可移植的核心游戏功能原型的不错工具。在游戏开发中，可以先用Lua构建出算法的结构，如果碰到有高性能需求的函数就可以用底层语言来实现。</p>
<h2 id="动态加载调试"><a href="#动态加载调试" class="headerlink" title="动态加载调试"></a>动态加载调试</h2><p>这也是脚本的一个普遍功能，只需要应用重新加载脚本，就可以完成修改，调试的时候不用再等系统“慢慢编译了”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lua的优点是可以快速地编写简单的游戏模型，并快速验证和迭代想法。在游戏开发领域，Lua和C/C++是一个功能十分强大的组合，使游戏开发更加随心所欲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" itemprop="url">lua与配置文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T13:55:15+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>lua的一项重要用途就是作为一种配置语言（configuration language）。<br>目前，我们常用的配置文件格式有XML和ini,  XML层次分明，但其缺点就是写起来太繁杂，对一些关键字如&lt;&gt;之类的处理比较特殊。而ini呢，配置不够灵活，只有简单的段-<br>键-值模式，对于一些多层结构的配置，或者一些列表类型的配置，就显得力不从心了，往往需要编码人员自己分割字符串。<br>Lua脚本非常简洁清晰，是非常适合做配置文件的，无论是映射表型配置，还是列表型配置，还是简单的键值配置，lua都可以完全胜任。而且lua格式清新简洁，一看就懂。</p>
<p>下面的代码主要是读变量和table。<br>mycon.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--my config </span></span><br><span class="line"></span><br><span class="line">width = <span class="number">300</span></span><br><span class="line">height = <span class="number">400</span></span><br><span class="line"></span><br><span class="line">luat_Test1=&#123;a=<span class="number">123</span>, b=<span class="number">456</span>, c=<span class="number">789</span>&#125;</span><br><span class="line">luat_Test2=&#123;<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里说个题外话，Lua不会根据一个范围的值来创建表，而是根据设定的单个值来创建表内容，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textTable &#x3D; &#123;&#125;</span><br><span class="line">textTable[2000] &#x3D; &quot;hello 2000!&quot;</span><br></pre></td></tr></table></figure>
<p>这里虽然会生成许多未使用的Key，但不必担心这个方法会牺牲任何表的存储空间。<br>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//如不用extern会出现连接错误，编译成了C++文件  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>   </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lua.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lauxlib.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lualib.h&quot;</span>  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;lua5.1.lib&quot;</span>)  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadVariable</span> <span class="params">(lua_State *L,<span class="keyword">int</span> *width,<span class="keyword">int</span> *height)</span></span>&#123;  </span><br><span class="line">    lua_getglobal(L,<span class="string">&quot;width&quot;</span>);   <span class="comment">//获得Lua中变量的值，将其放入栈中  </span></span><br><span class="line">    lua_getglobal(L,<span class="string">&quot;height&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(!lua_isnumber(L,<span class="number">-2</span>))     <span class="comment">//栈顶为-1，然后依次减少  </span></span><br><span class="line">        luaL_error(L,<span class="string">&quot;`width&#x27; should be a number\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(!lua_isnumber(L,<span class="number">-1</span>))  </span><br><span class="line">        luaL_error(L,<span class="string">&quot;`height&#x27; should be a number\n&quot;</span>);  </span><br><span class="line">    *width = (<span class="keyword">int</span>)lua_tonumber(L,<span class="number">-2</span>);    <span class="comment">//将栈顶元素转化为数字  </span></span><br><span class="line">    *height = (<span class="keyword">int</span>)lua_tonumber(L,<span class="number">-1</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;width is %d ,height is %d\n\n&quot;</span>,*width,*height);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadTableFromItem</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableName, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableItem)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    lua_getglobal(L, lpszTableName);  </span><br><span class="line">  </span><br><span class="line">    lua_pushstring(L, lpszTableItem);<span class="comment">//首先把元素的名字压入栈顶  </span></span><br><span class="line">    lua_gettable(L, <span class="number">-2</span>);<span class="comment">//值会放在栈顶，同时刚才压入的元素名字被弹出  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s.%s=%d\n&quot;</span>, lpszTableName, lpszTableItem, (<span class="keyword">int</span>)lua_tonumber(L, <span class="number">-1</span>));  </span><br><span class="line">    lua_pop(L, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadTableFromIndex</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableName, <span class="keyword">int</span> index)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    lua_getglobal(L, lpszTableName);  </span><br><span class="line">    lua_rawgeti(L, <span class="number">-1</span>, index);<span class="comment">//获得第一个元素  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s[%d]=%d\n&quot;</span>, lpszTableName, index, (<span class="keyword">int</span>)lua_tonumber(L, <span class="number">-1</span>));  </span><br><span class="line">    lua_pop(L, <span class="number">2</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnumTableItem</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span>* lpszTableName)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    lua_getglobal(L, lpszTableName);  </span><br><span class="line">    <span class="keyword">int</span> it = lua_gettop(L);  </span><br><span class="line">    lua_pushnil(L);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enum %s:&quot;</span>, lpszTableName);  </span><br><span class="line">    <span class="keyword">while</span>(lua_next(L, it))<span class="comment">//用lua_next可以遍历这个数组  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %d&quot;</span>, (<span class="keyword">int</span>)lua_tonumber(L, <span class="number">-1</span>));  </span><br><span class="line">        lua_pop(L, <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);  </span><br><span class="line">    lua_pop(L, <span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;param error!\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> *filename = argv[<span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    lua_State *L = lua_open();  </span><br><span class="line">    luaL_openlibs(L);  <span class="comment">//新版本库添加的方法  </span></span><br><span class="line">    <span class="keyword">if</span>(luaL_loadfile(L,filename) || lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))&#123;  </span><br><span class="line">        luaL_error(L,<span class="string">&quot;loadfile error! %s \n&quot;</span>,lua_tostring(L,<span class="number">-1</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> w=<span class="number">1</span>,h=<span class="number">2</span>;  </span><br><span class="line">    ReadVariable(L,&amp;w,&amp;h);  </span><br><span class="line">  </span><br><span class="line">    ReadTableFromItem(L, <span class="string">&quot;luat_Test1&quot;</span>, <span class="string">&quot;a&quot;</span>);  <span class="comment">// 等价与lua代码：print(luat_Test1.a)  </span></span><br><span class="line">    ReadTableFromItem(L, <span class="string">&quot;luat_Test1&quot;</span>, <span class="string">&quot;b&quot;</span>);  </span><br><span class="line">    ReadTableFromItem(L, <span class="string">&quot;luat_Test1&quot;</span>, <span class="string">&quot;c&quot;</span>);  </span><br><span class="line">    EnumTableItem(L, <span class="string">&quot;luat_Test1&quot;</span>);    <span class="comment">// 枚举Table  </span></span><br><span class="line">  </span><br><span class="line">    ReadTableFromIndex(L, <span class="string">&quot;luat_Test2&quot;</span>, <span class="number">1</span>);  <span class="comment">// 等价与lua代码：print(luat_Test1[1])  </span></span><br><span class="line">    ReadTableFromIndex(L, <span class="string">&quot;luat_Test2&quot;</span>, <span class="number">2</span>);  </span><br><span class="line">    ReadTableFromIndex(L, <span class="string">&quot;luat_Test2&quot;</span>, <span class="number">3</span>);  </span><br><span class="line">    EnumTableItem(L, <span class="string">&quot;luat_Test2&quot;</span>);  </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于配置文件安全的问题，一般会将这些lua文件进行加密。</p>
<h2 id="excel转lua"><a href="#excel转lua" class="headerlink" title="excel转lua"></a>excel转lua</h2><p>配置文件多数以excel转lua的方式配置，网上也有很多相关工具。例如用xlrd</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>用[]表示数组，如</p>
<ul>
<li>[123456,123457]表示两个物品</li>
<li>[1,1001001,1]表示物品的类型、code、数量</li>
<li>如果要配置多种数据，可以使用json<h3 id="多key配置"><a href="#多key配置" class="headerlink" title="多key配置"></a>多key配置</h3>这个要写个配置文件，明确是用哪些字段作key<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3>可以按这个格式<blockquote>
<p>2019-1-1 1:00:00</p>
</blockquote>
</li>
</ul>
<p>再根据需求转时间戳</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua-state/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua-state/" itemprop="url">lua_state</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T10:55:25+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Lua除了是一门扩展的言语外，还是一门“胶水语言”。最著名的就是作为游戏的脚本开发。</p>
<p>这里主要说lua怎样与c交互。<br>Lua和c语言通信的主要方法是一个无所不在的虚拟栈。几乎所有的API调用都会操作这个栈上的值。所有的数据交换，无论是Lua到C语言或C语言到Lua都通过这个栈来完成。栈可以解决Lua和C语言之间存在的两大差异，第一种差异是Lua使用垃圾收集，而C语言要求显式地释放内存；第二种是Lua使用动态类型，而C语言使用静态类型。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    lua_State *L = luaL_newstate();<span class="comment">//创建一个新的环境</span></span><br><span class="line">    luaL_openlibs(L);<span class="comment">//打开标准库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fgets(buff,<span class="keyword">sizeof</span>(buff),<span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        error = luaL_loadbuffer(L,buff,<span class="built_in">strlen</span>(buff),<span class="string">&quot;line&quot;</span>) || lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s&quot;</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">            lua_pop(L,<span class="number">1</span>);<span class="comment">//从栈中弹出错误消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>luaL_newstate用c运行库的内存分配函数。<br>lua_newstate可自定义内存分配函数。</p>
<p>头文件lua.h定义了lua提供的基础函数，包括创建lua环境、调用lua函数（如lua_pcall）、读写lua环境中全局变量，以及注册供lua调用的新函数等。Lua.h中定义所有内容都有一个lua_前缀。<br>头文件lauxlib.h定义了辅助库（auxiliary library,auxlib）提供的函数。它的所有定义都以luaL_开头（如luaL_loadbuffer）。辅助库是一个使用lua.h中API编写出的一个较高的抽象层。Lua的所有标准库编写都用到了辅助库。</p>
<p>注意：Lua脚本的编译执行是相互独立的，在不同的线程上执行。通过luaL_newstate()函数可以申请一个虚拟机，返回指针类型lua_State。今后其他所有Lua Api函数的调用都需要此指针作为第一参数，用来指定某个虚拟机。所以lua_State代表一个lua虚拟机对像，luaL_newstate()分配一个虚拟机。lua类库管理着所有的虚拟机。销毁指定虚拟机的所有对像（如果有垃圾回收相关的无方法则会调用该方法）并收回所有由该虚拟机动态分配产生的内存，在有些平台下我们不需要调用此函数，因为当主程序退出时，资源会被自然的释放掉，但是但一个长时间运行的程序，比如后台运行的web服务器，需要立即回收虚拟机资源以避免内存过高占用。</p>
<h2 id="Lua虚拟机相关的数据结构与栈"><a href="#Lua虚拟机相关的数据结构与栈" class="headerlink" title="Lua虚拟机相关的数据结构与栈"></a>Lua虚拟机相关的数据结构与栈</h2><p>下列代码分析，均源自lua5.1。</p>
<p>解释器要做的就是模拟计算机的执行，这主要分为以下两大块。<br>CPU：用于指令的执行。<br>内存：用于数据的存储。<br>指令执行的部分在<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/113">lua虚拟机</a>（lua虚拟机工作流程）大体介绍过，即解释器分析Lua文件之后生成 Proto结构体，最后到luaV_execute函数中依次取出指令来执行。<br>而“内存”部分，在Lua解释器中就存放在Lua战中。 Lua中也是把栈的某一个位置称为寄存器（非真CPU中的寄存器）。<br>每个Lua虚拟机对应一个lua_State结构体，它使用TValue数组来模拟栈，其中包括几个与找相关的成员<br>stack ：栈数组的起始位置。<br>base ： 当前函数栈的基地址 。<br>top ： 当前栈的下一个可用位置 。<br>这些成员的初始化操作在stack_init函数中完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stack_init</span> <span class="params">(lua_State *L1, lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* initialize CallInfo array */</span></span><br><span class="line">  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);</span><br><span class="line">  L1-&gt;ci = L1-&gt;base_ci;</span><br><span class="line">  L1-&gt;size_ci = BASIC_CI_SIZE;</span><br><span class="line">  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci - <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看lua_State</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** `per thread&#x27; state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte status;</span><br><span class="line">  StkId top;  <span class="comment">/* first free slot in the stack */</span></span><br><span class="line">  StkId base;  <span class="comment">/* base of current function */</span></span><br><span class="line">  global_State *l_G;</span><br><span class="line">  CallInfo *ci;  <span class="comment">/* call info for current function */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lua_State里面存放的是一个Lua虚拟机的全局状态，当执行到一个两数时，需要有对应的数据结构来表示函数相关的信息。这个数据结构就是CallInfo，这个结构体中同样有top、base这两个与战相关的成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** informations about a call</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CallInfo</span> &#123;</span></span><br><span class="line">  StkId base;  <span class="comment">/* base for this function */</span></span><br><span class="line">  StkId func;  <span class="comment">/* function index in the stack */</span></span><br><span class="line">  StkId	top;  <span class="comment">/* top for this function */</span></span><br><span class="line">  <span class="keyword">const</span> Instruction *savedpc;</span><br><span class="line">  <span class="keyword">int</span> nresults;  <span class="comment">/* expected number of results from this function */</span></span><br><span class="line">  <span class="keyword">int</span> tailcalls;  <span class="comment">/* number of tail calls lost under this entry */</span></span><br><span class="line">&#125; CallInfo;</span><br></pre></td></tr></table></figure>
<p>无论函数怎么执行，有多少函数，最终它们引用到的栈都是当前Lua虚拟机的栈。 这好比一个操作系统中的进程无论有多少，最终引用的内存实际上都还是由操作系统内核来管理的。<br>在lua_Stat巴中，有一个base_ci的CallInfo数组，存储的就是CallInfo的信息。而另一个ci成员，指向的就是当前函数的CallInfo指针。<br>在调用函数之前，一般会调用luaD_precall函数，它主要完成如下几个操作 。<br>(1 ）保存当前虚拟机执行的指令savedpc到当前CallInfo的savedpc中。此处保存下来是为了后面调用完毕之后恢复执行。<br>(2）分别计算出待调用函数的base、top值，这些值的计算依赖于函数的参数数量。<br>(3）从lua_State的base_ci数组中分配一个新的CallInfo指针，存储前面两步计算出来的信息，切换到这个函数中准备调用。<br>可以看到，lua_State结构体中的top、base指针是与函数执行相关的变量，在函数执行前后都会有所变化。</p>
<p>需要注意的是，前后调用的函数中Lua栈的大小是有限的，同时CallInfo数组的大小也是有限的。 栈的使用和函数的嵌套层次都不能过多，以防这些资源、用尽了。 这就好比操作系统内核不可能无限制新建进程，也不可能无限制分配内存，资源总是有限的 。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/lua%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/lua%E7%8E%AF%E5%A2%83%E4%B8%8E%E6%A8%A1%E5%9D%97/" itemprop="url">lua环境与模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T10:32:51+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Lua实现了一个安全的运行环境、一套自动内存管理机制、优秀的字符串处理能力和动态大小数据的处理功能。</p>
<p>我们都知道，只要应用程序加入lua解析器的功能，就能解析lua脚本。那lua脚本是怎样执行的？<br>我们通常用dofile去打开编译一个lua脚本。当应用程序调用dofile后，在执行完脚本后，才能后到主程序中，这lua脚本相当于一个函数。要等函数执行完才能回到主程序中。<br>在lua脚本中，一般有变量，函数，这些东西都保存在一个常规的table中，这个table称为“环境”。</p>
<h2 id="loadfile、dofile、require"><a href="#loadfile、dofile、require" class="headerlink" title="loadfile、dofile、require"></a>loadfile、dofile、require</h2><p>loadfile——只加载编译，不运行<br>dofile——执行<br>require——只执行一次</p>
<p>用require函数只能加载一次,因为它的特性是:<br>1、require函数会搜索目录加载文件<br>2、require会判断是否文件已经加载避免重复加载同一文件。<br>但当有一些特殊的需求需要反复加载某个lua文件，那如何实现反复加载一个lua文件?<br>答案是:二次加载前加这一句<br>package.loaded[luafile] = nil</p>
<h2 id="环境相关的变量"><a href="#环境相关的变量" class="headerlink" title="环境相关的变量"></a>环境相关的变量</h2><p>这里首先分析几个与环境相关的特殊变量一–Global表 、 env表 、 registry表以及UpValue 。<br>关于前3个表，需要注意以下几点 。</p>
<ul>
<li>Global表存放在 lua State结构体中也称为G表 。 每个 lua State结构体都有一个对应的G表。 不用多说，这个表就是存放全局变量的。</li>
<li>env表存放在Closure结构体中，也就是每个函数有自己独立的一个环境 。</li>
<li>registry表是全局唯一的，它存放在global_State结构体中，这个结构体在整个运行环境中只有一个。</li>
</ul>
<p>在讲解OP G ETG LOBAL 以及OP SETG LOBA L指令时说到，查找一个全局变量的操作，其实更精确地说，是在当前函数的 env表中查找 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_GETGLOBAL: &#123;</span><br><span class="line">        TValue g;</span><br><span class="line">        TValue *rb = KBx(i);</span><br><span class="line">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class="line">        lua_assert(ttisstring(rb));</span><br><span class="line">        Protect(luaV_gettable(L, &amp;g, rb, ra));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">case</span> OP_SETGLOBAL: &#123;</span><br><span class="line">        TValue g;</span><br><span class="line">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class="line">        lua_assert(ttisstring(KBx(i)));</span><br><span class="line">        Protect(luaV_settable(L, &amp;g, KBx(i), ra));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个操作都是到函数对应的Closure指针中的巴nv表去查询数据 。 这里仍然需要提醒一下前面提到的一点，即使对一个没有任何函数的代码而言，分析完毕之后都对应一个Closure 。 因此，这里提到的“当前函数环境”，指的不一定是某一个具体的函数，也可能是一个Lua文件 。</p>
<p>Lua提供了几个API来读取当前函数的环境，分别是getfenv和 setfenv<br>因此，如果执行以下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>,&#123;&#125;)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>实际上找不到Lua标准库提供的 print函数，并且会提示报错attempt to call global ’庐山’（a nilvalue） 。 原因就是首先使用 setfenv 函数将当前函数的 env表置为一个空表，此时在当前函数的 env表中查找不到这个名字的函数。</p>
<p>下面来看看函数的 env表是如何创建的 。 在创建一个Closure对象时，都会调用getcurrenv函数来获取当前的环境表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Table *<span class="title">getcurrenv</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;ci == L-&gt;base_ci)  <span class="comment">/* no enclosing function? */</span></span><br><span class="line">    <span class="keyword">return</span> hvalue(gt(L));  <span class="comment">/* use global table as environment */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Closure *func = curr_func(L);</span><br><span class="line">    <span class="keyword">return</span> func-&gt;c.env;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将区分如下两种情况</p>
<ul>
<li>如果该函数不是内嵌函数，那么直接返回G表</li>
<li>再则，如果是内嵌函数，就返回其母函数的 env表</li>
</ul>
<p>在创建一个新的 Closure时，会调用这个函数返回的结果，对新的Closure的环境进行赋值。这里可以看出， env表会逐层继承。</p>
<p>接着来看看registry表的作用，该表存放在global_State结构体中，因此里面的内容可供多个 lua State访问 。 另外，这个表只能由 C代码访问， Lua代码不能访问 。 除此之外，它和普通的表没有什么区别 。</p>
<p>但是需要注意的是，使用普通的对表进行赋值的API对registry表进行赋值时，应该使用字符串类型的键。 LuaAPI中对外提供了接口 lua_ref 、 lua_unre于和lua_getref ，用于提供在registry表中存取唯一的数字键。 通过这组API ，使用者不需要关心给某个需要存放到registry表的数据如何分配一个全局唯一的键，由 Lua解释器自己来保证这一点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \</span></span><br><span class="line">      (lua_pushstring(L, <span class="string">&quot;unlocked references are obsolete&quot;</span>), lua_error(L), <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))</span></span><br></pre></td></tr></table></figure>
<p>接着来看看这里面lual ref和 lu a L unref函数的实现。 需要说明的是，在调用 luaL ref函数之前，需要存放的数据已经位于枝顶：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaL_ref</span> <span class="params">(lua_State *L, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ref;</span><br><span class="line">  t = abs_index(L, t);</span><br><span class="line">  <span class="keyword">if</span> (lua_isnil(L, <span class="number">-1</span>)) &#123;</span><br><span class="line">    lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove from stack */</span></span><br><span class="line">    <span class="keyword">return</span> LUA_REFNIL;  <span class="comment">/* `nil&#x27; has a unique fixed reference */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_rawgeti(L, t, FREELIST_REF);  <span class="comment">/* get first free element */</span></span><br><span class="line">  ref = (<span class="keyword">int</span>)lua_tointeger(L, <span class="number">-1</span>);  <span class="comment">/* ref = t[FREELIST_REF] */</span></span><br><span class="line">  lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove it from stack */</span></span><br><span class="line">  <span class="keyword">if</span> (ref != <span class="number">0</span>) &#123;  <span class="comment">/* any free element? */</span></span><br><span class="line">    lua_rawgeti(L, t, ref);  <span class="comment">/* remove it from list */</span></span><br><span class="line">    lua_rawseti(L, t, FREELIST_REF);  <span class="comment">/* (t[FREELIST_REF] = t[ref]) */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* no free elements */</span></span><br><span class="line">    ref = (<span class="keyword">int</span>)lua_objlen(L, t);</span><br><span class="line">    ref++;  <span class="comment">/* create new reference */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_rawseti(L, t, ref);</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaL_unref</span> <span class="params">(lua_State *L, <span class="keyword">int</span> t, <span class="keyword">int</span> ref)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ref &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    t = abs_index(L, t);</span><br><span class="line">    lua_rawgeti(L, t, FREELIST_REF);</span><br><span class="line">    lua_rawseti(L, t, ref);  <span class="comment">/* t[ref] = t[FREELIST_REF] */</span></span><br><span class="line">    lua_pushinteger(L, ref);</span><br><span class="line">    lua_rawseti(L, t, FREELIST_REF);  <span class="comment">/* t[FREELIST_REF] = ref */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的设计其实很巧妙，仅使用一个数组就模拟了一个链表的实现，其原理如下</p>
<ul>
<li>FREELIST_REF用于保存当前registry表中可用键的索引，每次需要存储之前，都会先到这里拿到当前存放的值。</li>
<li>如果拿出来的值是0 ，说明当前的h巳list中还没有数据，直接返回当前registry表的数据盐作为新的索引 。</li>
<li>当调用 lual unref释放一个索引值的时候，将该索引值返回 FREELIST REF链表中 。</li>
</ul>
<p>下图演示了分配可用索引前后freelist的变化<br><img src="https://user-images.githubusercontent.com/11263320/113692378-126f2480-9700-11eb-99a2-8a8d4bbea09a.JPG" alt="捕获"><br>最后来看UpValue 。 前面谈到， registry表提供的是全局变量的存储， env表提供的是函数内全局变茸的存储，而UpValue用于提供函数内静态变量的存储，这些变量存储的地方，倒不是某个特殊的表，其实就是换算成对应的UpValue的索引值来访问函数的UpValue数组而已<br>接着我们来看一个关键的函数index2adr ，这个函数集中处理了所有索引值转换为械地址值的操作，不论该索’寻｜是椅上元素的索引，还是前面这几种特殊变量的索引：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** pseudo-indices</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_REGISTRYINDEX	(-10000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_ENVIRONINDEX	(-10001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_GLOBALSINDEX	(-10002)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TValue *<span class="title">index2adr</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    TValue *o = L-&gt;base + (idx - <span class="number">1</span>);</span><br><span class="line">    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);</span><br><span class="line">    <span class="keyword">if</span> (o &gt;= L-&gt;top) <span class="keyword">return</span> cast(TValue *, luaO_nilobject);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> o;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (idx &gt; LUA_REGISTRYINDEX) &#123;</span><br><span class="line">    api_check(L, idx != <span class="number">0</span> &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);</span><br><span class="line">    <span class="keyword">return</span> L-&gt;top + idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">switch</span> (idx) &#123;  <span class="comment">/* pseudo-indices */</span></span><br><span class="line">    <span class="keyword">case</span> LUA_REGISTRYINDEX: <span class="keyword">return</span> registry(L);</span><br><span class="line">    <span class="keyword">case</span> LUA_ENVIRONINDEX: &#123;</span><br><span class="line">      Closure *func = curr_func(L);</span><br><span class="line">      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);</span><br><span class="line">      <span class="keyword">return</span> &amp;L-&gt;env;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GLOBALSINDEX: <span class="keyword">return</span> gt(L);</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      Closure *func = curr_func(L);</span><br><span class="line">      idx = LUA_GLOBALSINDEX - idx;</span><br><span class="line">      <span class="keyword">return</span> (idx &lt;= func-&gt;c.nupvalues)</span><br><span class="line">                ? &amp;func-&gt;c.upvalue[idx<span class="number">-1</span>]</span><br><span class="line">                : cast(TValue *, luaO_nilobject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑主要是根据传人的 idx的几种情况，分别返回不同的值。</p>
<ul>
<li>如果 idx &gt;O ，那么以 idx值为索引，返回基于 lua State的 base指针的值，也就是相对于战底向上的偏移值。</li>
<li>如果 idx&gt;LUA_REGISTRYINDEX ，则以 idx值为索引，返回基于 l ua_State的top指针的值，也就是相对于钱顶向下的偏移值。</li>
<li>如果是LUA_REGISTRYINDEX ，那么返回 registry表。</li>
<li>如果是LUA ENVIRONINDEX ，那么返回当前函数的env表。</li>
<li>如果是LUA GLOBALSINDEX ，那么返回Global表。</li>
<li>如果以上都不符合，那么将根据情况返回当前函数的叩value数组中的值。</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>这一节将讲解Lua模块相关的知识点，首先介绍模块的加载、编写等原理，然后介绍热更新原理。</p>
<h3 id="模块的加载"><a href="#模块的加载" class="headerlink" title="模块的加载"></a>模块的加载</h3><p>在Lua内部，所有模块的注册都在linit.c的函数lual_openlibs 中提供。 可以看到，它依次访问lualibs数组中的成员，这些成员定义了每个模块的模块名及相应的模块注册函数，依次调用每个模块的注册函数完成模块的注册 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg lualibs[] = &#123;</span><br><span class="line">  &#123;<span class="string">&quot;&quot;</span>, luaopen_base&#125;,</span><br><span class="line">  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,</span><br><span class="line">  &#123;LUA_TABLIBNAME, luaopen_table&#125;,</span><br><span class="line">  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class="line">  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br><span class="line">  &#123;LUA_STRLIBNAME, luaopen_string&#125;,</span><br><span class="line">  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,</span><br><span class="line">  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class="line">  &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaL_openlibs</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> luaL_Reg *lib = lualibs;</span><br><span class="line">  <span class="keyword">for</span> (; lib-&gt;func; lib++) &#123;</span><br><span class="line">    lua_pushcfunction(L, lib-&gt;func);</span><br><span class="line">    lua_pushstring(L, lib-&gt;name);</span><br><span class="line">    lua_call(L, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体lual_Reg有两个变量，分别是模块名以及模块初始化函数。 可以看到，第一个模块是base模块，其模块名是一个空字符串，因此访问这个模块的函数不需要加模块名前缀，比如我们熟悉的 print 函数就是属于这个模块的 。 这就是在调用 print函数时，不需要在前面加模块名前缀的原因 。 这里就以 base模块为例来讲解模块的注册过程。</p>
<p>加载base模块最终会调用 base_open函数，下面我们看看这个函数里面最核心的几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">base_open</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* set global _G */</span></span><br><span class="line">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class="line">  lua_setglobal(L, <span class="string">&quot;_G&quot;</span>);</span><br><span class="line">  <span class="comment">/* open lib into global table */</span></span><br><span class="line">  luaL_register(L, <span class="string">&quot;_G&quot;</span>, base_funcs);</span><br></pre></td></tr></table></figure>
<p>最开始的两句首先将 LUA_GLOBA LSINDEX对应的值压人拢中，接着调用 lua_setglobal(L ,二C ”） ; , e n 当在 lua_State 的 l_gt表中查找工C”时，查找到的是索引值为 LUA_GLOBALSINDEX的表 。如果觉得有点绕，可以简单理解为，在C表满足这个等式＿G = _G ［二G”］ 。 也就是这个叫＿G的表内部有一个key为二G”的表是指向自己的 。 可以在Lua命令行中执行print(_G ）和 print(_G ［”＿G”］）看看输出结果，来验证一下这个结论。</p>
<p>我猜想这么处理的理由是 ： 为了让G表和其他表使用同样的机制 。 查找变量时，最终会一直顺着层次往上查到G表中，这是很自然的事情 。 所以，为了也能按照这个机制顺利地查找到自己，于是在G表中有一个同名成员指向自己 。</p>
<p>好了，前两句的作用已经分析完毕，其结果有以下两个 ：</p>
<ul>
<li>＿G = _G [”_G”]</li>
<li>G表的值压入函数枝中方便后面的调用 。</li>
</ul>
<p>所以，这个G表的注册操作需要在所有模块注册之前进行。</p>
<p>在第63 1行中， base_fu n cs也是一个lual_Reg数组，上面的操作会将base_funcs数组中的函数注册到G表中，但是里面还有些细节需要看看。 这个操作最终会调用函数luaI←openlib:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaI_openlib</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *libname,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> luaL_Reg *l, <span class="keyword">int</span> nup)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (libname) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = libsize(l);</span><br><span class="line">    <span class="comment">/* check whether lib already exists */</span></span><br><span class="line">    luaL_findtable(L, LUA_REGISTRYINDEX, <span class="string">&quot;_LOADED&quot;</span>, size);</span><br><span class="line">    lua_getfield(L, <span class="number">-1</span>, libname);  <span class="comment">/* get _LOADED[libname] */</span></span><br><span class="line">    <span class="keyword">if</span> (!lua_istable(L, <span class="number">-1</span>)) &#123;  <span class="comment">/* not found? */</span></span><br><span class="line">      lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove previous result */</span></span><br><span class="line">      <span class="comment">/* try global variable (and create one if it does not exist) */</span></span><br><span class="line">      <span class="keyword">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != <span class="literal">NULL</span>)</span><br><span class="line">        luaL_error(L, <span class="string">&quot;name conflict for module &quot;</span> LUA_QS, libname);</span><br><span class="line">      lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">      lua_setfield(L, <span class="number">-3</span>, libname);  <span class="comment">/* _LOADED[libname] = new table */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_remove(L, <span class="number">-2</span>);  <span class="comment">/* remove _LOADED table */</span></span><br><span class="line">    lua_insert(L, -(nup+<span class="number">1</span>));  <span class="comment">/* move library table to below upvalues */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; l-&gt;name; l++) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;nup; i++)  <span class="comment">/* copy upvalues to the top */</span></span><br><span class="line">      lua_pushvalue(L, -nup);</span><br><span class="line">    lua_pushcclosure(L, l-&gt;func, nup);</span><br><span class="line">    lua_setfield(L, -(nup+<span class="number">2</span>), l-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pop(L, nup);  <span class="comment">/* remove upvalues */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册这些函数之前，首先会到registry ［二LOADED＂］表中查找该库，如果不存在，则在G表中查找这个库，若不存在则创建一个表。<br>因此，不管是Lua内部的库还是外部使用require引用的库，首先会到 registry ［”一LOADED ”］ 中存放该库的表。 最后，再遍历传进来的函数指针数组，完成库函数的注册。<br>比如，注册as . print时，首先将print函数绑定在一个函数指针上，再去l_registry[_LOADED]和G表中查询名为OS的库是否存在，不存在则创建一个表，即 ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G[”OS<span class="string">&quot;] = &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>紧跟着注册print函数，即： G ［”os ”］［ ” print ”］＝待注册的函数指针。<br>这样在调用os . print(1）时，首先根据OS到G表中查找对应的表，再在这个表中查找print成员得到函数指针，最后完成函数的调用 。</p>
<h3 id="模块的编写"><a href="#模块的编写" class="headerlink" title="模块的编写"></a>模块的编写</h3><p>在定义Lua模块时，第一句代码一般都是module(xxx ） 。 module调用的对应C函数是loadlib.c中的函数ll_module:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ll_module</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *modname = luaL_checkstring(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> loaded = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of _LOADED table */</span></span><br><span class="line">  lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;_LOADED&quot;</span>);</span><br><span class="line">  lua_getfield(L, loaded, modname);  <span class="comment">/* get _LOADED[modname] */</span></span><br><span class="line">  <span class="keyword">if</span> (!lua_istable(L, <span class="number">-1</span>)) &#123;  <span class="comment">/* not found? */</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove previous result */</span></span><br><span class="line">    <span class="comment">/* try global variable (and create one if it does not exist) */</span></span><br><span class="line">    <span class="keyword">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, modname, <span class="number">1</span>) != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> luaL_error(L, <span class="string">&quot;name conflict for module &quot;</span> LUA_QS, modname);</span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">    lua_setfield(L, loaded, modname);  <span class="comment">/* _LOADED[modname] = new table */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* check whether table already has a _NAME field */</span></span><br><span class="line">  lua_getfield(L, <span class="number">-1</span>, <span class="string">&quot;_NAME&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!lua_isnil(L, <span class="number">-1</span>))  <span class="comment">/* is table an initialized module? */</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* no; initialize it */</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">    modinit(L, modname);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">  setfenv(L);</span><br><span class="line">  dooptions(L, loaded - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的前半部分首先根据module(XXX）中的模块名去registry [“_LOADED”］表中查找，如果找不到，则创建一个新表，这个表为＿G ［” xxx叮＝ registry ［二LOADED ”］［ “XXX ＂］ 。 换言之，这个名为xxx 的模块本质上是一个表，这个表存储了这个模块中的所有变革－以及函数，它既可以通过一G ［” xxx”］来访问，也可以通过registry ［二 LOADED ”］［ “XXX ”］来访问 。<br>紧跟着，在modi nit 函数中，将这个表的成员 K NAME 、 PACKAGE分别赋值。<br>最后，调用 setfenv将该模块对应的环境置空 。 根据前面的分析， setfenv将该模块对应的环境置空就是将这个模块分析完毕之后返回的Closure对应的env环境表置空 。 这意味着，前面的所有全局变量都看不见了，比如下面的代码中 ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myprint=<span class="built_in">print</span></span><br><span class="line">myprint(”<span class="number">1</span>”)</span><br><span class="line"><span class="built_in">module</span>(”test”)</span><br><span class="line">myprint (” <span class="number">2</span>”)</span><br></pre></td></tr></table></figure>
<p>这里首先将全局函数printl赋值给全局变量myprint ，第二行代码可以正常调用这个函数。但当调用module声明 test模块之后，在此之前的全局变量myprint被清空，第四行代码调用myprint函数时就会报错，错误信息是attempt to call global ‘myprint’(a nil value），因为此时已经查不到这个变量了 。<br>如果写下的是module(xxx,package . seeall）呢？它将会调用后面的dooptions 函数并且最后调用 package.seeall对应的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ll_seeall</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  luaL_checktype(L, <span class="number">1</span>, LUA_TTABLE);</span><br><span class="line">  <span class="keyword">if</span> (!lua_getmetatable(L, <span class="number">1</span>)) &#123;</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* create new metatable */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">    lua_setmetatable(L, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class="line">  lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;__index&quot;</span>);  <span class="comment">/* mt.__index = _G */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就两个作用 ： 一个是创建该模块对应表的metatable ， 另一个是将meta表的 index指向 G表。 也就是说，所有在该模块中找不到的变量都会去 G表中查找 。 可以看到，这里的操作并不会把环境表清空 。 因此，如果把前面的代码改成这样，就可以正确执行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myprint=<span class="built_in">print</span></span><br><span class="line">myprint(” test ”)</span><br><span class="line">morlule (”test <span class="string">&#x27;’, package. seeall)</span></span><br><span class="line"><span class="string">myprint(”test”) </span></span><br></pre></td></tr></table></figure>
<p>根据前面对module函数的分析，得出以下几个结论。</p>
<ul>
<li>创建模块时会创建一个表，该表挂载在registry ［ ”一LOADED ＇ ’ ］、＿G ［模块名］下 。 自然而然地，该模块中的变量（函数也是一种变量）就会挂载到这个表里面 。</li>
<li>在 module 函数的参数中写下 package.seeall将会创建该表的 metatable ，同时该表的index将指向 G表。 简单地说，这个模块将可以看到所有全局环境下的变量（这里再提醒一次，函数也是一种变量） 。</li>
</ul>
<p>明白了 module 背后的作用，再来看看 require 函数，它对应的处理函数是 loadlib.c 中的ll_require 函数，这个函数做了如下几件事情 。</p>
<ul>
<li>首先在 registry[ “_LOADED”］表中查找该库，如果已存在，说明是已经加载过的模块，不再重复加载直接返回。</li>
<li>在当前环境表中查找 loaders变量，这里存放的是所有加载器组成的数组 。 在 Lua代码中，有4个loader :<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> lua_CFunction loaders[] =</span><br><span class="line">  &#123;loader_preload, loader_Lua, loader_C, loader_Croot, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>
加载时，会依次调用 loaders数组中的四种 loader 。 如果加载的结果在Lua找中返回的是函数（前面提过，分析完Lua源代码文件，返回的是Closure ），那么说明加载成功，不再继续往下调用其他的 loader加载模块 。<br>最后，调用lua call函数尝试加载该模块。 加载之前，在L回校中压入一个哨兵值sentinel,如果加载完毕之后这个值没有被改动过，则说明加载完毕，将registry ［ ”＿LOADED”］赋值为true表示加载成功 。</li>
</ul>
<h3 id="模块的热更新原理"><a href="#模块的热更新原理" class="headerlink" title="模块的热更新原理"></a>模块的热更新原理</h3><p>能很好地支持代码热更新机制，是开发时选择使用脚本语言的原因之一 。 热更新的好处很在于，能在不重启程序或者发布新版本的情况下更新脚本，给调试和线上解决问题带来很大的便利，对开发效率有很大的提升 。<br>下面就来谈谈如何实现热更新 。先简单回顾之前提过的模块和lrequire机制 。 Lua内部提供了一个require 函数来实现模块的加载，它做的事情主要有以下几个。</p>
<ul>
<li>在registry ［二LOADED”］表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码 。</li>
<li>依次调用注册的 loader来加载模块 。</li>
<li>将加载过的模块赋值给registry ［”一LOADED ＂］表。<br>而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua虚拟机认为它之前没有加载过。 查看Lua代码可以发现 ， registry ［”一LOADED ”］表实际上对应的是package.loaded表，这在以下函数中有体现：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaopen_package</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">/* create new type _LOADLIB */</span></span><br><span class="line">  luaL_newmetatable(L, <span class="string">&quot;_LOADLIB&quot;</span>);</span><br><span class="line">  lua_pushcfunction(L, gctm);</span><br><span class="line">  lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;__gc&quot;</span>);</span><br></pre></td></tr></table></figure>
因此，事情就很简单了，需要提供require_ex函数，可以把它理解为require的增强版 。 使用这个函数，可以动态更新某个模块的代码：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">干unction require_ex( _mname )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">string</span> .<span class="built_in">format</span>(<span class="string">&quot;require_ex ＝喃5 ”，＿mname) )</span></span><br><span class="line"><span class="string">if package.loaded[_mname] then</span></span><br><span class="line"><span class="string">print( string.format(”require_ex module[ %s] reload”,_mname))</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">package .loaded[_mname] = nil</span></span><br><span class="line"><span class="string">require( _mname )</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>
这个函数做的事情一目了然 。 首先，判断是否曾经加载过这个模块，如果有，则打印一条日志，表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。</li>
</ul>
<p>一般热更新都是函数的实现，所以需要对全局变量做一些保护 。 比如，当前某全局变量为 100 ，表示某个操作已经进行了 100次，它不能因为热更新重置为0 ，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样 ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a <span class="keyword">or</span> o</span><br></pre></td></tr></table></figure>
<p>这个原理很简单，只有当前a这个变量没有初始值的时候才会赋值为0 ，而后面不管这个Lua文件被加载多少次， a者~J之会因为重新加载了Lua代码而发生改变 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《lua设计与实现》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/mysql%EF%BC%9A%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/mysql%EF%BC%9A%E9%94%81/" itemprop="url">mysql：锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T00:42:29+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>锁机制用于管理对共享资源的并发访问。</p>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁只在存储引擎层实现，在服务器层没有实现。</p>
<h2 id="mysql乐观锁、悲观锁"><a href="#mysql乐观锁、悲观锁" class="headerlink" title="mysql乐观锁、悲观锁"></a>mysql乐观锁、悲观锁</h2><p>latch门闩，因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>
<p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commt或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁升级是指将当前锁的粒度降低。比如，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表负。如果在数据库的设计中认为锁是一种稀有资源，而且想避免锁的开销，那数据库中会频繁出现锁升级现象</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/23/mysql%EF%BC%9A%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/mysql%EF%BC%9A%E4%BA%8B%E5%8A%A1/" itemprop="url">mysql：事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-23T00:21:10+08:00">
                2021-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：<br>⑴ 原子性（Atomicity）<br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>⑵ 一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>⑶ 隔离性（Isolation）<br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。<br>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>
<p>⑷ 持久性（Durability）<br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<br>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<p>以上介绍完事务的四大特性(简称ACID)</p>
<p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。<br>mysql服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中使用多种存储引擎是不可靠的。</p>
<p>输入：MySQL的 ROLLBACK 命令用来回退（撤销）MySQL语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from ordertotals;</span><br><span class="line">start transaction;</span><br><span class="line">delete from ordertotals;</span><br><span class="line">select * from ordertotals;</span><br><span class="line">rollback;</span><br><span class="line">select * from ordertotals;</span><br></pre></td></tr></table></figure>
<p>养成书写start tran + commit/rollback的习惯，exec的时候不要离开现场<br>rollback 是回滚事务，只要没有commit提交，还可以恢复之前的数据。commit是提交事务，你不提交事务，你之前所有更改的数据别人在查看是看不到只能看到之前的数据，commit提交以后，别人才可看到你更新后的数据</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/linux%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/22/linux%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/" itemprop="url">linux下的一些网络调试命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-22T22:55:06+08:00">
                2021-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="测试到达目的主机的网络是否连接-但ping无法检查系统端口是否开放"><a href="#测试到达目的主机的网络是否连接-但ping无法检查系统端口是否开放" class="headerlink" title="测试到达目的主机的网络是否连接,但ping无法检查系统端口是否开放"></a>测试到达目的主机的网络是否连接,但ping无法检查系统端口是否开放</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure>
<h2 id="检查某个端口是否开放"><a href="#检查某个端口是否开放" class="headerlink" title="检查某个端口是否开放"></a>检查某个端口是否开放</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet ip_addr:port</span><br></pre></td></tr></table></figure>
<h2 id="检测发出数据包的主机到目标主机之间所经过的网关数量"><a href="#检测发出数据包的主机到目标主机之间所经过的网关数量" class="headerlink" title="检测发出数据包的主机到目标主机之间所经过的网关数量"></a>检测发出数据包的主机到目标主机之间所经过的网关数量</h2><p>traceroute 的原理是试图以最小的TTL发出探测包来跟踪数据包到达目标主机所经过的网关，然后监听一个来自网关ICMP的应答。<br>程序利用增加存活时间（TTL）值来实现其功能。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并传送一个ICMP TTL数据包给原数据包的发出者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.google.com</span><br></pre></td></tr></table></figure>
<h2 id="判断连接是否健康"><a href="#判断连接是否健康" class="headerlink" title="判断连接是否健康"></a>判断连接是否健康</h2><h3 id="查看服务器端口有没有客户端来连接"><a href="#查看服务器端口有没有客户端来连接" class="headerlink" title="查看服务器端口有没有客户端来连接"></a>查看服务器端口有没有客户端来连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep xxxx</span><br></pre></td></tr></table></figure>
<h3 id="查看到进程id之后，使用netstat命令查看其占用的端口"><a href="#查看到进程id之后，使用netstat命令查看其占用的端口" class="headerlink" title="查看到进程id之后，使用netstat命令查看其占用的端口"></a>查看到进程id之后，使用netstat命令查看其占用的端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nap | grep pid</span><br></pre></td></tr></table></figure>
<h3 id="查看tcp连接数及状态"><a href="#查看tcp连接数及状态" class="headerlink" title="查看tcp连接数及状态"></a>查看tcp连接数及状态</h3><p>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LAST_ACK 5  </span><br><span class="line">SYN_RECV 30  </span><br><span class="line">ESTABLISHED 15  </span><br><span class="line">FIN_WAIT1 51  </span><br><span class="line">FIN_WAIT2 5  </span><br><span class="line">TIME_WAIT 10  </span><br></pre></td></tr></table></figure>
<p>状态：描述<br>CLOSED：无连接是活动的或正在进行<br>LISTEN：服务器在等待进入呼叫<br>SYN_RECV：一个连接请求已经到达，等待确认<br>SYN_SENT：应用已经开始，打开一个连接<br>ESTABLISHED：正常数据传输状态<br>FIN_WAIT1：应用说它已经完成<br>FIN_WAIT2：另一边已同意释放<br>ITMED_WAIT：等待所有分组死掉<br>CLOSING：两边同时尝试关闭<br>TIME_WAIT表示处理完毕，等待超时结束的请求数。<br>LAST_ACK：等待所有分组死掉</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/mysql%EF%BC%9A%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/22/mysql%EF%BC%9A%E7%B4%A2%E5%BC%95/" itemprop="url">mysql：索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-22T22:36:08+08:00">
                2021-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>聚集索引以及非聚集索引用的是B+树索引。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>单单从定义来看是不是显得有点抽象，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址。</p>
<h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致</p>
<h2 id="为什么要创建索引"><a href="#为什么要创建索引" class="headerlink" title="为什么要创建索引"></a>为什么要创建索引</h2><p>这是因为，创建索引可以大大提高系统的性能。<br>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<h2 id="深入浅出理解索引结构"><a href="#深入浅出理解索引结构" class="headerlink" title="深入浅出理解索引结构"></a>深入浅出理解索引结构</h2><p>实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：</p>
<p>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。</p>
<p>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。</p>
<p>通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p>
<h2 id="何时使用聚集索引或非聚集索引"><a href="#何时使用聚集索引或非聚集索引" class="headerlink" title="何时使用聚集索引或非聚集索引"></a>何时使用聚集索引或非聚集索引</h2><p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p>
<h2 id="结合实际，谈索引使用的误区"><a href="#结合实际，谈索引使用的误区" class="headerlink" title="结合实际，谈索引使用的误区"></a>结合实际，谈索引使用的误区</h2><p>理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。</p>
<p>1、主键就是聚集索引<br>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。<br>通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。<br>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。<br>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。<br>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。<br>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。<br>在这里之所以提到“理论上”三字，是因为如果您的聚集索引还是盲目地建在ID这个主键上时，您的查询速度是没有这么高的，即使您在“日期”这个字段上建立的索引（非聚合索引）。</p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。<br>所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。<br>当然，在实践中，作为一个尽职的数据库管理员，您还要多测试一些方案，找出哪种方案效率最高、最为有效。</p>
<p>有索引情况下，insert速度一定有影响，不过：</p>
<ol>
<li>你不大可能一该不停地进行insert, SQL Server能把你传来的命令缓存起来，依次执行，不会漏掉任何一个insert。</li>
<li>你也可以建立一个相同结构但不做索引的表，insert数据先插入到这个表里，当这个表中行数达到一定行数再用insert table1 select * from table2这样的命令整批插入到有索引的那个表里。</li>
</ol>
<h2 id="InnoDB存储引擎支持以下几种常见的索引"><a href="#InnoDB存储引擎支持以下几种常见的索引" class="headerlink" title="InnoDB存储引擎支持以下几种常见的索引"></a>InnoDB存储引擎支持以下几种常见的索引</h2><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>就是传统意义上的索引，B+树索引的构造类似于二叉树，根据键值快速找到数据。B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>通过数值比较、范围过滤就可以完成绝大多数我们需要的查询了。但是，如果你希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>
<h2 id="mysql-键值类型"><a href="#mysql-键值类型" class="headerlink" title="mysql 键值类型"></a>mysql 键值类型</h2><p>普通索引 index (id name sex age loves)<br>唯一索引 unique<br>主键 primary key<br>外键 foreign key<br>全文索引 fulltext </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/%E6%80%8E%E6%A0%B7%E7%9C%8Bmysql%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/22/%E6%80%8E%E6%A0%B7%E7%9C%8Bmysql%E6%80%A7%E8%83%BD/" itemprop="url">怎样看mysql性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-22T22:25:19+08:00">
                2021-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow%&#x27;</span>; </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;%slow%&#x27;</span>; </span><br></pre></td></tr></table></figure>
<h2 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>; </span><br></pre></td></tr></table></figure>
<h2 id="进程使用情况"><a href="#进程使用情况" class="headerlink" title="进程使用情况"></a>进程使用情况</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> ‘Thread<span class="operator">%</span>’; </span><br></pre></td></tr></table></figure>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>mysql数据库常见的日志文件有：<br>错误日志（error log）<br>二进制日志（binlog）<br>慢查询日志（slow query log）<br>查询日志（log）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/22/mysql%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/22/mysql%E6%9E%B6%E6%9E%84/" itemprop="url">mysql架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-22T11:18:09+08:00">
                2021-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MySQL是单进程多线程，而Oracle等是多进程。</p>
<p>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 </p>
<h2 id="mysql包括"><a href="#mysql包括" class="headerlink" title="mysql包括"></a>mysql包括</h2><ul>
<li>DBMS数据库管理系统（实例）</li>
<li>数据库（容器）<br>在mysql数据库中，实例与数据库的关系通常是一一对应的，但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。</li>
</ul>
<h2 id="mysql逻辑架构"><a href="#mysql逻辑架构" class="headerlink" title="mysql逻辑架构"></a>mysql逻辑架构</h2><p><img src="https://user-images.githubusercontent.com/11263320/108652560-6bdc1500-74ff-11eb-9f36-34d29dbcc2ef.jpg" alt="1425134-20190311163049501-1910090477"><br>上层是服务器层的服务和查询执行引擎，下层则是存储引擎。 </p>
<p>除非需要用到某些InnodDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎。<br>除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题，以及一些潜在的bug和边界问题。存储引擎层和服务器层的交互已经比较复杂，更不用说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。</p>
<p>因为MySQL是单进程多线程，所以每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。</p>
<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p><img src="https://user-images.githubusercontent.com/11263320/108652613-86ae8980-74ff-11eb-97c2-3943134276da.jpg" alt="1425134-20190315154442820-765166828"></p>
<h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>master：核心线程，主要负责将缓冲池中的数据异步刷新到磁盘。<br>IO：负责IO请求的回调处理。<br>purge：事务被提交台，其所使用的undolog可能不再需要，因此需要purge来回收已经使用并分配的undo页。<br>page cleaner：脏页的刷新操作。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>缓冲池：InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>
<h2 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h2><p>插入缓冲<br>两次写<br>自适应哈希索引<br>异步IO<br>刷新邻接页</p>
<p>关系型数据库系统和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。当前几乎所有的关系型数据库都提供了约束机制，该机制提供了一条强大而简易的途径来保证数据库中数据的完整性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">losophy</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  













<!-- LOCAL: You can save these files to your site and update links -->
  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- END LOCAL -->
 
    
 




  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
