<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Lua实现了一个安全的运行环境、一套自动内存管理机制、优秀的字符串处理能力和动态大小数据的处理功能。 我们都知道，只要应用程序加入lua解析器的功能，就能解析lua脚本。那lua脚本是怎样执行的？我们通常用dofile去打开编译一个lua脚本。当应用程序调用dofile后，在执行完脚本后，才能后到主程序中，这lua脚本相当于一个函数。要等函数执行完才能回到主程序中。在lua脚本中，一般有变量，函数">
<meta property="og:type" content="article">
<meta property="og:title" content="lua环境与模块">
<meta property="og:url" content="http://example.com/post/ceeb0073.html">
<meta property="og:site_name" content="losophy">
<meta property="og:description" content="Lua实现了一个安全的运行环境、一套自动内存管理机制、优秀的字符串处理能力和动态大小数据的处理功能。 我们都知道，只要应用程序加入lua解析器的功能，就能解析lua脚本。那lua脚本是怎样执行的？我们通常用dofile去打开编译一个lua脚本。当应用程序调用dofile后，在执行完脚本后，才能后到主程序中，这lua脚本相当于一个函数。要等函数执行完才能回到主程序中。在lua脚本中，一般有变量，函数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/113692378-126f2480-9700-11eb-99a2-8a8d4bbea09a.JPG">
<meta property="article:published_time" content="2021-02-23T02:32:51.000Z">
<meta property="article:modified_time" content="2021-05-12T07:13:23.349Z">
<meta property="article:author" content="losophy">
<meta property="article:tag" content="lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/11263320/113692378-126f2480-9700-11eb-99a2-8a8d4bbea09a.JPG">

<link rel="canonical" href="http://example.com/post/ceeb0073.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>lua环境与模块 | losophy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/losophy" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">losophy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/ceeb0073.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          lua环境与模块
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-23 10:32:51" itemprop="dateCreated datePublished" datetime="2021-02-23T10:32:51+08:00">2021-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-12 15:13:23" itemprop="dateModified" datetime="2021-05-12T15:13:23+08:00">2021-05-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Lua实现了一个安全的运行环境、一套自动内存管理机制、优秀的字符串处理能力和动态大小数据的处理功能。</p>
<p>我们都知道，只要应用程序加入lua解析器的功能，就能解析lua脚本。那lua脚本是怎样执行的？<br>我们通常用dofile去打开编译一个lua脚本。当应用程序调用dofile后，在执行完脚本后，才能后到主程序中，这lua脚本相当于一个函数。要等函数执行完才能回到主程序中。<br>在lua脚本中，一般有变量，函数，这些东西都保存在一个常规的table中，这个table称为“环境”。</p>
<h2 id="loadfile、dofile、require"><a href="#loadfile、dofile、require" class="headerlink" title="loadfile、dofile、require"></a>loadfile、dofile、require</h2><p>loadfile——只加载编译，不运行<br>dofile——执行<br>require——只执行一次</p>
<p>用require函数只能加载一次,因为它的特性是:<br>1、require函数会搜索目录加载文件<br>2、require会判断是否文件已经加载避免重复加载同一文件。<br>但当有一些特殊的需求需要反复加载某个lua文件，那如何实现反复加载一个lua文件?<br>答案是:二次加载前加这一句<br>package.loaded[luafile] = nil</p>
<h2 id="环境相关的变量"><a href="#环境相关的变量" class="headerlink" title="环境相关的变量"></a>环境相关的变量</h2><p>这里首先分析几个与环境相关的特殊变量一–Global表 、 env表 、 registry表以及UpValue 。<br>关于前3个表，需要注意以下几点 。</p>
<ul>
<li>Global表存放在 lua State结构体中也称为G表 。 每个 lua State结构体都有一个对应的G表。 不用多说，这个表就是存放全局变量的。</li>
<li>env表存放在Closure结构体中，也就是每个函数有自己独立的一个环境 。</li>
<li>registry表是全局唯一的，它存放在global_State结构体中，这个结构体在整个运行环境中只有一个。</li>
</ul>
<p>在讲解OP G ETG LOBAL 以及OP SETG LOBA L指令时说到，查找一个全局变量的操作，其实更精确地说，是在当前函数的 env表中查找 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_GETGLOBAL: &#123;</span><br><span class="line">        TValue g;</span><br><span class="line">        TValue *rb = KBx(i);</span><br><span class="line">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class="line">        lua_assert(ttisstring(rb));</span><br><span class="line">        Protect(luaV_gettable(L, &amp;g, rb, ra));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">case</span> OP_SETGLOBAL: &#123;</span><br><span class="line">        TValue g;</span><br><span class="line">        sethvalue(L, &amp;g, cl-&gt;env);</span><br><span class="line">        lua_assert(ttisstring(KBx(i)));</span><br><span class="line">        Protect(luaV_settable(L, &amp;g, KBx(i), ra));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个操作都是到函数对应的Closure指针中的巴nv表去查询数据 。 这里仍然需要提醒一下前面提到的一点，即使对一个没有任何函数的代码而言，分析完毕之后都对应一个Closure 。 因此，这里提到的“当前函数环境”，指的不一定是某一个具体的函数，也可能是一个Lua文件 。</p>
<p>Lua提供了几个API来读取当前函数的环境，分别是getfenv和 setfenv<br>因此，如果执行以下代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>,&#123;&#125;)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>实际上找不到Lua标准库提供的 print函数，并且会提示报错attempt to call global ’庐山’（a nilvalue） 。 原因就是首先使用 setfenv 函数将当前函数的 env表置为一个空表，此时在当前函数的 env表中查找不到这个名字的函数。</p>
<p>下面来看看函数的 env表是如何创建的 。 在创建一个Closure对象时，都会调用getcurrenv函数来获取当前的环境表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Table *<span class="title">getcurrenv</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;ci == L-&gt;base_ci)  <span class="comment">/* no enclosing function? */</span></span><br><span class="line">    <span class="keyword">return</span> hvalue(gt(L));  <span class="comment">/* use global table as environment */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Closure *func = curr_func(L);</span><br><span class="line">    <span class="keyword">return</span> func-&gt;c.env;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将区分如下两种情况</p>
<ul>
<li>如果该函数不是内嵌函数，那么直接返回G表</li>
<li>再则，如果是内嵌函数，就返回其母函数的 env表</li>
</ul>
<p>在创建一个新的 Closure时，会调用这个函数返回的结果，对新的Closure的环境进行赋值。这里可以看出， env表会逐层继承。</p>
<p>接着来看看registry表的作用，该表存放在global_State结构体中，因此里面的内容可供多个 lua State访问 。 另外，这个表只能由 C代码访问， Lua代码不能访问 。 除此之外，它和普通的表没有什么区别 。</p>
<p>但是需要注意的是，使用普通的对表进行赋值的API对registry表进行赋值时，应该使用字符串类型的键。 LuaAPI中对外提供了接口 lua_ref 、 lua_unre于和lua_getref ，用于提供在registry表中存取唯一的数字键。 通过这组API ，使用者不需要关心给某个需要存放到registry表的数据如何分配一个全局唯一的键，由 Lua解释器自己来保证这一点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \</span></span><br><span class="line">      (lua_pushstring(L, <span class="string">&quot;unlocked references are obsolete&quot;</span>), lua_error(L), <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))</span></span><br></pre></td></tr></table></figure>
<p>接着来看看这里面lual ref和 lu a L unref函数的实现。 需要说明的是，在调用 luaL ref函数之前，需要存放的数据已经位于枝顶：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaL_ref</span> <span class="params">(lua_State *L, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ref;</span><br><span class="line">  t = abs_index(L, t);</span><br><span class="line">  <span class="keyword">if</span> (lua_isnil(L, <span class="number">-1</span>)) &#123;</span><br><span class="line">    lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove from stack */</span></span><br><span class="line">    <span class="keyword">return</span> LUA_REFNIL;  <span class="comment">/* `nil&#x27; has a unique fixed reference */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_rawgeti(L, t, FREELIST_REF);  <span class="comment">/* get first free element */</span></span><br><span class="line">  ref = (<span class="keyword">int</span>)lua_tointeger(L, <span class="number">-1</span>);  <span class="comment">/* ref = t[FREELIST_REF] */</span></span><br><span class="line">  lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove it from stack */</span></span><br><span class="line">  <span class="keyword">if</span> (ref != <span class="number">0</span>) &#123;  <span class="comment">/* any free element? */</span></span><br><span class="line">    lua_rawgeti(L, t, ref);  <span class="comment">/* remove it from list */</span></span><br><span class="line">    lua_rawseti(L, t, FREELIST_REF);  <span class="comment">/* (t[FREELIST_REF] = t[ref]) */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* no free elements */</span></span><br><span class="line">    ref = (<span class="keyword">int</span>)lua_objlen(L, t);</span><br><span class="line">    ref++;  <span class="comment">/* create new reference */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_rawseti(L, t, ref);</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaL_unref</span> <span class="params">(lua_State *L, <span class="keyword">int</span> t, <span class="keyword">int</span> ref)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ref &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    t = abs_index(L, t);</span><br><span class="line">    lua_rawgeti(L, t, FREELIST_REF);</span><br><span class="line">    lua_rawseti(L, t, ref);  <span class="comment">/* t[ref] = t[FREELIST_REF] */</span></span><br><span class="line">    lua_pushinteger(L, ref);</span><br><span class="line">    lua_rawseti(L, t, FREELIST_REF);  <span class="comment">/* t[FREELIST_REF] = ref */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的设计其实很巧妙，仅使用一个数组就模拟了一个链表的实现，其原理如下</p>
<ul>
<li>FREELIST_REF用于保存当前registry表中可用键的索引，每次需要存储之前，都会先到这里拿到当前存放的值。</li>
<li>如果拿出来的值是0 ，说明当前的h巳list中还没有数据，直接返回当前registry表的数据盐作为新的索引 。</li>
<li>当调用 lual unref释放一个索引值的时候，将该索引值返回 FREELIST REF链表中 。</li>
</ul>
<p>下图演示了分配可用索引前后freelist的变化<br><img src="https://user-images.githubusercontent.com/11263320/113692378-126f2480-9700-11eb-99a2-8a8d4bbea09a.JPG" alt="捕获"><br>最后来看UpValue 。 前面谈到， registry表提供的是全局变量的存储， env表提供的是函数内全局变茸的存储，而UpValue用于提供函数内静态变量的存储，这些变量存储的地方，倒不是某个特殊的表，其实就是换算成对应的UpValue的索引值来访问函数的UpValue数组而已<br>接着我们来看一个关键的函数index2adr ，这个函数集中处理了所有索引值转换为械地址值的操作，不论该索’寻｜是椅上元素的索引，还是前面这几种特殊变量的索引：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** pseudo-indices</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_REGISTRYINDEX	(-10000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_ENVIRONINDEX	(-10001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_GLOBALSINDEX	(-10002)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TValue *<span class="title">index2adr</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    TValue *o = L-&gt;base + (idx - <span class="number">1</span>);</span><br><span class="line">    api_check(L, idx &lt;= L-&gt;ci-&gt;top - L-&gt;base);</span><br><span class="line">    <span class="keyword">if</span> (o &gt;= L-&gt;top) <span class="keyword">return</span> cast(TValue *, luaO_nilobject);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> o;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (idx &gt; LUA_REGISTRYINDEX) &#123;</span><br><span class="line">    api_check(L, idx != <span class="number">0</span> &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);</span><br><span class="line">    <span class="keyword">return</span> L-&gt;top + idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">switch</span> (idx) &#123;  <span class="comment">/* pseudo-indices */</span></span><br><span class="line">    <span class="keyword">case</span> LUA_REGISTRYINDEX: <span class="keyword">return</span> registry(L);</span><br><span class="line">    <span class="keyword">case</span> LUA_ENVIRONINDEX: &#123;</span><br><span class="line">      Closure *func = curr_func(L);</span><br><span class="line">      sethvalue(L, &amp;L-&gt;env, func-&gt;c.env);</span><br><span class="line">      <span class="keyword">return</span> &amp;L-&gt;env;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LUA_GLOBALSINDEX: <span class="keyword">return</span> gt(L);</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      Closure *func = curr_func(L);</span><br><span class="line">      idx = LUA_GLOBALSINDEX - idx;</span><br><span class="line">      <span class="keyword">return</span> (idx &lt;= func-&gt;c.nupvalues)</span><br><span class="line">                ? &amp;func-&gt;c.upvalue[idx<span class="number">-1</span>]</span><br><span class="line">                : cast(TValue *, luaO_nilobject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑主要是根据传人的 idx的几种情况，分别返回不同的值。</p>
<ul>
<li>如果 idx &gt;O ，那么以 idx值为索引，返回基于 lua State的 base指针的值，也就是相对于战底向上的偏移值。</li>
<li>如果 idx&gt;LUA_REGISTRYINDEX ，则以 idx值为索引，返回基于 l ua_State的top指针的值，也就是相对于钱顶向下的偏移值。</li>
<li>如果是LUA_REGISTRYINDEX ，那么返回 registry表。</li>
<li>如果是LUA ENVIRONINDEX ，那么返回当前函数的env表。</li>
<li>如果是LUA GLOBALSINDEX ，那么返回Global表。</li>
<li>如果以上都不符合，那么将根据情况返回当前函数的叩value数组中的值。</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>这一节将讲解Lua模块相关的知识点，首先介绍模块的加载、编写等原理，然后介绍热更新原理。</p>
<h3 id="模块的加载"><a href="#模块的加载" class="headerlink" title="模块的加载"></a>模块的加载</h3><p>在Lua内部，所有模块的注册都在linit.c的函数lual_openlibs 中提供。 可以看到，它依次访问lualibs数组中的成员，这些成员定义了每个模块的模块名及相应的模块注册函数，依次调用每个模块的注册函数完成模块的注册 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg lualibs[] = &#123;</span><br><span class="line">  &#123;<span class="string">&quot;&quot;</span>, luaopen_base&#125;,</span><br><span class="line">  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,</span><br><span class="line">  &#123;LUA_TABLIBNAME, luaopen_table&#125;,</span><br><span class="line">  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class="line">  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br><span class="line">  &#123;LUA_STRLIBNAME, luaopen_string&#125;,</span><br><span class="line">  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,</span><br><span class="line">  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class="line">  &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaL_openlibs</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> luaL_Reg *lib = lualibs;</span><br><span class="line">  <span class="keyword">for</span> (; lib-&gt;func; lib++) &#123;</span><br><span class="line">    lua_pushcfunction(L, lib-&gt;func);</span><br><span class="line">    lua_pushstring(L, lib-&gt;name);</span><br><span class="line">    lua_call(L, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体lual_Reg有两个变量，分别是模块名以及模块初始化函数。 可以看到，第一个模块是base模块，其模块名是一个空字符串，因此访问这个模块的函数不需要加模块名前缀，比如我们熟悉的 print 函数就是属于这个模块的 。 这就是在调用 print函数时，不需要在前面加模块名前缀的原因 。 这里就以 base模块为例来讲解模块的注册过程。</p>
<p>加载base模块最终会调用 base_open函数，下面我们看看这个函数里面最核心的几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">base_open</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* set global _G */</span></span><br><span class="line">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class="line">  lua_setglobal(L, <span class="string">&quot;_G&quot;</span>);</span><br><span class="line">  <span class="comment">/* open lib into global table */</span></span><br><span class="line">  luaL_register(L, <span class="string">&quot;_G&quot;</span>, base_funcs);</span><br></pre></td></tr></table></figure>
<p>最开始的两句首先将 LUA_GLOBA LSINDEX对应的值压人拢中，接着调用 lua_setglobal(L ,二C ”） ; , e n 当在 lua_State 的 l_gt表中查找工C”时，查找到的是索引值为 LUA_GLOBALSINDEX的表 。如果觉得有点绕，可以简单理解为，在C表满足这个等式＿G = _G ［二G”］ 。 也就是这个叫＿G的表内部有一个key为二G”的表是指向自己的 。 可以在Lua命令行中执行print(_G ）和 print(_G ［”＿G”］）看看输出结果，来验证一下这个结论。</p>
<p>我猜想这么处理的理由是 ： 为了让G表和其他表使用同样的机制 。 查找变量时，最终会一直顺着层次往上查到G表中，这是很自然的事情 。 所以，为了也能按照这个机制顺利地查找到自己，于是在G表中有一个同名成员指向自己 。</p>
<p>好了，前两句的作用已经分析完毕，其结果有以下两个 ：</p>
<ul>
<li>＿G = _G [”_G”]</li>
<li>G表的值压入函数枝中方便后面的调用 。</li>
</ul>
<p>所以，这个G表的注册操作需要在所有模块注册之前进行。</p>
<p>在第63 1行中， base_fu n cs也是一个lual_Reg数组，上面的操作会将base_funcs数组中的函数注册到G表中，但是里面还有些细节需要看看。 这个操作最终会调用函数luaI←openlib:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">void</span> <span class="title">luaI_openlib</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *libname,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> luaL_Reg *l, <span class="keyword">int</span> nup)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (libname) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = libsize(l);</span><br><span class="line">    <span class="comment">/* check whether lib already exists */</span></span><br><span class="line">    luaL_findtable(L, LUA_REGISTRYINDEX, <span class="string">&quot;_LOADED&quot;</span>, size);</span><br><span class="line">    lua_getfield(L, <span class="number">-1</span>, libname);  <span class="comment">/* get _LOADED[libname] */</span></span><br><span class="line">    <span class="keyword">if</span> (!lua_istable(L, <span class="number">-1</span>)) &#123;  <span class="comment">/* not found? */</span></span><br><span class="line">      lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove previous result */</span></span><br><span class="line">      <span class="comment">/* try global variable (and create one if it does not exist) */</span></span><br><span class="line">      <span class="keyword">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != <span class="literal">NULL</span>)</span><br><span class="line">        luaL_error(L, <span class="string">&quot;name conflict for module &quot;</span> LUA_QS, libname);</span><br><span class="line">      lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">      lua_setfield(L, <span class="number">-3</span>, libname);  <span class="comment">/* _LOADED[libname] = new table */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_remove(L, <span class="number">-2</span>);  <span class="comment">/* remove _LOADED table */</span></span><br><span class="line">    lua_insert(L, -(nup+<span class="number">1</span>));  <span class="comment">/* move library table to below upvalues */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; l-&gt;name; l++) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;nup; i++)  <span class="comment">/* copy upvalues to the top */</span></span><br><span class="line">      lua_pushvalue(L, -nup);</span><br><span class="line">    lua_pushcclosure(L, l-&gt;func, nup);</span><br><span class="line">    lua_setfield(L, -(nup+<span class="number">2</span>), l-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pop(L, nup);  <span class="comment">/* remove upvalues */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册这些函数之前，首先会到registry ［二LOADED＂］表中查找该库，如果不存在，则在G表中查找这个库，若不存在则创建一个表。<br>因此，不管是Lua内部的库还是外部使用require引用的库，首先会到 registry ［”一LOADED ”］ 中存放该库的表。 最后，再遍历传进来的函数指针数组，完成库函数的注册。<br>比如，注册as . print时，首先将print函数绑定在一个函数指针上，再去l_registry[_LOADED]和G表中查询名为OS的库是否存在，不存在则创建一个表，即 ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G[”OS<span class="string">&quot;] = &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>紧跟着注册print函数，即： G ［”os ”］［ ” print ”］＝待注册的函数指针。<br>这样在调用os . print(1）时，首先根据OS到G表中查找对应的表，再在这个表中查找print成员得到函数指针，最后完成函数的调用 。</p>
<h3 id="模块的编写"><a href="#模块的编写" class="headerlink" title="模块的编写"></a>模块的编写</h3><p>在定义Lua模块时，第一句代码一般都是module(xxx ） 。 module调用的对应C函数是loadlib.c中的函数ll_module:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ll_module</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *modname = luaL_checkstring(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> loaded = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of _LOADED table */</span></span><br><span class="line">  lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;_LOADED&quot;</span>);</span><br><span class="line">  lua_getfield(L, loaded, modname);  <span class="comment">/* get _LOADED[modname] */</span></span><br><span class="line">  <span class="keyword">if</span> (!lua_istable(L, <span class="number">-1</span>)) &#123;  <span class="comment">/* not found? */</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);  <span class="comment">/* remove previous result */</span></span><br><span class="line">    <span class="comment">/* try global variable (and create one if it does not exist) */</span></span><br><span class="line">    <span class="keyword">if</span> (luaL_findtable(L, LUA_GLOBALSINDEX, modname, <span class="number">1</span>) != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> luaL_error(L, <span class="string">&quot;name conflict for module &quot;</span> LUA_QS, modname);</span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">    lua_setfield(L, loaded, modname);  <span class="comment">/* _LOADED[modname] = new table */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* check whether table already has a _NAME field */</span></span><br><span class="line">  lua_getfield(L, <span class="number">-1</span>, <span class="string">&quot;_NAME&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!lua_isnil(L, <span class="number">-1</span>))  <span class="comment">/* is table an initialized module? */</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* no; initialize it */</span></span><br><span class="line">    lua_pop(L, <span class="number">1</span>);</span><br><span class="line">    modinit(L, modname);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">  setfenv(L);</span><br><span class="line">  dooptions(L, loaded - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的前半部分首先根据module(XXX）中的模块名去registry [“_LOADED”］表中查找，如果找不到，则创建一个新表，这个表为＿G ［” xxx叮＝ registry ［二LOADED ”］［ “XXX ＂］ 。 换言之，这个名为xxx 的模块本质上是一个表，这个表存储了这个模块中的所有变革－以及函数，它既可以通过一G ［” xxx”］来访问，也可以通过registry ［二 LOADED ”］［ “XXX ”］来访问 。<br>紧跟着，在modi nit 函数中，将这个表的成员 K NAME 、 PACKAGE分别赋值。<br>最后，调用 setfenv将该模块对应的环境置空 。 根据前面的分析， setfenv将该模块对应的环境置空就是将这个模块分析完毕之后返回的Closure对应的env环境表置空 。 这意味着，前面的所有全局变量都看不见了，比如下面的代码中 ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myprint=<span class="built_in">print</span></span><br><span class="line">myprint(”<span class="number">1</span>”)</span><br><span class="line"><span class="built_in">module</span>(”test”)</span><br><span class="line">myprint (” <span class="number">2</span>”)</span><br></pre></td></tr></table></figure>
<p>这里首先将全局函数printl赋值给全局变量myprint ，第二行代码可以正常调用这个函数。但当调用module声明 test模块之后，在此之前的全局变量myprint被清空，第四行代码调用myprint函数时就会报错，错误信息是attempt to call global ‘myprint’(a nil value），因为此时已经查不到这个变量了 。<br>如果写下的是module(xxx,package . seeall）呢？它将会调用后面的dooptions 函数并且最后调用 package.seeall对应的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ll_seeall</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  luaL_checktype(L, <span class="number">1</span>, LUA_TTABLE);</span><br><span class="line">  <span class="keyword">if</span> (!lua_getmetatable(L, <span class="number">1</span>)) &#123;</span><br><span class="line">    lua_createtable(L, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* create new metatable */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-1</span>);</span><br><span class="line">    lua_setmetatable(L, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushvalue(L, LUA_GLOBALSINDEX);</span><br><span class="line">  lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;__index&quot;</span>);  <span class="comment">/* mt.__index = _G */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就两个作用 ： 一个是创建该模块对应表的metatable ， 另一个是将meta表的 index指向 G表。 也就是说，所有在该模块中找不到的变量都会去 G表中查找 。 可以看到，这里的操作并不会把环境表清空 。 因此，如果把前面的代码改成这样，就可以正确执行：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myprint=<span class="built_in">print</span></span><br><span class="line">myprint(” test ”)</span><br><span class="line">morlule (”test <span class="string">&#x27;’, package. seeall)</span></span><br><span class="line"><span class="string">myprint(”test”) </span></span><br></pre></td></tr></table></figure>
<p>根据前面对module函数的分析，得出以下几个结论。</p>
<ul>
<li>创建模块时会创建一个表，该表挂载在registry ［ ”一LOADED ＇ ’ ］、＿G ［模块名］下 。 自然而然地，该模块中的变量（函数也是一种变量）就会挂载到这个表里面 。</li>
<li>在 module 函数的参数中写下 package.seeall将会创建该表的 metatable ，同时该表的index将指向 G表。 简单地说，这个模块将可以看到所有全局环境下的变量（这里再提醒一次，函数也是一种变量） 。</li>
</ul>
<p>明白了 module 背后的作用，再来看看 require 函数，它对应的处理函数是 loadlib.c 中的ll_require 函数，这个函数做了如下几件事情 。</p>
<ul>
<li>首先在 registry[ “_LOADED”］表中查找该库，如果已存在，说明是已经加载过的模块，不再重复加载直接返回。</li>
<li>在当前环境表中查找 loaders变量，这里存放的是所有加载器组成的数组 。 在 Lua代码中，有4个loader :<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> lua_CFunction loaders[] =</span><br><span class="line">  &#123;loader_preload, loader_Lua, loader_C, loader_Croot, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure>
加载时，会依次调用 loaders数组中的四种 loader 。 如果加载的结果在Lua找中返回的是函数（前面提过，分析完Lua源代码文件，返回的是Closure ），那么说明加载成功，不再继续往下调用其他的 loader加载模块 。<br>最后，调用lua call函数尝试加载该模块。 加载之前，在L回校中压入一个哨兵值sentinel,如果加载完毕之后这个值没有被改动过，则说明加载完毕，将registry ［ ”＿LOADED”］赋值为true表示加载成功 。</li>
</ul>
<h3 id="模块的热更新原理"><a href="#模块的热更新原理" class="headerlink" title="模块的热更新原理"></a>模块的热更新原理</h3><p>能很好地支持代码热更新机制，是开发时选择使用脚本语言的原因之一 。 热更新的好处很在于，能在不重启程序或者发布新版本的情况下更新脚本，给调试和线上解决问题带来很大的便利，对开发效率有很大的提升 。<br>下面就来谈谈如何实现热更新 。先简单回顾之前提过的模块和lrequire机制 。 Lua内部提供了一个require 函数来实现模块的加载，它做的事情主要有以下几个。</p>
<ul>
<li>在registry ［二LOADED”］表中判断该模块是否已经加载过了，如果是则返回，避免重复加载某个模块代码 。</li>
<li>依次调用注册的 loader来加载模块 。</li>
<li>将加载过的模块赋值给registry ［”一LOADED ＂］表。<br>而如果要实现Lua的代码热更新，其实也就是需要重新加载某个模块，因此就要想办法让Lua虚拟机认为它之前没有加载过。 查看Lua代码可以发现 ， registry ［”一LOADED ”］表实际上对应的是package.loaded表，这在以下函数中有体现：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaopen_package</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">/* create new type _LOADLIB */</span></span><br><span class="line">  luaL_newmetatable(L, <span class="string">&quot;_LOADLIB&quot;</span>);</span><br><span class="line">  lua_pushcfunction(L, gctm);</span><br><span class="line">  lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;__gc&quot;</span>);</span><br></pre></td></tr></table></figure>
因此，事情就很简单了，需要提供require_ex函数，可以把它理解为require的增强版 。 使用这个函数，可以动态更新某个模块的代码：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">干unction require_ex( _mname )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">string</span> .<span class="built_in">format</span>(<span class="string">&quot;require_ex ＝喃5 ”，＿mname) )</span></span><br><span class="line"><span class="string">if package.loaded[_mname] then</span></span><br><span class="line"><span class="string">print( string.format(”require_ex module[ %s] reload”,_mname))</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">package .loaded[_mname] = nil</span></span><br><span class="line"><span class="string">require( _mname )</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>
这个函数做的事情一目了然 。 首先，判断是否曾经加载过这个模块，如果有，则打印一条日志，表示需要重新加载某个模块，然后将该模块原来在表中注册的值赋空，然后再次调用require进行模块的加载和注册。</li>
</ul>
<p>一般热更新都是函数的实现，所以需要对全局变量做一些保护 。 比如，当前某全局变量为 100 ，表示某个操作已经进行了 100次，它不能因为热更新重置为0 ，所以要对这些不能改变的全局变量做一个保护，最简单的方式就是这样 ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a <span class="keyword">or</span> o</span><br></pre></td></tr></table></figure>
<p>这个原理很简单，只有当前a这个变量没有初始值的时候才会赋值为0 ，而后面不管这个Lua文件被加载多少次， a者~J之会因为重新加载了Lua代码而发生改变 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《lua设计与实现》</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\post\6349ecd2.html" rel="bookmark">lua Table</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\post\d46217f.html" rel="bookmark">lua_state</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\post\b165dcb7.html" rel="bookmark">lua与C/C++程序的整合</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\post\fde3146b.html" rel="bookmark">lua与配置文件</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\post\e141c56e.html" rel="bookmark">lua元表和元方法</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/lua/" rel="tag"><i class="fa fa-tag"></i> lua</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/d620d60b.html" rel="prev" title="mysql：锁">
      <i class="fa fa-chevron-left"></i> mysql：锁
    </a></div>
      <div class="post-nav-item">
    <a href="/post/d46217f.html" rel="next" title="lua_state">
      lua_state <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#loadfile%E3%80%81dofile%E3%80%81require"><span class="nav-number">1.</span> <span class="nav-text">loadfile、dofile、require</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">环境相关的变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">3.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.1.</span> <span class="nav-text">模块的加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E5%86%99"><span class="nav-number">3.2.</span> <span class="nav-text">模块的编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">模块的热更新原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <!--
  <p class="site-author-name" itemprop="name">losophy</p>
  -->
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">losophy</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '305836da6c4a706f6fb7',
      clientSecret: '69be853985a105119444ad9dd25d60ac7ee03f3d',
      repo        : 'blog.comments',
      owner       : 'losophy',
      admin       : ['losophy'],
      id          : 'f8e28f9b815111a06ff0e55906afefa5',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
