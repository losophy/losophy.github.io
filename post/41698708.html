<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="首先，要了解 skynet 内的一个非常重要的概念 ———『服务』。所谓的服务，本质就是一个接收消息然后处理消息的过程，它跟我们日常生活中所说的服务（例如：外卖服务、快递服务等等）是一样的，它不是一个真实可见的物体，而是一个抽象的逻辑过程，它需要一个执行者来执行并完成它。这其实就是skynet实现的Actor模型。">
<meta property="og:type" content="article">
<meta property="og:title" content="skynet服务">
<meta property="og:url" content="http://example.com/post/41698708.html">
<meta property="og:site_name" content="losophy">
<meta property="og:description" content="首先，要了解 skynet 内的一个非常重要的概念 ———『服务』。所谓的服务，本质就是一个接收消息然后处理消息的过程，它跟我们日常生活中所说的服务（例如：外卖服务、快递服务等等）是一样的，它不是一个真实可见的物体，而是一个抽象的逻辑过程，它需要一个执行者来执行并完成它。这其实就是skynet实现的Actor模型。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/121668104-89001800-cadd-11eb-9f52-bf47bcebb1b3.jpg">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/121674426-a08ecf00-cae4-11eb-9564-a1f96020ec41.jpg">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/121778933-df4b8480-cbcb-11eb-9df5-d67d8bd5a313.JPG">
<meta property="og:image" content="https://user-images.githubusercontent.com/11263320/121795692-c67fb500-cc45-11eb-8eec-923835c58f97.jpg">
<meta property="article:published_time" content="2021-02-23T13:14:13.000Z">
<meta property="article:modified_time" content="2024-09-04T12:27:12.517Z">
<meta property="article:author" content="losophy">
<meta property="article:tag" content="skynet">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/11263320/121668104-89001800-cadd-11eb-9f52-bf47bcebb1b3.jpg">

<link rel="canonical" href="http://example.com/post/41698708.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>skynet服务 | losophy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/losophy" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">losophy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/41698708.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="losophy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="losophy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          skynet服务
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-23 13:14:13" itemprop="dateCreated datePublished" datetime="2021-02-23T13:14:13+00:00">2021-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-04 12:27:12" itemprop="dateModified" datetime="2024-09-04T12:27:12+00:00">2024-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>首先，要了解 skynet 内的一个非常重要的概念 ———『服务』。所谓的服务，本质就是一个接收消息然后处理消息的过程，它跟我们日常生活中所说的服务（例如：外卖服务、快递服务等等）是一样的，它不是一个真实可见的物体，而是一个抽象的逻辑过程，它需要一个执行者来执行并完成它。这其实就是<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/78">skynet实现的Actor</a>模型。</p>
<a id="more"></a>

<p>了解了“服务”后，现在，我们把上面的银行场景套用在 skynet 框架上，可以做出下面的转换关系：</p>
<blockquote>
<p>服务 = 银行提供的业务（个人业务、对公业务…）<br>工作线程 = 办事窗口（负责处理客户业务需求并完成需求）<br>CPU 核心 = 银行柜员（需要在办事窗口上工作）<br>网络线程 = 大堂接待（也相当于一个办事窗口）<br>定时器线程 = 银行的排队叫号系统</p>
</blockquote>
<p>有了这一层转换后，我们再转入到 skynet 的代码框架中，就清晰很多了。比如，对于工作线程的抢占执行，就类似银行柜员工作人员不足，导致有一些办事窗口没人工作，从而导致银行等待的人增多；在办理某一个业务时，可能会涉及到其他业务，就需要多个窗口沟通合作，这就类似 skynet 的服务间消息传递。</p>
<h2 id="服务的本质"><a href="#服务的本质" class="headerlink" title="服务的本质"></a>服务的本质</h2><p>每个skynet服务都是一个lua state，也就是一个lua虚拟机实例。而且，每个服务都是隔离的，各自使用自己独立的内存空间，服务之间通过发消息来完成数据交换。</p>
<p>lua state本身没有多线程支持的，为了实现cpu的摊分，skynet实现上在一个线程运行多个lua state实例。而同一时间下，调度线程只运行一个服务实例。为了提高系统的并发性，skynet会启动一定数量的调度线程。同时，为了提高服务的并发性，就利用lua协程并发处理。</p>
<p>所以，skynet的并发性有3点：<br>1、多个调度线程并发<br>2、lua协程并发处理<br>3、服务调度的切换</p>
<p>skynet服务的设计基于Actor模型。有两个特点：</p>
<ol>
<li>每个Actor依次处理收到的消息</li>
<li>不同的Actor可同时处理各自的消息<br>实现上，cpu会按照一定规则分摊给每个Actor，每个Actor不会独占cpu，在处理一定数量消息后主动让出cpu，给其他进程处理消息。</li>
</ol>
<p>skynet刚开始是单进程多线程的，它是由一个一个的服务组成的。在skynet上做开发，实际上就是在写服务。服务与服务之间通过消息队列进行通信。<br>一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。</p>
<h2 id="服务是怎么调用的"><a href="#服务是怎么调用的" class="headerlink" title="服务是怎么调用的"></a>服务是怎么调用的</h2><p>调用\lualib\skynet.lua 文件内的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">simpledb.lua： skynet.register “SIMPLEDB” 向skynet里注册一个服务 </span><br><span class="line">agent.lua： skynet.call(“SIMPLEDB”, “text”, text) 调用相应的服务 </span><br><span class="line">main.lua： skynet.newservice(“simpledb”) 启动一个服务</span><br></pre></td></tr></table></figure>
<p>以下是几个写服务时经常要用到的函数</p>
<blockquote>
<p>newservice(name, …) 启动一个名为 name 的新服务。<br>uniqueservice(name, …) 启动一个唯一服务，如果服务该服务已经启动，则返回已启动的服务地址。<br>queryservice(name) 查询一个由 uniqueservice 启动的唯一服务的地址，若该服务尚未启动则等待。<br>localname(name) 返回同一进程内，用 register 注册的具名服务的地址。</p>
</blockquote>
<blockquote>
<p>newservice可以在一个进程里启动多个服务，这适用于无状态的服务。<br>uniqueservice则是类似于设计模式中的单件(singleton)，这适用于需要唯一性的服务。举个例子，比如写日志，只想写一份。或者是全局共享的数据。</p>
</blockquote>
<h2 id="服务的实现"><a href="#服务的实现" class="headerlink" title="服务的实现"></a>服务的实现</h2><p>接下来，我会分成服务的创建、消息的处理以及服务的回收三个部分来深入服务模块。</p>
<h3 id="服务创建流程"><a href="#服务创建流程" class="headerlink" title="服务创建流程"></a>服务创建流程</h3><p>服务上下文与actor的关系密切，具体看<a target="_blank" rel="noopener" href="https://github.com/losophy/losophy.github.io/issues/78">skynet与actor</a>文中的Actor参与者部分。</p>
<h4 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h4><p>接下来看下服务上下文的创建和初始化流程，下图是一个服务上下文的详细创建过程：<br><img src="https://user-images.githubusercontent.com/11263320/121668104-89001800-cadd-11eb-9f52-bf47bcebb1b3.jpg" alt="a4knd-2myjp"></p>
<p>整个流程都封装在 skynet_context_new 这个函数中，函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * </span></span><br><span class="line"><span class="class"><span class="title">skynet_context_new</span>(<span class="title">const</span> <span class="title">char</span> * <span class="title">name</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">param</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span> =</span> skynet_module_query(name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mod == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *inst = skynet_module_instance_create(mod);</span><br><span class="line">	<span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*ctx));</span><br><span class="line">	CHECKCALLING_INIT(ctx)</span><br><span class="line"></span><br><span class="line">	ctx-&gt;mod = mod;</span><br><span class="line">	ctx-&gt;instance = inst;</span><br><span class="line">	ctx-&gt;ref = <span class="number">2</span>; <span class="comment">// 思考为什么是 2</span></span><br><span class="line">	ctx-&gt;cb = <span class="literal">NULL</span>;</span><br><span class="line">	ctx-&gt;cb_ud = <span class="literal">NULL</span>;</span><br><span class="line">	ctx-&gt;session_id = <span class="number">0</span>;</span><br><span class="line">	ctx-&gt;logfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;init = <span class="literal">false</span>;</span><br><span class="line">	ctx-&gt;endless = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;cpu_cost = <span class="number">0</span>;</span><br><span class="line">	ctx-&gt;cpu_start = <span class="number">0</span>;</span><br><span class="line">	ctx-&gt;message_count = <span class="number">0</span>;</span><br><span class="line">	ctx-&gt;profile = G_NODE.profile;</span><br><span class="line">	<span class="comment">// Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle</span></span><br><span class="line">	ctx-&gt;handle = <span class="number">0</span>;	</span><br><span class="line">	ctx-&gt;handle = skynet_handle_register(ctx);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">queue</span> =</span> ctx-&gt;<span class="built_in">queue</span> = skynet_mq_create(ctx-&gt;handle);</span><br><span class="line">	<span class="comment">// init function maybe use ctx-&gt;handle, so it must init at last</span></span><br><span class="line">	context_inc();</span><br><span class="line"></span><br><span class="line">	CHECKCALLING_BEGIN(ctx)</span><br><span class="line">	<span class="keyword">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);</span><br><span class="line">	CHECKCALLING_END(ctx)</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 初始化成功</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ret</span> =</span> skynet_context_release(ctx);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			ctx-&gt;init = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		skynet_globalmq_push(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			skynet_error(ret, <span class="string">&quot;LAUNCH %s %s&quot;</span>, name, param ? param : <span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 初始化失败，回收 ctx</span></span><br><span class="line">		skynet_error(ctx, <span class="string">&quot;FAILED launch %s&quot;</span>, name);</span><br><span class="line">		<span class="keyword">uint32_t</span> handle = ctx-&gt;handle;</span><br><span class="line">		skynet_context_release(ctx);</span><br><span class="line">		skynet_handle_retire(handle);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> =</span> &#123; handle &#125;;</span><br><span class="line">		skynet_mq_release(<span class="built_in">queue</span>, drop_message, &amp;d);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数一共有三个地方调用，其中有两处是在 skynet 启动过程中（skynet_start）调用，这两个函数调用会创建两个重要的服务：</p>
<blockquote>
<p>logger 服务，用来输出 skynet 的日志信息到文件（由配置字段 logger 指定）或标准输出（stdout），当然，我们可以重载 skynet 自带的 logger 服务，修改配置字段 logservice 即可。<br>bootstrap 服务，是一个 lua 服务，它负责引导基础服务，例如 launcher 服务等，它的作用类似于电脑开机时的引导程序一样。<br>前面两处调用都是用来初始化 skynet 进程所需的核心服务，而第三处调用是为了支持在已经启动的服务实例中能方便的启动其他服务，skynet 底层进一步对上面的流程进行封装，然后把封装好的接口暴露个上层使用，类似于 linux 内核暴露出的系统调用。<br>封装的服务启动接口原型如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">cmd_launch(struct skynet_context * context, <span class="keyword">const</span> <span class="keyword">char</span> * param);</span><br></pre></td></tr></table></figure>
<p>这个接口接收一个 const char *param 的参数，它用来控制skynet 应该启动一个什么服务，以及服务启动时的参数，服务类型名称和服务参数用空格分隔。例如，传递参数是 “snlua launcher”，则表示启动一个 launcher 的 lua 服务（这个服务专门负责 lua 层的服务启动，是一个非常重要的服务）。</p>
<p>下图是 launcher 服务创建一个新服务的调用图：<br><img src="https://user-images.githubusercontent.com/11263320/121674426-a08ecf00-cae4-11eb-9564-a1f96020ec41.jpg" alt="awgiu-8r86o"><br>创建好的 context 会被注册到服务仓库 handle_storage *H 中，如果注册成功，会给 context 分配一个 handle (即服务上下文的id，类似与文件描述符id)，handle 是一个无符号 32 位整型，高 8 位用来表示 harbor_id，低 24 位则表示 context 的索引号 index，即：handle=(harbor_id&lt;&lt;24)|index。需要注意的是，这两部分值都需要大于 0，即：harbor_id&gt;0 &amp;&amp; index&gt;01；然后创建服务的消息队列 queue，至此，服务已经创建完成，接下来便是服务的初始化过程。<br>服务初始化过程，其实是一个服务差异化的过程，每个创建好的服务实例通过传入参数的不同，会有不同的设置，这一部分会在接下来的汽车工厂的例子有更多详细的讲解。 然后设置服务的回调，最后把服务的消息队列 push 到全局消息队列中，以被工作线程消费、执行。</p>
<h4 id="服务模板"><a href="#服务模板" class="headerlink" title="服务模板"></a>服务模板</h4><p>所谓的服务模板，有点像一个工厂类，一个服务模板可以创建和初始化一个或多个服务实例，同时在创建服务实例时传递一些参数，对其进行一些定制操作。<br>套用现实生活场景中，一个汽车工厂可以生产很多辆汽车，每一辆生产出来的汽车就相当于一个服务实例，当然，工厂可以在生产汽车时，为了满足客户需求，提供一些可控的定制化服务，例如：车身颜色定制、配件增加等，而其中用来生产汽车的流水线就是一个服务模板。<br>在 skynet 中，这些模板是以动态库的形式存在，这些服务模板动态库编译后存放在 cservice 目录，目前，skynet 已有四个服务模板，它们分别是：</p>
<blockquote>
<p>logger，日志服务模板，在上面已经有提到；<br>gate，网关服务模板，最新版的 skynet 已经有另外一套 lua gate 实现方案；<br>harbor，提供 master/slave 模式的集群方案；<br>snlua，所有的 lua 服务都由它负责。</p>
</blockquote>
<p>当然，所有的服务模板都需要遵守一些约定，它们需要提供以下 4 个 api:</p>
<blockquote>
<p>create，必须，此 api 用来创建对应的服务实例；<br>init，必须，此 api 用来对服务实例进行初始化，同时还会设置 context 的回调实例和回调函数；<br>release，必须，用来释放服务实例，做一些清理工作；<br>signal，可选，用来跳出 lua 服务的死循环2。</p>
</blockquote>
<p>以上的这些接口定义可以在 skynet_module.h 头文件中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api 原型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * (*skynet_dl_create)(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*skynet_dl_init)</span><span class="params">(<span class="keyword">void</span> * inst, struct skynet_context *, <span class="keyword">const</span> <span class="keyword">char</span> * parm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*skynet_dl_release)</span><span class="params">(<span class="keyword">void</span> * inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*skynet_dl_signal)</span><span class="params">(<span class="keyword">void</span> * inst, <span class="keyword">int</span> signal)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务模板结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">	<span class="keyword">void</span> * <span class="keyword">module</span>;</span><br><span class="line">	skynet_dl_create create;</span><br><span class="line">	skynet_dl_init init;</span><br><span class="line">	skynet_dl_release release;</span><br><span class="line">	skynet_dl_signal signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>一个服务实例一定有一个服务消息队列（很多人称之为次级消息队列）与之对应，它的实现方式是一个环形队列。<br><img src="https://user-images.githubusercontent.com/11263320/121778933-df4b8480-cbcb-11eb-9df5-d67d8bd5a313.JPG" alt="65436345"><br>消息队列的容量默认是 64，若容量不足则以 2 倍的方式进行增长，另外，当消息队列中堆积的消息过载，则每次达到 1024 的整数倍时，由监控线程发出警报。</p>
<h3 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h3><p>注意，先停一停，从 skynet 的代码世界中跳出来，先思考一个现实生活中快递站点的场景：<br>有一个快递配送点，每天会把要派送的包裹分成多堆存放在不同仓库或角落，每一堆表示这个站点配送范围内的一个片区，且每一堆包裹由一个快递小哥负责用三轮车进行配送，假如你是这个配送站的负责人，你当然是希望快递尽可能快速、合理的被配送，那应该采用什么方案呢？</p>
<p>最直接的办法是让一个快递员固定负责一个片区，但是如果负责的片区过多，需要的快递员就会增多，这样人力成本就会上升。改进的办法是让快递员不固定在一个片区内，而是在送完一个片区的包裹后，如果其他片区还没有人在负责配送，则动态分配到其他片区，不过这里还是会存在一个问题，如果某个快递员在派送其中一个片区的快递时，又有新的包裹添加进来，这时问题产生了：这个片区一直在进行包裹的配送，而其他片区因为快递员不足导致包裹滞留（即“线程饿死”）。</p>
<p>我们对上面的方案再次进行改进：每个片区按照先后顺序排列，每个快递员按照顺序取出片区队列中的第一个片区并派送固定数量的包裹，配送完一批包裹后，如果这个片区还有未配送的包裹，就把这个片区重新插入到片区队列尾部，以此循环配送，每次的配送数量可以按照一定的规则来决定，例如三轮车大一点、动力好一点就配送多一些包裹。以这样的方式进行配送，既能保证每个片区的包裹都能得到派送，不至于长时间滞留，又能节约人力成本。</p>
<p>好，现在再回到 skynet 中的消息处理流程，它其实就是采用了类似快递配送的最后的改良方案，我对其进行一次转换，就一目了然。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">片区队列 &#x3D; 全局消息队列</span><br><span class="line">片区仓库 &#x3D; 服务消息队列</span><br><span class="line">配送数量 &#x3D; 一次派发的消息数量</span><br><span class="line">分配派送流程 &#x3D; 工作线程</span><br></pre></td></tr></table></figure>
<p>要注意的是：消息并不存放在全局消息队列中，类似于包裹是被堆积在不同的片区仓库内，只是这个片区被插入到片区队列内，真正的消息是存放在服务消息队列（或称次级消息队列）中；另外，关于派发消息数量，skynet 用一套权重 weight 规则来计算，后面会详细讲解</p>
<h4 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h4><p>skynet 有四类线程，其中只有工作线程创建多个，它由配置中的 thread 字段控制，如果不配置默认为 8。此线程负责的逻辑非常简单，就是从全局消息队列中 pop 出一个服务消息队列，然后派发一定数量的消息。它的大致流程如下图所示：<br><img src="https://user-images.githubusercontent.com/11263320/121795692-c67fb500-cc45-11eb-8eec-923835c58f97.jpg" alt="aqj54-9j2is"><br>具体的代码实现在函数 skynet_context_message_dispatch 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * </span></span><br><span class="line"><span class="class"><span class="title">skynet_context_message_dispatch</span>(<span class="keyword">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span>, <span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">q</span>, <span class="title">int</span> <span class="title">weight</span>) &#123;</span></span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		q = skynet_globalmq_pop();</span><br><span class="line">		<span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> handle = skynet_mq_handle(q);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> skynet_handle_grab(handle);</span><br><span class="line">	<span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> <span class="title">d</span> =</span> &#123; handle &#125;;</span><br><span class="line">		skynet_mq_release(q, drop_message, &amp;d);</span><br><span class="line">		<span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i,n=<span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;</span><br><span class="line">			skynet_context_release(ctx);</span><br><span class="line">			<span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			n = skynet_mq_length(q);</span><br><span class="line">			n &gt;&gt;= weight;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> overload = skynet_mq_overload(q);</span><br><span class="line">		<span class="keyword">if</span> (overload) &#123;</span><br><span class="line">			skynet_error(ctx, <span class="string">&quot;May overload, message queue length = %d&quot;</span>, overload);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skynet_monitor_trigger(sm, msg.source , handle);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			skynet_free(msg.data);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dispatch_message(ctx, &amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assert(q == ctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">nq</span> =</span> skynet_globalmq_pop();</span><br><span class="line">	<span class="keyword">if</span> (nq) &#123;</span><br><span class="line">		<span class="comment">// If global mq is not empty , push q back, and return next queue (nq)</span></span><br><span class="line">		<span class="comment">// Else (global mq is empty or block, don&#x27;t push q back, and return q again (for next dispatch)</span></span><br><span class="line">		skynet_globalmq_push(q);</span><br><span class="line">		q = nq;</span><br><span class="line">	&#125; </span><br><span class="line">	skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然整体逻辑较为简单，不过在其实现过程中还是有几个点可以拿出来研究一番。<br>动态唤醒<br>首先要知道一个原则：全局消息队列内是存放的诸多不为空的服务消息队列，也就是说没有消息的服务是不会把它的消息队列 push 进全局队列中的3（除了服务创建时的第一次 push）。那我们思考一个问题：因为工作线程数量有限，而活跃的服务（有消息且在全局队列中）数量是不定的，当它们的比例关系 m(工作线程):n(活跃服务) 小于等于 1 时，表示每个线程都处于工作中；而如果这个比例大于 1 时，则表示工作线程有空余，套用上面快递员的例子，就是存在一些快递员没有包裹需要派送，处于休息状态。<br>此时，如果不对这些空闲线程做挂起操作，就会浪费 CPU 资源，进而浪费电(→_→)。skynet 采取的策略是在全局消息队列为空时，使用条件变量（pthread_cond_t）来挂起工作线程，而对于线程的唤醒，一共有两处地方：</p>
<ul>
<li>网络线程唤醒，采用“懒惰唤醒”，即只有在所有工作线程都挂起时，才会唤醒一个。举个栗子，如果有 8 个工作线程，其中 7 个都处于挂起状态，那么在网络线程收到网络消息后，也不会进行唤醒，除非 8 个工作线程都被挂起；</li>
<li>定时器线程唤醒，采用“贪婪唤醒”，即只要有工作线程处于挂起状态，就会唤醒一次；另外在定时器线程结束后，还会广播唤醒所有挂起的工作线程；</li>
</ul>
<p>均衡派发<br>均衡派发是指在处理多个服务的消息队列时，尽量做到“雨露均沾”，以此来解决上面提到的“线程饿死”的情况。skynet 会给每个工作线程一个权重值 weight，根据这个权重值计算出工作线程每次应该处理的消息数量 n，计算方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> weight &gt; <span class="number">0</span> then</span><br><span class="line">    n = 消息队列当前容量 &gt;&gt; weight</span><br><span class="line">elseif weight == <span class="number">0</span> then</span><br><span class="line">    n = 消息队列当前容量</span><br><span class="line">elseif weight &lt; <span class="number">0</span> then</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>也就是说，当 weight&lt;0时，每次处理一个消息，当 weight==0 时，每次会处理完“当前队列”中的所有消息，而当 weight&gt;0 时，每次处理“当前队列”容量的 1/(2^weight)，权重值越大，每次处理的消息越少。注意：这里所说的“当前队列”容量是指在处理第一个消息时，该时刻服务消息队列的消息容量，本质上是一个“过去时”的值，这也是为什么“当前队列”要加引号的原因。</p>
<h4 id="插入消息"><a href="#插入消息" class="headerlink" title="插入消息"></a>插入消息</h4><p>在 skynet 中，服务之间传递的消息都被封装成统一的格式，不论是网络消息还是定时器消息，消息结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> source;<span class="comment">//表示发出这个消息的服务 handle id，如果一个服务收到了一个 source=0 的消息，则表示这个消息是不是从一个服务实例中发出的，例如定时器消息和网络消息，或者发出这个消息的服务实例已经被销毁；</span></span><br><span class="line">	<span class="keyword">int</span> session;<span class="comment">//表示这个消息的序列号，类似 TCP 数据报(segment)的 SEQ，需要注意的是每一个请求包才需要生成一个新的 session，而返回包是不需要生成新的 session，只需要把请求包的 session 在返回时赋值给返回包即可，当然，需要标识这个包是一个返回包，接下来就会说到消息包的类型，一个消息包session的生成规则会涉及到 ctx 的 session_id 字段</span></span><br><span class="line">	<span class="keyword">void</span> * data;它是一个指针，指向了消息携带数据真正的内存地址，可以为空指针，即没有消息数据，对于一个从 lua 服务中传递过来的消息数据（在 lua 中使用了 c.send），可以是 LUA_TSTRING 和 LUA_TLIGHTUSERDATA，前者必须做一次内存拷贝（原因请查阅 lua_tolstring 的说明文档），而后者则不需要。</span><br><span class="line">	<span class="keyword">size_t</span> sz;<span class="comment">//sz 字面意思是消息数据的长度，但其实该字段除了包含了数据的长度，还携带了另外一个信息，就是这个消息的类型，消息类型的定义可以在 skynet.h 头文件中找到，它用 sz 的高 8 位（1 byte）来表示，例如在 64 位系统下 sz = 消息类型&lt;&lt;56 | 数据长度。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面已经对 skynet 的消息结构有了一个全方位的了解，对于如何把一个消息插入到目的服务的消息队列中，已经没有太多需要深入的细节。可能唯一需要注意的是，当一个消息插入到服务的消息队列中时，如果这个服务处于“非活跃”状态（即没有加入到全局消息队列），那么会将该服务重新触发为“活跃”状态，实现细节在 skynet_mq_push。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_mq_push(struct message_queue *q, struct skynet_message *message) &#123;</span><br><span class="line">	assert(message);</span><br><span class="line">	SPIN_LOCK(q)</span><br><span class="line"></span><br><span class="line">	q-&gt;<span class="built_in">queue</span>[q-&gt;tail] = *message;</span><br><span class="line">	<span class="keyword">if</span> (++ q-&gt;tail &gt;= q-&gt;cap) &#123;</span><br><span class="line">		q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (q-&gt;head == q-&gt;tail) &#123;</span><br><span class="line">		expand_queue(q);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (q-&gt;in_global == <span class="number">0</span>) &#123;</span><br><span class="line">		q-&gt;in_global = MQ_IN_GLOBAL;</span><br><span class="line">		skynet_globalmq_push(q);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SPIN_UNLOCK(q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h4><p>消息处理的过程已经在前面讲解的差不多了，其过程也较为简单，即服务通过注册的回调函数来处理收到的消息，回调函数（skynet_cb）的定义可以在 skynet.h 中找到（在前面也已经提到），它接收 7 个参数：<br>context，表示处理该消息的服务上下文；<br>ud，表示真正处理该消息的服务实体指针（不一定是服务实例，也可以是服务实例内的其他元素，例如 snlua 服务实例的 lua 虚拟机指针）；<br>type，消息的类型（上文已提到）；<br>session，消息的序列号；<br>source，发生消息的源服务 handle id；<br>msg，消息数据的指针；<br>sz，消息数据的长度；<br>关于消息处理的一个原则是：一个消息的数据必须由最后处理该消息的服务进行回收处理。这是什么意思呢？下面通过一个例子来解释这条原则。<br>假如你的朋友小明给你送一盒橘子，你会有两种方式收到这一盒橘子并吃掉它们：</p>
<ul>
<li>小明直接亲自送到你手上</li>
<li>小明用快递邮寄，通过快递员送到你的手上</li>
</ul>
<p>不管通过哪一种方式，最终你会收到一盒橘子，然后吃掉它们，那吃完后剩下的橘子皮肯定是由你自己负责清扫，不可能让朋友小明或者快递员来给你处理（除非你想被打），在这一个流程中，你就是最后处理消息的人，你就需要负责最后的数据回收，快递员虽然也处理过这条消息，但是他是不能吃掉盒子内的橘子（即消息包中携带的数据）。<br>理解了上面的例子后，现在回头看看 skynet 的消息处理流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dispatch_message(struct skynet_context *ctx, struct skynet_message *msg) &#123;</span><br><span class="line">	assert(ctx-&gt;init);</span><br><span class="line">	CHECKCALLING_BEGIN(ctx)</span><br><span class="line">	pthread_setspecific(G_NODE.handle_key, (<span class="keyword">void</span> *)(<span class="keyword">uintptr_t</span>)(ctx-&gt;handle));</span><br><span class="line">	<span class="keyword">int</span> type = msg-&gt;sz &gt;&gt; MESSAGE_TYPE_SHIFT;</span><br><span class="line">	<span class="keyword">size_t</span> sz = msg-&gt;sz &amp; MESSAGE_TYPE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;logfile) &#123;</span><br><span class="line">		skynet_log_output(ctx-&gt;logfile, msg-&gt;source, type, msg-&gt;session, msg-&gt;data, sz);</span><br><span class="line">	&#125;</span><br><span class="line">	++ctx-&gt;message_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		reserve_msg : 回调函数的返回值</span></span><br><span class="line"><span class="comment">		reserve_msg = 1，表示不能释放消息数据 msg-&gt;data，只是做转发处理，在 clusterproxy 中有使用，lua 接口为 skynet.forward_type()</span></span><br><span class="line"><span class="comment">		reserve_msg = 0，表示需要释放消息数据 msg-&gt;data，也说明这次是消息的终点</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> reserve_msg;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;profile) &#123;</span><br><span class="line">		ctx-&gt;cpu_start = skynet_thread_time();</span><br><span class="line">		reserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);</span><br><span class="line">		<span class="keyword">uint64_t</span> cost_time = skynet_thread_time() - ctx-&gt;cpu_start;</span><br><span class="line">		ctx-&gt;cpu_cost += cost_time;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!reserve_msg) &#123;</span><br><span class="line">		skynet_free(msg-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	CHECKCALLING_END(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意回调函数 ctx-&gt;cb 的返回值，当 reserve_msg = 1 时，表示不需要 free 消息数据，只是负责转发这个消息；当 reserve_msg = 0 时，在回调结束后，会 free 消息数据。而对于 snlua 服务来说，是否开启转发是由 api c.callback 的第二个参数决定的，例如 c.callback(func, true) 则表示开启转发（具体参见 skynet.forward_type）。</p>
<p>这里还涉及到了一个多线程的知识点：线程局部存储(Thread-Local Storage)，用于在工作线程中获取当前正在处理的服务 handle：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> </span><br><span class="line">skynet_current_handle(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (G_NODE.init) &#123;</span><br><span class="line">		<span class="keyword">void</span> * handle = pthread_getspecific(G_NODE.handle_key);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">uint32_t</span>)(<span class="keyword">uintptr_t</span>)handle;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> v = (<span class="keyword">uint32_t</span>)(-THREAD_MAIN);</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务回收流程"><a href="#服务回收流程" class="headerlink" title="服务回收流程"></a>服务回收流程</h3><p>服务的回收过程可以分为三个部分：服务实例的回收、服务消息队列的回收以及服务上下文（ctx）的回收，整个回收过程在 delete_context 函数中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">delete_context(struct skynet_context *ctx) &#123;</span><br><span class="line">	<span class="comment">// 如果服务有日志文件，先关闭该日志文件</span></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;logfile) &#123;</span><br><span class="line">		fclose(ctx-&gt;logfile);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回收服务实例</span></span><br><span class="line">	skynet_module_instance_release(ctx-&gt;mod, ctx-&gt;instance);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记服务消息队列为“可回收(release)”</span></span><br><span class="line">	skynet_mq_mark_release(ctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	CHECKCALLING_DESTROY(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回收ctx</span></span><br><span class="line">	skynet_free(ctx);</span><br><span class="line">	context_dec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要指出的是，服务消息队列的回收方式稍微特殊一点，消息队列的内存并不会立即被 free 掉，还需要处理回收前遗留在队列中的消息，我会在接下来章节详细展开。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>skynet 使用引用计数的方式来决定是否销毁一个服务上下文，这有点类似 C++ 的智能指针，当 ctx-&gt;ref = 0 时，则会触发服务 ctx 的销毁流程。在代码中会发现 skynet_handle_grab 和 skynet_context_release 基本都是成对出现，前者引用一次 ctx（引用次数 +1），后者释放一次引用（引用次数 -1）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * </span></span><br><span class="line"><span class="class"><span class="title">skynet_handle_grab</span>(<span class="title">uint32_t</span> <span class="title">handle</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> *<span class="title">s</span> =</span> H;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	rwlock_rlock(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> hash = handle &amp; (s-&gt;slot_size<span class="number">-1</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> s-&gt;slot[hash];</span><br><span class="line">	<span class="keyword">if</span> (ctx &amp;&amp; skynet_context_handle(ctx) == handle) &#123;</span><br><span class="line">		result = ctx;</span><br><span class="line">		skynet_context_grab(result); <span class="comment">// ctx 引用次数 +1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rwlock_runlock(&amp;s-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * </span></span><br><span class="line"><span class="class"><span class="title">skynet_context_release</span>(<span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span>) &#123;</span></span><br><span class="line">	<span class="keyword">if</span> (ATOM_DEC(&amp;ctx-&gt;ref) == <span class="number">0</span>) &#123;</span><br><span class="line">		delete_context(ctx); <span class="comment">// ctx 引用次数等于0，则触发回收流程</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里回顾一下前面提到的服务 ctx 创建过程，思考一下为什么初始的 ctx-&gt;ref 要设置为 2，为什么不是 0 或者 1 呢？<br>首先，若 ref 设置为 0，肯定是错误的，因为在 ctx 注册到服务仓库 handler_storage *H中时，ctx 其实就已经被引用一次了，也就是说创建并注册成功的 ctx，其引用计数至少是 1。那为什么不直接设置 ctx 的 ref 为 1，而要设置为 2 呢？原因是 skynet 需要在 ctx 初始化后再次确保其是否是真实可用状态，举个例子：一个新的 ctx 在工作线程 A 中被创建，在 ctx 执行初始化操作后，若它在工作线程 B 中意外被减少一次引用（例如被执行了 kill），此时就会在线程 A 中出现一个已经被回收的 ctx 被 push 到全局消息队列的情况。</p>
<h4 id="回收消息队列"><a href="#回收消息队列" class="headerlink" title="回收消息队列"></a>回收消息队列</h4><p>服务消息队列的回收过程与服务实例回收和服务 ctx 回收相比会稍微复杂一点，不仅仅需要回收消息队列的内存，还需要处理队列中遗留的消息，要给这些遗留的消息的发送服务一个错误反馈，这就像你从一家公司离职后，当有之前的老客户和你联系时，你需要告知别人“我已经离职了”，而不是没有任何反馈信息。</p>
<p>消息队列的回收过程分为两个步骤：</p>
<blockquote>
<p>标记要回收的消息队列(skynet_mq_mark_release)，并把它 push 到全局消息队列中；<br>工作线程执行 skynet_mq_release，使用指定的丢弃函数(drop_message)来处理队列中遗留的消息包；</p>
</blockquote>
<p>回收函数 skynet_mq_release 和丢弃函数 drop_message 的函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">skynet_mq_release(struct message_queue *q, message_drop drop_func, <span class="keyword">void</span> *ud) &#123;</span><br><span class="line">	SPIN_LOCK(q)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;release) &#123;</span><br><span class="line">		SPIN_UNLOCK(q)</span><br><span class="line">		<span class="comment">// 循环pop剩余的消息，并drop掉</span></span><br><span class="line">		_drop_queue(q, drop_func, ud);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		skynet_globalmq_push(q);</span><br><span class="line">		SPIN_UNLOCK(q)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">drop_message(struct skynet_message *msg, <span class="keyword">void</span> *ud) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">drop_t</span> *<span class="title">d</span> =</span> ud;</span><br><span class="line">	skynet_free(msg-&gt;data);</span><br><span class="line">	<span class="keyword">uint32_t</span> source = d-&gt;handle;</span><br><span class="line">	assert(source);</span><br><span class="line">	<span class="comment">// report error to the message source</span></span><br><span class="line">	skynet_send(<span class="literal">NULL</span>, source, msg-&gt;source, PTYPE_ERROR, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个回收过程就是一个把遗留的消息一个个 pop 出来，再由丢弃函数向消息源服务发送一个错误消息，最后释放掉消息队列的内存。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>深入理解skynet —— 服务 详见：<a target="_blank" rel="noopener" href="https://domicat.me/_posts/2020-05-10-learn-skynet-service/">https://domicat.me/_posts/2020-05-10-learn-skynet-service/</a></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/post/e9005ae.html" rel="bookmark">skynet cluster</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/post/577e23ed.html" rel="bookmark">skynet module</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/post/a40f5bf.html" rel="bookmark">skynet monitor</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/post/933b71d7.html" rel="bookmark">skynet mq</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/post/5ebf6d7e.html" rel="bookmark">skynet socket</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/skynet/" rel="tag"><i class="fa fa-tag"></i> skynet</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/9ff34ca8.html" rel="prev" title="lua协程">
      <i class="fa fa-chevron-left"></i> lua协程
    </a></div>
      <div class="post-nav-item">
    <a href="/post/933b71d7.html" rel="next" title="skynet mq">
      skynet mq <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.</span> <span class="nav-text">服务的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">服务是怎么调用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">服务的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">服务创建流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">3.1.1.</span> <span class="nav-text">创建上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.1.2.</span> <span class="nav-text">服务模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.1.3.</span> <span class="nav-text">消息队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">消息处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">工作线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%B6%88%E6%81%AF"><span class="nav-number">3.2.2.</span> <span class="nav-text">插入消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9"><span class="nav-number">3.2.3.</span> <span class="nav-text">消息消费</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">服务回收流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.3.2.</span> <span class="nav-text">回收消息队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reference"><span class="nav-number">4.</span> <span class="nav-text">reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <!--
  <p class="site-author-name" itemprop="name">losophy</p>
  -->
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">121</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">losophy</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '305836da6c4a706f6fb7',
      clientSecret: '69be853985a105119444ad9dd25d60ac7ee03f3d',
      repo        : 'blog.comments',
      owner       : 'losophy',
      admin       : ['losophy'],
      id          : 'b78d1c6efdc99da55f4d6fd9bba7fe71',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
